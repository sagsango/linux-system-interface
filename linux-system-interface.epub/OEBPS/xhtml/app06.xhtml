<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="app06"><span epub:type="pagebreak" id="page_1425"/><strong><span class="big">F</span></strong><br/><strong>SOLUTIONS TO SELECTED EXERCISES</strong></h2>
<h3 class="h3a" id="app06lev1sec01"><strong>Chapter 5</strong></h3>
<p class="exer"><strong><a href="ch05.xhtml#ch5exe3">5-3</a>.</strong>&#160;&#160;&#160;&#160;&#160;A solution is provided in the file <span class="literal">fileio/atomic_append.c</span> in the source code distribution for this book. Here is an example of the results that we see when we run this program as suggested:</p>
<p class="programs1">$ <span class="codestrong">ls -l f1 f2</span><br/>-rw-------&#160;&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;&#160;2000000 Jan&#160;&#160;9 11:14 f1<br/>-rw-------&#160;&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;&#160;1999962 Jan&#160;&#160;9 11:14 f2</p>
<p class="exerp">Because the combination of <em>lseek()</em> plus <em>write()</em> is not atomic, one instance of the program sometimes overwrote bytes written by the other instance. As a result, the file <span class="literal">f2</span> contains less than 2 million bytes.</p>
<p class="exer"><strong><a href="ch05.xhtml#ch5exe4">5-4</a>.</strong>&#160;&#160;&#160;&#160;&#160;A call to <em>dup()</em> can be rewritten as:</p>
<p class="programs1">fd = fcntl(oldfd, F_DUPFD, 0);</p>
<p class="exerp"><span epub:type="pagebreak" id="page_1426"/>A call to <em>dup2()</em> can be rewritten as:</p>
<p class="programs1">if (oldfd == newfd) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* oldfd == newfd is a special case */<br/>&#160;&#160;&#160;&#160;if (fcntl(oldfd, F_GETFL) == -1) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Is oldfd valid? */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errno = EBADF;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fd = -1;<br/>&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fd = oldfd;<br/>&#160;&#160;&#160;&#160;}<br/>} else {<br/>&#160;&#160;&#160;&#160;close(newfd);<br/>&#160;&#160;&#160;&#160;fd = fcntl(oldfd, F_DUPFD, newfd);<br/>}</p>
<p class="exer"><strong><a href="ch05.xhtml#ch5exe6">5-6</a>.</strong>&#160;&#160;&#160;&#160;&#160;The first point to realize is that, since <em>fd2</em> is a duplicate of <em>fd1</em>, they both share a single open file description, and thus a single file offset. However, because <em>fd3</em> is created via a separate call to <em>open()</em>, it has a separate file offset.</p>
<p class="bull1">&#8226; After the first <em>write()</em>, the file contents are <span class="literal">Hello,</span>.</p>
<p class="bull1">&#8226; Since <em>fd2</em> shares a file offset with <em>fd1</em>, the second <em>write()</em> call appends to the existing text, yielding <span class="literal">Hello, world</span>.</p>
<p class="bull1">&#8226; The <em>lseek()</em> call adjusts the single file offset shared by <em>fd1</em> and <em>fd2</em> to point to the start of the file, and thus the third <em>write()</em> call overwrites part of the existing text to yield <span class="literal">HELLO, world</span>.</p>
<p class="bull1">&#8226; The file offset for <em>fd3</em> has not so far been modified, and so points to the start of the file. Therefore, the final <em>write()</em> call changes the file contents to <span class="literal">Gidday world</span>.</p>
<p class="exerp">Run the program <span class="literal">fileio/multi_descriptors.c</span> in the source code distribution for this book to see these results.</p>
<h3 class="h3a" id="app06lev1sec02"><strong>Chapter 6</strong></h3>
<p class="exer"><strong><a href="ch06.xhtml#ch6exe1">6-1</a>.</strong>&#160;&#160;&#160;&#160;&#160;Since the array <em>mbuf</em> is not initialized, it is part of the uninitialized data segment. Therefore, no disk space is required to hold this variable. Instead, it is allocated (and initialized to 0) when the program is loaded.</p>
<p class="exer"><strong><a href="ch06.xhtml#ch6exe2">6-2</a>.</strong>&#160;&#160;&#160;&#160;&#160;A demonstration of the incorrect usage of <em>longjmp()</em> is provided in the file <span class="literal">proc/bad_longjmp.c</span> in the source code distribution for this book.</p>
<p class="exer"><strong><a href="ch06.xhtml#ch6exe3">6-3</a>.</strong>&#160;&#160;&#160;&#160;&#160;Sample implementations of <em>setenv()</em> and <em>unsetenv()</em> are provided in the file <span class="literal">proc/setenv.c</span> in the source code distribution for this book.</p>
<h3 class="h3a" id="app06lev1sec03"><strong>Chapter 8</strong></h3>
<p class="exer"><strong><a href="ch08.xhtml#ch8exe1">8-1</a>.</strong>&#160;&#160;&#160;&#160;&#160;The two <em>getpwuid()</em> calls are executed before the <em>printf()</em> output string is constructed, and&#8212;since <em>getpwuid()</em> returns its <em>pw_name</em> result in a statically allocated buffer&#8212;the second call overwrites the result returned by the first call.</p>
<h3 class="h3a" id="app06lev1sec04"><span epub:type="pagebreak" id="page_1427"/><strong>Chapter 9</strong></h3>
<p class="exer"><strong><a href="ch09.xhtml#ch9exe1">9-1</a>.</strong>&#160;&#160;&#160;&#160;&#160;In considering the following, remember that changes to the effective user ID always also change the file-system user ID.</p>
<p class="olista1">a) <em>real=2000, effective=2000, saved=2000, file-system=2000</em></p>
<p class="olista1">b) <em>real=1000, effective=2000, saved=2000, file-system=2000</em></p>
<p class="olista1">c) <em>real=1000, effective=2000, saved=0, file-system=2000</em></p>
<p class="olista1">d) <em>real=1000, effective=0, saved=0, file-system=2000</em></p>
<p class="olista1">e) <em>real=1000, effective=2000, saved=3000, file-system=2000</em></p>
<p class="exer"><strong><a href="ch09.xhtml#ch9exe2">9-2</a>.</strong>&#160;&#160;&#160;&#160;&#160;Strictly speaking, such a process is unprivileged, since its effective user ID is nonzero. However, an unprivileged process can use the <em>setuid()</em>, <em>setreuid()</em>, <em>seteuid()</em>, or <em>setresuid()</em> calls to set its effective user ID to the same value as its real user ID or saved set-user-ID. Thus, this process could use one of these calls to regain privilege.</p>
<p class="exer"><strong><a href="ch09.xhtml#ch9exe4">9-4</a>.</strong>&#160;&#160;&#160;&#160;&#160;The following code shows the steps for each system call.</p>
<p class="programs1">e = geteuid();&#160;&#160;&#160;&#160;&#160;/* Save initial value of effective user ID */<br/><br/>setuid(getuid());&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Suspend privileges */<br/>setuid(e);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Resume privileges */<br/>/* Can't permanently drop the set-user-ID identity with setuid() */<br/><br/>seteuid(getuid());&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Suspend privileges */<br/>seteuid(e);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Resume privileges */<br/>/* Can't permanently drop the set-user-ID identity with seteuid() */<br/><br/>setreuid(-1, getuid());&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Temporarily drop privileges */<br/>setreuid(-1, e);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Resume privileges */<br/>setreuid(getuid(), getuid());&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Permanently drop privileges */<br/><br/>setresuid(-1, getuid(), -1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Temporarily drop privileges */<br/>setresuid(-1, e, -1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Resume privileges */<br/>setresuid(getuid(), getuid(), getuid());&#160;&#160;/* Permanently drop privileges */</p>
<p class="exer"><strong><a href="ch09.xhtml#ch9exe5">9-5</a>.</strong>&#160;&#160;&#160;&#160;&#160;With the exception of <em>setuid()</em>, the answers are the same as for the previous exercise, except that we can substitute the value 0 for the variable <em>e</em>. For <em>setuid()</em>, the following holds:</p>
<p class="programs1">/* (a) Can't suspend and resume privileges with setuid() */<br/><br/>setuid(getuid());&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* (b) Permanently drop privileges */</p>
<h3 class="h3a" id="app06lev1sec05"><strong>Chapter 10</strong></h3>
<p class="exer"><strong><a href="ch10.xhtml#ch10exe1">10-1</a>.</strong>&#160;&#160;&#160;The maximum signed 32-bit integer value is 2,147,483,647. Divided by 100 clock ticks per second, this corresponds to somewhat more than 248 days. Divided by 1 million (<span class="literal">CLOCKS_PER_SEC</span>), this corresponds to 36 minutes and 47 seconds.</p>
<h3 class="h3a" id="app06lev1sec06"><span epub:type="pagebreak" id="page_1428"/><strong>Chapter 12</strong></h3>
<p class="exer"><strong><a href="ch12.xhtml#ch12exe1">12-1</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">sysinfo/procfs_user_exe.c</span> in the source code distribution for this book.</p>
<h3 class="h3a" id="app06lev1sec07"><strong>Chapter 13</strong></h3>
<p class="exer"><strong><a href="ch13.xhtml#ch13exe3">13-3</a>.</strong>&#160;&#160;&#160;This sequence of statements ensures that the data written to a <em>stdio</em> buffer is flushed to the disk. The <em>fflush()</em> call flushes the <em>stdio</em> buffer for <em>fp</em> to the kernel buffer cache. The argument given to the subsequent <em>fsync()</em> is the file descriptor underlying <em>fp</em>; thus, the call flushes the (recently filled) kernel buffer for that file descriptor to disk.</p>
<p class="exer"><strong><a href="ch13.xhtml#ch13exe4">13-4</a>.</strong>&#160;&#160;&#160;When standard output is sent to a terminal, it is line-buffered, so that the output of the <em>printf()</em> call appears immediately, and is followed by the output of <em>write()</em>. When standard output is sent to a disk file, it is block-buffered. Consequently, the output of the <em>printf()</em> is held in a <em>stdio</em> buffer and is flushed only when the program exits (i.e., after the <em>write()</em> call). (A complete program containing the code of this exercise is available in the file <span class="literal">filebuff/mix23_linebuff.c</span> in the source code distribution for this book.)</p>
<h3 class="h3a" id="app06lev1sec08"><strong>Chapter 15</strong></h3>
<p class="exer"><strong><a href="ch15.xhtml#ch15exe2">15-2</a>.</strong>&#160;&#160;&#160;The <em>stat()</em> system call doesn&#8217;t change any file timestamps, since all it does is fetch information from the file i-node (and there is no <em>last i-node access</em> timestamp).</p>
<p class="exer"><strong><a href="ch15.xhtml#ch15exe4">15-4</a>.</strong>&#160;&#160;&#160;The GNU C library provides just such a function, named <em>euidaccess()</em>, in the library source file <span class="literal">sysdeps/posix/euidaccess.c</span>.</p>
<p class="exer"><strong><a href="ch15.xhtml#ch15exe5">15-5</a>.</strong>&#160;&#160;&#160;In order to do this, we must use two calls to <em>umask()</em>, as follows:</p>
<p class="programs1">mode_t currUmask;<br/><br/>currUmask = umask(0);&#160;&#160;&#160;&#160;&#160;&#160;/* Retrieve current umask, set umask to 0 */<br/>umask(currUmask);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Restore umask to previous value */</p>
<p class="exerp">Note, however, that this solution is not thread-safe, since threads share the process umask setting.</p>
<p class="exer"><strong><a href="ch15.xhtml#ch15exe7">15-7</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">files/chiflag.c</span> in the source code distribution for this book.</p>
<h3 class="h3a" id="app06lev1sec09"><strong>Chapter 18</strong></h3>
<p class="exer"><strong><a href="ch18.xhtml#ch18exe1">18-1</a>.</strong>&#160;&#160;&#160;Using <em>ls &#8211;li</em> shows that the executable file has different i-node numbers after each compilation. What happens is that the compiler removes (unlinks) any existing file with the same name as its target executable, and then creates a new file with the same name. It is permissible to unlink an executable file that is running. The name is removed immediately, but the file itself remains in existence until the process executing it terminates.</p>
<p class="exer"><strong><a href="ch18.xhtml#ch18exe2">18-2</a>.</strong>&#160;&#160;&#160;The file <span class="literal">myfile</span> is created in the subdirectory <span class="literal">test</span>. The <em>symlink()</em> call creates a relative link in the parent directory. Despite appearances, this is a dangling link, <span epub:type="pagebreak" id="page_1429"/>since it is interpreted relative to the location of the link file, and thus refers to a nonexistent file in the parent directory. Consequently, <em>chmod()</em> fails with the error <span class="literal">ENOENT</span> (&#8220;No such file or directory&#8221;). (A complete program containing the code of this exercise is available in the file <span class="literal">dirs_links/bad_symlink.c</span> in the source code distribution for this book.)</p>
<p class="exer"><strong><a href="ch18.xhtml#ch18exe4">18-4</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">dirs_links/list_files_readdir_r.c</span>, which can be found in the source code distribution for this book.</p>
<p class="exer"><strong><a href="ch18.xhtml#ch18exe7">18-7</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">dirs_links/file_type_stats.c</span>, which can be found in the source code distribution for this book.</p>
<p class="exer"><strong><a href="ch18.xhtml#ch18exe9">18-9</a>.</strong>&#160;&#160;&#160;Using <em>fchdir()</em> is more efficient. If we are performing the operation repeatedly within a loop, then with <em>fchdir()</em> we can perform one call to <em>open()</em> before executing the loop, and with <em>chdir()</em> we can place the <em>getcwd()</em> call outside the loop. Then we are measuring the difference between repeated calls to <em>fchdir(fd)</em> and <em>chdir(buf)</em>. Calls to <em>chdir()</em> are more expensive for two reasons: passing the <em>buf</em> argument to the kernel requires a larger data transfer between user space and kernel space, and the pathname in <em>buf</em> must be resolved to the corresponding directory i-node on each call. (Kernel caching of directory entry information reduces the work required for the second point, but some work must still be done.)</p>
<h3 class="h3a" id="app06lev1sec10"><strong>Chapter 20</strong></h3>
<p class="exer"><strong><a href="ch20.xhtml#ch20exe2">20-2</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">signals/ignore_pending_sig.c</span> in the source code distribution for this book.</p>
<p class="exer"><strong><a href="ch20.xhtml#ch20exe4">20-4</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">signals/siginterrupt.c</span> in the source code distribution for this book.</p>
<h3 class="h3a" id="app06lev1sec11"><strong>Chapter 22</strong></h3>
<p class="exer"><strong><a href="ch22.xhtml#ch22exe2">22-2</a>.</strong>&#160;&#160;&#160;As with most UNIX implementations, Linux delivers standard signals before realtime signals (SUSv3 doesn&#8217;t require this). This makes sense, because some standard signals indicate critical conditions (e.g., hardware exceptions) that a program should deal with as soon as possible.</p>
<p class="exer"><strong><a href="ch22.xhtml#ch22exe3">22-3</a>.</strong>&#160;&#160;&#160;Replacing <em>sigsuspend()</em> plus a signal handler with <em>sigwaitinfo()</em> in this program provides a 25 to 40 percent speed improvement. (The exact figure varies somewhat across kernel versions.)</p>
<h3 class="h3a" id="app06lev1sec12"><strong>Chapter 23</strong></h3>
<p class="exer"><strong><a href="ch23.xhtml#ch23exe2">23-2</a>.</strong>&#160;&#160;&#160;A modified program using <em>clock_nanosleep()</em> is provided in the file <span class="literal">timers/t_clock_nanosleep.c</span> in the source code distribution for this book.</p>
<p class="exer"><strong><a href="ch23.xhtml#ch23exe3">23-3</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">timers/ptmr_null_evp.c</span> in the source code distribution for this book.</p>
<h3 class="h3a" id="app06lev1sec13"><strong>Chapter 24</strong></h3>
<p class="exer"><strong><a href="ch24.xhtml#ch24exe1">24-1</a>.</strong>&#160;&#160;&#160;The first <em>fork()</em> call creates one new child. Both parent and child carry on to execute the second <em>fork()</em>, and thus each creates a further process, making a total of four <span epub:type="pagebreak" id="page_1430"/>processes. All four processes carry on to execute the next <em>fork()</em>, each creating a further child. Consequently, a total of seven new processes are created.</p>
<p class="exer"><strong><a href="ch24.xhtml#ch24exe2">24-2</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">procexec/vfork_fd_test.c</span> in the source code distribution for this book.</p>
<p class="exer"><strong><a href="ch24.xhtml#ch24exe3">24-3</a>.</strong>&#160;&#160;&#160;If we call <em>fork()</em>, and then have the child call <em>raise()</em> to send itself a signal such as <span class="literal">SIGABRT</span>, this will yield a core dump file that closely mirrors the state of the parent at the time of the <em>fork()</em>. The <em>gdb gcore</em> command allows us to perform a similar task for a program, without needing to change the source code.</p>
<p class="exer"><strong><a href="ch24.xhtml#ch24exe5">24-5</a>.</strong>&#160;&#160;&#160;Add a converse <em>kill()</em> call in the parent:</p>
<p class="programs1">if (kill(childPid, SIGUSR1) == -1)<br/>&#160;&#160;&#160;&#160;errExit("kill")</p>
<p class="exerp">And in the child, add a converse <em>sigsuspend()</em> call:</p>
<p class="programs1">sigsuspend(&#38;origMask);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Unblock SIGUSR1, wait for signal */</p>
<h3 class="h3a" id="app06lev1sec14"><strong>Chapter 25</strong></h3>
<p class="exer"><strong><a href="ch25.xhtml#ch25exe1">25-1</a>.</strong>&#160;&#160;&#160;Assuming a two&#8217;s complement architecture, where &#8211;1 is represented by a bit pattern with all bits on, then the parent will see an exit status of 255 (all bits on in the least significant 8 bits, which are all that is passed back to the parent when it calls <em>wait()</em>). (The presence of the call <em>exit(&#8211;1)</em> in a program is usually a programmer error resulting from confusion with the &#8211;1 return used to indicate failure of a system call.)</p>
<h3 class="h3a" id="app06lev1sec15"><strong>Chapter 26</strong></h3>
<p class="exer"><strong><a href="ch26.xhtml#ch26exe1">26-1</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">procexec/orphan.c</span> in the source code distribution for this book.</p>
<h3 class="h3a" id="app06lev1sec16"><strong>Chapter 27</strong></h3>
<p class="exer"><strong><a href="ch27.xhtml#ch27exe1">27-1</a>.</strong>&#160;&#160;&#160;The <em>execvp()</em> function first fails to exec the file <span class="literal">xyz</span> in <span class="literal">dir1</span>, because execute permission is denied. It therefore continues its search in <span class="literal">dir2</span>, where it successfully execs <span class="literal">xyz</span>.</p>
<p class="exer"><strong><a href="ch27.xhtml#ch27exe2">27-2</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">procexec/execlp.c</span> in the source code distribution of this book.</p>
<p class="exer"><strong><a href="ch27.xhtml#ch27exe3">27-3</a>.</strong>&#160;&#160;&#160;The script specifies the <em>cat</em> program as its interpreter. The <em>cat</em> program &#8220;interprets&#8221; a file by printing its contents&#8212;in this case with the <em>&#8211;n</em> (line numbering) option enabled (as though we had entered the command <em>cat &#8211;n ourscript</em>). Thus, we would see the following:</p>
<p class="programs4">1 #!/bin/cat -n<br/>2 Hello world</p>
<p class="exer"><strong><a href="ch27.xhtml#ch27exe4">27-4</a>.</strong>&#160;&#160;&#160;Two successive <em>fork()</em> calls yield a total of three processes related as parent, child, and grandchild. Having created the grandchild process, the child immediately exits, and is reaped by the <em>waitpid()</em> call in the parent. As a consequence of being <span epub:type="pagebreak" id="page_1431"/>orphaned, the grandchild is adopted by <em>init</em> (process ID of 1). The program doesn&#8217;t need to perform a second <em>wait()</em> call, since <em>init</em> automatically reaps the zombie when the grandchild terminates. Therein lies a possible use for this code sequence: if we need to create a child for which we can&#8217;t later wait, then this sequence can be used to ensure that no zombie results. One example of such a requirement is where the parent execs some program that is not guaranteed to perform a wait (and we don&#8217;t want to rely on setting the disposition of <span class="literal">SIGCHLD</span> to <span class="literal">SIG_IGN</span>, since the disposition of an ignored <span class="literal">SIGCHLD</span> after an <em>exec()</em> is left unspecified by SUSv3).</p>
<p class="exer"><strong><a href="ch27.xhtml#ch27exe5">27-5</a>.</strong>&#160;&#160;&#160;The string given to <em>printf()</em> doesn&#8217;t include a newline character, and therefore the output is not flushed before the <em>execlp()</em> call. The <em>execlp()</em> overwrites the existing program&#8217;s data segments (as well as the heap and stack), which contain the <em>stdio</em> buffers, and thus the unflushed output is lost.</p>
<p class="exer"><strong><a href="ch27.xhtml#ch27exe6">27-6</a>.</strong>&#160;&#160;&#160;<span class="literal">SIGCHLD</span> is delivered to the parent. If the <span class="literal">SIGCHLD</span> handler attempts to do a <em>wait()</em>, then the call returns an error (<span class="literal">ECHILD</span>) indicating that there were no children whose status could be returned. (This assumes that the parent had no other terminated children. If it did, then the <em>wait()</em> would block; or if <em>waitpid()</em> was used with the <span class="literal">WNOHANG</span> flag, <em>waitpid()</em> would return 0.) This is exactly the situation that may arise if a program establishes a handler for <span class="literal">SIGCHLD</span> before calling <em>system()</em>.</p>
<h3 class="h3a" id="app06lev1sec17"><strong>Chapter 29</strong></h3>
<p class="exer"><strong><a href="ch29.xhtml#ch29exe1">29-1</a>.</strong>&#160;&#160;&#160;There are two possible outcomes (both permitted by SUSv3): the thread deadlocks, blocked while trying to join with itself, or the <em>pthread_join()</em> call fails, returning the error <span class="literal">EDEADLK</span>. On Linux, the latter behavior occurs. Given a thread ID in <em>tid</em>, we can prevent such an eventuality using the following code:</p>
<p class="programs1">if (!pthread_equal(tid, pthread_self()))<br/>&#160;&#160;&#160;pthread_join(tid, NULL);</p>
<p class="exer"><strong><a href="ch29.xhtml#ch29exe2">29-2</a>.</strong>&#160;&#160;&#160;After the main thread terminates, <em>threadFunc()</em> will continue working with storage on the main thread&#8217;s stack, with unpredictable results.</p>
<h3 class="h3a" id="app06lev1sec18"><strong>Chapter 31</strong></h3>
<p class="exer"><strong><a href="ch31.xhtml#ch31exe1">31-1</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">threads/one_time_init.c</span> in the source code distribution for this book.</p>
<h3 class="h3a" id="app06lev1sec19"><strong>Chapter 33</strong></h3>
<p class="exer"><strong><a href="ch33.xhtml#ch33exe2">33-2</a>.</strong>&#160;&#160;&#160;The <span class="literal">SIGCHLD</span> signal that is generated on child termination is process-directed. It may be delivered to any thread (not necessarily the one that called <em>fork()</em>) that is not blocking the signal.</p>
<h3 class="h3a" id="app06lev1sec20"><strong>Chapter 34</strong></h3>
<p class="exer"><strong><a href="ch34.xhtml#ch34exe1">34-1</a>.</strong>&#160;&#160;&#160;Suppose that the program is part of a shell pipeline:</p>
<p class="programs1">$ <span class="codestrong">./ourprog | grep '<span class="codeitalic">some string</span>'</span></p>
<p class="exerp"><span epub:type="pagebreak" id="page_1432"/>The problem is that <em>grep</em> will be part of the same process group as <em>ourprog</em>, and therefore the <em>killpg()</em> call will also terminate the <em>grep</em> process. This is probably not desired, and is likely to confuse users. The solution is to use <em>setpgid()</em> to ensure that the child processes are placed in their own new group (the process ID of the first child could be used as the process group ID of the group), and then signal that process group. This also removes the need for the parent to make itself immune to the signal.</p>
<p class="exer"><strong><a href="ch34.xhtml#ch34exe5">34-5</a>.</strong>&#160;&#160;&#160;If the <span class="literal">SIGTSTP</span> signal is unblocked before raising it again, then there is a small window of time (between the calls to <em>sigprocmask()</em> and <em>raise()</em>) during which, if the user types a second suspend character (<em>Control-Z</em>), the process will be stopped while still in the handler. Consequently, two <span class="literal">SIGCONT</span> signals will be required to resume the process.</p>
<h3 class="h3a" id="app06lev1sec21"><strong>Chapter 35</strong></h3>
<p class="exer"><strong><a href="ch35.xhtml#ch35exe3">35-3</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">procpri/demo_sched_fifo.c</span> in the source code distribution for this book.</p>
<h3 class="h3a" id="app06lev1sec22"><strong>Chapter 36</strong></h3>
<p class="exer"><strong><a href="ch36.xhtml#ch36exe1">36-1</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">procres/rusage_wait.c</span> in the source code distribution for this book.</p>
<p class="exer"><strong><a href="ch36.xhtml#ch36exe2">36-2</a>.</strong>&#160;&#160;&#160;A solution is provided in the files <span class="literal">rusage.c</span> and <span class="literal">print_rusage.c</span> in the <span class="literal">procres</span> subdirectory in the source code distribution for this book.</p>
<h3 class="h3a" id="app06lev1sec23"><strong>Chapter 37</strong></h3>
<p class="exer"><strong><a href="ch37.xhtml#ch37exe1">37-1</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">daemons/t_syslog.c</span> in the source code distribution for this book.</p>
<h3 class="h3a" id="app06lev1sec24"><strong>Chapter 38</strong></h3>
<p class="exer"><strong><a href="ch38.xhtml#ch38exe1">38-1</a>.</strong>&#160;&#160;&#160;Whenever a file is modified by an unprivileged user, the kernel clears the file&#8217;s set-user-ID permission bit. The set-group-ID permission bit is similarly cleared if the group-execute permission bit is enabled. (As detailed in <a href="ch55.xhtml#ch55lev1sec04">Section 55.4</a>, the combination of having the set-group-ID bit on while the group-execute bit is <em>off</em> has nothing to do with set-group-ID programs; instead, it is used to enable mandatory locking, and for this reason modifications to such a file don&#8217;t disable the set-group-ID bit.) Clearing these bits ensures that if the program file is writable by arbitrary users, then it can&#8217;t be modified and still retain its ability to give privileges to users executing the file. A privileged (<span class="literal">CAP_FSETID</span>) process can modify a file without the kernel clearing these permission bits.</p>
<h3 class="h3a" id="app06lev1sec25"><strong>Chapter 44</strong></h3>
<p class="exer"><strong><a href="ch44.xhtml#ch44exe1">44-1</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">pipes/change_case.c</span> in the source code distribution for this book.</p>
<p class="exer"><strong><a href="ch44.xhtml#ch44exe5">44-5</a>.</strong>&#160;&#160;&#160;It creates a race condition. Suppose that between the time the server sees end-of-file and the time it closes the file reading descriptor, a client opens the FIFO for <span epub:type="pagebreak" id="page_1433"/>writing (this will succeed without blocking), and then writes data to the FIFO <em>after</em> the server has closed the reading descriptor. At this point, the client will receive a <span class="literal">SIGPIPE</span> signal, since no process has the FIFO open for reading. Alternatively, the client might be able to both open the FIFO and write data to it before the server closes the reading descriptor. In this case, the client&#8217;s data would be lost, and it wouldn&#8217;t receive a response from the server. As a further exercise, you could try to demonstrate these behaviors by making the suggested modification to the server and creating a special-purpose client that repeatedly opens the server&#8217;s FIFOs, sends a message to the server, closes the server&#8217;s FIFO, and reads the server&#8217;s response (if any).</p>
<p class="exer"><strong><a href="ch44.xhtml#ch44exe6">44-6</a>.</strong>&#160;&#160;&#160;One possible solution would be to set a timer on the <em>open()</em> of the client FIFO using <em>alarm()</em>, as described in <a href="ch23.xhtml#ch23lev1sec03">Section 23.3</a>. This solution suffers from the drawback that the server would still be delayed for the period of the timeout. Another possible solution would be to open the client FIFO using the <span class="literal">O_NONBLOCK</span> flag. If this fails, then the server can assume a misbehaving client. This latter solution also requires changes to the client, which needs to ensure that it opens its FIFO (also using the <span class="literal">O_NONBLOCK</span> flag) prior to sending a request to the server. For convenience, the client should then turn off the <span class="literal">O_NONBLOCK</span> flag for the FIFO file descriptor, so that the subsequent <em>read()</em> call blocks. Finally, it is possible to implement a concurrent server solution for this application, with the main server process creating a child to send the response message to each client. (This would represent a rather resource-expensive solution in the case of this simple application.)</p>
<p class="exerpi">Other conditions that are not handled by this server remain. For example, it doesn&#8217;t handle the possibilities of the sequence number overflowing or a misbehaving client requesting large groups of sequence numbers in order to produce such overflows. The server also does not handle the possibility that the client specifies a negative value for the sequence length. Furthermore, a malicious client could create its reply FIFO, and then open the FIFO for reading and writing, and fill it with data before sending a request to the server; as a consequence, the server would be able to successfully open the reply FIFO, but would block when it tries to write the reply. As a further exercise, you could try to devise strategies for dealing with these possibilities.</p>
<p class="exerpi">In <a href="ch44.xhtml#ch44lev1sec08">Section 44.8</a>, we also noted another limitation that applies to the server in <a href="ch44.xhtml#ch44ex7">Listing 44-7</a>: if a client sends a message that contains the wrong number of bytes, then the server will be out of step when reading all subsequent client messages. One simple way to deal with this problem is to discard the use of fixed-length messages in favor of the use of a delimiter character.</p>
<h3 class="h3a" id="app06lev1sec26"><strong>Chapter 45</strong></h3>
<p class="exer"><strong><a href="ch45.xhtml#ch45exe2">45-2</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">svipc/t_ftok.c</span> in the source code distribution for this book.</p>
<h3 class="h3a" id="app06lev1sec27"><strong>Chapter 46</strong></h3>
<p class="exer"><strong><a href="ch46.xhtml#ch46exe3">46-3</a>.</strong>&#160;&#160;&#160;The value 0 is a valid message queue identifier, but 0 can&#8217;t be used as a message type.</p>
<h3 class="h3a" id="app06lev1sec28"><span epub:type="pagebreak" id="page_1434"/><strong>Chapter 47</strong></h3>
<p class="exer"><strong><a href="ch47.xhtml#ch47exe5">47-5</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">svsem/event_flags.c</span> in the source code distribution for this book.</p>
<p class="exer"><strong><a href="ch47.xhtml#ch47exe6">47-6</a>.</strong>&#160;&#160;&#160;A reserve operation can be implemented by reading a byte from the FIFO. Conversely, a release operation can be implemented by writing a byte to the FIFO. A conditional reserve operation can be implemented as a nonblocking read of a byte from the FIFO.</p>
<h3 class="h3a" id="app06lev1sec29"><strong>Chapter 48</strong></h3>
<p class="exer"><strong><a href="ch48.xhtml#ch48exe2">48-2</a>.</strong>&#160;&#160;&#160;Since access to the <em>shmp&#8211;&gt;cnt</em> value in the <span class="literal">for</span> loop increment step is no longer protected by the semaphore, there is a race condition between the writer next updating this value and the reader fetching it.</p>
<p class="exer"><strong><a href="ch48.xhtml#ch48exe4">48-4</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">svshm/svshm_mon.c</span> in the source code distribution for this book.</p>
<h3 class="h3a" id="app06lev1sec30"><strong>Chapter 49</strong></h3>
<p class="exer"><strong><a href="ch49.xhtml#ch49exe1">49-1</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">mmap/mmcopy.c</span> in the source code distribution for this book.</p>
<h3 class="h3a" id="app06lev1sec31"><strong>Chapter 50</strong></h3>
<p class="exer"><strong><a href="ch50.xhtml#ch50exe2">50-2</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">vmem/madvise_dontneed.c</span> in the source code distribution for this book.</p>
<h3 class="h3a" id="app06lev1sec32"><strong>Chapter 52</strong></h3>
<p class="exer"><strong><a href="ch52.xhtml#ch52exe6">52-6</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">pmsg/mq_notify_sigwaitinfo.c</span> in the source code distribution for this book.</p>
<p class="exer"><strong><a href="ch52.xhtml#ch52exe7">52-7</a>.</strong>&#160;&#160;&#160;It would not be safe to make <em>buffer</em> global. Once message notification is reenabled in <em>threadFunc()</em>, there is a chance that a second notification would be generated while <em>threadFunc()</em> is still executing. This second notification could initiate a second thread that executes <em>threadFunc()</em> at the same time as the first thread. Both threads would attempt to use the same global <em>buffer</em>, with unpredictable results. Note that the behavior here is implementation-dependent. SUSv3 permits an implementation to sequentially deliver notifications to the same thread. However, it is also permissible to deliver notifications in separate threads that execute concurrently, and this is what Linux does.</p>
<h3 class="h3a" id="app06lev1sec33"><strong>Chapter 53</strong></h3>
<p class="exer"><strong><a href="ch53.xhtml#ch53exe2">53-2</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">psem/psem_timedwait.c</span> in the source code distribution for this book.</p>
<h3 class="h3a" id="app06lev1sec34"><span epub:type="pagebreak" id="page_1435"/><strong>Chapter 55</strong></h3>
<p class="exer"><strong><a href="ch55.xhtml#ch55exe1">55-1</a>.</strong>&#160;&#160;&#160;The following hold for <em>flock()</em> on Linux:</p>
<p class="olista1">a) A series of shared locks can starve a process waiting to place an exclusive lock.</p>
<p class="olista1">b) There are no rules regarding which process is granted the lock. Essentially, the lock is granted to the process that is next scheduled. If that process happens to be one that obtains a shared lock, then all other processes requesting shared locks will also be able to have their requests granted simultaneously.</p>
<p class="exer"><strong><a href="ch55.xhtml#ch55exe2">55-2</a>.</strong>&#160;&#160;&#160;The <em>flock()</em> system call doesn&#8217;t detect deadlock. This is true of most <em>flock()</em> implementations, except those that implement <em>flock()</em> in terms of <em>fcntl()</em>.</p>
<p class="exer"><strong><a href="ch55.xhtml#ch55exe4">55-4</a>.</strong>&#160;&#160;&#160;In all except early (1.2 and earlier) Linux kernels, the two types of locking operate independently, and have no affect on one another.</p>
<h3 class="h3a" id="app06lev1sec35"><strong>Chapter 57</strong></h3>
<p class="exer"><strong><a href="ch57.xhtml#ch57exe4">57-4</a>.</strong>&#160;&#160;&#160;On Linux, the <em>sendto()</em> call fails with the error <span class="literal">EPERM</span>. On some other UNIX systems, a different error results. Some other UNIX implementations don&#8217;t enforce this constraint, letting a connected UNIX domain datagram socket receive datagrams from a sender other than its peer.</p>
<h3 class="h3a" id="app06lev1sec36"><strong>Chapter 59</strong></h3>
<p class="exer"><strong><a href="ch59.xhtml#ch59exe1">59-1</a>.</strong>&#160;&#160;&#160;A solution is provided in the files <span class="literal">read_line_buf.h</span> and <span class="literal">read_line_buf.c</span> in the <span class="literal">sockets</span> subdirectory in the source code distribution for this book.</p>
<p class="exer"><strong><a href="ch59.xhtml#ch59exe2">59-2</a>.</strong>&#160;&#160;&#160;A solution is provided in the files <span class="literal">is_seqnum_v2_sv.c</span>, <span class="literal">is_seqnum_v2_cl.c</span>, and <span class="literal">is_seqnum_v2.h</span> in the <span class="literal">sockets</span> subdirectory in the source code distribution for this book.</p>
<p class="exer"><strong><a href="ch59.xhtml#ch59exe3">59-3</a>.</strong>&#160;&#160;&#160;A solution is provided in the files <span class="literal">unix_sockets.h</span>, <span class="literal">unix_sockets.c</span>, <span class="literal">us_xfr_v2.h</span>, <span class="literal">us_xfr_v2_sv.c</span>, and <span class="literal">us_xfr_v2_cl.c</span> in the <span class="literal">sockets</span> subdirectory in the source code distribution for this book.</p>
<p class="exer"><strong><a href="ch59.xhtml#ch59exe5">59-5</a>.</strong>&#160;&#160;&#160;In the Internet domain, datagrams from a nonpeer socket are silently discarded.</p>
<h3 class="h3a" id="app06lev1sec37"><strong>Chapter 60</strong></h3>
<p class="exer"><strong><a href="ch60.xhtml#ch60exe2">60-2</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">sockets/is_echo_v2_sv.c</span> in the source code distribution for this book.</p>
<h3 class="h3a" id="app06lev1sec38"><strong>Chapter 61</strong></h3>
<p class="exer"><strong><a href="ch61.xhtml#ch61exe1">61-1</a>.</strong>&#160;&#160;&#160;Since the send and receive buffers for a TCP socket have a limited size, if the client sent a large quantity of data, then it might fill these buffers, at which point a further <em>write()</em> would (permanently) block the client before it read any of the server&#8217;s response.</p>
<p class="exer"><strong><a href="ch61.xhtml#ch61exe3">61-3</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">sockets/sendfile.c</span> in the source code distribution for this book.</p>
<h3 class="h3a" id="app06lev1sec39"><span epub:type="pagebreak" id="page_1436"/><strong>Chapter 62</strong></h3>
<p class="exer"><strong><a href="ch62.xhtml#ch62exe1">62-1</a>.</strong>&#160;&#160;&#160;The <em>tcgetattr()</em> function fails if it is applied to a file descriptor that doesn&#8217;t refer to a terminal.</p>
<p class="exer"><strong><a href="ch62.xhtml#ch62exe2">62-2</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">tty/ttyname.c</span> in the source code distribution for this book.</p>
<h3 class="h3a" id="app06lev1sec40"><strong>Chapter 63</strong></h3>
<p class="exer"><strong><a href="ch63.xhtml#ch63exe3">63-3</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">altio/select_mq.c</span> in the source code distribution for this book.</p>
<p class="exer"><strong><a href="ch63.xhtml#ch63exe4">63-4</a>.</strong>&#160;&#160;&#160;A race condition would result. Suppose the following sequence of events: (a) after <em>select()</em> has informed the program that the self-pipe has data, it performs the appropriate actions in response to the signal; (b) another signal arrives, and the handler writes a byte to the self-pipe and returns; and (c) the main program drains the self-pipe. As a consequence, the program misses the signal that was delivered in step (b).</p>
<p class="exer"><strong><a href="ch63.xhtml#ch63exe6">63-6</a>.</strong>&#160;&#160;&#160;The <em>epoll_wait()</em> call blocks, even when the interest list is empty. This can be useful in a multithreaded program, where one thread might add a descriptor to the <em>epoll</em> interest list, while another thread is blocked in an <em>epoll_wait()</em> call.</p>
<p class="exer"><strong><a href="ch63.xhtml#ch63exe7">63-7</a>.</strong>&#160;&#160;&#160;Successive <em>epoll_wait()</em> calls cycle through the list of ready file descriptors. This is useful because it helps prevent file-descriptor starvation, which could occur if <em>epoll_wait()</em> always (for example) returned the lowest-numbered ready file descriptor, and that file descriptor always had some input available.</p>
<h3 class="h3a" id="app06lev1sec41"><strong>Chapter 64</strong></h3>
<p class="exer"><strong><a href="ch64.xhtml#ch64exe1">64-1</a>.</strong>&#160;&#160;&#160;First, the child shell process terminates, followed by the <em>script</em> parent process. Since the terminal is operating in raw mode, the <em>Control-D</em> character is not interpreted by the terminal driver, but is instead passed as a literal character to the <em>script</em> parent process, which writes it to the pseudoterminal master. The pseudoterminal slave is operating in canonical mode, so this <em>Control-D</em> character is treated as an end-of-file, which causes the child shell&#8217;s next <em>read()</em> to return 0, with the result that the shell terminates. The termination of the shell closes the only file descriptor referring to the pseudoterminal slave. As a consequence, the next <em>read()</em> by the parent <em>script</em> process fails with the error <span class="literal">EIO</span> (or end-of-file on some other UNIX implementations), and this process then terminates.</p>
<p class="exer"><strong><a href="ch64.xhtml#ch64exe7">64-7</a>.</strong>&#160;&#160;&#160;A solution is provided in the file <span class="literal">pty/unbuffer.c</span> in the source code distribution for this book.</p>
</body>
</html>
