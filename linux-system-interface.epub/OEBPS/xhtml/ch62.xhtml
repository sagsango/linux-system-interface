<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch62"><span epub:type="pagebreak" id="page_1289"/><strong><span class="big">62</span></strong><br/><strong>TERMINALS</strong></h2>
<p class="noindenta">Historically, users accessed a UNIX system using a terminal connected via a serial line (an RS-232 connection). Terminals were cathode ray tubes (CRTs) capable of displaying characters and, in some cases, primitive graphics. Typically, CRTs provided a monochrome display of 24 lines by 80 columns. By today&#8217;s standards, these CRTs were small and expensive. In even earlier times, terminals were sometimes hard-copy teletype devices. Serial lines were also used to connect other devices, such as printers and modems, to a computer or to connect one computer to another.</p>
<div class="block">
<p class="noindent">On early UNIX systems, the terminal lines connected to the system were represented by character devices with names of the form <span class="literal">/dev/tty</span><em>n</em>. (On Linux, the <span class="literal">/dev/tty</span><em>n</em> devices are the virtual consoles on the system.) It is common to see the abbreviation <em>tty</em> (derived from teletype) as a shorthand for <em>terminal</em>.</p>
</div>
<p class="noindent">Especially during the early years of UNIX, terminal devices were not standardized, which meant that different character sequences were required to perform operations such as moving the cursor to the beginning of the line or the top of the screen. (Eventually, some vendor implementations of such <em>escape sequences</em>&#8212;for example, Digital&#8217;s VT-100&#8212;became de facto and, ultimately, ANSI standards, but a wide variety of terminal types continued to exist.) This lack of standardization meant that it was difficult to write portable programs that used terminal features. The <em>vi</em> editor was an early example of a program with such requirements. The <em>termcap</em> and <em>terminfo</em> databases (described in [<a href="bib.xhtml#bib98">Strang et al., 1988</a>]), which tabulate <span epub:type="pagebreak" id="page_1290"/>how to perform various screen-control operations for a wide variety of terminal types, and the <em>curses</em> library ([<a href="bib.xhtml#bib97">Strang, 1986</a>]) were developed in response to this lack of standardization.</p>
<p class="indent">It is no longer common to see a conventional terminal. The usual interface to modern UNIX systems is an X Window System window manager on a high-performance bit-mapped graphical monitor. (An old-style terminal provided functionality roughly equivalent to a single terminal window&#8212;an <em>xterm</em> or similar&#8212;in an X Window System. The fact that the user of such a terminal had only a single &#8220;window&#8221; to the system was the driving force behind the development of the job-control facilities described in <a href="ch34.xhtml#ch34lev1sec07">Section 34.7</a>.) Similarly, many devices (e.g., printers) that were once connected directly to a computer are now often intelligent devices connected via a network.</p>
<p class="indent">All of the above is a preamble to saying that the need to program terminal devices is less frequent than it used to be. Therefore, this chapter focuses on the aspects of terminal programming that are particularly relevant to software terminal emulators (i.e., <em>xterm</em> and similar). It gives only brief coverage to serial lines; references for further information about serial programming are provided at the end of this chapter.</p>
<h3 class="h3" id="ch62lev1sec01"><strong>62.1 Overview</strong></h3>
<p class="noindenta">Both a conventional terminal and a terminal emulator have an associated terminal driver that handles input and output on the device. (In the case of a terminal emulator, the device is a pseudoterminal. We describe pseudoterminals in <a href="ch64.xhtml#ch64">Chapter 64</a>.) Various aspects of the operation of the terminal driver can be controlled using the functions described in this chapter.</p>
<p class="indentb">When performing input, the driver is capable of operating in either of the following modes:</p>
<p class="bull">&#8226; <em>Canonical mode</em>: In this mode, terminal input is processed line by line, and line editing is enabled. Lines are terminated by a newline character, generated when the user presses the <em>Enter</em> key. A <em>read()</em> from the terminal returns only when a complete line of input is available, and returns at most one line. (If the <em>read()</em> requests fewer bytes than are available in the current line, then the remaining bytes are available for the next <em>read()</em>.) This is the default input mode.</p>
<p class="bull">&#8226; <em>Noncanonical mode</em>: Terminal input is not gathered into lines. Programs such as <em>vi</em>, <em>more</em>, and <em>less</em> place the terminal in noncanonical mode so that they can read single characters without the user needing to press the <em>Enter</em> key.</p>
<p class="noindentt">The terminal driver also interprets a range of special characters, such as the <em>interrupt</em> character (normally <em>Control-C</em>) and the <em>end-of-file</em> character (normally <em>Control-D</em>). Such interpretation may result in a signal being generated for the foreground process group or some type of input condition occurring for a program reading from the terminal. Programs that place the terminal in noncanonical mode typically also disable processing of some or all of these special characters.</p>
<p class="indent">A terminal driver operates two queues (<a href="ch62.xhtml#ch62fig1">Figure 62-1</a>): one for input characters transmitted from the terminal device to the reading process(es) and the other for output characters transmitted from processes to the terminal. If terminal echoing <span epub:type="pagebreak" id="page_1291"/>is enabled, then the terminal driver automatically appends a copy of any input character to the end of the output queue, so that input characters are also output on the terminal.</p>
<div class="block">
<p class="noindent">SUSv3 specifies the limit <span class="literal">MAX_INPUT</span>, which an implementation can use to indicate the maximum length of the terminal&#8217;s input queue. A related limit, <span class="literal">MAX_CANON</span>, defines the maximum number of bytes in a line of input in canonical mode. On Linux, <em>sysconf(_SC_MAX_INPUT)</em> and <em>sysconf(_SC_MAX_CANON)</em> both return the value 255. However, neither of these limits is actually employed by the kernel, which simply imposes a limit of 4096 bytes on the input queue. A corresponding limit on the size of the output queue also exists. However, applications don&#8217;t need to be concerned with this, since, if a process produces output faster than the terminal driver can handle it, the kernel suspends execution of the writing process until space is once more available in the output queue.</p>
<p class="indent">On Linux, we can call <em>ioctl(fd, FIONREAD, &#38;cnt)</em> to obtain the number of unread bytes in the input queue of the terminal referred to by the file descriptor <em>fd</em>. This feature is not specified in SUSv3.</p>
</div>
<div class="image"><img src="../images/f62-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch62fig1"/><strong>Figure 62-1:</strong> Input and output queues for a terminal device</p>
<h3 class="h3" id="ch62lev1sec02"><strong>62.2 Retrieving and Modifying Terminal Attributes</strong></h3>
<p class="noindenta">The <em>tcgetattr()</em> and <em>tcsetattr()</em> functions retrieve and modify the attributes of a terminal.</p>
<div class="box">
<p class="programsa">#include &lt;termios.h&gt;<br/><br/>int <span class="codestrong">tcgetattr</span>(int <span class="font1">fd</span>, struct termios *<span class="font1">termios_p</span>);<br/>int <span class="codestrong">tcsetattr</span>(int <span class="font1">fd</span>, int <span class="font1">optional_actions</span>, const struct termios *<span class="font1">termios_p</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_1292"/>The <em>fd</em> argument is a file descriptor that refers to a terminal. (If <em>fd</em> doesn&#8217;t refer to a terminal, these functions fail with the error <span class="literal">ENOTTY</span>.)</p>
<p class="indent">The <em>termios_p</em> argument is a pointer to a <em>termios</em> structure, which records terminal attributes:</p>
<p class="programs">struct termios {<br/>&#160;&#160;&#160;&#160;tcflag_t c_iflag;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Input flags */<br/>&#160;&#160;&#160;&#160;tcflag_t c_oflag;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Output flags */<br/>&#160;&#160;&#160;&#160;tcflag_t c_cflag;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Control flags */<br/>&#160;&#160;&#160;&#160;tcflag_t c_lflag;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Local modes */<br/>&#160;&#160;&#160;&#160;cc_t&#160;&#160;&#160;&#160;&#160;c_line;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Line discipline (nonstandard)*/<br/>&#160;&#160;&#160;&#160;cc_t&#160;&#160;&#160;&#160;&#160;c_cc[NCCS];&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Terminal special characters */<br/>&#160;&#160;&#160;&#160;speed_t&#160;&#160;c_ispeed;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Input speed (nonstandard; unused) */<br/>&#160;&#160;&#160;&#160;speed_t&#160;&#160;c_ospeed;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Output speed (nonstandard; unused) */<br/>};</p>
<p class="noindentb">The first four fields of the <em>termios</em> structure are bit masks (the <em>tcflag_t</em> data type is an integer type of suitable size) containing flags that control various aspects of the terminal driver&#8217;s operation:</p>
<p class="bull">&#8226; <em>c_iflag</em> contains flags controlling terminal input;</p>
<p class="bull">&#8226; <em>c_oflag</em> contains flags controlling terminal output;</p>
<p class="bull">&#8226; <em>c_cflag</em> contains flags relating to hardware control of the terminal line; and</p>
<p class="bull">&#8226; <em>c_lflag</em> contains flags controlling the user interface for terminal input.</p>
<p class="noindentt">All of the flags used in the above fields are listed in <a href="ch62.xhtml#ch62table2">Table 62-2</a> (on <a href="ch62.xhtml#page_1302">page 1302</a>).</p>
<p class="indent">The <em>c_line</em> field specifies the line discipline for this terminal. For the purposes of programming terminal emulators, the line discipline will always be set to <span class="literal">N_TTY</span>, the so-called <em>new</em> discipline, a component of the kernel terminal-handling code that implements canonical mode I/O processing. Setting the line discipline can be relevant when programming serial lines.</p>
<p class="indent">The <em>c_cc</em> array contains the terminal special characters (<em>interrupt</em>, <em>suspend</em>, and so on) as well as fields controlling the operation of noncanonical mode input. The <em>cc_t</em> data type is an unsigned integer type suitable for holding these values, and the <span class="literal">NCCS</span> constant specifies the number of elements in this array. We describe the terminal special characters in <a href="ch62.xhtml#ch62lev1sec04">Section 62.4</a>.</p>
<p class="indent">The <em>c_ispeed</em> and <em>c_ospeed</em> fields are unused on Linux (and are not specified in SUSv3). We explain how Linux stores terminal line speeds in <a href="ch62.xhtml#ch62lev1sec07">Section 62.7</a>.</p>
<div class="block">
<p class="noindent">The Seventh Edition and early BSD terminal driver (known as the <em>tty</em> driver) had grown over time so that it used no less than four different data structures to represent the information equivalent to the <em>termios</em> structure. System V replaced this baroque arrangement with a single structure called <em>termio</em>. The initial POSIX committee selected the System V API almost as is, in the process renaming it to <em>termios</em>.</p>
</div>
<p class="noindentb"><span epub:type="pagebreak" id="page_1293"/>When changing terminal attributes with <em>tcsetattr()</em>, the <em>optional_actions</em> argument determines when the change takes effect. This argument is specified as one of the following values:</p>
<p class="term"><span class="literal">TCSANOW</span></p>
<p class="termlist">The change is carried out immediately.</p>
<p class="term"><span class="literal">TCSADRAIN</span></p>
<p class="termlist">The change takes effect after all currently queued output has been transmitted to the terminal. Normally, this flag should be specified when making changes that affect terminal output, so that we don&#8217;t affect output that has already been queued but not yet displayed.</p>
<p class="term"><span class="literal">TCSAFLUSH</span></p>
<p class="termlist">The change takes effect as for <span class="literal">TCSADRAIN</span>, but, in addition, any input that is still pending at the time the change takes effect is discarded. This is useful, for example, when reading a password, where we wish to disable terminal echoing and prevent user type-ahead.</p>
<p class="noindentt">The usual (and recommended) way to change terminal attributes is to use <em>tcgetattr()</em> to retrieve a <em>termios</em> structure containing a copy of the current settings, change the desired attributes, and then use <em>tcsetattr()</em> to push the updated structure back to the driver. (This approach ensures that we pass a fully initialized structure to <em>tcsetattr()</em>.) For example, we can use the following sequence to turn terminal echoing off:</p>
<p class="programs">struct termios tp;<br/><br/>if (tcgetattr(STDIN_FILENO, &#38;tp) == -1)<br/>&#160;&#160;&#160;&#160;errExit("tcgetattr");<br/>tp.c_lflag &#38;= ~ECHO;<br/>if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &#38;tp) == -1)<br/>&#160;&#160;&#160;&#160;errExit("tcsetattr");</p>
<p class="noindent">The <em>tcsetattr()</em> function returns successfully if <em>any</em> of the requested changes to terminal attributes could be performed; it fails only if <em>none</em> of the requested changes could be made. This means that, when making multiple attribute changes, it may sometimes be necessary to make a further call to <em>tcgetattr()</em> to retrieve the new terminal attributes and compare them against the requested changes.</p>
<div class="block">
<p class="noindent">In <a href="ch34.xhtml#ch34lev2sec04">Section 34.7.2</a>, we noted that if <em>tcsetattr()</em> is called from a process in a background process group, then the terminal driver suspends the process group by delivering a <span class="literal">SIGTTOU</span> signal, and that, if called from an orphaned process group, <em>tcsetattr()</em> fails with the error <span class="literal">EIO</span>. The same statements apply for various other functions described in this chapter, including <em>tcflush()</em>, <em>tcflow()</em>, <em>tcsendbreak()</em>, and <em>tcdrain()</em>.</p>
<p class="indent">In earlier UNIX implementations, terminal attributes were accessed using <em>ioctl()</em> calls. Like several other functions described in this chapter, the <em>tcgetattr()</em> and <em>tcsetattr()</em> functions are POSIX inventions designed to address the problem that type checking of the third argument of <em>ioctl()</em> isn&#8217;t possible. On Linux, as in many other UNIX implementations, these are library functions layered on top of <em>ioctl()</em>.</p>
</div>
<h3 class="h3" id="ch62lev1sec03"><span epub:type="pagebreak" id="page_1294"/><strong>62.3 The <em>stty</em> Command</strong></h3>
<p class="noindenta">The <em>stty</em> command is the command-line analog of the <em>tcgetattr()</em> and <em>tcsetattr()</em> functions, allowing us to view and change terminal attributes from the shell. This is useful when trying to monitor, debug, or undo the effects of programs that modify terminal attributes.</p>
<p class="indent">We can view the current settings of all terminal attributes using the following command (here carried out on a virtual console):</p>
<p class="programs">$ <span class="codestrong">stty -a</span><br/>speed 38400 baud; rows 25; columns 80; line = 0;<br/>intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &lt;undef&gt;;<br/>eol2 = &lt;undef&gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R;<br/>werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;<br/>-parenb -parodd cs8 hupcl -cstopb cread -clocal -crtscts<br/>-ignbrk brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff<br/>-iuclc -ixany imaxbel -iutf8<br/>opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0<br/>isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt<br/>echoctl echoke</p>
<p class="noindent">The first line of the above output shows the terminal line speed (bits per second), the terminal window size, and the line discipline in numeric form (0 corresponds to <span class="literal">N_TTY</span>, the new line discipline).</p>
<p class="indent">The next three lines show the settings of the various terminal special characters. The notation <span class="literal">^C</span> denotes <em>Control-C</em>, and so on. The string <span class="literal">&lt;undef&gt;</span> means that the corresponding terminal special character is not currently defined. The <em>min</em> and <em>time</em> values relate to noncanonical mode input, and are described in <a href="ch62.xhtml#ch62lev2sec02">Section 62.6.2</a>.</p>
<p class="indent">The remaining lines show the settings of the various flags from (in order) the <em>c_cflag</em>, <em>c_iflag</em>, <em>c_oflag</em>, and <em>c_lflag</em> fields of the <em>termios</em> structure. Where a flag name is preceded by a hyphen (<span class="literal">-</span>), the flag is currently disabled; otherwise, it is currently enabled.</p>
<p class="indent">When entered without command-line arguments, <em>stty</em> shows just the terminal line speed, the line discipline, and any of the other settings that deviate from sane values.</p>
<p class="indent">We can change the settings of terminal special characters using commands such as the following:</p>
<p class="programs">$ <span class="codestrong">stty intr ^L</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Make the interrupt character Control-L</span></p>
<p class="noindentb">When specifying a control character as the final argument, we can do so in a variety of ways:</p>
<p class="bull">&#8226; as a 2-character sequence consisting of a caret (<span class="literal">^</span>) followed by the corresponding character (as shown above);</p>
<p class="bull">&#8226; as an octal or hexadecimal number (thus: <span class="literal">014</span> or <span class="literal">0xC</span>); or</p>
<p class="bull">&#8226; by typing the actual character itself.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_1295"/>If we employ the final option, and the character in question is one interpreted specially by the shell or the terminal driver, then we must precede it with the <em>literal next</em> character (usually <em>Control-V</em>):</p>
<p class="programs">$ <span class="codestrong">stty intr</span> <span class="font1">Control-V Control-L</span></p>
<p class="noindent">(Although, for readability, a space is shown between the <em>Control-V</em> and the <em>Control-L</em> in the above example, no white-space characters should be typed between the <em>Control-V</em> and the desired character.)</p>
<p class="indent">It is possible, though unusual, to define terminal special characters to be something other than control characters:</p>
<p class="programs">$ <span class="codestrong">stty intr q</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Make the interrupt character q</span></p>
<p class="noindent">Of course, when we do this, we can no longer use the <em>q</em> key for its usual purpose (i.e., generating the letter <em>q</em>).</p>
<p class="indent">To change terminal flags, such as the <span class="literal">TOSTOP</span> flag, we can use commands such as the following:</p>
<p class="programs">$ <span class="codestrong">stty tostop</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Enable the</span> TOSTOP <span class="font1">flag</span><br/>$ <span class="codestrong">stty -tostop</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Disable the</span> TOSTOP <span class="font1">flag</span></p>
<p class="noindent">Sometimes, when developing programs that modify terminal attributes, a program may crash, leaving the terminal in a state that renders it all but unusable. On a terminal emulator, we have the luxury of simply closing the terminal window and starting another. Alternatively, we can type in the following character sequence to restore the terminal flags and special characters to a reasonable state:</p>
<p class="programs"><span class="font1">Control-J</span> <span class="codestrong">stty sane</span> <span class="font1">Control-J</span></p>
<p class="noindent">The <em>Control-J</em> character is the real newline character (ASCII 10 decimal). We use this character because, in some modes, the terminal driver may no longer map the <em>Enter</em> key (ASCII 13 decimal) into a newline character. We type an initial <em>Control-J</em> to ensure that we have a fresh command line with no preceding characters. This may not be easy to verify if, for example, terminal echoing has been disabled.</p>
<p class="indent">The <em>stty</em> command operates on the terminal referred to by standard input. Using the <em>&#8211;F</em> option, we can (subject to permission checks) monitor and set the attributes of a terminal other than the one on which the <em>stty</em> command is run:</p>
<p class="programs">$ <span class="codestrong">su</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Need privilege to access another user's terminal</span><br/>Password:<br/># <span class="codestrong">stty -a -F /dev/tty3</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Fetch attributes for terminal</span> /dev/tty3<br/><span class="font1">Output omitted for brevity</span></p>
<p class="noindent">The <em>&#8211;F</em> option is a Linux-specific extension to the <em>stty</em> command. On many other UNIX implementations, <em>stty</em> always acts on the terminal referred to by standard input, and we must use the following alternative form (which can also be used on Linux):</p>
<p class="programs"># <span class="codestrong">stty -a &lt; /dev/tty3</span></p>
<h3 class="h3" id="ch62lev1sec04"><span epub:type="pagebreak" id="page_1296"/><strong>62.4 Terminal Special Characters</strong></h3>
<p class="noindenta"><a href="ch62.xhtml#ch62table1">Table 62-1</a> lists the special characters recognized by the Linux terminal driver. The first two columns show the name of the character and the corresponding constant that can be used as a subscript in the <em>c_cc</em> array. (As can be seen, these constants simply prefix the letter <em>V</em> in front of the character name.) The CR and NL characters don&#8217;t have corresponding <em>c_cc</em> subscripts, because the values of these characters can&#8217;t be changed.</p>
<p class="indent">The <em>Default setting</em> column of the table shows the usual default value for the special character. As well as being able to set a terminal special character to a specific value, it is also possible to disable the character by setting it to the value returned by the call <em>fpathconf(fd, _PC_VDISABLE)</em>, where <em>fd</em> is a file descriptor referring to a terminal. (On most UNIX implementations, this call returns the value 0.)</p>
<p class="indent">The operation of each of the special characters is subject to the setting of various flags in the <em>termios</em> bit-mask fields (described in <a href="ch62.xhtml#ch62lev1sec05">Section 62.5</a>), as shown in the penultimate column of the table.</p>
<p class="indent">The final column indicates which of these characters are specified by SUSv3. Regardless of the SUSv3 specification, most of these characters are supported on all UNIX implementations.</p>
<p class="tablecap"><a id="ch62table1"/><strong>Table 62-1:</strong> Terminal special characters</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Character</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><em>c_cc</em> subscript</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Description</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Default setting</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Relevant bit-mask flags</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="tablec"><strong>SUSv3</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">CR</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">(none)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Carriage return</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">^M</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ICANON</span>, <span class="literal">IGNCR</span>, <span class="literal">ICRNL</span>, <span class="literal">OPOST</span>, <span class="literal">OCRNL</span>, <span class="literal">ONOCR</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">DISCARD</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">VDISCARD</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Discard output</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">^O</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">(not implemented)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">EOF</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">VEOF</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">End-of-file</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">^D</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ICANON</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">EOL</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">VEOL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">End-of-line</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ICANON</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">EOL2</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">VEOL2</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Alternate end-of-line</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ICANON</span>, <span class="literal">IEXTEN</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">ERASE</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">VERASE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Erase character</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">^?</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ICANON</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">INTR</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">VINTR</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Interrupt (<span class="literal">SIGINT</span>)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">^C</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ISIG</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">KILL</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">VKILL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Erase line</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">^U</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ICANON</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">LNEXT</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">VLNEXT</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Literal next</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">^V</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ICANON</span>, <span class="literal">IEXTEN</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">NL</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">(none)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Newline</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">^J</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ICANON</span>, <span class="literal">INLCR</span>, <span class="literal">ECHONL</span>, <span class="literal">OPOST</span>, <span class="literal">ONLCR</span>, <span class="literal">ONLRET</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">QUIT</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">VQUIT</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Quit (<span class="literal">SIGQUIT</span>)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">^\</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ISIG</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">REPRINT</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">VREPRINT</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Reprint input line</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">^R</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ICANON</span>, <span class="literal">IEXTEN</span>, <span class="literal">ECHO</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">START</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">VSTART</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Start output</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">^Q</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IXON</span>, <span class="literal">IXOFF</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">STOP</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">VSTOP</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Stop output</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">^S</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IXON</span>, <span class="literal">IXOFF</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">SUSP</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">VSUSP</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Suspend (<span class="literal">SIGTSTP</span>)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">^Z</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ISIG</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table">WERASE</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">VWERASE</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">Erase word</p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec"><span class="literal">^W</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">ICANON</span>, <span class="literal">IEXTEN</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">&#160;</p></td>
</tr>
</tbody>
</table>
<p class="noindent">The following paragraphs provide more detailed explanations of the terminal special characters. Note that if the terminal driver performs its special input interpretation on one of these characters, then&#8212;with the exception of CR, EOL, EOL2, and NL&#8212;the character is discarded (i.e., it is not passed to any reading process).</p>
<h5 class="h5" id="ch62lev3sec01"><span epub:type="pagebreak" id="page_1297"/><strong>CR</strong></h5>
<p class="noindenta">CR is the <em>carriage return</em> character. This character is passed to the reading process. In canonical mode (<span class="literal">ICANON</span> flag set) with the <span class="literal">ICRNL</span> (<em>map CR to NL on input</em>) flag set (the default), this character is first converted to a newline (ASCII 10 decimal, <span class="literal">^J</span>) before being passed to the reading process. If the <span class="literal">IGNCR</span> (<em>ignore CR</em>) flag is set, then this character is ignored on input (in which case the true newline character must be used to terminate a line of input). An output CR character causes the terminal to move the cursor to the beginning of the line.</p>
<h5 class="h5" id="ch62lev3sec02"><strong>DISCARD</strong></h5>
<p class="noindenta">DISCARD is the <em>discard output</em> character. Although this character is defined within the <em>c_cc</em> array, it has no effect on Linux. On some other UNIX implementations, typing this character once causes program output to be discarded. This character is a toggle&#8212;typing it once more reenables the display of output. This is useful when a program is generating a large amount of output and we want to skip some of it. (This was much more useful on traditional terminals, where line speeds were slower and other &#8220;terminal windows&#8221; were unavailable.) This character is not passed to the reading process.</p>
<h5 class="h5" id="ch62lev3sec03"><strong>EOF</strong></h5>
<p class="noindenta">EOF is the canonical mode <em>end-of-file</em> character (usually <em>Control-D</em>). Entering this character at the beginning of a line causes an end-of-file condition to be detected by a process reading from the terminal (i.e., <em>read()</em> returns 0). If typed anywhere other than the initial character of a line, then this character simply causes <em>read()</em> to complete immediately, returning the characters so far input in the line. In both cases, the EOF character itself is not passed to the reading process.</p>
<h5 class="h5" id="ch62lev3sec04"><strong>EOL and EOL2</strong></h5>
<p class="noindenta">EOL and EOL2 are <em>additional line-delimiter</em> characters that operate like the standard newline (NL) character for canonical mode input, terminating a line of input and making it available to the reading process. By default, these characters are undefined. If they are defined, they are passed to the reading process. The EOL2 character is operational only if the <span class="literal">IEXTEN</span> (<em>extended input processing</em>) flag is set (the default).</p>
<p class="indent">These characters are rarely used. One application that does use them is <em>telnet</em>. By setting EOL or EOL2 to be the <em>telnet</em> escape character (usually <em>Control-]</em>, or, alternatively, the tilde character, <span class="literal">~</span>, if operating in <em>rlogin</em> mode), <em>telnet</em> is able to immediately catch that character, even while reading input in canonical mode.</p>
<h5 class="h5" id="ch62lev3sec05"><strong>ERASE</strong></h5>
<p class="noindenta">In canonical mode, typing the ERASE character erases the previously input character on the current line. The erased character and the ERASE character itself are not passed to the reading process.</p>
<h5 class="h5" id="ch62lev3sec06"><strong>INTR</strong></h5>
<p class="noindenta">INTR is the <em>interrupt</em> character. If the <span class="literal">ISIG</span> (<em>enable signals</em>) flag is set (the default), typing this character causes an <em>interrupt</em> signal (<span class="literal">SIGINT</span>) to be sent to the terminal&#8217;s <span epub:type="pagebreak" id="page_1298"/>foreground process group (<a href="ch34.xhtml#ch34lev1sec02">Section 34.2</a>). The INTR character itself is not passed to the reading process.</p>
<h5 class="h5" id="ch62lev3sec07"><strong>KILL</strong></h5>
<p class="noindenta">KILL is the <em>erase line</em> (also known as <em>kill line</em>) character. In canonical mode, typing this character causes the current line of input to be discarded (i.e., the characters typed so far, as well as the KILL character itself, are not passed to the reading process).</p>
<h5 class="h5" id="ch62lev3sec08"><strong>LNEXT</strong></h5>
<p class="noindenta">LNEXT is the <em>literal next</em> character. In some circumstances, we may wish to treat one of the terminal special characters as though it were a normal character for input to a reading process. Typing the literal next character (usually <em>Control-V</em>) causes the next character to be treated literally, voiding any special interpretation of the character that the terminal driver would normally perform. Thus, we could enter the 2-character sequence <em>Control-V Control-C</em> to supply a real <em>Control-C</em> character (ASCII 3) as input to the reading process. The LNEXT character itself is not passed to the reading process. This character is interpreted only in canonical mode with the <span class="literal">IEXTEN</span> (<em>extended input processing</em>) flag set (which is the default).</p>
<h5 class="h5" id="ch62lev3sec09"><strong>NL</strong></h5>
<p class="noindenta">NL is the <em>newline</em> character. In canonical mode, this character terminates an input line. The NL character itself is included in the line returned to the reading process. (The CR character is normally converted to NL in canonical mode.) An output NL character causes the terminal to move the cursor down one line. If the <span class="literal">OPOST</span> and <span class="literal">ONLCR</span> (<em>map NL to CR-NL</em>) flags are set (the default), then, on output, a newline character is mapped to the 2-character sequence CR plus NL. (The combination of the <span class="literal">ICRNL</span> and <span class="literal">ONLCR</span> flags means that an input CR is converted to a NL, and then echoed as CR plus NL.)</p>
<h5 class="h5" id="ch62lev3sec10"><strong>QUIT</strong></h5>
<p class="noindenta">If the <span class="literal">ISIG</span> flag is set (the default), typing the QUIT character causes a <em>quit</em> signal (<span class="literal">SIGQUIT</span>) to be sent to the terminal&#8217;s foreground process group (<a href="ch34.xhtml#ch34lev1sec02">Section 34.2</a>). The QUIT character itself is not passed to the reading process.</p>
<h5 class="h5" id="ch62lev3sec11"><strong>REPRINT</strong></h5>
<p class="noindenta">REPRINT is the <em>reprint input</em> character. In canonical mode with the <span class="literal">IEXTEN</span> flag set (the default), typing this character causes the current (as yet incomplete) line of input to be redisplayed on the terminal. This is useful if some other program (e.g., <em>wall(1)</em> or <em>write(1)</em>) has written output that has messed up the terminal display. The REPRINT character itself is not passed to the reading process.</p>
<h5 class="h5" id="ch62lev3sec12"><strong>START and STOP</strong></h5>
<p class="noindenta">START and STOP are the <em>start output</em> and <em>stop output</em> characters, which operate if the <span class="literal">IXON</span> (<em>enable start/stop output control</em>) flag is enabled (the default). (The START and STOP characters are not honored by some terminal emulators.)</p>
<p class="indent">Typing the STOP character suspends terminal output. The STOP character itself is not passed to the reading process. If the <span class="literal">IXOFF</span> flag is set and the terminal <span epub:type="pagebreak" id="page_1299"/>input queue is full, then the terminal driver automatically sends a STOP character to throttle the input.</p>
<p class="indent">Typing the START character causes terminal output to resume after previously being stopped by the STOP character. The START character itself is not passed to the reading process. If the <span class="literal">IXOFF</span> (<em>enable start/stop input control</em>) flag is set (this flag is disabled by default) and the terminal driver had previously sent a STOP character because the input queue was full, the terminal driver automatically generates a START character when space once more becomes available in the input queue.</p>
<p class="indent">If the <span class="literal">IXANY</span> flag is set, then any character, not just <span class="literal">START</span>, may be typed in order to restart output (and that character is similarly not passed to the reading process).</p>
<p class="indent">The START and STOP characters are used for software flow control in either direction between the computer and the terminal device. One function of these characters is to allow users to stop and start terminal output. This is output flow control, as enabled by <span class="literal">IXON</span>. However, flow control in the other direction (i.e., control of input flow from the device to the computer, as enabled by <span class="literal">IXOFF</span>) is also important when, for example, the device in question is a modem or another computer. Input flow control makes sure that no data is lost if the application is slow to handle input and the kernel buffers fill up.</p>
<p class="indent">With the higher line speeds that are nowadays typical, software flow control has been superseded by hardware (RTS/CTS) flow control, whereby data flow is enabled and disabled using signals sent via separate wires on the serial port. (RTS stands for <em>Request To Send</em>, and CTS stands for <em>Clear To Send</em>.)</p>
<h5 class="h5" id="ch62lev3sec13"><strong>SUSP</strong></h5>
<p class="noindenta">SUSP is the <em>suspend</em> character. If the <span class="literal">ISIG</span> flag is set (the default), typing this character causes a <em>terminal suspend</em> signal (<span class="literal">SIGTSTP</span>) to be sent to the terminal&#8217;s foreground process group (<a href="ch34.xhtml#ch34lev1sec02">Section 34.2</a>). The SUSP character itself is not passed to the reading process.</p>
<h5 class="h5" id="ch62lev3sec14"><strong>WERASE</strong></h5>
<p class="noindenta">WERASE is the <em>word erase</em> character. In canonical mode, with the <span class="literal">IEXTEN</span> flag set (the default), typing this character erases all characters back to the beginning of the previous word. A word is considered to be a sequence of letters, digits, and the underscore character. (On some UNIX implementations, a word is considered to be delimited by white space.)</p>
<h5 class="h5" id="ch62lev3sec15"><strong>Other terminal special characters</strong></h5>
<p class="noindenta">Other UNIX implementations provide terminal special characters in addition to those listed in <a href="ch62.xhtml#ch62table1">Table 62-1</a>.</p>
<p class="indent">BSD provides the DSUSP and STATUS characters. The DSUSP character (typically <em>Control-Y</em>) operates in a fashion similar to the SUSP character, but suspends the foreground process group only when it attempts to read the character (i.e., after all preceding input has been read). Several non-BSD-derived implementations also provide the DSUSP character.</p>
<p class="indent">The STATUS character (typically <em>Control-T</em>) causes the kernel to display status information on the terminal (including the state of the foreground process and how much CPU time it has consumed), and sends a <span class="literal">SIGINFO</span> signal to the foreground process group. If desired, processes can catch this signal and display further status <span epub:type="pagebreak" id="page_1300"/>information. (Linux provides a vaguely similar feature in the form of the <em>magic SysRq key</em>; see the kernel source file <span class="literal">Documentation/sysrq.txt</span> for details.)</p>
<p class="indent">System V derivatives provide the SWTCH character. This character is used to switch shells under <em>shell layers</em>, a System V predecessor to job control.</p>
<h5 class="h5" id="ch62lev3sec16"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch62.xhtml#ch62ex1">Listing 62-1</a> shows the use of <em>tcgetattr()</em> and <em>tcsetattr()</em> to change the terminal <em>interrupt</em> character. This program sets the <em>interrupt</em> character to be the character whose numeric value is supplied as the program&#8217;s command-line argument, or disables the <em>interrupt</em> character if no command-line argument is supplied.</p>
<p class="indent">The following shell session demonstrates the use of this program. We begin by setting the <em>interrupt</em> character to <em>Control-L</em> (ASCII 12), and then verify the change with <em>stty</em>:</p>
<p class="programs">$ <span class="codestrong">./new_intr 12</span><br/>$ <span class="codestrong">stty</span><br/>speed 38400 baud; line = 0;<br/>intr = ^L;</p>
<p class="noindent">We then start a process running <em>sleep(1)</em>. We find that typing <em>Control-C</em> no longer has its usual effect of terminating a process, but typing <em>Control-L</em> does terminate the process.</p>
<p class="programs">$ <span class="codestrong">sleep 10</span><br/>^C&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Control-C has no effect; it is just echoed</span><br/><span class="font1">Type Control-L to terminate sleep</span></p>
<p class="noindent">We now display the value of the shell <em>$?</em> variable, which shows the termination status of the last command:</p>
<p class="programs">$ <span class="codestrong">echo $?</span><br/>130</p>
<p class="noindent">We see that the termination status of the process was 130. This indicates that the process was killed by signal 130 &#8211; 128 = 2; signal number 2 is <span class="literal">SIGINT</span>.</p>
<p class="indent">Next, we use our program to disable the <em>interrupt</em> character.</p>
<p class="programs">$ <span class="codestrong">./new_intr</span><br/>$ <span class="codestrong">stty</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Verify the change</span><br/>speed 38400 baud; line = 0;<br/>intr = &lt;undef&gt;;</p>
<p class="noindent">Now we find that neither <em>Control-C</em> nor <em>Control-L</em> generates a <span class="literal">SIGINT</span> signal, and we must instead use <em>Control-\</em> to terminate a program:</p>
<p class="programs">$ <span class="codestrong">sleep 10</span><br/>^C^L&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Control-C and Control-L are simply echoed</span><br/><span class="font1">Type Control-\ to generate</span> SIGQUIT<br/>Quit<br/>$ <span class="codestrong">stty sane</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Return terminal to a sane state</span></p>
<p class="examplet"><span epub:type="pagebreak" id="page_1301"/><a id="ch62ex1"/><strong>Listing 62-1:</strong> Changing the terminal <em>interrupt</em> character</p>
<p class="programsli">___________________________________________________________ <span class="codestrong">tty/new_intr.c</span><br/><br/>#include &lt;termios.h&gt;<br/>#include &lt;ctype.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct termios tp;<br/>&#160;&#160;&#160;&#160;int intrChar;<br/><br/>&#160;&#160;&#160;&#160;if (argc &gt; 1 &#38;&#38; strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s [intr-char]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;/* Determine new INTR setting from command line */<br/><br/>&#160;&#160;&#160;&#160;if (argc == 1) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Disable */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;intrChar = fpathconf(STDIN_FILENO, _PC_VDISABLE);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (intrChar == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("Couldn't determine VDISABLE");<br/>&#160;&#160;&#160;&#160;} else if (isdigit((unsigned char) argv[1][0])) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;intrChar = strtoul(argv[1], NULL, 0);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allows hex, octal */<br/>&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Literal character */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;intrChar = argv[1][0];<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;/* Fetch current terminal settings, modify INTR character, and<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;push changes back to the terminal driver */<br/><br/>&#160;&#160;&#160;&#160;if (tcgetattr(STDIN_FILENO, &#38;tp) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("tcgetattr");<br/>&#160;&#160;&#160;&#160;tp.c_cc[VINTR] = intrChar;<br/>&#160;&#160;&#160;&#160;if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &#38;tp) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("tcsetattr");<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>___________________________________________________________ <span class="codestrong">tty/new_intr.c</span></p>
<h3 class="h3" id="ch62lev1sec05"><strong>62.5 Terminal Flags</strong></h3>
<p class="noindenta"><a href="ch62.xhtml#ch62table2">Table 62-2</a> lists the settings controlled by each of the four flag fields of the <em>termios</em> structure. The constants listed in this table correspond to single bits, except those specifying the term <em>mask</em>, which are values spanning several bits; these may contain one of a range of values, shown in parentheses. The column labeled <em>SUSv3</em> indicates whether the flag is specified in SUSv3. The <em>Default</em> column shows the default settings for a virtual console login.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_1302"/>Many shells that provide command-line editing facilities perform their own manipulations of the flags listed in <a href="ch62.xhtml#ch62table2">Table 62-2</a>. This means that if we try using <em>stty(1)</em> to experiment with these settings, then the changes may not be effective when entering shell commands. To circumvent this behavior, we must disable command-line editing in the shell. For example, command-line editing can be disabled by specifying the command-line option <em>&#8211;&#8211;noediting</em> when invoking <em>bash</em>.</p>
</div>
<p class="tablecap"><a id="ch62table2"/><strong>Table 62-2:</strong> Terminal flags</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Field/Flag</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Description</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong>Default</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="tablec"><strong>SUSv3</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>c_iflag</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">BRKINT</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Signal interrupt (<span class="literal">SIGINT</span>) on BREAK condition</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">on</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">ICRNL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Map CR to NL on input</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">on</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">IGNBRK</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Ignore BREAK condition</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">IGNCR</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Ignore CR on input</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">IGNPAR</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Ignore characters with parity errors</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">IMAXBEL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Ring bell when terminal input queue is full (unused)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">(on)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">INLCR</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Map NL to CR on input</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">INPCK</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Enable input parity checking</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">ISTRIP</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Strip high bit (bit 8) from input characters</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">IUTF8</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Input is UTF-8 (since Linux 2.6.4)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">IUCLC</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Map uppercase to lowercase on input (if <span class="literal">IEXTEN</span> also set)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">IXANY</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Allow any character to restart stopped output</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">IXOFF</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Enable start/stop input flow control</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">IXON</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Enable start/stop output flow control</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">on</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="tablei"><span class="literal">PARMRK</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Mark parity errors (with 2 prefix bytes: 0377 + 0)</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>c_oflag</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">BSDLY</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Backspace delay mask (<span class="literal">BS0</span>, <span class="literal">BS1</span>)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">BS0</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">CRDLY</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">CR delay mask (<span class="literal">CR0</span>, <span class="literal">CR1</span>, <span class="literal">CR2</span>, <span class="literal">CR3</span>)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">CR0</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">FFDLY</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Form-feed delay mask (<span class="literal">FF0</span>, <span class="literal">FF1</span>)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">FF0</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">NLDLY</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Newline delay mask (<span class="literal">NL0</span>, <span class="literal">NL1</span>)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">NL0</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">OCRNL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Map CR to NL on output (see also <span class="literal">ONOCR</span>)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">OFDEL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Use DEL (0177) as fill character; otherwise NUL (0)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">OFILL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Use fill characters for delay (rather than timed delay)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">OLCUC</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Map lowercase to uppercase on output</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">ONLCR</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Map NL to CR-NL on output</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">on</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">ONLRET</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Assume NL performs CR function (move to start of line)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">ONOCR</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Don&#8217;t output CR if already at column 0 (start of line)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">OPOST</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Perform output postprocessing</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">on</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">TABDLY</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Horizontal-tab delay mask (<span class="literal">TAB0</span>, <span class="literal">TAB1</span>, <span class="literal">TAB2</span>, <span class="literal">TAB3</span>)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">TAB0</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="tablei"><span class="literal">VTDLY</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Vertical-tab delay mask (<span class="literal">VT0</span>, <span class="literal">VT1</span>)</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">VT0</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>c_cflag</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">CBAUD</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Baud (bit rate) mask (<span class="literal">B0</span>, <span class="literal">B2400</span>, <span class="literal">B9600</span>, and so on)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">B38400</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">CBAUDEX</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Extended baud (bit rate) mask (for rates &gt; 38,400)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">CIBAUD</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Input baud (bit rate), if different from output (unused)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">(off)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">CLOCAL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Ignore modem status lines (don&#8217;t check carrier signal)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">CMSPAR</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Use &#8220;stick&#8221; (mark/space) parity</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span epub:type="pagebreak" id="page_1303"/><span class="literal">CREAD</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Allow input to be received</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">on</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">CRTSCTS</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Enable RTS/CTS (hardware) flow control</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">CSIZE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Character-size mask (5 to 8 bits: <span class="literal">CS5</span>, <span class="literal">CS6</span>, <span class="literal">CS7</span>, <span class="literal">CS8</span>)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">CS8</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">CSTOPB</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Use 2 stop bits per character; otherwise 1</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">HUPCL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Hang up (drop modem connection) on last close</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">on</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">PARENB</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Parity enable</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="tablei"><span class="literal">PARODD</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Use odd parity; otherwise even</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>c_lflag</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">ECHO</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Echo input characters</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">on</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">ECHOCTL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Echo control characters visually (e.g., <span class="literal">^L</span>)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">on</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">ECHOE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Perform ERASE visually</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">on</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">ECHOK</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Echo KILL visually</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">on</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">ECHOKE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Don&#8217;t output a newline after echoed KILL</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">on</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">ECHONL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Echo NL (in canonical mode) even if echoing is disabled</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">ECHOPRT</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Echo deleted characters backward (between <span class="literal">\</span> and <span class="literal">/</span>)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">FLUSHO</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Output is being flushed (unused)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">-</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">ICANON</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Canonical mode (line-by-line) input</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">on</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">IEXTEN</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Enable extended processing of input characters</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">on</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">ISIG</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Enable signal-generating characters (INTR, QUIT, SUSP)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">on</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">NOFLSH</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Disable flushing on INTR, QUIT, and SUSP</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">PENDIN</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Redisplay pending input at next read (not implemented)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">(off)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablei"><span class="literal">TOSTOP</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Generate <span class="literal">SIGTTOU</span> for background output (<a href="ch34.xhtml#ch34lev2sec03">Section 34.7.1</a>)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">off</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="tablei"><span class="literal">XCASE</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">Canonical upper/lowercase presentation (unimplemented)</p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec">(off)</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">&#160;</p></td>
</tr>
</tbody>
</table>
<p class="noindent">Several of the flags listed in <a href="ch62.xhtml#ch62table2">Table 62-2</a> were provided for historical terminals with limited capabilities, and these flags have little use on modern systems. For example, the <span class="literal">IUCLC</span>, <span class="literal">OLCUC</span>, and <span class="literal">XCASE</span> flags were used with terminals that were capable of displaying only uppercase letters. On many older UNIX systems, if a user tried logging in with an uppercase username, the <em>login</em> program assumed that the user was sitting at such a terminal and would set these flags, and then the following password prompt would appear:</p>
<p class="programs">\PASSWORD:</p>
<p class="noindent">From this point on, all lowercase characters were output in uppercase, and real uppercase characters were preceded by a backslash (<span class="literal">\</span>). Similarly, for input, a real uppercase character could be specified by a preceding backslash. The <span class="literal">ECHOPRT</span> flag was also designed for limited-capability terminals.</p>
<p class="indent">The various delay masks are also historical, allowing for terminals and printers that took longer to echo characters such as carriage return and form feed. The related <span class="literal">OFILL</span> and <span class="literal">OFDEL</span> flags specified how such a delay was to be performed. Most of these flags are unused on Linux. One exception is the <span class="literal">TAB3</span> setting for the <span class="literal">TABDLY</span> mask, which causes tab characters to be output as (up to eight) spaces.</p>
<p class="indent">The following paragraphs provide more details about some of the <em>termios</em> flags.</p>
<h5 class="h5" id="ch62lev3sec17"><span epub:type="pagebreak" id="page_1304"/><span class="literal"><span class="codestrong">BRKINT</span></span></h5>
<p class="noindent">If the <span class="literal">BRKINT</span> flag is set and the <span class="literal">IGNBRK</span> flag is not set, then a <span class="literal">SIGINT</span> signal is sent to the foreground process group when a BREAK condition occurs.</p>
<div class="block">
<p class="noindent">Most conventional dumb terminals provided a <em>BREAK</em> key. Pressing this key doesn&#8217;t actually generate a character, but instead causes a <em>BREAK condition</em>, whereby a series of 0 bits is sent to the terminal driver for a specified length of time, typically 0.25 or 0.5 seconds (i.e., longer than the time required to transmit a single byte). (Unless the <span class="literal">IGNBRK</span> flag has been set, the terminal driver consequently delivers a single 0 byte to the reading process.) On many UNIX systems, the BREAK condition acted as a signal to a remote host to change its line speed (baud) to something suitable for the terminal. Thus, the user would press the <em>BREAK</em> key until a valid login prompt appeared, indicating that the line speed was now suitable for this terminal.</p>
<p class="indent">On a virtual console, we can generate a BREAK condition by pressing <em>Control-Break</em>.</p>
</div>
<h5 class="h5" id="ch62lev3sec18"><span class="literal"><span class="codestrong">ECHO</span></span></h5>
<p class="noindent">Setting the <span class="literal">ECHO</span> flag enables echoing of input characters. Disabling echoing is useful when reading passwords. Echoing is also disabled within the command mode of <em>vi</em>, where keyboard characters are interpreted as editing commands rather than text input. The <span class="literal">ECHO</span> flag is effective in both canonical and noncanonical modes.</p>
<h5 class="h5" id="ch62lev3sec19"><span class="literal"><span class="codestrong">ECHOCTL</span></span></h5>
<p class="noindent">If <span class="literal">ECHO</span> is set, then enabling the <span class="literal">ECHOCTL</span> flag causes control characters other than tab, newline, START, and STOP to be echoed in the form <span class="literal">^A</span> (for <em>Control-A</em>), and so on. If <span class="literal">ECHOCTL</span> is disabled, control characters are not echoed.</p>
<div class="block">
<p class="noindent">The control characters are those with ASCII codes less than 32, plus the DEL character (127 decimal). A control character, <em>x</em>, is echoed using a caret (<span class="literal">^</span>) followed by the character resulting from the expression <em>(x ^ 64)</em>. For all characters except DEL, the effect of the XOR (<span class="literal">^</span>) operator in this expression is to add 64 to the value of the character. Thus, <em>Control-A</em> (ASCII 1) is echoed as caret plus <span class="literal">A</span> (ASCII 65). For DEL, the expression has the effect of subtracting 64 from 127, yielding the value 63, the ASCII code for <span class="literal">?</span>, so that DEL is echoed as <span class="literal">^?</span>.</p>
</div>
<h5 class="h5" id="ch62lev3sec20"><span class="literal"><span class="codestrong">ECHOE</span></span></h5>
<p class="noindent">In canonical mode, setting the <span class="literal">ECHOE</span> flag causes ERASE to be performed visually, by outputting the sequence backspace-space-backspace to the terminal. If <span class="literal">ECHOE</span> is disabled, then the ERASE character is instead echoed (e.g., as <span class="literal">^?</span>), but still performs its function of deleting a character.</p>
<h5 class="h5" id="ch62lev3sec21"><span class="literal"><span class="codestrong">ECHOK</span></span> <strong>and</strong> <span class="literal"><span class="codestrong">ECHOKE</span></span></h5>
<p class="noindenta">The <span class="literal">ECHOK</span> and <span class="literal">ECHOKE</span> flags control the visual display when using the KILL (erase line) character in canonical mode. In the default case (both flags enabled), a line is erased visually (see <span class="literal">ECHOE</span>). If either of these flags is disabled, then a visual erase is not performed (but the input line is still discarded), and the KILL character is echoed (e.g., as <span class="literal">^U</span>). If <span class="literal">ECHOK</span> is set, but not <span class="literal">ECHOKE</span>, then a newline character is also output.</p>
<h5 class="h5" id="ch62lev3sec22"><span epub:type="pagebreak" id="page_1305"/><span class="literal"><span class="codestrong">ICANON</span></span></h5>
<p class="noindenta">Setting the <span class="literal">ICANON</span> flag enables canonical mode input. Input is gathered into lines, and special interpretation of the EOF, EOL, EOL2, ERASE, LNEXT, KILL, REPRINT, and WERASE characters is enabled (but note the effect of the <span class="literal">IEXTEN</span> flag described below).</p>
<h5 class="h5" id="ch62lev3sec23"><span class="literal"><span class="codestrong">IEXTEN</span></span></h5>
<p class="noindenta">Setting the <span class="literal">IEXTEN</span> flag enables extended processing of input characters. This flag (as well as <span class="literal">ICANON</span>) must be set in order for the following characters to be interpreted: EOL2, LNEXT, REPRINT, and WERASE. The <span class="literal">IEXTEN</span> flag must also be set for the <span class="literal">IUCLC</span> flag to be effective. SUSv3 merely says that the <span class="literal">IEXTEN</span> flag enables extended (implementation-defined) functions; details may vary on other UNIX implementations.</p>
<h5 class="h5" id="ch62lev3sec24"><span class="literal"><span class="codestrong">IMAXBEL</span></span></h5>
<p class="noindenta">On Linux, the setting of the <span class="literal">IMAXBEL</span> flag is ignored. On a console login, the bell is always rung when the input queue is full.</p>
<h5 class="h5" id="ch62lev3sec25"><span class="literal"><span class="codestrong">IUTF8</span></span></h5>
<p class="noindenta">Setting the <span class="literal">IUTF8</span> flag enables cooked mode (<a href="ch62.xhtml#ch62lev2sec03">Section 62.6.3</a>) to correctly handle UTF-8 input when performing line editing.</p>
<h5 class="h5" id="ch62lev3sec26"><span class="literal"><span class="codestrong">NOFLSH</span></span></h5>
<p class="noindenta">By default, when a signal is generated by typing the INTR, QUIT, or SUSP character, any outstanding data in the terminal input and output queues is flushed (discarded). Setting the <span class="literal">NOFLSH</span> flag disables such flushing.</p>
<h5 class="h5" id="ch62lev3sec27"><span class="literal"><span class="codestrong">OPOST</span></span></h5>
<p class="noindenta">Setting the <span class="literal">OPOST</span> flag enables output postprocessing. This flag must be set in order for any of the flags in the <em>c_oflag</em> field of the <em>termios</em> structure to be effective. (Put conversely, disabling the <span class="literal">OPOST</span> flag prevents all output postprocessing.)</p>
<h5 class="h5" id="ch62lev3sec28"><span class="literal"><span class="codestrong">PARENB</span></span>, <span class="literal"><span class="codestrong">IGNPAR</span></span>, <span class="literal"><span class="codestrong">INPCK</span></span>, <span class="literal"><span class="codestrong">PARMRK</span></span>, <strong>and</strong> <span class="literal"><span class="codestrong">PARODD</span></span></h5>
<p class="noindenta">The <span class="literal">PARENB</span>, <span class="literal">IGNPAR</span>, <span class="literal">INPCK</span>, <span class="literal">PARMRK</span>, and <span class="literal">PARODD</span> flags are concerned with parity generation and checking.</p>
<p class="indent">The <span class="literal">PARENB</span> flag enables generation of parity check bits for output characters and parity checking for input characters. If we want to perform only output parity generation, then we can disable input parity checking by turning <span class="literal">INPCK</span> off. If the <span class="literal">PARODD</span> flag is set, then odd parity is used in both cases; otherwise, even parity is used.</p>
<p class="indent">The remaining flags specify how an input character with parity errors should be handled. If the <span class="literal">IGNPAR</span> flag is set, the character is discarded (not passed to the reading process). Otherwise, if the <span class="literal">PARMRK</span> flag is set, then the character is passed to the reading process, but is preceded by the 2-byte sequence 0377 + 0. (If the <span class="literal">PARMRK</span> flag is set and <span class="literal">ISTRIP</span> is clear, then a real 0377 character is doubled to become 0377 + 0377.) If <span class="literal">PARMRK</span> is not set, but <span class="literal">INPCK</span> is set, then the character is discarded, and a 0 byte is <span epub:type="pagebreak" id="page_1306"/>passed to the reading process instead. If none of <span class="literal">IGNPAR</span>, <span class="literal">PARMRK</span>, or <span class="literal">INPCK</span> is set, then the character is passed as is to the reading process.</p>
<h5 class="h5" id="ch62lev3sec29"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch62.xhtml#ch62ex2">Listing 62-2</a> demonstrates the use of <em>tcgetattr()</em> and <em>tcsetattr()</em> to turn off the <span class="literal">ECHO</span> flag, so that input characters are not echoed. Here is an example of what we see when running this program:</p>
<p class="programs">$ <span class="codestrong">./no_echo</span><br/>Enter text:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">We type some text, which is not echoed,</span><br/>Read: Knock, knock, Neo.&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">but was nevertheless read</span></p>
<p class="examplet"><a id="ch62ex2"/><strong>Listing 62-2:</strong> Disabling terminal echoing</p>
<p class="programsli">____________________________________________________________ <span class="codestrong">tty/no_echo.c</span><br/><br/>#include &lt;termios.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>#define BUF_SIZE 100<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct termios tp, save;<br/>&#160;&#160;&#160;&#160;char buf[BUF_SIZE];<br/><br/>&#160;&#160;&#160;&#160;/* Retrieve current terminal settings, turn echoing off */<br/><br/>&#160;&#160;&#160;&#160;if (tcgetattr(STDIN_FILENO, &#38;tp) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("tcgetattr");<br/>&#160;&#160;&#160;&#160;save = tp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* So we can restore settings later */<br/>&#160;&#160;&#160;&#160;tp.c_lflag &#38;= ~ECHO;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* ECHO off, other bits unchanged */<br/>&#160;&#160;&#160;&#160;if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &#38;tp) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("tcsetattr");<br/><br/>&#160;&#160;&#160;&#160;/* Read some input and then display it back to the user */<br/><br/>&#160;&#160;&#160;&#160;printf("Enter text: ");<br/>&#160;&#160;&#160;&#160;fflush(stdout);<br/>&#160;&#160;&#160;&#160;if (fgets(buf, BUF_SIZE, stdin) == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Got end-of-file/error on fgets()\n");<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("\nRead: %s", buf);<br/><br/>&#160;&#160;&#160;&#160;/* Restore original terminal settings */<br/><br/>&#160;&#160;&#160;&#160;if (tcsetattr(STDIN_FILENO, TCSANOW, &#38;save) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("tcsetattr");<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>____________________________________________________________ <span class="codestrong">tty/no_echo.c</span></p>
<h3 class="h3" id="ch62lev1sec06"><span epub:type="pagebreak" id="page_1307"/><strong>62.6 Terminal I/O Modes</strong></h3>
<p class="noindenta">We have already noted that the terminal driver is capable of handling input in either canonical or noncanonical mode, depending on the setting of the <span class="literal">ICANON</span> flag. We now describe these two modes in detail. We then describe three useful terminal modes&#8212;cooked, cbreak, and raw&#8212;that were available in Seventh Edition UNIX, and show how these modes are emulated on modern UNIX systems by setting appropriate values in the <em>termios</em> structure.</p>
<h4 class="h4" id="ch62lev2sec01"><strong>62.6.1 Canonical Mode</strong></h4>
<p class="noindentab">Canonical mode input is enabled by setting the <span class="literal">ICANON</span> flag. Terminal input in canonical mode is distinguished by the following features:</p>
<p class="bull">&#8226; Input is gathered into lines, terminated by one of the line-delimiter characters: NL, EOL, EOL2 (if the <span class="literal">IEXTEN</span> flag is set), EOF (at anything other than the initial position in the line), or CR (if the <span class="literal">ICRNL</span> flag is enabled). Except in the case of EOF, the line delimiter is passed back to the reading process (as the last character in the line).</p>
<p class="bull">&#8226; Line editing is enabled, so that the current line of input can be modified. Thus, the following characters are enabled: ERASE, KILL, and, if the <span class="literal">IEXTEN</span> flag is set, WERASE.</p>
<p class="bull">&#8226; If the <span class="literal">IEXTEN</span> flag is set, the REPRINT and LNEXT characters are also enabled.</p>
<p class="noindentt">In canonical mode, a terminal <em>read()</em> returns when a complete line of input is available. (The <em>read()</em> itself may fetch only part of that line if it requested fewer bytes; remaining bytes will be fetched by subsequent calls to <em>read()</em>.) A <em>read()</em> may also terminate if interrupted by a signal handler and restarting of system calls is not enabled for this signal (<a href="ch21.xhtml#ch21lev1sec05">Section 21.5</a>).</p>
<div class="block">
<p class="noindent">While describing the <span class="literal">NOFLSH</span> flag in <a href="ch62.xhtml#ch62lev1sec05">Section 62.5</a>, we noted that the characters that generate signals also cause the terminal driver to flush the terminal input queue. This flushing occurs regardless of whether the signal is caught or ignored by an application. We can prevent such flushing by enabling the <span class="literal">NOFLSH</span> flag.</p>
</div>
<h4 class="h4" id="ch62lev2sec02"><strong>62.6.2 Noncanonical Mode</strong></h4>
<p class="noindenta">Some applications (e.g., <em>vi</em> and <em>less</em>) need to read characters from the terminal without the user supplying a line delimiter. Noncanonical mode is provided for this purpose. In noncanonical mode (<span class="literal">ICANON</span> unset), no special input processing is performed. In particular, input is no longer gathered into lines, but is instead available immediately.</p>
<p class="indent">In what circumstances does a noncanonical <em>read()</em> complete? We can specify that a noncanonical <em>read()</em> terminates after a certain time, after a certain number of bytes have been read, or both in combination. Two elements of the <em>termios c_cc</em> array determine the behavior: TIME and MIN. The TIME element (indexed using the constant <span class="literal">VTIME</span>) specifies a timeout value in tenths of a second. The MIN element (indexed using <span class="literal">VMIN</span>) specifies the minimum number of bytes to be read. (The MIN and TIME settings have no effect on canonical-mode terminal I/O.)</p>
<p class="indent"><span epub:type="pagebreak" id="page_1308"/>The precise operation and interaction of the MIN and TIME parameters depends on whether they each have nonzero values. The four possible cases are described below. Note that in all cases, if, at the time of a <em>read()</em>, sufficient bytes are already available to satisfy the requirements specified by MIN, <em>read()</em> returns immediately with the lesser of the number of bytes available and the number of bytes requested.</p>
<h5 class="h5" id="ch62lev3sec30"><strong>MIN == 0, TIME == 0 (polling read)</strong></h5>
<p class="noindenta">If data is available at the time of the call, then <em>read()</em> returns immediately with the lesser of the number of bytes available and the number of bytes requested. If no bytes are available, <em>read()</em> completes immediately, returning 0.</p>
<p class="indent">This case serves the usual requirements of polling, allowing the application to check if input is available without blocking if it is not. This mode is somewhat similar to setting the <span class="literal">O_NONBLOCK</span> flag (<a href="ch05.xhtml#ch05lev1sec09">Section 5.9</a>) for the terminal while in canonical mode. However, with <span class="literal">O_NONBLOCK</span>, if no bytes are available for reading, then <em>read()</em> returns &#8211;1 with the error <span class="literal">EAGAIN</span>.</p>
<h5 class="h5" id="ch62lev3sec31"><strong>MIN &gt; 0, TIME == 0 (blocking read)</strong></h5>
<p class="noindenta">The <em>read()</em> blocks (possibly indefinitely) until MIN bytes are available, and returns up to the number of bytes requested.</p>
<p class="indent">Programs such as <em>less</em> typically set MIN to 1 and TIME to 0. This allows the program to wait for single key presses without needing to waste CPU time by polling in a busy loop.</p>
<p class="indent">If a terminal is placed in noncanonical mode with MIN set to 1 and TIME set to 0, then the techniques described in <a href="ch63.xhtml#ch63">Chapter 63</a> can be used to check whether a single character (rather than a complete line) has been typed at the terminal.</p>
<h5 class="h5" id="ch62lev3sec32"><strong>MIN == 0, TIME &gt; 0 (read with timeout)</strong></h5>
<p class="noindenta">A timer is started when <em>read()</em> is called. The call returns as soon as at least 1 byte is available, or when TIME tenths of a second have elapsed. In the latter case, <em>read()</em> returns 0.</p>
<p class="indent">This case is useful for programs talking to a serial device (e.g., a modem). The program can send data to the device and then wait for a response, using a timeout to avoid hanging forever in case the device doesn&#8217;t respond.</p>
<h5 class="h5" id="ch62lev3sec33"><strong>MIN &gt; 0, TIME &gt; 0 (read with interbyte timeout)</strong></h5>
<p class="noindenta">After the initial byte of input becomes available, a timer is restarted as each further byte is received. The <em>read()</em> returns when either the lesser of MIN bytes and the number of bytes requested has been read, or when the time between receiving successive bytes exceeds TIME tenths of a second. Since the timer is started only after the initial byte becomes available, at least 1 byte is returned. (A <em>read()</em> can block indefinitely for this case.)</p>
<p class="indent">This case is useful for handling terminal keys that generate escape sequences. For example, on many terminals, the left-arrow key generates the 3-character sequence consisting of <em>Escape</em> followed by <span class="literal">OD</span>. These characters are transmitted in quick succession. Applications handling such sequences need to distinguish the pressing of such a key from the situation where the user slowly types each of the <span epub:type="pagebreak" id="page_1309"/>characters individually. This can be done by performing a <em>read()</em> with a small inter-byte timeout, say 0.2 seconds. Such a technique is used in the command mode of some versions of <em>vi</em>. (Depending on the length of the timeout, in such applications, we may be able to simulate a left-arrow key press by quickly typing the aforementioned 3-character sequence.)</p>
<h5 class="h5" id="ch62lev3sec34"><strong>Portably modifying and restoring MIN and TIME</strong></h5>
<p class="noindenta">For historical compatibility with some UNIX implementations, SUSv3 allows the values of the <span class="literal">VMIN</span> and <span class="literal">VTIME</span> constants to be the same as <span class="literal">VEOF</span> and <span class="literal">VEOL</span>, respectively, which means that these elements of the <em>termios c_cc</em> array may coincide. (On Linux, the values of these constants are distinct.) This is possible because <span class="literal">VEOF</span> and <span class="literal">VEOL</span> are unused in noncanonical mode. The fact that <span class="literal">VMIN</span> and <span class="literal">VEOF</span> may have the same value means that caution is needed in a program that enters noncanonical mode, sets MIN (typically to 1), and then later returns to canonical mode. On return to canonical mode, EOF will no longer have its usual value of ASCII 4 (<em>Control-D</em>). The portable way to deal with this problem is to save a copy of the <em>termios</em> settings prior to changing to noncanonical mode, and then use this saved structure to return to canonical mode.</p>
<h4 class="h4" id="ch62lev2sec03"><strong>62.6.3 Cooked, Cbreak, and Raw Modes</strong></h4>
<p class="noindenta">The terminal driver in Seventh Edition UNIX (as well as in early versions of BSD) was capable of handling input in three modes: <em>cooked</em>, <em>cbreak</em>, and <em>raw</em>. The differences between the three modes are summarized in <a href="ch62.xhtml#ch62table3">Table 62-3</a>.</p>
<p class="tablecap"><a id="ch62table3"/><strong>Table 62-3:</strong> Differences between cooked, cbreak, and raw terminal modes</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th" rowspan="2"><p class="table"><strong>Feature</strong></p></td>
<td style="vertical-align: top;" class="table_th1" colspan="3"><p class="tablec"><strong>Mode</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Cooked</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Cbreak</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Raw</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Input available</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">line by line</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">char. by char.</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">char. by char.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Line-editing?</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">no</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">no</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Signal-generating characters interpreted?</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">no</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">START/STOP interpreted?</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">no</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Other special characters interpreted?</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">no</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">no</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Other input processing performed?</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">no</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Other output processing performed?</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">no</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table">Input echoed?</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">yes</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">maybe</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">no</p></td>
</tr>
</tbody>
</table>
<p class="noindent">Cooked mode was essentially canonical mode with all of the default special character processing enabled (i.e., interpretation of <span class="literal">CR</span>, <span class="literal">NL</span>, and <span class="literal">EOF</span>; enabling of line editing; handling of signal-generating characters; <span class="literal">ICRNL</span>; <span class="literal">OCRNL</span>; and so on).</p>
<p class="indent">Raw mode was the converse: noncanonical mode, with all input and output processing, as well as echoing, switched off. (An application that needed to ensure that the terminal driver makes absolutely no changes to the data transferred across a serial line would use this mode.)</p>
<p class="indent">Cbreak mode was intermediate between cooked and raw modes. Input was noncanonical, but signal-generating characters were interpreted, and the various input and output transformations could still occur (depending on individual flag <span epub:type="pagebreak" id="page_1310"/>settings). Cbreak mode did not disable echoing, but applications employing this mode would usually disable echoing as well. Cbreak mode was useful in screen-handling applications (such as <em>less</em>) that permitted character-by-character input, but still needed to allow interpretation of characters such as INTR, QUIT, and SUSP.</p>
<h5 class="h5" id="ch62lev3sec35"><strong>Example: setting raw and cbreak mode</strong></h5>
<p class="noindenta">In the Seventh Edition and the original BSD terminal drivers, it was possible to switch to raw or cbreak mode by tweaking single bits (called <span class="literal">RAW</span> and <span class="literal">CBREAK</span>) in the terminal driver data structures. With the transition to the POSIX <em>termios</em> interface (now supported on all UNIX implementations), single bits for selecting raw and cbreak mode are no longer available, and applications emulating these modes must explicitly change the required fields of the <em>termios</em> structure. <a href="ch62.xhtml#ch62ex3">Listing 62-3</a> provides two functions, <em>ttySetCbreak()</em> and <em>ttySetRaw()</em>, that implement the equivalents of these terminal modes.</p>
<div class="block">
<p class="noindent">Applications that use the <em>ncurses</em> library can call the functions <em>cbreak()</em> and <em>raw()</em>, which perform similar tasks to our functions in <a href="ch62.xhtml#ch62ex3">Listing 62-3</a>.</p>
</div>
<p class="examplet"><a id="ch62ex3"/><strong>Listing 62-3:</strong> Switching a terminal to cbreak and raw modes</p>
<p class="programsli">_______________________________________________________ <span class="codestrong">tty/tty_functions.c</span><br/><br/>#include &lt;termios.h&gt;<br/>#include &lt;unistd.h&gt;<br/>#include "tty_functions.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declares functions defined here */<br/><br/>/* Place terminal referred to by 'fd' in cbreak mode (noncanonical mode<br/>&#160;&#160;&#160;with echoing turned off). This function assumes that the terminal is<br/>&#160;&#160;&#160;currently in cooked mode (i.e., we shouldn't call it if the terminal<br/>&#160;&#160;&#160;is currently in raw mode, since it does not undo all of the changes<br/>&#160;&#160;&#160;made by the ttySetRaw() function below). Return 0 on success, or -1<br/>&#160;&#160;&#160;on error. If 'prevTermios' is non-NULL, then use the buffer to which<br/>&#160;&#160;&#160;it points to return the previous terminal settings. */<br/><br/>int<br/>ttySetCbreak(int fd, struct termios *prevTermios)<br/>{<br/>&#160;&#160;&#160;&#160;struct termios t;<br/><br/>&#160;&#160;&#160;&#160;if (tcgetattr(fd, &#38;t) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/>&#160;&#160;&#160;&#160;if (prevTermios != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*prevTermios = t;<br/><br/>&#160;&#160;&#160;&#160;t.c_lflag &#38;= ~(ICANON | ECHO);<br/>&#160;&#160;&#160;&#160;t.c_lflag |= ISIG;<br/><br/>&#160;&#160;&#160;&#160;t.c_iflag &#38;= ~ICRNL;<br/><br/>&#160;&#160;&#160;&#160;t.c_cc[VMIN] = 1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Character-at-a-time input */<br/>&#160;&#160;&#160;&#160;t.c_cc[VTIME] = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* with blocking */<br/><br/>&#160;&#160;&#160;&#160;if (tcsetattr(fd, TCSAFLUSH, &#38;t) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>/* Place terminal referred to by 'fd' in raw mode (noncanonical mode<br/>&#160;&#160;&#160;with all input and output processing disabled). Return 0 on success,<br/>&#160;&#160;&#160;or -1 on error. If 'prevTermios' is non-NULL, then use the buffer to<br/>&#160;&#160;&#160;which it points to return the previous terminal settings. */<br/><br/>int<br/>ttySetRaw(int fd, struct termios *prevTermios)<br/>{<br/>&#160;&#160;&#160;&#160;struct termios t;<br/><br/>&#160;&#160;&#160;&#160;if (tcgetattr(fd, &#38;t) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/>&#160;&#160;&#160;&#160;if (prevTermios != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*prevTermios = t;<br/><br/>&#160;&#160;&#160;&#160;t.c_lflag &#38;= ~(ICANON | ISIG | IEXTEN | ECHO);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Noncanonical mode, disable signals, extended<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;input processing, and echoing */<br/><br/>&#160;&#160;&#160;&#160;t.c_iflag &#38;= ~(BRKINT | ICRNL | IGNBRK | IGNCR | INLCR |<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;INPCK | ISTRIP | IXON | PARMRK);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Disable special handling of CR, NL, and BREAK.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;No 8th-bit stripping or parity error handling.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Disable START/STOP output flow control. */<br/><br/>&#160;&#160;&#160;&#160;t.c_oflag &#38;= ~OPOST;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Disable all output processing */<br/><br/>&#160;&#160;&#160;&#160;t.c_cc[VMIN] = 1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Character-at-a-time input */<br/>&#160;&#160;&#160;&#160;t.c_cc[VTIME] = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* with blocking */<br/><br/>&#160;&#160;&#160;&#160;if (tcsetattr(fd, TCSAFLUSH, &#38;t) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/>_______________________________________________________ <span class="codestrong">tty/tty_functions.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_1311"/>A program that places the terminal in raw or cbreak mode must be careful to return the terminal to a usable mode when it terminates. Among other tasks, this entails handling all of the signals that are likely to be sent to the program, so that <span epub:type="pagebreak" id="page_1312"/>the program is not prematurely terminated. (Job-control signals can still be generated from the keyboard in cbreak mode.)</p>
<p class="indentb">An example of how to do this is provided in <a href="ch62.xhtml#ch62ex4">Listing 62-4</a>. This program performs the following steps:</p>
<p class="bull">&#8226; Set the terminal to either cbreak mode <span class="ent">&#x2468;</span> or raw mode <span class="ent">&#x246B;</span>, depending on whether a command-line argument (any string) is supplied <span class="ent">&#x2467;</span>. The previous terminal settings are saved in the global variable <em>userTermios</em> <span class="ent">&#x2460;</span>.</p>
<p class="bull">&#8226; If the terminal was placed in cbreak mode, then signals can be generated from the terminal. These signals need to be handled so that terminating or suspending the program leaves the terminal in a state that the user expects. The program installs the same handler for <span class="literal">SIGQUIT</span> and <span class="literal">SIGINT</span> <span class="ent">&#x2469;</span>. The <span class="literal">SIGTSTP</span> signal requires special treatment, so a different handler is installed for that signal <span class="ent">&#x246A;</span>.</p>
<p class="bull">&#8226; Install a handler for the <span class="literal">SIGTERM</span> signal, in order to catch the default signal sent by the <em>kill</em> command <span class="ent">&#x246C;</span>.</p>
<p class="bull">&#8226; Execute a loop that reads characters one at a time from <em>stdin</em> and echoes them on standard output <span class="ent">&#x246D;</span>. The program treats various input characters specially before outputting them <span class="ent">&#x246E;</span>:</p>
<p class="dash1">&#8211; All letters are converted to lowercase before being output.</p>
<p class="dash1">&#8211; The newline (<span class="literal">\n</span>) and carriage return (<span class="literal">\r</span>) characters are echoed without change.</p>
<p class="dash1">&#8211; Control characters other than the newline and carriage return are echoed as a 2-character sequence: caret (<span class="literal">^</span>) plus the corresponding uppercase letter (e.g., <em>Control-A</em> echoes as <span class="literal">^A</span>).</p>
<p class="dash1">&#8211; All other characters are echoed as asterisks (<span class="literal">*</span>).</p>
<p class="dash1">&#8211; The letter <em>q</em> causes the loop to terminate <span class="ent">&#x246F;</span>.</p>
<p class="bull">&#8226; On exit from the loop, restore the terminal to its state as last set by the user, and then terminate <span class="ent">&#x2470;</span>.</p>
<p class="noindentt">The program installs the same handler for <span class="literal">SIGQUIT</span>, <span class="literal">SIGINT</span>, and <span class="literal">SIGTERM</span>. This handler restores the terminal to its state as last set by the user and terminates the program <span class="ent">&#x2461;</span>.</p>
<p class="indentb">The handler for the <span class="literal">SIGTSTP</span> signal <span class="ent">&#x2462;</span> deals with the signal in the manner described in <a href="ch34.xhtml#ch34lev2sec05">Section 34.7.3</a>. Note the following additional details of the operation of this signal handler:</p>
<p class="bull">&#8226; Upon entry, the handler saves the current terminal settings (in <em>ourTermios</em>) <span class="ent">&#x2463;</span>, and then resets the terminal to the settings that were in effect (saved in <em>userTermios</em>) when the program was started <span class="ent">&#x2464;</span>, before once more raising <span class="literal">SIGTSTP</span> to actually stop the process.</p>
<p class="bull">&#8226; Upon resumption of execution after receipt of <span class="literal">SIGCONT</span>, the handler once more saves the current terminal settings in <em>userTermios</em> <span class="ent">&#x2465;</span>, since the user may have changed the settings while the program was stopped (using the <em>stty</em> command, for example). The handler then returns the terminal to the state (<em>ourTermios</em>) required by the program <span class="ent">&#x2466;</span>.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1313"/><a id="ch62ex4"/><strong>Listing 62-4:</strong> Demonstrating cbreak and raw modes</p>
<p class="programsli">__________________________________________________ <span class="codestrong">tty/test_tty_functions.c</span><br/><br/>&#160;&#160;&#160;#include &lt;termios.h&gt;<br/>&#160;&#160;&#160;#include &lt;signal.h&gt;<br/>&#160;&#160;&#160;#include &lt;ctype.h&gt;<br/>&#160;&#160;&#160;#include "tty_functions.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declarations of ttySetCbreak()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;and ttySetRaw() */<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/><span class="ent">&#x2460;</span> static struct termios userTermios;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Terminal settings as defined by user */<br/><br/>&#160;&#160;&#160;static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* General handler: restore tty settings and exit */<br/>&#160;&#160;&#160;handler(int sig)<br/>&#160;&#160;&#160;{<br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &#38;userTermios) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("tcsetattr");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;_exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Handler for SIGTSTP */<br/><span class="ent">&#x2462;</span> tstpHandler(int sig)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct termios ourTermios;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* To save our tty settings */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigset_t tstpMask, prevMask;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sigaction sa;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int savedErrno;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;savedErrno = errno;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* We might change 'errno' here */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Save current terminal settings, restore terminal to<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;state at time of program startup */<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;if (tcgetattr(STDIN_FILENO, &#38;ourTermios) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("tcgetattr");<br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &#38;userTermios) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("tcsetattr");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Set the disposition of SIGTSTP to the default, raise the signal<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;once more, and then unblock it so that we actually stop */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (signal(SIGTSTP, SIG_DFL) == SIG_ERR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("signal");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;raise(SIGTSTP);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;tstpMask);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigaddset(&#38;tstpMask, SIGTSTP);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigprocmask(SIG_UNBLOCK, &#38;tstpMask, &#38;prevMask) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Execution resumes here after SIGCONT */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigprocmask(SIG_SETMASK, &#38;prevMask, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Reblock SIGTSTP */<br/><span epub:type="pagebreak" id="page_1314"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Reestablish handler */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_flags = SA_RESTART;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_handler = tstpHandler;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGTSTP, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* The user may have changed the terminal settings while we were<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;stopped; save the settings so we can restore them later */<br/><br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;if (tcgetattr(STDIN_FILENO, &#38;userTermios) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("tcgetattr");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Restore our terminal settings */<br/><br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &#38;ourTermios) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("tcsetattr");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;errno = savedErrno;<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char ch;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sigaction sa, prev;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;ssize_t n;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_flags = SA_RESTART;<br/><br/><span class="ent">&#x2467;</span>&#160;&#160;&#160;&#160;&#160;if (argc &gt; 1) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Use cbreak mode */<br/><span class="ent">&#x2468;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (ttySetCbreak(STDIN_FILENO, &#38;userTermios) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("ttySetCbreak");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Terminal special characters can generate signals in cbreak<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mode. Catch them so that we can adjust the terminal mode.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;We establish handlers only if the signals are not being ignored. */<br/><br/><span class="ent">&#x2469;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_handler = handler;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGQUIT, NULL, &#38;prev) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (prev.sa_handler != SIG_IGN)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGQUIT, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGINT, NULL, &#38;prev) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (prev.sa_handler != SIG_IGN)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGINT, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/><span class="ent">&#x246A;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_handler = tstpHandler;<br/><br/><span epub:type="pagebreak" id="page_1315"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGTSTP, NULL, &#38;prev) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (prev.sa_handler != SIG_IGN)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGTSTP, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Use raw mode */<br/><span class="ent">&#x246B;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (ttySetRaw(STDIN_FILENO, &#38;userTermios) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("ttySetRaw");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/><span class="ent">&#x246C;</span>&#160;&#160;&#160;&#160;&#160;sa.sa_handler = handler;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGTERM, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;setbuf(stdout, NULL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Disable stdout buffering */<br/><br/><span class="ent">&#x246D;</span>&#160;&#160;&#160;&#160;&#160;for (;;) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Read and echo stdin */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;n = read(STDIN_FILENO, &#38;ch, 1);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (n == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("read");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (n == 0)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Can occur after terminal disconnect */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/><span class="ent">&#x246E;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (isalpha((unsigned char) ch))&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Letters --&gt; lowercase */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;putchar(tolower((unsigned char) ch));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (ch == '\n' || ch == '\r')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;putchar(ch);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (iscntrl((unsigned char) ch))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("^%c", ch ^ 64);&#160;&#160;&#160;&#160;&#160;/* Echo Control-A as ^A, etc. */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;putchar('*');&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* All other chars as '*' */<br/><br/><span class="ent">&#x246F;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (ch == 'q')&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Quit loop */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/><span class="ent">&#x2470;</span>&#160;&#160;&#160;&#160;&#160;if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &#38;userTermios) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("tcsetattr");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;}<br/>__________________________________________________ <span class="codestrong">tty/test_tty_functions.c</span></p>
<p class="noindent">Here is an example of what we see when we ask the program in <a href="ch62.xhtml#ch62ex4">Listing 62-4</a> to use raw mode:</p>
<p class="programs">$ <span class="codestrong">stty</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Initial terminal mode is sane (cooked)</span><br/>speed 38400 baud; line = 0;<br/>$ <span class="codestrong">./test_tty_functions</span><br/><span class="codestrong">abc</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Type abc, and Control-J</span><br/>&#160;&#160;&#160;<span class="codestrong">def</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Type DEF, Control-J, and Enter</span><br/><span class="codestrong">^C^Z</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Type Control-C, Control-Z, and Control-J</span><br/>&#160;&#160;&#160;&#160;<span class="codestrong">q</span>$&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Type q to exit</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_1316"/>In the last line of the preceding shell session, we see that the shell printed its prompt on the same line as the <em>q</em> character that caused the program to terminate.</p>
<p class="indent">The following shows an example run using cbreak mode:</p>
<p class="programs">$ <span class="codestrong">./test_tty_functions x</span><br/><span class="codestrong">XYZ</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Type XYZ and Control-Z</span><br/>[1]+&#160;&#160;Stopped&#160;&#160;&#160;&#160;&#160;&#160;./test_tty_functions x<br/>$ <span class="codestrong">stty</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Verify that terminal mode was restored</span><br/>speed 38400 baud; line = 0;<br/>$ <span class="codestrong">fg</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Resume in foreground</span><br/>./test_tty_functions x<br/>***&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Type 123 and Control-J</span><br/>&#160;&#160;&#160;$&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Type Control-C to terminate program</span><br/><span class="font1">Press Enter to get next shell prompt</span><br/>$ <span class="codestrong">stty</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Verify that terminal mode was restored</span><br/>speed 38400 baud; line = 0;</p>
<h3 class="h3" id="ch62lev1sec07"><strong>62.7 Terminal Line Speed (Bit Rate)</strong></h3>
<p class="noindenta">Different terminals (and serial lines) are capable of transmitting and receiving at different speeds (bits per second). The <em>cfgetispeed()</em> and <em>cfsetispeed()</em> functions retrieve and modify the input line speed. The <em>cfgetospeed()</em> and <em>cfsetospeed()</em> functions retrieve and modify the output line speed.</p>
<div class="block">
<p class="noindent">The term <em>baud</em> is commonly used as a synonym for the terminal line speed (in bits per second), although this usage is not technically correct. Precisely, baud is the per-second rate at which signal changes can occur on the line, which is not necessarily the same as the number of bits transmitted per second, since the latter depends on how bits are encoded into signals. Nevertheless, the term <em>baud</em> continues to be used synonymously with <em>bit rate</em> (bits per second). (The term <em>baud rate</em> is often also used synonymously with <em>baud</em>, but this is redundant; the baud is by definition a rate.) To avoid confusion, we&#8217;ll generally use terms like <em>line speed</em> or <em>bit rate</em>.</p>
</div>
<div class="box">
<p class="programsa">#include &lt;termios.h&gt;<br/><br/>speed_t <span class="codestrong">cfgetispeed</span>(const struct termios *<span class="font1">termios_p</span>);<br/>speed_t <span class="codestrong">cfgetospeed</span>(const struct termios *<span class="font1">termios_p</span>);</p>
<p class="right">Both return a line speed from given <em>termios</em> structure</p>
<p class="programsat">int <span class="codestrong">cfsetospeed</span>(struct termios *<span class="font1">termios_p</span>, speed_t <span class="font1">speed</span>);<br/>int <span class="codestrong">cfsetispeed</span>(struct termios *<span class="font1">termios_p</span>, speed_t <span class="font1">speed</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">Each of these functions works on a <em>termios</em> structure that must be previously initialized by a call to <em>tcgetattr()</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1317"/>For example, to find out the current terminal output line speed, we would do the following:</p>
<p class="programs">struct termios tp;<br/>speed_t rate;<br/><br/>if (tcgetattr(fd, &#38;tp) == -1)<br/>&#160;&#160;&#160;&#160;errExit("tcgetattr");<br/>rate = cfgetospeed(&#38;tp);<br/>if (rate == -1)<br/>&#160;&#160;&#160;&#160;errExit("cfgetospeed");</p>
<p class="noindent">If we then wanted to change this line speed, we would continue as follows:</p>
<p class="programs">if (cfsetospeed(&#38;tp, B38400) == -1)<br/>&#160;&#160;&#160;&#160;errExit("cfsetospeed");<br/>if (tcsetattr(fd, TCSAFLUSH, &#38;tp) == -1)<br/>&#160;&#160;&#160;&#160;errExit("tcsetattr");</p>
<p class="noindent">The <em>speed_t</em> data type is used to store a line speed. Rather than directly assigning numeric values for line speeds, a set of symbolic constants (defined in <span class="literal">&lt;termios.h&gt;</span>) is used. These constants define a series of discrete values. Some examples of such constants are <span class="literal">B300</span>, <span class="literal">B2400</span>, <span class="literal">B9600</span>, and <span class="literal">B38400</span>, corresponding, respectively, to the line speeds 300, 2400, 9600, and 38,400 bits per second. The use of a set of discrete values reflects the fact that terminals are normally designed to work with a limited set of different (standardized) line speeds, derived from the division of some base rate (e.g., 115,200 is typical on PCs) by integral values (e.g., 115,200 / 12 = 9600).</p>
<p class="indent">SUSv3 specifies that the terminal line speeds are stored in the <em>termios</em> structure, but (deliberately) does not specify where. Many implementations, including Linux, maintain these values in the <em>c_cflag</em> field, using the <span class="literal">CBAUD</span> mask and the <span class="literal">CBAUDEX</span> flag. (In <a href="ch62.xhtml#ch62lev1sec02">Section 62.2</a>, we noted that the nonstandard <em>c_ispeed</em> and <em>c_ospeed</em> fields of the Linux <em>termios</em> structure are unused.)</p>
<p class="indent">Although the <em>cfsetispeed()</em> and <em>cfsetospeed()</em> functions allow separate input and output line speeds to be specified, on many terminals, these two speeds must be the same. Furthermore, Linux uses only a single field to store the line speed (i.e., the two rates are assumed to be always the same), which means that all of the input and output line-speed functions access the same <em>termios</em> field.</p>
<div class="block">
<p class="noindent">Specifying <em>speed</em> as 0 in a call to <em>cfsetispeed()</em> means &#8220;set the input speed to whatever the output speed is when <em>tcsetattr()</em> is later called.&#8221; This is useful on systems where the two line speeds are maintained as separate values.</p>
</div>
<h3 class="h3" id="ch62lev1sec08"><strong>62.8 Terminal Line Control</strong></h3>
<p class="noindenta">The <em>tcsendbreak()</em>, <em>tcdrain()</em>, <em>tcflush()</em>, and <em>tcflow()</em> functions perform tasks that are usually collectively grouped under the term <em>line control</em>. (These functions are POSIX inventions designed to replace various <em>ioctl()</em> operations.)</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_1318"/>#include &lt;termios.h&gt;<br/><br/>int <span class="codestrong">tcsendbreak</span>(int <span class="font1">fd</span>, int <span class="font1">duration</span>);<br/>int <span class="codestrong">tcdrain</span>(int <span class="font1">fd</span>);<br/>int <span class="codestrong">tcflush</span>(int <span class="font1">fd</span>, int <span class="font1">queue_selector</span>);<br/>int <span class="codestrong">tcflow</span>(int <span class="font1">fd</span>, int <span class="font1">action</span>);</p>
<p class="right">All return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">In each function, <em>fd</em> is a file descriptor that refers to a terminal or other remote device on a serial line.</p>
<p class="indent">The <em>tcsendbreak()</em> function generates a BREAK condition, by transmitting a continuous stream of 0 bits. The <em>duration</em> argument specifies the length of the transmission. If <em>duration</em> is 0, 0 bits are transmitted for 0.25 seconds. (SUSv3 specifies at least 0.25 and not more than 0.5 seconds.) If <em>duration</em> is greater than 0, 0 bits are transmitted for <em>duration</em> milliseconds. SUSv3 leaves this case unspecified; the handling of a nonzero <em>duration</em> varies widely on other UNIX implementations (the details described here are for <em>glibc</em>).</p>
<p class="indent">The <em>tcdrain()</em> function blocks until all output has been transmitted (i.e., until the terminal output queue has been emptied).</p>
<p class="indent">The <em>tcflush()</em> function flushes (discards) the data in the terminal input queue, the terminal output queue, or both queues (see <a href="ch62.xhtml#ch62fig1">Figure 62-1</a>). Flushing the input queue discards data that has been received by the terminal driver but not yet read by any process. For example, an application can use <em>tcflush()</em> to discard terminal type-ahead before prompting for a password. Flushing the output queue discards data that has been written (passed to the terminal driver) but not yet transmitted to the device. The <em>queue_selector</em> argument specifies one of the values shown in <a href="ch62.xhtml#ch62table4">Table 62-4</a>.</p>
<div class="block">
<p class="noindent">Note that the term <em>flush</em> is used in a different sense with <em>tcflush()</em> than when talking about file I/O. For file I/O, <em>flushing</em> means forcing the output to be transferred either user-space memory to the buffer cache in the case of the <em>stdio fflush()</em>, or from the buffer cache to the disk, in the case of <em>fsync()</em>, <em>fdatasync()</em>, and <em>sync()</em>.</p>
</div>
<p class="tablecap"><a id="ch62table4"/><strong>Table 62-4:</strong> Values for the <em>tcflush() queue_selector</em> argument</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Value</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">TCIFLUSH</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Flush the input queue</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">TCOFLUSH</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Flush the output queue</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">TCIOFLUSH</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Flush both the input and the output queues</p></td>
</tr>
</tbody>
</table>
<p class="noindent">The <em>tcflow()</em> function controls the flow of data in either direction between the computer and the terminal (or other remote device). The <em>action</em> argument is one of the values shown in <a href="ch62.xhtml#ch62table5">Table 62-5</a>. The <span class="literal">TCIOFF</span> and <span class="literal">TCION</span> values are effective only if the terminal is capable of interpreting STOP and START characters, in which case these operations respectively cause the terminal to suspend and resume sending data to the computer, respectively.</p>
<p class="tablecap"><span epub:type="pagebreak" id="page_1319"/><a id="ch62table5"/><strong>Table 62-5:</strong> Values for the <em>tcflow() action</em> argument</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Value</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">TCOOFF</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Suspend output to the terminal</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">TCOON</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Resume output to the terminal</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">TCIOFF</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Transmit a STOP character to the terminal</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">TCION</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Transmit a START character to the terminal</p></td>
</tr>
</tbody>
</table>
<h3 class="h3" id="ch62lev1sec09"><strong>62.9 Terminal Window Size</strong></h3>
<p class="noindentab">In a windowing environment, a screen-handling application needs to be able to monitor the size of a terminal window, so that the screen can be redrawn appropriately if the user modifies the window size. The kernel provides two pieces of support to allow this to happen:</p>
<p class="bull">&#8226; A <span class="literal">SIGWINCH</span> signal is sent to the foreground process group after a change in the terminal window size. By default, this signal is ignored.</p>
<p class="bull">&#8226; At any time&#8212;usually following the receipt of a <span class="literal">SIGWINCH</span> signal&#8212;a process can use the <em>ioctl()</em> <span class="literal">TIOCGWINSZ</span> operation to find out the current size of the terminal window.</p>
<p class="noindentt">The <em>ioctl()</em> <span class="literal">TIOCGWINSZ</span> operation is used as follows:</p>
<p class="programs">if (ioctl(fd, TIOCGWINSZ, &#38;ws) == -1)<br/>&#160;&#160;&#160;&#160;errExit("ioctl");</p>
<p class="noindent">The <em>fd</em> argument is a file descriptor referring to a terminal window. The final argument to <em>ioctl()</em> is a pointer to a <em>winsize</em> structure (defined in <span class="literal">&lt;sys/ioctl.h&gt;</span>), used to return the terminal window size:</p>
<p class="programs">struct winsize {<br/>&#160;&#160;&#160;&#160;unsigned short ws_row;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of rows (characters) */<br/>&#160;&#160;&#160;&#160;unsigned short ws_col;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of columns (characters) */<br/>&#160;&#160;&#160;&#160;unsigned short ws_xpixel;&#160;&#160;&#160;&#160;&#160;&#160;/* Horizontal size (pixels) */<br/>&#160;&#160;&#160;&#160;unsigned short ws_ypixel;&#160;&#160;&#160;&#160;&#160;&#160;/* Vertical size (pixels) */<br/>};</p>
<p class="noindent">Like many other implementations, Linux doesn&#8217;t use the pixel-size fields of the <em>winsize</em> structure.</p>
<p class="indent"><a href="ch62.xhtml#ch62ex5">Listing 62-5</a> demonstrates the use of the <span class="literal">SIGWINCH</span> signal and the <em>ioctl()</em> <span class="literal">TIOCGWINSZ</span> operation. The following shows an example of the output produced when this program is run under a window manager and the terminal window size is changed three times:</p>
<p class="programs">$ <span class="codestrong">./demo_SIGWINCH</span><br/>Caught SIGWINCH, new window size: 35 rows * 80 columns<br/>Caught SIGWINCH, new window size: 35 rows * 73 columns<br/>Caught SIGWINCH, new window size: 22 rows * 73 columns<br/><span class="font1">Type Control-C to terminate program</span></p>
<p class="examplet"><span epub:type="pagebreak" id="page_1320"/><a id="ch62ex5"/><strong>Listing 62-5:</strong> Monitoring changes in the terminal window size</p>
<p class="programsli">______________________________________________________ <span class="codestrong">tty/demo_SIGWINCH.c</span><br/><br/>#include &lt;signal.h&gt;<br/>#include &lt;termios.h&gt;<br/>#include &lt;sys/ioctl.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static void<br/>sigwinchHandler(int sig)<br/>{<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct winsize ws;<br/>&#160;&#160;&#160;&#160;struct sigaction sa;<br/><br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;sa.sa_flags = 0;<br/>&#160;&#160;&#160;&#160;sa.sa_handler = sigwinchHandler;<br/>&#160;&#160;&#160;&#160;if (sigaction(SIGWINCH, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;for (;;) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pause();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for SIGWINCH signal */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (ioctl(STDIN_FILENO, TIOCGWINSZ, &#38;ws) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("ioctl");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Caught SIGWINCH, new window size: "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"%d rows * %d columns\n", ws.ws_row, ws.ws_col);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>______________________________________________________ <span class="codestrong">tty/demo_SIGWINCH.c</span></p>
<p class="noindent">It is also possible to change the terminal driver&#8217;s notion of the window size by passing an initialized <em>winsize</em> structure in an <em>ioctl()</em> <span class="literal">TIOCSWINSZ</span> operation:</p>
<p class="programs">ws.ws_row = 40;<br/>ws.ws_col = 100;<br/>if (ioctl(fd, TIOCSWINSZ, &#38;ws) == -1)<br/>&#160;&#160;&#160;&#160;errExit("ioctl");</p>
<p class="noindentb">If the new values in the <em>winsize</em> structure differ from the terminal driver&#8217;s current notion of the terminal window size, two things happen:</p>
<p class="bull">&#8226; The terminal driver data structures are updated using the values supplied in the <em>ws</em> argument.</p>
<p class="bull">&#8226; A <span class="literal">SIGWINCH</span> signal is sent to the foreground process group of the terminal.</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1321"/>Note, however, that these events on their own are insufficient to change the actual dimensions of the displayed window, which are controlled by software outside the kernel (such as a window manager or a terminal emulator program).</p>
<p class="indent">Although not standardized in SUSv3, most UNIX implementations provide access to the terminal window size using the <em>ioctl()</em> operations described in this section.</p>
<h3 class="h3" id="ch62lev1sec10"><strong>62.10 Terminal Identification</strong></h3>
<p class="noindenta">In <a href="ch34.xhtml#ch34lev1sec04">Section 34.4</a>, we described the <em>ctermid()</em> function, which returns the name of the controlling terminal for a process (usually <span class="literal">/dev/tty</span> on UNIX systems). The functions described in this section are also useful for identifying a terminal.</p>
<p class="indent">The <em>isatty()</em> function enables us to determine whether a file descriptor, <em>fd</em>, is associated with a terminal (as opposed to some other file type).</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">isatty</span>(int <span class="font1">fd</span>);</p>
<p class="right">Returns true (1) if <em>fd</em> is associated with a terminal, otherwise false (0)</p>
</div>
<p class="noindent">The <em>isatty()</em> function is useful in editors and other screen-handling programs that need to determine whether their standard input and output are directed to a terminal.</p>
<p class="indent">Given a file descriptor, the <em>ttyname()</em> function returns the name of the associated terminal device.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>char *<span class="codestrong">ttyname</span>(int <span class="font1">fd</span>);</p>
<p class="right">Returns pointer to (statically allocated) string containing terminal name, or <span class="literal">NULL</span> on error</p>
</div>
<p class="noindent">To find the name of the terminal, <em>ttyname()</em> uses the <em>opendir()</em> and <em>readdir()</em> functions described in <a href="ch18.xhtml#ch18lev1sec08">Section 18.8</a> to walk through the directories holding terminal device names, looking at each directory entry until it finds one whose device ID (the <em>st_rdev</em> field of the <em>stat</em> structure) matches that of the device referred to by the file descriptor <em>fd</em>. Terminal device entries normally reside in two directories: <span class="literal">/dev</span> and <span class="literal">/dev/pts</span>. The <span class="literal">/dev</span> directory contains entries for virtual consoles (e.g., <span class="literal">/dev/tty1</span>) and BSD pseudoterminals. The <span class="literal">/dev/pts</span> directory contains entries for (System V-style) pseudoterminal slave devices. (We describe pseudoterminals in <a href="ch64.xhtml#ch64">Chapter 64</a>.)</p>
<div class="block">
<p class="noindent">A reentrant version of <em>ttyname()</em> exists in the form of <em>ttyname_r()</em>.</p>
<p class="indent">The <em>tty(1)</em> command, which displays the name of the terminal referred to by its standard input, is the command-line analog of <em>ttyname()</em>.</p>
</div>
<h3 class="h3" id="ch62lev1sec11"><span epub:type="pagebreak" id="page_1322"/><strong>62.11 Summary</strong></h3>
<p class="noindenta">On early UNIX systems, terminals were real hardware devices connected to a computer via serial lines. Early terminals were not standardized, meaning that different escape sequences were required to program the terminals produced by different vendors. On modern workstations, such terminals have been superseded by bitmapped monitors running the X Window System. However, the ability to program terminals is still required when dealing with virtual devices, such as virtual consoles and terminal emulators (which employ pseudoterminals), and real devices connected via serial lines.</p>
<p class="indent">Terminal settings (with the exception of the terminal window size) are maintained in a structure of type <em>termios</em>, which contains four bit-mask fields that control various terminal settings and an array that defines the various special characters interpreted by the terminal driver. The <em>tcgetattr()</em> and <em>tcsetattr()</em> functions allow a program to retrieve and modify the terminal settings.</p>
<p class="indent">When performing input, the terminal driver can operate in two different modes. In canonical mode, input is gathered into lines (terminated by one of the line-delimiter characters) and line editing is enabled. By contrast, noncanonical mode allows an application to read terminal input a character at a time, without needing to wait for the user to type a line-delimiter character. Line editing is disabled in noncanonical mode. Completion of a noncanonical mode read is controlled by the MIN and TIME fields of the <em>termios</em> structure, which determine the minimum number of characters to be read and a timeout to be applied to the read operation. We described four distinct cases for the operation of noncanonical reads.</p>
<p class="indent">Historically, the Seventh Edition and BSD terminal drivers provided three input modes&#8212;cooked, cbreak, and raw&#8212;which performed varying degrees of processing of terminal input and output. Cbreak and raw modes can be emulated by changing various fields within the <em>termios</em> structure.</p>
<p class="indent">A range of functions perform various other terminal operations. These include changing the terminal line speed and performing line-control operations (generating a break condition, pausing until output has been transmitted, flushing terminal input and output queues, and suspending or resuming transmission of data in either direction between the terminal and the computer). Other functions allow us to check if a given file descriptor refers to a terminal and to obtain the name of that terminal. The <em>ioctl()</em> system call can be used to retrieve and modify the terminal window size recorded by the kernel, and to perform a range of other terminal-related operations.</p>
<h5 class="h5" id="ch62lev3sec36"><strong>Further information</strong></h5>
<p class="noindenta">[<a href="bib.xhtml#bib88">Stevens, 1992</a>] also describes terminal programming and goes into much more detail on programming serial ports. Several good online resources discuss terminal programming. Hosted at the LDP web site (<em><a href="http://www.tldp.org">http://www.tldp.org</a></em>) are the <em>Serial HOWTO</em> and the <em>Text-terminal HOWTO</em>, both by David S. Lawyer. Another useful source of information is the <em>Serial Programming Guide for POSIX Operating Systems</em> by Michael R. Sweet, available online at <em><a href="http://www.easysw.com/~mike/serial/">http://www.easysw.com/~mike/serial/</a></em>.</p>
<h3 class="h3" id="ch62lev1sec12"><span epub:type="pagebreak" id="page_1323"/><strong>62.12 Exercises</strong></h3>
<p class="exer"><a id="ch62exe1"/><strong>62-1.</strong>&#160;&#160;&#160;Implement <em>isatty()</em>. (You may find it useful to read the description of <em>tcgetattr()</em> in <a href="ch62.xhtml#ch62lev1sec02">Section 62.2</a>.)</p>
<p class="exer"><a id="ch62exe2"/><strong>62-2.</strong>&#160;&#160;&#160;Implement <em>ttyname()</em>.</p>
<p class="exer"><a id="ch62exe3"/><strong>62-3.</strong>&#160;&#160;&#160;Implement the <em>getpass()</em> function described in <a href="ch08.xhtml#ch08lev1sec05">Section 8.5</a>. (The <em>getpass()</em> function can obtain a file descriptor for the controlling terminal by opening <span class="literal">/dev/tty</span>.)</p>
<p class="exer"><a id="ch62exe4"/><strong>62-4.</strong>&#160;&#160;&#160;Write a program that displays information indicating whether the terminal referred to by standard input is in canonical or noncanonical mode. If in noncanonical mode, then display the values of TIME and MIN.<span epub:type="pagebreak" id="page_1324"/></p>
</body>
</html>
