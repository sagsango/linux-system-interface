<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch23"><span epub:type="pagebreak" id="page_479"/><strong><span class="big">23</span></strong><br/><strong>TIMERS AND SLEEPING</strong></h2>
<p class="noindentab">A timer allows a process to schedule a notification for itself to occur at some time in the future. Sleeping allows a process (or thread) to suspend execution for a period of time. This chapter describes the interfaces used for setting timers and for sleeping. It covers the following topics:</p>
<p class="bull">&#8226; the classical UNIX APIs for setting interval timers (<em>setitimer()</em> and <em>alarm()</em>) to notify a process when a certain amount of time has passed;</p>
<p class="bull">&#8226; the APIs that allow a process to sleep for a specified interval;</p>
<p class="bull">&#8226; the POSIX.1b clocks and timers APIs; and</p>
<p class="bull">&#8226; the Linux-specific <em>timerfd</em> facility, which allows the creation of timers whose expirations can be read from a file descriptor.</p>
<h3 class="h3" id="ch23lev1sec01"><strong>23.1 Interval Timers</strong></h3>
<p class="noindenta">The <em>setitimer()</em> system call establishes an <em>interval timer</em>, which is a timer that expires at a future point in time and (optionally) at regular intervals after that.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_480"/>#include &lt;sys/time.h&gt;<br/><br/>int <span class="codestrong">setitimer</span>(int <span class="font1">which</span>, const struct itimerval *<span class="font1">new_value</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct itimerval *<span class="font1">old_value</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb">Using <em>setitimer()</em>, a process can establish three different types of timers, by specifying <em>which</em> as one of the following:</p>
<p class="term"><span class="literal">ITIMER_REAL</span></p>
<p class="termlist">Create a timer that counts down in real (i.e., wall clock) time. When the timer expires, a <span class="literal">SIGALRM</span> signal is generated for the process.</p>
<p class="term"><span class="literal">ITIMER_VIRTUAL</span></p>
<p class="termlist">Create a timer that counts down in process virtual time (i.e., user-mode CPU time). When the timer expires, a <span class="literal">SIGVTALRM</span> signal is generated for the process.</p>
<p class="term"><span class="literal">ITIMER_PROF</span></p>
<p class="termlist">Create a <em>profiling</em> timer. A profiling timer counts in process time (i.e., the sum of both user-mode and kernel-mode CPU time). When the timer expires, a <span class="literal">SIGPROF</span> signal is generated for the process.</p>
<p class="noindentt">The default disposition of all of the timer signals is to terminate the process. Unless this is the desired result, we must establish a handler for the signal delivered by the timer.</p>
<p class="indent">The <em>new_value</em> and <em>old_value</em> arguments are pointers to <em>itimerval</em> structures, defined as follows:</p>
<p class="programs">struct itimerval {<br/>&#160;&#160;&#160;&#160;struct timeval it_interval;&#160;&#160;&#160;&#160;&#160;/* Interval for periodic timer */<br/>&#160;&#160;&#160;&#160;struct timeval it_value;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Current value (time until<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;next expiration) */<br/>};</p>
<p class="noindent">Each of the fields in the <em>itimerval</em> structure is in turn a structure of type <em>timeval</em>, containing seconds and microseconds fields:</p>
<p class="programs">struct timeval {<br/>&#160;&#160;&#160;&#160;time_t&#160;&#160;&#160;&#160;&#160;&#160;tv_sec;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Seconds */<br/>&#160;&#160;&#160;&#160;suseconds_t tv_usec;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Microseconds (long int) */<br/>};</p>
<p class="noindent">The <em>it_value</em> substructure of the <em>new_value</em> argument specifies the delay until the timer is to expire. The <em>it_interval</em> substructure specifies whether this is to be a periodic timer. If both fields of <em>it_interval</em> are set to 0, then the timer expires just once, at the time given by <em>it_value</em>. If one or both of the <em>it_interval</em> fields are nonzero, then, after each expiration of the timer, the timer will be reset to expire again at the specified interval.</p>
<p class="indent">A process has only one of each of the three types of timers. If we call <em>setitimer()</em> a second time, it will change the characteristics of any existing timer corresponding <span epub:type="pagebreak" id="page_481"/>to <em>which</em>. If we call <em>setitimer()</em> with both fields of <em>new_value.it_value</em> set to 0, then any existing timer is disabled.</p>
<p class="indent">If <em>old_value</em> is not <span class="literal">NULL</span>, then it points to an <em>itimerval</em> structure that is used to return the previous value of the timer. If both fields of <em>old_value.it_value</em> are 0, then the timer was previously disabled. If both fields of <em>old_value.it_interval</em> are 0, then the previous timer was set to expire just once, at the time given by <em>old_value.it_value</em>. Retrieving the previous settings of the timer can be useful if we want to restore the settings after the new timer has expired. If we are not interested in the previous value of the timer, we can specify <em>old_value</em> as <span class="literal">NULL</span>.</p>
<p class="indent">As a timer progresses, it counts down from the initial value (<em>it_value</em>) toward 0. When the timer reaches 0, the corresponding signal is sent to the process, and then, if the interval (<em>it_interval</em>) is nonzero, the timer value (<em>it_value</em>) is reloaded with the interval value, and counting down toward 0 recommences.</p>
<p class="indent">At any time, we can use <em>getitimer()</em> to retrieve the current state of the timer in order to see how much time is left before it next expires.</p>
<div class="box">
<p class="programsa">#include &lt;sys/time.h&gt;<br/><br/>int <span class="codestrong">getitimer</span>(int <span class="font1">which</span>, struct itimerval *<span class="font1">curr_value</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>getitimer()</em> system call returns the current state of the timer specified by <em>which</em>, in the buffer pointed to by <em>curr_value</em>. This is exactly the same information as is returned via the <em>old_value</em> argument of <em>setitimer()</em>, with the difference that we don&#8217;t need to change the timer settings in order to retrieve the information. The <em>curr_value.it_value</em> substructure returns the amount of time remaining until the timer next expires. This value changes as the timer counts down, and is reset on timer expiration if a nonzero <em>it_interval</em> value was specified when the timer was set. The <em>curr_value.it_interval</em> substructure returns the interval for this timer; this value remains unchanged until a subsequent call to <em>setitimer()</em>.</p>
<p class="indent">Timers established using <em>setitimer()</em> (and <em>alarm()</em>, which we discuss shortly) are preserved across <em>exec()</em>, but are not inherited by a child created by <em>fork()</em>.</p>
<div class="block">
<p class="noindent">SUSv4 marks <em>getitimer()</em> and <em>setitimer()</em> obsolete, noting that the POSIX timers API (<a href="ch23.xhtml#ch23lev1sec06">Section 23.6</a>) is preferred.</p>
</div>
<h5 class="h5" id="ch23lev3sec01"><strong>Example program</strong></h5>
<p class="noindentab"><a href="ch23.xhtml#ch23ex1">Listing 23-1</a> demonstrates the use of <em>setitimer()</em> and <em>getitimer()</em>. This program performs the following steps:</p>
<p class="bull">&#8226; Establish a handler for the <span class="literal">SIGALRM</span> signal <span class="ent">&#x2462;</span>.</p>
<p class="bull">&#8226; Set the value and interval fields for a real (<span class="literal">ITIMER_REAL</span>) timer using the values supplied in its command-line arguments <span class="ent">&#x2463;</span>. If these arguments are absent, the program sets a timer that expires just once, after 2 seconds.</p>
<p class="bull">&#8226; Execute a continuous loop <span class="ent">&#x2464;</span>, consuming CPU time and periodically calling the function <em>displayTimes()</em> <span class="ent">&#x2460;</span>, which displays the elapsed real time since the program began, as well as the current state of the <span class="literal">ITIMER_REAL</span> timer.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_482"/>Each time the timer expires, the <span class="literal">SIGALRM</span> handler is invoked, and it sets a global flag, <em>gotAlarm</em> <span class="ent">&#x2461;</span>. Whenever this flag is set, the loop in the main program calls <em>displayTimes()</em> in order to show when the handler was called and the state of the timer <span class="ent">&#x2465;</span>. (We designed the signal handler in this manner to avoid calling non-async-signal-safe functions from within the handler, for the reasons described in <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>.) If the timer has a zero interval, then the program exits on delivery of the first signal; otherwise, it catches up to three signals before terminating <span class="ent">&#x2466;</span>.</p>
<p class="indent">When we run the program in <a href="ch23.xhtml#ch23ex1">Listing 23-1</a>, we see the following:</p>
<p class="programs">$ <span class="codestrong">./real_timer 1 800000 1 0</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Initial value 1.8 seconds, interval 1 second</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;Elapsed&#160;&#160;&#160;Value&#160;&#160;Interval<br/>START:&#160;&#160;&#160;&#160;0.00<br/>Main:&#160;&#160;&#160;&#160;&#160;0.50&#160;&#160;&#160;&#160;1.30&#160;&#160;&#160;&#160;1.00&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Timer counts down until expiration</span><br/>Main:&#160;&#160;&#160;&#160;&#160;1.00&#160;&#160;&#160;&#160;0.80&#160;&#160;&#160;&#160;1.00<br/>Main:&#160;&#160;&#160;&#160;&#160;1.50&#160;&#160;&#160;&#160;0.30&#160;&#160;&#160;&#160;1.00<br/>ALARM:&#160;&#160;&#160;&#160;1.80&#160;&#160;&#160;&#160;1.00&#160;&#160;&#160;&#160;1.00&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">On expiration, timer is reloaded from interval</span><br/>Main:&#160;&#160;&#160;&#160;&#160;2.00&#160;&#160;&#160;&#160;0.80&#160;&#160;&#160;&#160;1.00<br/>Main:&#160;&#160;&#160;&#160;&#160;2.50&#160;&#160;&#160;&#160;0.30&#160;&#160;&#160;&#160;1.00<br/>ALARM:&#160;&#160;&#160;&#160;2.80&#160;&#160;&#160;&#160;1.00&#160;&#160;&#160;&#160;1.00<br/>Main:&#160;&#160;&#160;&#160;&#160;3.00&#160;&#160;&#160;&#160;0.80&#160;&#160;&#160;&#160;1.00<br/>Main:&#160;&#160;&#160;&#160;&#160;3.50&#160;&#160;&#160;&#160;0.30&#160;&#160;&#160;&#160;1.00<br/>ALARM:&#160;&#160;&#160;&#160;3.80&#160;&#160;&#160;&#160;1.00&#160;&#160;&#160;&#160;1.00<br/>That's all folks</p>
<p class="examplet"><a id="ch23ex1"/><strong>Listing 23-1:</strong> Using a real-time timer</p>
<p class="programsli">______________________________________________________ <span class="codestrong">timers/real_timer.c</span><br/><br/>&#160;&#160;&#160;#include &lt;signal.h&gt;<br/>&#160;&#160;&#160;#include &lt;sys/time.h&gt;<br/>&#160;&#160;&#160;#include &lt;time.h&gt;<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;static volatile sig_atomic_t gotAlarm = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Set nonzero on receipt of SIGALRM */<br/><br/>&#160;&#160;&#160;/* Retrieve and display the real time, and (if 'includeTimer' is<br/>&#160;&#160;&#160;&#160;&#160;&#160;TRUE) the current value and interval for the ITIMER_REAL timer */<br/><br/>&#160;&#160;&#160;static void<br/><span class="ent">&#x2460;</span> displayTimes(const char *msg, Boolean includeTimer)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct itimerval itv;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;static struct timeval start;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct timeval curr;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;static int callNum = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of calls to this function */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (callNum == 0)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Initialize elapsed time meter */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (gettimeofday(&#38;start, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("gettimeofday");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (callNum % 20 == 0)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Print header every 20 lines */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;&#160;&#160;&#160;Elapsed&#160;&#160;&#160;Value Interval\n");<br/><br/>&#160;&#160;&#160;<span epub:type="pagebreak" id="page_483"/>&#160;&#160;&#160;&#160;if (gettimeofday(&#38;curr, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("gettimeofday");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%-7s %6.2f", msg, curr.tv_sec - start.tv_sec +<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(curr.tv_usec - start.tv_usec) / 1000000.0);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (includeTimer) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (getitimer(ITIMER_REAL, &#38;itv) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("getitimer");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;%6.2f %6.2f",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;itv.it_value.tv_sec + itv.it_value.tv_usec / 1000000.0,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;itv.it_interval.tv_sec + itv.it_interval.tv_usec / 1000000.0);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;callNum++;<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;static void<br/>&#160;&#160;&#160;sigalrmHandler(int sig)<br/>&#160;&#160;&#160;{<br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;gotAlarm = 1;<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct itimerval itv;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;clock_t prevClock;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int maxSigs;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of signals to catch before exiting */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int sigCnt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of signals so far caught */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sigaction sa;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc &gt; 1 &#38;&#38; strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s [secs [usecs [int-secs [int-usecs]]]]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigCnt = 0;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_flags = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_handler = sigalrmHandler;<br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGALRM, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Set timer from the command-line arguments */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;itv.it_value.tv_sec = (argc &gt; 1) ? getLong(argv[1], 0, "secs") : 2;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;itv.it_value.tv_usec = (argc &gt; 2) ? getLong(argv[2], 0, "usecs") : 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;itv.it_interval.tv_sec = (argc &gt; 3) ? getLong(argv[3], 0, "int-secs") : 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;itv.it_interval.tv_usec = (argc &gt; 4) ? getLong(argv[4], 0, "int-usecs") : 0;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Exit after 3 signals, or on first signal if interval is 0 */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;maxSigs = (itv.it_interval.tv_sec == 0 &#38;&#38;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;itv.it_interval.tv_usec == 0) ? 1 : 3;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;displayTimes("START:", FALSE);<br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;if (setitimer(ITIMER_REAL, &#38;itv, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("setitimer");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;prevClock = clock();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigCnt = 0;<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;for (;;) {<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Inner loop consumes at least 0.5 seconds CPU time */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (((clock() - prevClock) * 10 / CLOCKS_PER_SEC) &lt; 5) {<br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (gotAlarm) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Did we get a signal? */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;gotAlarm = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;displayTimes("ALARM:", TRUE);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigCnt++;<br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigCnt &gt;= maxSigs) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("That's all folks\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;prevClock = clock();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;displayTimes("Main: ", TRUE);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/>______________________________________________________ <span class="codestrong">timers/real_timer.c</span></p>
<h5 class="h5" id="ch23lev3sec02"><span epub:type="pagebreak" id="page_484"/><strong>A simpler timer interface: <em>alarm()</em></strong></h5>
<p class="noindenta">The <em>alarm()</em> system call provides a simple interface for establishing a real-time timer that expires once, with no repeating interval. (Historically, <em>alarm()</em> was the original UNIX API for setting a timer.)</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>unsigned int <span class="codestrong">alarm</span>(unsigned int <span class="font1">seconds</span>);</p>
<p class="right">Always succeeds, returning number of seconds remaining on any previously set timer, or 0 if no timer previously was set</p>
</div>
<p class="noindent">The <em>seconds</em> argument specifies the number of seconds in the future when the timer is to expire. At that time, a <span class="literal">SIGALRM</span> signal is delivered to the calling process.</p>
<p class="indent">Setting a timer with <em>alarm()</em> overrides any previously set timer. We can disable an existing timer using the call <em>alarm(0)</em>.</p>
<p class="indent">As its return value, <em>alarm()</em> gives us the number of seconds remaining until the expiration of any previously set timer, or 0 if no timer was set.</p>
<p class="noindent"><span epub:type="pagebreak" id="page_485"/>An example of the use of <em>alarm()</em> is shown in <a href="ch23.xhtml#ch23lev1sec03">Section 23.3</a>.</p>
<div class="block">
<p class="noindent">In some later example programs in this book, we use <em>alarm()</em> to start a timer without establishing a corresponding <span class="literal">SIGALRM</span> handler, as a technique for ensuring that a process is killed if it is not otherwise terminated.</p>
</div>
<h5 class="h5" id="ch23lev3sec03"><strong>Interactions between <em>setitimer()</em> and <em>alarm()</em></strong></h5>
<p class="noindenta">On Linux, <em>alarm()</em> and <em>setitimer()</em> share the same per-process real-time timer, which means that setting a timer with one of these functions changes any timer previously set by either of the functions. This may not be the case on other UNIX implementations (i.e., these functions could control independent timers). SUSv3 explicitly leaves unspecified the interactions between <em>setitimer()</em> and <em>alarm()</em>, as well as the interactions of these functions with the <em>sleep()</em> function described in <a href="ch23.xhtml#ch23lev2sec01">Section 23.4.1</a>. For maximum portability, we should ensure that our applications use only one of <em>setitimer()</em> and <em>alarm()</em> for setting real-time timers.</p>
<h3 class="h3" id="ch23lev1sec02"><strong>23.2 Scheduling and Accuracy of Timers</strong></h3>
<p class="noindenta">Depending on system load and the scheduling of processes, a process may not be scheduled to run until some short time (i.e., usually some small fraction of a second) after actual expiration of the timer. Notwithstanding this, the expiration of a periodic timer established by <em>setitimer()</em>, or the other interfaces described later in this chapter, will remain regular. For example, if a real-time timer is set to expire every 2 seconds, then the delivery of individual timer events may be subject to the delays just described, but the scheduling of subsequent expirations will nevertheless be at exactly the next 2-second interval. In other words, interval timers are not subject to creeping errors.</p>
<p class="indent">Although the <em>timeval</em> structure used by <em>setitimer()</em> allows for microsecond precision, the accuracy of a timer has traditionally been limited by the frequency of the software clock (<a href="ch10.xhtml#ch10lev1sec06">Section 10.6</a>). If a timer value does not exactly match a multiple of the granularity of the software clock, then the timer value is rounded up. This means that if, for example, we specified an interval timer to go off each 19,100 microseconds (i.e., just over 19 milliseconds), then, assuming a jiffy value of 4 milliseconds, we would actually get a timer that expired every 20 milliseconds.</p>
<h5 class="h5" id="ch23lev3sec04"><strong>High-resolution timers</strong></h5>
<p class="noindenta">On modern Linux kernels, the preceding statement that timer resolution is limited by the frequency of the software clock no longer holds true. Since kernel 2.6.21, Linux optionally supports high-resolution timers. If this support is enabled (via the <span class="literal">CONFIG_HIGH_RES_TIMERS</span> kernel configuration option), then the accuracy of the various timer and sleep interfaces that we describe in this chapter is no longer constrained by the size of the kernel jiffy. Instead, these calls can be as accurate as the underlying hardware allows. On modern hardware, accuracy down to a microsecond is typical.</p>
<div class="block">
<p class="noindent">The availability of high-resolution timers can be determined by examining the clock resolution returned by <em>clock_getres()</em>, described in <a href="ch23.xhtml#ch23lev2sec03">Section 23.5.1</a>.</p>
</div>
<h3 class="h3" id="ch23lev1sec03"><span epub:type="pagebreak" id="page_486"/><strong>23.3 Setting Timeouts on Blocking Operations</strong></h3>
<p class="noindenta">One use of real-time timers is to place an upper limit on the time for which a blocking system call can remain blocked. For example, we may wish to cancel a <em>read()</em> from a terminal if the user has not entered a line of input within a certain time. We can do this as follows:</p>
<ol>
<li class="order"><p class="orderp">Call <em>sigaction()</em> to establish a handler for <span class="literal">SIGALRM</span>, omitting the <span class="literal">SA_RESTART</span> flag, so that system calls are not restarted (refer to <a href="ch21.xhtml#ch21lev1sec05">Section 21.5</a>).</p></li>
<li class="order"><p class="orderp">Call <em>alarm()</em> or <em>setitimer()</em> to establish a timer specifying the upper limit of time for which we wish the system call to block.</p></li>
<li class="order"><p class="orderp">Make the blocking system call.</p></li>
<li class="order"><p class="orderp">After the system call returns, call <em>alarm()</em> or <em>setitimer()</em> once more to disable the timer (in case the system call completed before the timer expired).</p></li>
<li class="order"><p class="orderp">Check to see whether the blocking system call failed with <em>errno</em> set to <span class="literal">EINTR</span> (interrupted system call).</p></li>
</ol>
<p class="noindent"><a href="ch23.xhtml#ch23ex2">Listing 23-2</a> demonstrates this technique for <em>read()</em>, using <em>alarm()</em> to establish the timer.</p>
<p class="examplet"><a id="ch23ex2"/><strong>Listing 23-2:</strong> Performing a <em>read()</em> with timeout</p>
<p class="programsli">______________________________________________________ <span class="codestrong">timers/timed_read.c</span><br/><br/>#include &lt;signal.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>#define BUF_SIZE 200<br/><br/>static void&#160;&#160;&#160;&#160;&#160;/* SIGALRM handler: interrupts blocked system call */<br/>handler(int sig)<br/>{<br/>&#160;&#160;&#160;&#160;printf("Caught signal\n");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* UNSAFE (see <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>) */<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct sigaction sa;<br/>&#160;&#160;&#160;&#160;char buf[BUF_SIZE];<br/>&#160;&#160;&#160;&#160;ssize_t numRead;<br/>&#160;&#160;&#160;&#160;int savedErrno;<br/><br/>&#160;&#160;&#160;&#160;if (argc &gt; 1 &#38;&#38; strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s [num-secs [restart-flag]]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;/* Set up handler for SIGALRM. Allow system calls to be interrupted,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;unless second command-line argument was supplied. */<br/><br/>&#160;&#160;&#160;&#160;sa.sa_flags = (argc &gt; 2) ? SA_RESTART : 0;<br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/><br/>&#160;&#160;&#160;&#160;sa.sa_handler = handler;<br/>&#160;&#160;&#160;&#160;if (sigaction(SIGALRM, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;alarm((argc &gt; 1) ? getInt(argv[1], GN_NONNEG, "num-secs") : 10);<br/><br/>&#160;&#160;&#160;&#160;numRead = read(STDIN_FILENO, buf, BUF_SIZE);<br/><br/>&#160;&#160;&#160;&#160;savedErrno = errno;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* In case alarm() changes it */<br/>&#160;&#160;&#160;&#160;alarm(0);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Ensure timer is turned off */<br/>&#160;&#160;&#160;&#160;errno = savedErrno;<br/><br/>&#160;&#160;&#160;&#160;/* Determine result of read() */<br/><br/>&#160;&#160;&#160;&#160;if (numRead == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno == EINTR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Read timed out\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("read");<br/>&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Successful read (%ld bytes): %.*s",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) numRead, (int) numRead, buf);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>______________________________________________________ <span class="codestrong">timers/timed_read.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_487"/>Note that there is a theoretical race condition in the program in <a href="ch23.xhtml#ch23ex2">Listing 23-2</a>. If the timer expires after the call to <em>alarm()</em>, but before the <em>read()</em> call is started, then the <em>read()</em> call won&#8217;t be interrupted by the signal handler. Since the timeout value used in scenarios like this is normally relatively large (at least several seconds) this is highly unlikely to occur, so that, in practice, this is a viable technique. [<a href="bib.xhtml#bib94">Stevens &#38; Rago, 2005</a>] proposes an alternative technique using <em>longjmp()</em>. A further alternative when dealing with I/O system calls is to use the timeout feature of the <em>select()</em> or <em>poll()</em> system calls (<a href="ch63.xhtml#ch63">Chapter 63</a>), which also have the advantage of allowing us to simultaneously wait for I/O on multiple descriptors.</p>
<h3 class="h3" id="ch23lev1sec04"><strong>23.4 Suspending Execution for a Fixed Interval (Sleeping)</strong></h3>
<p class="noindenta">Sometimes, we want to suspend execution of a process for a fixed amount of time. While it is possible to do this using a combination of <em>sigsuspend()</em> and the timer functions already described, it is easier to use one of the sleep functions instead.</p>
<h4 class="h4" id="ch23lev2sec01"><strong>23.4.1 Low-Resolution Sleeping: <em>sleep()</em></strong></h4>
<p class="noindenta">The <em>sleep()</em> function suspends execution of the calling thread for the number of seconds specified in the <em>seconds</em> argument or until a signal is caught (thus interrupting the call).</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_488"/>#include &lt;unistd.h&gt;<br/><br/>unsigned int <span class="codestrong">sleep</span>(unsigned int <span class="font1">seconds</span>);</p>
<p class="right">Returns 0 on normal completion, or number of unslept seconds if prematurely terminated</p>
</div>
<p class="noindent">If the sleep completes, <em>sleep()</em> returns 0. If the sleep is interrupted by a signal, <em>sleep()</em> returns the number of remaining (unslept) seconds. As with timers set by <em>alarm()</em> and <em>setitimer()</em>, system load may mean that the process is rescheduled only at some (normally short) time after the completion of the <em>sleep()</em> call.</p>
<p class="indent">SUSv3 leaves possible interactions of <em>sleep()</em> with <em>alarm()</em> and <em>setitimer()</em> unspecified. On Linux, <em>sleep()</em> is implemented as a call to <em>nanosleep()</em> (<a href="ch23.xhtml#ch23lev2sec02">Section 23.4.2</a>), with the consequence that there is no interaction between <em>sleep()</em> and the timer functions. However, on many implementations, especially older ones, <em>sleep()</em> is implemented using <em>alarm()</em> and a handler for the <span class="literal">SIGALRM</span> signal. For portability, we should avoid mixing the use of <em>sleep()</em> with <em>alarm()</em> and <em>setitimer()</em>.</p>
<h4 class="h4" id="ch23lev2sec02"><strong>23.4.2 High-Resolution Sleeping: <em>nanosleep()</em></strong></h4>
<p class="noindenta">The <em>nanosleep()</em> function performs a similar task to <em>sleep()</em>, but provides a number of advantages, including finer resolution when specifying the sleep interval.</p>
<div class="box">
<p class="programsa">#define _POSIX_C_SOURCE 199309<br/>#include &lt;time.h&gt;<br/><br/>int <span class="codestrong">nanosleep</span>(const struct timespec *<span class="font1">request</span>, struct timespec *<span class="font1">remain</span>);</p>
<p class="right">Returns 0 on successfully completed sleep, or &#8211;1 on error or interrupted sleep</p>
</div>
<p class="noindent">The <em>request</em> argument specifies the duration of the sleep interval and is a pointer to a structure of the following form:</p>
<p class="programs">struct timespec {<br/>&#160;&#160;&#160;&#160;time_t tv_sec;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Seconds */<br/>&#160;&#160;&#160;&#160;long tv_nsec;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Nanoseconds */<br/>};</p>
<p class="noindent">The <em>tv_nsec</em> field specifies a nanoseconds value. It must be a number in the range 0 to 999,999,999.</p>
<p class="indent">A further advantage of <em>nanosleep()</em> is that SUSv3 explicitly specifies that it should not be implemented using signals. This means that, unlike the situation with <em>sleep()</em>, we can portably mix calls to <em>nanosleep()</em> with calls to <em>alarm()</em> or <em>setitimer()</em>.</p>
<p class="indent">Although it is not implemented using signals, <em>nanosleep()</em> may still be interrupted by a signal handler. In this case, <em>nanosleep()</em> returns &#8211;1, with <em>errno</em> set to the usual <span class="literal">EINTR</span> and, if the argument <em>remain</em> is not <span class="literal">NULL</span>, the buffer it points to returns the remaining unslept time. If desired, we can use the returned value to restart the system call and complete the sleep. This is demonstrated in <a href="ch23.xhtml#ch23ex3">Listing 23-3</a>. As command-line arguments, <span epub:type="pagebreak" id="page_489"/>this program expects seconds and nanosecond values for <em>nanosleep()</em>. The program loops repeatedly, executing <em>nanosleep()</em> until the total sleep interval is passed. If <em>nanosleep()</em> is interrupted by the handler for <span class="literal">SIGINT</span> (generated by typing <em>Control-C</em>), then the call is restarted using the value returned in <em>remain</em>. When we run this program, we see the following:</p>
<p class="programs">$ <span class="codestrong">./t_nanosleep 10 0</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Sleep for 10 seconds<br/>Type Control-C</span><br/>Slept for:&#160;&#160;1.853428 secs<br/>Remaining:&#160;&#160;8.146617000<br/><span class="font1">Type Control-C</span><br/>Slept for:&#160;&#160;4.370860 secs<br/>Remaining:&#160;&#160;5.629800000<br/><span class="font1">Type Control-C</span><br/>Slept for:&#160;&#160;6.193325 secs<br/>Remaining:&#160;&#160;3.807758000<br/>Slept for: 10.008150 secs<br/>Sleep complete</p>
<p class="noindent">Although <em>nanosleep()</em> allows nanosecond precision when specifying the sleep interval, the accuracy of the sleep interval is limited to the granularity of the software clock (<a href="ch10.xhtml#ch10lev1sec06">Section 10.6</a>). If we specify an interval that is not a multiple of the software clock, then the interval is rounded up.</p>
<div class="block">
<p class="noindent">As noted earlier, on systems that support high-resolution timers, the accuracy of the sleep interval can be much finer than the granularity of the software clock.</p>
</div>
<p class="noindent">This rounding behavior means that if signals are received at a high rate, then there is a problem with the approach employed in the program in <a href="ch23.xhtml#ch23ex3">Listing 23-3</a>. The problem is that each restart of <em>nanosleep()</em> will be subject to rounding errors, since the returned <em>remain</em> time is unlikely to be an exact multiple of the granularity of the software clock. Consequently, each restarted <em>nanosleep()</em> will sleep longer than the value returned in <em>remain</em> by the previous call. In the case of an extremely high rate of signal delivery (i.e., as or more frequent than the software clock granularity), the process may never be able to complete its sleep. On Linux 2.6, this problem can be avoided by making use of <em>clock_nanosleep()</em> with the <span class="literal">TIMER_ABSTIME</span> option. We describe <em>clock_nanosleep()</em> in <a href="ch23.xhtml#ch23lev2sec06">Section 23.5.4</a>.</p>
<div class="block">
<p class="noindent">In Linux 2.4 and earlier, there is an eccentricity in the implementation of <em>nanosleep()</em>. Suppose that a process performing a <em>nanosleep()</em> call is stopped by a signal. When the process is later resumed via delivery of <span class="literal">SIGCONT</span>, then the <em>nanosleep()</em> call fails with the error <span class="literal">EINTR</span>, as expected. However, if the program subsequently restarts the <em>nanosleep()</em> call, then the time that the process has spent in the stopped state is <em>not</em> counted against the sleep interval, so that the process will sleep longer than expected. This eccentricity is eliminated in Linux 2.6, where the <em>nanosleep()</em> call automatically resumes on delivery of the <span class="literal">SIGCONT</span> signal, and the time spent in the stopped state is counted against the sleep interval.</p>
</div>
<p class="examplet"><span epub:type="pagebreak" id="page_490"/><a id="ch23ex3"/><strong>Listing 23-3:</strong> Using <em>nanosleep()</em></p>
<p class="programsli">______________________________________________________ <span class="codestrong">timers/t_nanosleep.c</span><br/><br/>#define _POSIX_C_SOURCE 199309<br/>#include &lt;sys/time.h&gt;<br/>#include &lt;time.h&gt;<br/>#include &lt;signal.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static void<br/>sigintHandler(int sig)<br/>{<br/>&#160;&#160;&#160;&#160;return;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Just interrupt nanosleep() */<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct timeval start, finish;<br/>&#160;&#160;&#160;&#160;struct timespec request, remain;<br/>&#160;&#160;&#160;&#160;struct sigaction sa;<br/>&#160;&#160;&#160;&#160;int s;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 3 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s secs nanosecs\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;request.tv_sec = getLong(argv[1], 0, "secs");<br/>&#160;&#160;&#160;&#160;request.tv_nsec = getLong(argv[2], 0, "nanosecs");<br/><br/>&#160;&#160;&#160;&#160;/* Allow SIGINT handler to interrupt nanosleep() */<br/><br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;sa.sa_flags = 0;<br/>&#160;&#160;&#160;&#160;sa.sa_handler = sigintHandler;<br/>&#160;&#160;&#160;&#160;if (sigaction(SIGINT, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;if (gettimeofday(&#38;start, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("gettimeofday");<br/><br/>&#160;&#160;&#160;&#160;for (;;) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = nanosleep(&#38;request, &#38;remain);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s == -1 &#38;&#38; errno != EINTR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("nanosleep");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (gettimeofday(&#38;finish, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("gettimeofday");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Slept for: %9.6f secs\n", finish.tv_sec - start.tv_sec +<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(finish.tv_usec - start.tv_usec) / 1000000.0);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* nanosleep() completed */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Remaining: %2ld.%09ld\n", (long) remain.tv_sec,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;remain.tv_nsec);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;request = remain;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Next sleep is with remaining time */<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;printf("Sleep complete\n");<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>______________________________________________________ <span class="codestrong">timers/t_nanosleep.c</span></p>
<h3 class="h3" id="ch23lev1sec05"><span epub:type="pagebreak" id="page_491"/><strong>23.5 POSIX Clocks</strong></h3>
<p class="noindenta">POSIX clocks (originally defined in POSIX.1b) provide an API for accessing clocks that measure time with nanosecond precision. Nanosecond time values are represented using the same <em>timespec</em> structure as is used by <em>nanosleep()</em> (<a href="ch23.xhtml#ch23lev2sec02">Section 23.4.2</a>).</p>
<p class="indent">On Linux, programs using this API must be compiled with the <em>&#8211;lrt</em> option, in order to link against the <em>librt</em> (realtime) library.</p>
<p class="indent">The main system calls in the POSIX clocks API are <em>clock_gettime()</em>, which retrieves the current value of a clock; <em>clock_getres()</em>, which returns the resolution of a clock; and <em>clock_settime()</em>, which updates a clock.</p>
<h4 class="h4" id="ch23lev2sec03"><strong>23.5.1 Retrieving the Value of a Clock: <em>clock_gettime()</em></strong></h4>
<p class="noindenta">The <em>clock_gettime()</em> system call returns the time according to the clock specified in <em>clockid</em>.</p>
<div class="box">
<p class="programsa">#define _POSIX_C_SOURCE 199309<br/>#include &lt;time.h&gt;<br/><br/>int <span class="codestrong">clock_gettime</span>(clockid_t <span class="font1">clockid</span>, struct timespec *<span class="font1">tp</span>);<br/>int <span class="codestrong">clock_getres</span>(clockid_t <span class="font1">clockid</span>, struct timespec *<span class="font1">res</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The time value is returned in the <em>timespec</em> structure pointed to by <em>tp</em>. Although the <em>timespec</em> structure affords nanosecond precision, the granularity of the time value returned by <em>clock_gettime()</em> may be coarser than this. The <em>clock_getres()</em> system call returns, via the argument <em>res</em>, a pointer to a <em>timespec</em> structure containing the resolution of the clock specified in <em>clockid</em>.</p>
<p class="indent">The <em>clockid_t</em> data type is a type specified by SUSv3 for representing a clock identifier. The first column of <a href="ch23.xhtml#ch23table1">Table 23-1</a> lists the values that can be specified for <em>clockid</em>.</p>
<p class="tablecap"><a id="ch23table1"/><strong>Table 23-1:</strong> POSIX.1b clock types</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Clock ID</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLOCK_REALTIME</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Settable system-wide real-time clock</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLOCK_MONOTONIC</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Nonsettable monotonic clock</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLOCK_PROCESS_CPUTIME_ID</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Per-process CPU-time clock (since Linux 2.6.12)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">CLOCK_THREAD_CPUTIME_ID</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Per-thread CPU-time clock (since Linux 2.6.12)</p></td>
</tr>
</tbody>
</table>
<p class="noindent"><span epub:type="pagebreak" id="page_492"/>The <span class="literal">CLOCK_REALTIME</span> clock is a system-wide clock that measures wall-clock time. By contrast with the <span class="literal">CLOCK_MONOTONIC</span> clock, the setting of this clock can be changed.</p>
<p class="indent">SUSv3 specifies that the <span class="literal">CLOCK_MONOTONIC</span> clock measures time since some &#8220;unspecified point in the past&#8221; that doesn&#8217;t change after system startup. This clock is useful for applications that must not be affected by discontinuous changes to the system clock (e.g., a manual change to the system time). On Linux, this clock measures the time since system startup.</p>
<p class="indent">The <span class="literal">CLOCK_PROCESS_CPUTIME_ID</span> clock measures the user and system CPU time consumed by the calling process. The <span class="literal">CLOCK_THREAD_CPUTIME_ID</span> clock performs the analogous task for an individual thread within a process.</p>
<p class="indent">All of the clocks in <a href="ch23.xhtml#ch23table1">Table 23-1</a> are specified in SUSv3, but only <span class="literal">CLOCK_REALTIME</span> is mandatory and widely supported on UNIX implementations.</p>
<div class="block">
<p class="noindent">Linux 2.6.28 adds a new clock type, <span class="literal">CLOCK_MONOTONIC_RAW</span>, to those listed in <a href="ch23.xhtml#ch23table1">Table 23-1</a>. This is a nonsettable clock that is similar to <span class="literal">CLOCK_MONOTONIC</span>, but it gives access to a pure hardware-based time that is unaffected by NTP adjustments. This nonstandard clock is intended for use in specialized clock-synchronization applications.</p>
<p class="indent">Linux 2.6.32 adds two more new clocks to those listed in <a href="ch23.xhtml#ch23table1">Table 23-1</a>: <span class="literal">CLOCK_REALTIME_COARSE</span> and <span class="literal">CLOCK_MONOTONIC_COARSE</span>. These clocks are similar to <span class="literal">CLOCK_REALTIME</span> and <span class="literal">CLOCK_MONOTONIC</span>, but intended for applications that want to obtain lower-resolution timestamps at minimal cost. These nonstandard clocks don&#8217;t cause any access to the hardware clock (which can be expensive for some hardware clock sources), and the resolution of the returned value is the jiffy (<a href="ch10.xhtml#ch10lev1sec06">Section 10.6</a>).</p>
</div>
<h4 class="h4" id="ch23lev2sec04"><strong>23.5.2 Setting the Value of a Clock: <em>clock_settime()</em></strong></h4>
<p class="noindenta">The <em>clock_settime()</em> system call sets the clock specified by <em>clockid</em> to the time supplied in the buffer pointed to by <em>tp</em>.</p>
<div class="box">
<p class="programsa">#define _POSIX_C_SOURCE 199309<br/>#include &lt;time.h&gt;<br/><br/>int <span class="codestrong">clock_settime</span>(clockid_t <span class="font1">clockid</span>, const struct timespec *<span class="font1">tp</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">If the time specified by <em>tp</em> is not a multiple of the clock resolution as returned by <em>clock_getres()</em>, the time is rounded downward.</p>
<p class="indent">A privileged (<span class="literal">CAP_SYS_TIME</span>) process may set the <span class="literal">CLOCK_REALTIME</span> clock. The initial value of this clock is typically the time since the Epoch. None of the other clocks in <a href="ch23.xhtml#ch23table1">Table 23-1</a> are modifiable.</p>
<div class="block">
<p class="noindent">According to SUSv3, an implementation may allow the <span class="literal">CLOCK_PROCESS_CPUTIME_ID</span> and <span class="literal">CLOCK_THREAD_CPUTIME_ID</span> clocks to be settable. At the time of writing, these clocks are read-only on Linux.</p>
</div>
<h4 class="h4" id="ch23lev2sec05"><span epub:type="pagebreak" id="page_493"/><strong>23.5.3 Obtaining the Clock ID of a Specific Process or Thread</strong></h4>
<p class="noindenta">The functions described in this section allow us to obtain the ID of a clock that measures the CPU time consumed by a particular process or thread. We can use the returned clock ID in a call to <em>clock_gettime()</em> in order to find out the CPU time consumed by the process or thread.</p>
<p class="indent">The <em>clock_getcpuclockid()</em> function returns the identifier of the CPU-time clock of the process whose ID is <em>pid</em>, in the buffer pointed to by <em>clockid</em>.</p>
<div class="box">
<p class="programsa">#include &lt;time.h&gt;<br/><br/>int <span class="codestrong">clock_getcpuclockid</span>(pid_t <span class="font1">pid</span>, clockid_t *<span class="font1">clockid</span>);</p>
<p class="right">Returns 0 on success, or a positive error number on error</p>
</div>
<p class="noindent">If <em>pid</em> is 0, <em>clock_getcpuclockid()</em> returns the ID of the CPU-time clock of the calling process.</p>
<p class="indent">The <em>pthread_getcpuclockid()</em> function is the POSIX threads analog of the <em>clock_getcpuclockid()</em> function. It returns the identifier of the clock measuring the CPU time consumed by a specific thread of the calling process.</p>
<div class="box">
<p class="programsa">#include &lt;pthread.h&gt;<br/>#include &lt;time.h&gt;<br/><br/>int <span class="codestrong">pthread_getcpuclockid</span>(pthread_t <span class="font1">thread</span>, clockid_t *<span class="font1">clockid</span>);</p>
<p class="right">Returns 0 on success, or a positive error number on error</p>
</div>
<p class="noindent">The <em>thread</em> argument is a POSIX thread ID that identifies the thread whose CPU-time clock ID we want to obtain. The clock ID is returned in the buffer pointed to by <em>clockid</em>.</p>
<h4 class="h4" id="ch23lev2sec06"><strong>23.5.4 Improved High-Resolution Sleeping: <em>clock_nanosleep()</em></strong></h4>
<p class="noindenta">Like <em>nanosleep()</em>, the Linux-specific <em>clock_nanosleep()</em> system call suspends the calling process until either a specified interval of time has passed or a signal arrives. In this section, we describe the features that distinguish <em>clock_nanosleep()</em> from <em>nanosleep()</em>.</p>
<div class="box">
<p class="programsa">#include &lt;time.h&gt;<br/><br/>int <span class="codestrong">clock_nanosleep</span>(clockid_t <span class="font1">clockid</span>, int <span class="font1">flags</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;const struct timespec *<span class="font1">request</span>, struct timespec *<span class="font1">remain</span>);</p>
<p class="right">Returns 0 on successfully completed sleep, or a positive error number on error or interrupted sleep</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_494"/>The <em>request</em> and <em>remain</em> arguments serve similar purposes to the analogous arguments for <em>nanosleep()</em>.</p>
<p class="indent">By default (i.e., if <em>flags</em> is 0), the sleep interval specified in <em>request</em> is relative (like <em>nanosleep()</em>). However, if we specify <span class="literal">TIMER_ABSTIME</span> in <em>flags</em> (see the example in <a href="ch23.xhtml#ch23ex4">Listing 23-4</a>), then <em>request</em> specifies an absolute time as measured by the clock identified by <em>clockid</em>. This feature is essential in applications that need to sleep accurately until a specific time. If we instead try retrieving the current time, calculating the difference until the desired target time, and doing a relative sleep, then there is a possibility that the process may be preempted in the middle of these steps, and consequently sleep for longer than desired.</p>
<p class="indent">As described in <a href="ch23.xhtml#ch23lev2sec02">Section 23.4.2</a>, this &#8220;oversleeping&#8221; problem is particularly marked for a process that uses a loop to restart a sleep that is interrupted by a signal handler. If signals are delivered at a high rate, then a relative sleep (of the type performed by <em>nanosleep()</em>) can lead to large inaccuracies in the time a process spends sleeping. We can avoid the oversleeping problem by making an initial call to <em>clock_gettime()</em> to retrieve the time, adding the desired amount to that time, and then calling <em>clock_nanosleep()</em> with the <span class="literal">TIMER_ABSTIME</span> flag (and restarting the system call if it is interrupted by a signal handler).</p>
<p class="indent">When the <span class="literal">TIMER_ABSTIME</span> flag is specified, the <em>remain</em> argument is unused (it is unnecessary). If the <em>clock_nanosleep()</em> call is interrupted by a signal handler, then the sleep can be restarted by repeating the call with the same <em>request</em> argument.</p>
<p class="indent">Another feature that distinguishes <em>clock_nanosleep()</em> from <em>nanosleep()</em> is that we can choose the clock that is used to measure the sleep interval. We specify the desired clock in <em>clockid</em>: <span class="literal">CLOCK_REALTIME</span>, <span class="literal">CLOCK_MONOTONIC</span>, or <span class="literal">CLOCK_PROCESS_CPUTIME_ID</span>. See <a href="ch23.xhtml#ch23table1">Table 23-1</a> for a description of these clocks.</p>
<p class="indent"><a href="ch23.xhtml#ch23ex4">Listing 23-4</a> demonstrates the use of <em>clock_nanosleep()</em> to sleep for 20 seconds against the <span class="literal">CLOCK_REALTIME</span> clock using an absolute time value.</p>
<p class="examplet"><a id="ch23ex4"/><strong>Listing 23-4:</strong> Using <em>clock_nanosleep()</em></p>
<p class="programsli">______________________________________________________________________<br/><br/>&#160;&#160;&#160;&#160;struct timespec request;<br/><br/>&#160;&#160;&#160;&#160;/* Retrieve current value of CLOCK_REALTIME clock */<br/><br/>&#160;&#160;&#160;&#160;if (clock_gettime(CLOCK_REALTIME, &#38;request) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("clock_gettime");<br/><br/>&#160;&#160;&#160;&#160;request.tv_sec += 20;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Sleep for 20 seconds from now */<br/><br/>&#160;&#160;&#160;&#160;s = clock_nanosleep(CLOCK_REALTIME, TIMER_ABSTIME, &#38;request, NULL);<br/>&#160;&#160;&#160;&#160;if (s != 0) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s == EINTR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Interrupted by signal handler\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "clock_nanosleep");<br/>&#160;&#160;&#160;&#160;}<br/>______________________________________________________________________</p>
<h3 class="h3" id="ch23lev1sec06"><span epub:type="pagebreak" id="page_495"/><strong>23.6 POSIX Interval Timers</strong></h3>
<p class="noindentab">The classical UNIX interval timers set by <em>setitimer()</em> suffer a number of limitations:</p>
<p class="bull">&#8226; We can set only one timer of each of the three types, <span class="literal">ITIMER_REAL</span>, <span class="literal">ITIMER_VIRTUAL</span>, and <span class="literal">ITIMER_PROF</span>.</p>
<p class="bull">&#8226; The only way of being notified of timer expiration is via delivery of a signal. Furthermore, we can&#8217;t change the signal that is generated when the timer expires.</p>
<p class="bull">&#8226; If an interval timer expires multiple times while the corresponding signal is blocked, then the signal handler is called only once. In other words, we have no way of knowing whether there was a <em>timer overrun</em>.</p>
<p class="bull">&#8226; Timers are limited to microsecond resolution. However, some systems have hardware clocks that provide finer resolution than this, and, on such systems, it is desirable to have software access to this greater resolution.</p>
<p class="noindentt">POSIX.1b defined an API to address these limitations, and this API is implemented in Linux 2.6.</p>
<div class="block">
<p class="noindent">On older Linux systems, an incomplete version of this API was provided via a threads-based implementation in <em>glibc</em>. However, this user-space implementation doesn&#8217;t provide all of the features described here.</p>
</div>
<p class="noindentb">The POSIX timer API divides the life of a timer into the following steps:</p>
<p class="bull">&#8226; The <em>timer_create()</em> system call creates a new timer and defines the method by which it will notify the process when it expires.</p>
<p class="bull">&#8226; The <em>timer_settime()</em> system call arms (starts) or disarms (stops) a timer.</p>
<p class="bull">&#8226; The <em>timer_delete()</em> system call deletes a timer that is no longer required.</p>
<p class="noindentt">POSIX timers are not inherited by a child created by <em>fork()</em>. They are disarmed and deleted during an <em>exec()</em> or on process termination.</p>
<p class="indent">On Linux, programs using the POSIX timer API must be compiled with the <em>&#8211;lrt</em> option, in order to link against the <em>librt</em> (realtime) library.</p>
<h4 class="h4" id="ch23lev2sec07"><strong>23.6.1 Creating a Timer: <em>timer_create()</em></strong></h4>
<p class="noindenta">The <em>timer_create()</em> function creates a new timer that measures time using the clock specified by <em>clockid</em>.</p>
<div class="box">
<p class="programsa">#define _POSIX_C_SOURCE 199309<br/>#include &lt;signal.h&gt;<br/>#include &lt;time.h&gt;<br/><br/>int <span class="codestrong">timer_create</span>(clockid_t <span class="font1">clockid</span>, struct sigevent *<span class="font1">evp</span>, timer_t *<span class="font1">timerid</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_496"/>The <em>clockid</em> can specify any of the values shown in <a href="ch23.xhtml#ch23table1">Table 23-1</a>, or the <em>clockid</em> value returned by <em>clock_getcpuclockid()</em> or <em>pthread_getcpuclockid()</em>. The <em>timerid</em> argument points to a buffer that returns a handle used to refer to the timer in later system calls. This buffer is typed as <em>timer_t</em>, which is a data type specified by SUSv3 for representing a timer identifier.</p>
<p class="indent">The <em>evp</em> argument determines how the program is to be notified when the timer expires. It points to a structure of type <em>sigevent</em>, defined as follows:</p>
<p class="programs">union sigval {<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;sival_int;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Integer value for accompanying data */<br/>&#160;&#160;&#160;&#160;void *sival_ptr;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Pointer value for accompanying data */<br/>};<br/><br/>struct sigevent {<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigev_notify;&#160;&#160;&#160;&#160;/* Notification method */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigev_signo;&#160;&#160;&#160;&#160;&#160;/* Timer expiration signal */<br/>&#160;&#160;&#160;&#160;union sigval sigev_value;&#160;&#160;&#160;&#160;&#160;/* Value accompanying signal or<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;passed to thread function */<br/>&#160;&#160;&#160;&#160;union {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pid_t&#160;&#160;&#160;&#160;&#160;&#160;_tid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* ID of thread to be signaled */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;void (*_function) (union sigval);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Thread notification function */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;void&#160;&#160;*_attribute;&#160;&#160;&#160;&#160;/* Really 'pthread_attr_t *' */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} _sigev_thread;<br/>&#160;&#160;&#160;&#160;} _sigev_un;<br/>};<br/><br/>#define sigev_notify_function&#160;&#160;&#160;&#160;_sigev_un._sigev_thread._function<br/>#define sigev_notify_attributes&#160;&#160;_sigev_un._sigev_thread._attribute<br/>#define sigev_notify_thread_id&#160;&#160;&#160;_sigev_un._tid</p>
<p class="noindent">The <em>sigev_notify</em> field of this structure is set to one of the values shown in <a href="ch23.xhtml#ch23table2">Table 23-2</a>.</p>
<p class="tablecap"><a id="ch23table2"/><strong>Table 23-2:</strong> Values for the <em>sigev_notify</em> field of the <em>sigevent</em> structure</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><em>sigev_notify</em> value</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Notification method</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="tablec"><strong>SUSv3</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGEV_NONE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No notification; monitor timer using <em>timer_gettime()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGEV_SIGNAL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Send signal <em>sigev_signo</em> to process</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGEV_THREAD</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Call <em>sigev_notify_function</em> as start function of new thread</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">SIGEV_THREAD_ID</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">Send signal <em>sigev_signo</em> to thread <em>sigev_notify_thread_id</em></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">&#160;</p></td>
</tr>
</tbody>
</table>
<p class="noindentb">Further details on the <em>sigev_notify</em> field constants, and the fields in the <em>sigval</em> structure that are associated with each constant value, are as follows:</p>
<p class="term"><span class="literal">SIGEV_NONE</span></p>
<p class="termlist">Don&#8217;t provide notification of timer expiration. The process can still monitor the progress of the timer using <em>timer_gettime()</em>.</p>
<p class="term"><span epub:type="pagebreak" id="page_497"/><span class="literal">SIGEV_SIGNAL</span></p>
<p class="termlist">When the timer expires, generate the signal specified in the <em>sigev_signo</em> field for the process. The <em>sigev_value</em> field specifies data (an integer or a pointer) to accompany the signal (<a href="ch22.xhtml#ch22lev2sec01">Section 22.8.1</a>). This data can be retrieved via the <em>si_value</em> field of the <em>siginfo_t</em> structure that is passed to the handler for this signal or returned by a call to <em>sigwaitinfo()</em> or <em>sigtimedwait()</em>.</p>
<p class="term"><span class="literal">SIGEV_THREAD</span></p>
<p class="termlist">When the timer expires, call the function specified in the <em>sigev_notify_function</em> field. This function is invoked <em>as if</em> it were the start function in a new thread. The &#8220;as if&#8221; wording is from SUSv3, and allows an implementation to generate the notifications for a periodic timer either by having each notification delivered to a new unique thread or by having the notifications delivered in series to a single new thread. The <em>sigev_notify_attributes</em> field can be specified as <span class="literal">NULL</span> or as a pointer to a <em>pthread_attr_t</em> structure that defines attributes for the thread (<a href="ch29.xhtml#ch29lev1sec08">Section 29.8</a>). The union <em>sigval</em> value specified in <em>sigev_value</em> is passed as the sole argument of the function.</p>
<p class="term"><span class="literal">SIGEV_THREAD_ID</span></p>
<p class="termlist">This is similar to <span class="literal">SIGEV_SIGNAL</span>, but the signal is sent to the thread whose thread ID matches <em>sigev_notify_thread_id</em>. This thread must be in the same process as the calling thread. (With <span class="literal">SIGEV_SIGNAL</span> notification, a signal is queued to the process as a whole, and, if there are multiple threads in the process, the signal will be delivered to an arbitrarily selected thread in the process. See <a href="ch33.xhtml#ch33lev1sec02">Section 33.2</a> for a discussion of the interaction of threads and signals.) The <em>sigev_notify_thread_id</em> field can be set to the value returned by <em>clone()</em> or the value returned by <em>gettid()</em>. The <span class="literal">SIGEV_THREAD_ID</span> flag is intended for use by threading libraries. (It requires a threading implementation that employs the <span class="literal">CLONE_THREAD</span> option, described in <a href="ch28.xhtml#ch28lev2sec01">Section 28.2.1</a>. The modern NPTL threading implementation employs <span class="literal">CLONE_THREAD</span>, but the older LinuxThreads threading implementation does not.)</p>
<p class="noindentt">All of the above constants are specified in SUSv3, except for <span class="literal">SIGEV_THREAD_ID</span>, which is Linux-specific.</p>
<p class="indent">The <em>evp</em> argument may be specified as <span class="literal">NULL</span>, which is equivalent to specifying <em>sigev_notify</em> as <span class="literal">SIGEV_SIGNAL</span>, <em>sigev_signo</em> as <span class="literal">SIGALRM</span> (this may be different on other systems, since SUSv3 merely says &#8220;a default signal number&#8221;), and <em>sigev_value.sival_int</em> as the timer ID.</p>
<p class="indent">As currently implemented, the kernel preallocates one queued realtime signal structure for each POSIX timer that is created using <em>timer_create()</em>. The intent of this preallocation is to ensure that at least one such structure is available for queuing a signal when the timer expires. This means that the number of POSIX timers that may be created is subject to the limitations on the number of realtime signals that can be queued (refer to <a href="ch22.xhtml#ch22lev1sec08">Section 22.8</a>).</p>
<h4 class="h4" id="ch23lev2sec08"><span epub:type="pagebreak" id="page_498"/><strong>23.6.2 Arming and Disarming a Timer: <em>timer_settime()</em></strong></h4>
<p class="noindenta">Once we have created a timer, we can arm (start) or disarm (stop) it using <em>timer_settime()</em>.</p>
<div class="box">
<p class="programsa">#define _POSIX_C_SOURCE 199309<br/>#include &lt;time.h&gt;<br/><br/>int <span class="codestrong">timer_settime</span>(timer_t <span class="font1">timerid</span>, int <span class="font1">flags</span>, const struct itimerspec *<span class="font1">value</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct itimerspec *<span class="font1">old_value</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>timerid</em> argument of <em>timer_settime()</em> is a timer handle returned by a previous call to <em>timer_create()</em>.</p>
<p class="indent">The <em>value</em> and <em>old_value</em> arguments are analogous to the <em>setitimer()</em> arguments of the same name: <em>value</em> specifies the new settings for the timer, and <em>old_value</em> is used to return the previous timer settings (see the description of <em>timer_gettime()</em> below). If we are not interested in the previous settings, we can specify <em>old_value</em> as <span class="literal">NULL</span>. The <em>value</em> and <em>old_value</em> arguments are pointers to <em>itimerspec</em> structures, defined as follows:</p>
<p class="programs">struct itimerspec {<br/>&#160;&#160;&#160;&#160;struct timespec it_interval;&#160;&#160;&#160;&#160;/* Interval for periodic timer */<br/>&#160;&#160;&#160;&#160;struct timespec it_value;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* First expiration */<br/>};</p>
<p class="noindent">Each of the fields of the <em>itimerspec</em> structure is in turn a structure of type <em>timespec</em>, which specifies time values as a number of seconds and nanoseconds:</p>
<p class="programs">struct timespec {<br/>&#160;&#160;&#160;&#160;time_t tv_sec;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Seconds */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;tv_nsec;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Nanoseconds */<br/>};</p>
<p class="noindent">The <em>it_value</em> field specifies when the timer will first expire. If either subfield of <em>it_interval</em> is nonzero, then this is a periodic timer that, after the initial expiry specified by <em>it_value</em>, will expire with the frequency specified in these subfields. If both subfields of <em>it_interval</em> are 0, this timer expires just once.</p>
<p class="indent">If <em>flags</em> is specified as 0, then <em>value.it_value</em> is interpreted relative to the clock value at the time of the call to <em>timer_settime()</em> (i.e., like <em>setitimer()</em>). If <em>flags</em> is specified as <span class="literal">TIMER_ABSTIME</span>, then <em>value.it_value</em> is interpreted as an absolute time (i.e., measured from the clock&#8217;s zero point). If that time has already passed on the clock, the timer expires immediately.</p>
<p class="indent">To arm a timer, we make a call to <em>timer_settime()</em> in which either or both of the subfields of <em>value.it_value</em> are nonzero. If the timer was previously armed, <em>timer_settime()</em> replaces the previous settings.</p>
<p class="indent">If the timer value and interval are not multiples of the resolution of the corresponding clock (as returned by <em>clock_getres()</em>), these values are rounded up to the next multiple of the resolution.</p>
<p class="indent"><span epub:type="pagebreak" id="page_499"/>On each expiration of the timer, the process is notified using the method defined in the <em>timer_create()</em> call that created this timer. If the <em>it_interval</em> structure contains nonzero values, these values are used to reload the <em>it_value</em> structure.</p>
<p class="indent">To disarm a timer, we make a call to <em>timer_settime()</em> specifying both fields of <em>value.it_value</em> as 0.</p>
<h4 class="h4" id="ch23lev2sec09"><strong>23.6.3 Retrieving the Current Value of a Timer: <em>timer_gettime()</em></strong></h4>
<p class="noindenta">The <em>timer_gettime()</em> system call returns the interval and remaining time for the POSIX timer identified by <em>timerid</em>.</p>
<div class="box">
<p class="programsa">#define _POSIX_C_SOURCE 199309<br/>#include &lt;time.h&gt;<br/><br/>int <span class="codestrong">timer_gettime</span>(timer_t <span class="font1">timerid</span>, struct itimerspec *<span class="font1">curr_value</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The interval and the time until the next expiration of the timer are returned in the <em>itimerspec</em> structure pointed to by <em>curr_value</em>. The <em>curr_value.it_value</em> field returns the time until next timer expiration, even if this timer was established as an absolute timer using <span class="literal">TIMER_ABSTIME</span>.</p>
<p class="indent">If both fields of the returned <em>curr_value.it_value</em> structure are 0, then the timer is currently disarmed. If both fields of the returned <em>curr_value.it_interval</em> structure are 0, then the timer expires just once, at the time given in <em>curr_value.it_value</em>.</p>
<h4 class="h4" id="ch23lev2sec10"><strong>23.6.4 Deleting a Timer: <em>timer_delete()</em></strong></h4>
<p class="noindenta">Each POSIX timer consumes a small amount of system resources. Therefore, when we have finished using a timer, we should free these resources by using <em>timer_delete()</em> to remove the timer.</p>
<div class="box">
<p class="programsa">#define _POSIX_C_SOURCE 199309<br/>#include &lt;time.h&gt;<br/><br/>int <span class="codestrong">timer_delete</span>(timer_t <span class="font1">timerid</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>timerid</em> argument is a handle returned by a previous call to <em>timer_create()</em>. If the timer was armed, then it is automatically disarmed before removal. If there is already a pending signal from an expiration of this timer, that signal remains pending. (SUSv3 leaves this point unspecified, so other UNIX implementations may behave differently.) Timers are deleted automatically when a process terminates.</p>
<h4 class="h4" id="ch23lev2sec11"><strong>23.6.5 Notification via a Signal</strong></h4>
<p class="noindentab">If we elect to receive timer notifications via a signal, then we can accept the signal via a signal handler, or by calling <em>sigwaitinfo()</em> or <em>sigtimedwait()</em>. Both mechanisms allow the receiving process to obtain a <em>siginfo_t</em> structure (<a href="ch21.xhtml#ch21lev1sec04">Section 21.4</a>) that provides <span epub:type="pagebreak" id="page_500"/>further information about the signal. (To take advantage of this feature in a signal handler, we specify the <span class="literal">SA_SIGINFO</span> flag when establishing the handler.) The following fields are set in the <em>siginfo_t</em> structure:</p>
<p class="bull">&#8226; <em>si_signo</em>: This field contains the signal generated by this timer.</p>
<p class="bull">&#8226; <em>si_code</em>: This field is set to <span class="literal">SI_TIMER</span>, indicating that this signal was generated because of the expiration of a POSIX timer.</p>
<p class="bull">&#8226; <em>si_value</em>: This field is set to the value that was supplied in <em>evp.sigev_value</em> when the timer was created using <em>timer_create()</em>. Specifying different <em>evp.sigev_value</em> values provides a means of distinguishing expirations of multiple timers that deliver the same signal.</p>
<p class="noindentt">When calling <em>timer_create()</em>, <em>evp.sigev_value.sival_ptr</em> is typically assigned the address of the <em>timerid</em> argument given in the same call (see <a href="ch23.xhtml#ch23ex5">Listing 23-5</a>). This allows the signal handler (or the <em>sigwaitinfo()</em> call) to obtain the ID of the timer that generated the signal. (Alternatively, <em>evp.sigev_value.sival_ptr</em> may be assigned the address of a structure that contains the <em>timerid</em> given to <em>timer_create()</em>.)</p>
<p class="indentb">Linux also supplies the following nonstandard field in the <em>siginfo_t</em> structure:</p>
<p class="bull">&#8226; <em>si_overrun</em>: This field contains the overrun count for this timer (described in <a href="ch23.xhtml#ch23lev2sec12">Section 23.6.6</a>).</p>
<div class="block1">
<p class="noindent">Linux also supplies another nonstandard field: <em>si_timerid</em>. This field contains an identifier that is used internally by the system to identify the timer (it is not the same as the ID returned by <em>timer_create()</em>). It is not useful to applications.</p>
</div>
<p class="noindent"><a href="ch23.xhtml#ch23ex5">Listing 23-5</a> demonstrates the use of signals as the notification mechanism for a POSIX timer.</p>
<p class="examplet"><a id="ch23ex5"/><strong>Listing 23-5:</strong> POSIX timer notification using a signal</p>
<p class="programsli">_________________________________________________ <span class="codestrong">timers/ptmr_sigev_signal.c</span><br/><br/>&#160;&#160;&#160;#define _POSIX_C_SOURCE 199309<br/>&#160;&#160;&#160;#include &lt;signal.h&gt;<br/>&#160;&#160;&#160;#include &lt;time.h&gt;<br/>&#160;&#160;&#160;#include "curr_time.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declares currTime() */<br/>&#160;&#160;&#160;#include "itimerspec_from_str.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declares itimerspecFromStr() */<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;#define TIMER_SIG SIGRTMAX&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Our timer notification signal */<br/><br/>&#160;&#160;&#160;static void<br/><span class="ent">&#x2460;</span> handler(int sig, siginfo_t *si, void *uc)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;timer_t *tidptr;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;tidptr = si-&gt;si_value.sival_ptr;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* UNSAFE: This handler uses non-async-signal-safe functions<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(printf(); see <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>) */<br/><span epub:type="pagebreak" id="page_501"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("[%s] Got signal %d\n", currTime("%T"), sig);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;*sival_ptr&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;= %ld\n", (long) *tidptr);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;timer_getoverrun() = %d\n", timer_getoverrun(*tidptr));<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct itimerspec ts;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sigaction&#160;&#160;sa;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sigevent&#160;&#160;&#160;sev;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;timer_t *tidlist;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int j;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc &lt; 2)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s secs[/nsecs][:int-secs[/int-nsecs]]...\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;tidlist = calloc(argc - 1, sizeof(timer_t));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (tidlist == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("malloc");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Establish handler for notification signal */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_flags = SA_SIGINFO;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_sigaction = handler;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;if (sigaction(TIMER_SIG, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create and start one timer for each command-line argument */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sev.sigev_notify = SIGEV_SIGNAL;&#160;&#160;&#160;&#160;/* Notify via signal */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sev.sigev_signo = TIMER_SIG;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Notify using this signal */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (j = 0; j &lt; argc - 1; j++) {<br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;itimerspecFromStr(argv[j + 1], &#38;ts);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sev.sigev_value.sival_ptr = &#38;tidlist[j];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allows handler to get ID of this timer */<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (timer_create(CLOCK_REALTIME, &#38;sev, &#38;tidlist[j]) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("timer_create");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Timer ID: %ld (%s)\n", (long) tidlist[j], argv[j + 1]);<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (timer_settime(tidlist[j], 0, &#38;ts, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("timer_settime");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;for (;;)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for incoming timer signals */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pause();<br/>&#160;&#160;&#160;}<br/>_________________________________________________ <span class="codestrong">timers/ptmr_sigev_signal.c</span></p>
<p class="noindentb"><span epub:type="pagebreak" id="page_502"/>Each of the command-line arguments of the program in <a href="ch23.xhtml#ch23ex5">Listing 23-5</a> specifies the initial value and interval for a timer. The syntax of these arguments is described in the program&#8217;s &#8220;usage&#8221; message and demonstrated in the shell session below. This program performs the following steps:</p>
<p class="bull">&#8226; Establish a handler for the signal that is used for timer notifications <span class="ent">&#x2461;</span>.</p>
<p class="bull">&#8226; For each command-line argument, create <span class="ent">&#x2463;</span> and arm <span class="ent">&#x2464;</span> a POSIX timer that uses the <span class="literal">SIGEV_SIGNAL</span> notification mechanism. The <em>itimerspecFromStr()</em> function that we use to convert <span class="ent">&#x2462;</span> the command-line arguments to <em>itimerspec</em> structures is shown in <a href="ch23.xhtml#ch23ex6">Listing 23-6</a>.</p>
<p class="bull">&#8226; On each timer expiration, the signal specified in <em>sev.sigev_signo</em> will be delivered to the process. The handler for this signal displays the value that was supplied in <em>sev.sigev_value.sival_ptr</em> (i.e., the timer ID, <em>tidlist[j]</em>) and the overrun value for the timer <span class="ent">&#x2460;</span>.</p>
<p class="bull">&#8226; Having created and armed the timers, wait for timer expirations by executing a loop that repeatedly calls <em>pause()</em> <span class="ent">&#x2465;</span>.</p>
<p class="noindentt"><a href="ch23.xhtml#ch23ex6">Listing 23-6</a> shows the function that converts each of the command-line arguments for the program in <a href="ch23.xhtml#ch23ex5">Listing 23-5</a> into a corresponding <em>itimerspec</em> structure. The format of the string arguments interpreted by this function is shown in a comment at the top of the listing (and demonstrated in the shell session below).</p>
<p class="examplet"><a id="ch23ex6"/><strong>Listing 23-6:</strong> Converting time-plus-interval string to an <em>itimerspec</em> value</p>
<p class="programsli">_______________________________________________ <span class="codestrong">timers/itimerspec_from_str.c</span><br/><br/>#include &lt;string.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include "itimerspec_from_str.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declares function defined here */<br/><br/>/* Convert a string of the following form to an itimerspec structure:<br/>&#160;&#160;&#160;"value.sec[/value.nanosec][:interval.sec[/interval.nanosec]]".<br/>&#160;&#160;&#160;Optional components that are omitted cause 0 to be assigned to the<br/>&#160;&#160;&#160;corresponding structure fields. */<br/><br/>void<br/>itimerspecFromStr(char *str, struct itimerspec *tsp)<br/>{<br/>&#160;&#160;&#160;&#160;char *dupstr, *cptr, *sptr;<br/><br/>&#160;&#160;&#160;&#160;dupstr = strdup(str);<br/><br/>&#160;&#160;&#160;&#160;cptr = strchr(dupstr, ':');<br/>&#160;&#160;&#160;&#160;if (cptr != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*cptr = '\0';<br/><br/>&#160;&#160;&#160;&#160;sptr = strchr(dupstr, '/');<br/>&#160;&#160;&#160;&#160;if (sptr != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*sptr = '\0';<br/><br/>&#160;&#160;&#160;&#160;tsp-&gt;it_value.tv_sec = atoi(dupstr);<br/>&#160;&#160;&#160;&#160;tsp-&gt;it_value.tv_nsec = (sptr != NULL) ? atoi(sptr + 1) : 0;<br/><br/>&#160;&#160;&#160;&#160;if (cptr == NULL) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tsp-&gt;it_interval.tv_sec = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tsp-&gt;it_interval.tv_nsec = 0;<br/>&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sptr = strchr(cptr + 1, '/');<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sptr != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*sptr = '\0';<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tsp-&gt;it_interval.tv_sec = atoi(cptr + 1);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tsp-&gt;it_interval.tv_nsec = (sptr != NULL) ? atoi(sptr + 1) : 0;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;free(dupstr);<br/>}<br/>_______________________________________________ <span class="codestrong">timers/itimerspec_from_str.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_503"/>We demonstrate the use of the program in <a href="ch23.xhtml#ch23ex5">Listing 23-5</a> in the following shell session, creating a single timer with an initial timer expiry of 2 seconds and an interval of 5 seconds.</p>
<p class="programs">$ <span class="codestrong">./ptmr_sigev_signal 2:5</span><br/>Timer ID: 134524952 (2:5)<br/>[15:54:56] Got signal 64 SIGRTMAX&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">is signal 64 on this system</span><br/>&#160;&#160;&#160;&#160;*sival_ptr&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;= 134524952&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">sival_ptr points to the variable tid</span><br/>&#160;&#160;&#160;&#160;timer_getoverrun() = 0<br/>[15:55:01] Got signal 64<br/>&#160;&#160;&#160;&#160;*sival_ptr&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;= 134524952<br/>&#160;&#160;&#160;&#160;timer_getoverrun() = 0<br/><span class="font1">Type Control-Z to suspend the process</span><br/>[1]+&#160;&#160;Stopped&#160;&#160;&#160;&#160;&#160;&#160;&#160;./ptmr_sigev_signal 2:5</p>
<p class="noindent">After suspending the program, we pause for a few seconds, allowing several timer expirations to occur before we resume the program:</p>
<p class="programs">$ <span class="codestrong">fg</span><br/>./ptmr_sigev_signal 2:5<br/>[15:55:34] Got signal 64<br/>&#160;&#160;&#160;&#160;*sival_ptr&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;= 134524952<br/>&#160;&#160;&#160;&#160;timer_getoverrun() = 5<br/><span class="font1">Type Control-C to kill the program</span></p>
<p class="noindent">The last line of program output shows that five timer overruns occurred, meaning that six timer expirations occurred since the previous signal delivery.</p>
<h4 class="h4" id="ch23lev2sec12"><strong>23.6.6 Timer Overruns</strong></h4>
<p class="noindenta">Suppose that we have chosen to receive notification of timer expiration via delivery of a signal (i.e., <em>sigev_notify</em> is <span class="literal">SIGEV_SIGNAL</span>). Suppose further that the timer expires multiple times before the associated signal is caught or accepted. This could occur as the result of a delay before the process is next scheduled. Alternatively, it could occur because delivery of the associated signal was blocked, either explicitly via <em>sigprocmask()</em>, or implicitly during the execution of the handler for the signal. How do we know that such <em>timer overruns</em> have happened?</p>
<p class="indent">We might suppose that using a realtime signal would help solve this problem, since multiple instances of a realtime signal are queued. However, this approach <span epub:type="pagebreak" id="page_504"/>turns out to be unworkable, because there are limits on the number of realtime signals that can be queued. Therefore, the POSIX.1b committee decided on a different approach: if we choose to receive timer notification via a signal, then multiple instances of the signal are never queued, even if we use a realtime signal. Instead, after receiving the signal (either via a signal handler or by using <em>sigwaitinfo()</em>), we can fetch the <em>timer overrun count</em>, which is the number of extra timer expirations that occurred between the time the signal was generated and the time it was received. For example, if the timer has expired three times since the last signal was received, then the overrun count is 2.</p>
<p class="indentb">After receiving a timer signal, we can obtain the timer overrun count in two ways:</p>
<p class="bull">&#8226; Call <em>timer_getoverrun()</em>, which we describe below. This is the SUSv3-specified way of obtaining the overrun count.</p>
<p class="bull">&#8226; Use the value in the <em>si_overrun</em> field of the <em>siginfo_t</em> structure returned with the signal. This approach saves the overhead of the <em>timer_getoverrun()</em> system call, but is a nonportable Linux extension.</p>
<p class="noindentt">The timer overrun count is reset each time we receive the timer signal. If the timer expired just once since the timer signal was handled or accepted, then the overrun count will be 0 (i.e., there were no overruns).</p>
<div class="box">
<p class="programsa">#define _POSIX_C_SOURCE 199309<br/>#include &lt;time.h&gt;<br/><br/>int <span class="codestrong">timer_getoverrun</span>(timer_t <span class="font1">timerid</span>);</p>
<p class="right">Returns timer overrun count on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>timer_getoverrun()</em> function returns the overrun count for the timer specified by its <em>timerid</em> argument.</p>
<p class="indent">The <em>timer_getoverrun()</em> function is one of those specified as being async-signal-safe in SUSv3 (<a href="ch21.xhtml#ch21table1">Table 21-1</a>, on <a href="ch21.xhtml#page_426">page 426</a>), so it is safe to call it from within a signal handler.</p>
<h4 class="h4" id="ch23lev2sec13"><strong>23.6.7 Notification via a Thread</strong></h4>
<p class="noindenta">The <span class="literal">SIGEV_THREAD</span> flag allows a program to obtain notification of timer expiration via the invocation of a function in a separate thread. Understanding this flag requires knowledge of POSIX threads that we present later, in <a href="ch29.xhtml#ch29">Chapters 29</a> and <a href="ch30.xhtml#ch30">30</a>. Readers unfamiliar with POSIX threads may want to read those chapters before examining the example program that we present in this section.</p>
<p class="indentb"><a href="ch23.xhtml#ch23ex7">Listing 23-7</a> demonstrates the use of <span class="literal">SIGEV_THREAD</span>. This program takes the same command-line arguments as the program in <a href="ch23.xhtml#ch23ex5">Listing 23-5</a>. The program performs the following steps:</p>
<p class="bull">&#8226; For each command-line argument, the program creates <span class="ent">&#x2465;</span> and arms <span class="ent">&#x2466;</span> a POSIX timer that uses the <span class="literal">SIGEV_THREAD</span> notification mechanism <span class="ent">&#x2462;</span>.</p>
<p class="bull">&#8226; Each time this timer expires, the function specified by <em>sev.sigev_notify_function</em> <span class="ent">&#x2463;</span> will be invoked in a separate thread. When this function is invoked, it receives <span epub:type="pagebreak" id="page_505"/>the value specified in <em>sev.sigev_value.sival_ptr</em> as an argument. We assign the address of the timer ID (<em>tidlist[j]</em>) to this field <span class="ent">&#x2464;</span> so that the notification function can obtain the ID of the timer that caused its invocation.</p>
<p class="bull">&#8226; Having created and armed all of the timers, the main program enters a loop that waits for timer expirations <span class="ent">&#x2467;</span>. Each time through the loop, the program uses <em>pthread_cond_wait()</em> to wait for a condition variable (<em>cond</em>) to be signaled by the thread that is handling a timer notification.</p>
<p class="bull">&#8226; The <em>threadFunc()</em> function is invoked on each timer expiration <span class="ent">&#x2460;</span>. After printing a message, it increments the value of the global variable <em>expireCnt</em>. To allow for the possibility of timer overruns, the value returned by <em>timer_getoverrun()</em> is also added to <em>expireCnt</em>. (We explained timer overruns in <a href="ch23.xhtml#ch23lev2sec12">Section 23.6.6</a> in relation to the <span class="literal">SIGEV_SIGNAL</span> notification mechanism. Timer overruns can also come into play with the <span class="literal">SIGEV_THREAD</span> mechanism, because a timer might expire multiple times before the notification function is invoked.) The notification function also signals the condition variable <em>cond</em> so that the main program knows to check that a timer has expired <span class="ent">&#x2461;</span>.</p>
<p class="noindentt">The following shell session log demonstrates the use of the program in <a href="ch23.xhtml#ch23ex7">Listing 23-7</a>. In this example, the program creates two timers: one with an initial expiry of 5 seconds and an interval of 5 seconds, and the other with an initial expiration of 10 seconds and an interval of 10 seconds.</p>
<p class="programs">$ <span class="codestrong">./ptmr_sigev_thread 5:5 10:10</span><br/>Timer ID: 134525024 (5:5)<br/>Timer ID: 134525080 (10:10)<br/>[13:06:22] Thread notify<br/>&#160;&#160;&#160;&#160;timer ID=134525024<br/>&#160;&#160;&#160;&#160;timer_getoverrun()=0<br/>main(): expireCnt = 1<br/>[13:06:27] Thread notify<br/>&#160;&#160;&#160;&#160;timer ID=134525080<br/>&#160;&#160;&#160;&#160;timer_getoverrun()=0<br/>main(): expireCnt = 2<br/>[13:06:27] Thread notify<br/>&#160;&#160;&#160;&#160;timer ID=134525024<br/>&#160;&#160;&#160;&#160;timer_getoverrun()=0<br/>main(): expireCnt = 3<br/><span class="font1">Type Control-Z to suspend the program</span><br/>[1]+&#160;&#160;Stopped&#160;&#160;&#160;&#160;&#160;&#160;&#160;./ptmr_sigev_thread 5:5 10:10<br/>$ <span class="codestrong">fg</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Resume execution</span><br/>./ptmr_sigev_thread 5:5 10:10<br/>[13:06:45] Thread notify<br/>&#160;&#160;&#160;&#160;timer ID=134525024<br/>&#160;&#160;&#160;&#160;timer_getoverrun()=2&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">There were timer overruns</span><br/>main(): expireCnt = 6<br/>[13:06:45] Thread notify<br/>&#160;&#160;&#160;&#160;timer ID=134525080<br/>&#160;&#160;&#160;&#160;timer_getoverrun()=0<br/>main(): expireCnt = 7<br/><span class="font1">Type Control-C to kill the program</span></p>
<p class="examplet"><span epub:type="pagebreak" id="page_506"/><a id="ch23ex7"/><strong>Listing 23-7:</strong> POSIX timer notification using a thread function</p>
<p class="programsli">_________________________________________________ <span class="codestrong">timers/ptmr_sigev_thread.c</span><br/><br/>&#160;&#160;&#160;#include &lt;signal.h&gt;<br/>&#160;&#160;&#160;#include &lt;time.h&gt;<br/>&#160;&#160;&#160;#include &lt;pthread.h&gt;<br/>&#160;&#160;&#160;#include "curr_time.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declaration of currTime() */<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/>&#160;&#160;&#160;#include "itimerspec_from_str.h"&#160;&#160;&#160;&#160;/* Declares itimerspecFromStr() */<br/><br/>&#160;&#160;&#160;static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;<br/>&#160;&#160;&#160;static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;<br/><br/>&#160;&#160;&#160;static int expireCnt = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of expirations of all timers */<br/><br/>&#160;&#160;&#160;static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Thread notification function */<br/><span class="ent">&#x2460;</span> threadFunc(union sigval sv)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;timer_t *tidptr;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int s;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;tidptr = sv.sival_ptr;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("[%s] Thread notify\n", currTime("%T"));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;timer ID=%ld\n", (long) *tidptr);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;timer_getoverrun()=%d\n", timer_getoverrun(*tidptr));<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Increment counter variable shared with main thread and signal<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;condition variable to notify main thread of the change. */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_mutex_lock(&#38;mtx);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_lock");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;expireCnt += 1 + timer_getoverrun(*tidptr);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_mutex_unlock(&#38;mtx);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_unlock");<br/><br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;s = pthread_cond_signal(&#38;cond);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_cond_signal");<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sigevent sev;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct itimerspec ts;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;timer_t *tidlist;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int s, j;<br/><br/><span epub:type="pagebreak" id="page_507"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc &lt; 2)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s secs[/nsecs][:int-secs[/int-nsecs]]...\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;tidlist = calloc(argc - 1, sizeof(timer_t));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (tidlist == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("malloc");<br/><br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;sev.sigev_notify = SIGEV_THREAD;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Notify via thread */<br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;sev.sigev_notify_function = threadFunc;&#160;&#160;&#160;&#160;&#160;/* Thread start function */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sev.sigev_notify_attributes = NULL;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Could be pointer to pthread_attr_t structure */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create and start one timer for each command-line argument */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (j = 0; j &lt; argc - 1; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;itimerspecFromStr(argv[j + 1], &#38;ts);<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sev.sigev_value.sival_ptr = &#38;tidlist[j];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Passed as argument to threadFunc() */<br/><br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (timer_create(CLOCK_REALTIME, &#38;sev, &#38;tidlist[j]) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("timer_create");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Timer ID: %ld (%s)\n", (long) tidlist[j], argv[j + 1]);<br/><br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (timer_settime(tidlist[j], 0, &#38;ts, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("timer_settime");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* The main thread waits on a condition variable that is signaled<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;on each invocation of the thread notification function. We<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print a message so that the user can see that this occurred. */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_mutex_lock(&#38;mtx);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_lock");<br/><br/><span class="ent">&#x2467;</span>&#160;&#160;&#160;&#160;&#160;for (;;) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_cond_wait(&#38;cond, &#38;mtx);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_cond_wait");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("main(): expireCnt = %d\n", expireCnt);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/>_________________________________________________ <span class="codestrong">timers/ptmr_sigev_thread.c</span></p>
<h3 class="h3" id="ch23lev1sec07"><strong>23.7 Timers That Notify via File Descriptors: The <em>timerfd</em> API</strong></h3>
<p class="noindenta">Starting with kernel 2.6.25, Linux provides another API for creating timers. The Linux-specific <em>timerfd</em> API creates a timer whose expiration notifications can be read from a file descriptor. This is useful because the file descriptor can be monitored along with other descriptors using <em>select()</em>, <em>poll()</em>, and <em>epoll</em> (described in <a href="ch63.xhtml#ch63">Chapter 63</a>). (With the other timer APIs discussed in this chapter, it requires some effort <span epub:type="pagebreak" id="page_508"/>to be able to simultaneously monitor one or more timers along with a set of file descriptors.)</p>
<p class="indent">The operation of the three new system calls in this API is analogous to the operation of the <em>timer_create()</em>, <em>timer_settime()</em>, and <em>timer_gettime()</em> system calls described in <a href="ch23.xhtml#ch23lev1sec06">Section 23.6</a>.</p>
<p class="indent">The first of the new system calls is <em>timerfd_create()</em>, which creates a new timer object and returns a file descriptor referring to that object.</p>
<div class="box">
<p class="programsa">#include &lt;sys/timerfd.h&gt;<br/><br/>int <span class="codestrong">timerfd_create</span>(int <span class="font1">clockid</span>, int <span class="font1">flags</span>);</p>
<p class="right">Returns file descriptor on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The value of <em>clockid</em> can be either <span class="literal">CLOCK_REALTIME</span> or <span class="literal">CLOCK_MONOTONIC</span> (see <a href="ch23.xhtml#ch23table1">Table 23-1</a>).</p>
<p class="indentb">In the initial implementation of <em>timerfd_create()</em>, the <em>flags</em> argument was reserved for future use and had to be specified as 0. However, since Linux 2.6.27, two flags are supported:</p>
<p class="term"><span class="literal">TFD_CLOEXEC</span></p>
<p class="termlist">Set the close-on-exec flag (<span class="literal">FD_CLOEXEC</span>) for the new file descriptor. This flag is useful for the same reasons as the <em>open()</em> <span class="literal">O_CLOEXEC</span> flag described in <a href="ch04.xhtml#ch04lev2sec01">Section 4.3.1</a>.</p>
<p class="term"><span class="literal">TFD_NONBLOCK</span></p>
<p class="termlist">Set the <span class="literal">O_NONBLOCK</span> flag on the underlying open file description, so that future reads will be nonblocking. This saves additional calls to <em>fcntl()</em> to achieve the same result.</p>
<p class="noindentt">When we have finished using a timer created by <em>timerfd_create()</em>, we should <em>close()</em> the associated file descriptor, so that the kernel can free the resources associated with the timer.</p>
<p class="indent">The <em>timerfd_settime()</em> system call arms (starts) or disarms (stops) the timer referred to by the file descriptor <em>fd</em>.</p>
<div class="box">
<p class="programsa">#include &lt;sys/timerfd.h&gt;<br/><br/>int <span class="codestrong">timerfd_settime</span>(int <span class="font1">fd</span>, int <span class="font1">flags</span>, const struct itimerspec *<span class="font1">new_value</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct itimerspec *<span class="font1">old_value</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>new_value</em> argument specifies the new settings for the timer. The <em>old_value</em> argument can be used to return the previous settings of the timer (see the description of <em>timerfd_gettime()</em> below for details). If we are not interested in the previous settings, we can specify <em>old_value</em> as <span class="literal">NULL</span>. Both of these arguments are <em>itimerspec</em> structures that are used in the same way as for <em>timer_settime()</em> (see <a href="ch23.xhtml#ch23lev2sec08">Section 23.6.2</a>).</p>
<p class="indent">The <em>flags</em> argument is similar to the corresponding argument for <em>timer_settime()</em>. It may either be 0, meaning that <em>new_value.it_value</em> is interpreted relative to the time of the call to <em>timerfd_settime()</em>, or it can be <span class="literal">TFD_TIMER_ABSTIME</span>, meaning that <span epub:type="pagebreak" id="page_509"/><em>new_value.it_value</em> is interpreted as an absolute time (i.e., measured from the clock&#8217;s zero point).</p>
<p class="indent">The <em>timerfd_gettime()</em> system call returns the interval and remaining time for the timer identified by the file descriptor <em>fd</em>.</p>
<div class="box">
<p class="programsa">#include &lt;sys/timerfd.h&gt;<br/><br/>int <span class="codestrong">timerfd_gettime</span>(int <span class="font1">fd</span>, struct itimerspec *<span class="font1">curr_value</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">As with <em>timer_gettime()</em>, the interval and the time until the next expiration of the timer are returned in the <em>itimerspec</em> structure pointed to by <em>curr_value</em>. The <em>curr_value.it_value</em> field returns the time until the next timer expiration, even if this timer was established as an absolute timer using <span class="literal">TFD_TIMER_ABSTIME</span>. If both fields of the returned <em>curr_value.it_value</em> structure are 0, then the timer is currently disarmed. If both fields of the returned <em>curr_value.it_interval</em> structure are 0, then the timer expires just once, at the time given in <em>curr_value.it_value</em>.</p>
<h5 class="h5" id="ch23lev3sec05"><strong>Interactions of <em>timerfd</em> with <em>fork()</em> and <em>exec()</em></strong></h5>
<p class="noindenta">During a <em>fork()</em>, a child process inherits copies of file descriptors created by <em>timerfd_create()</em>. These file descriptors refer to the same timer objects as the corresponding descriptors in the parent, and timer expirations can be read in either process.</p>
<p class="indent">File descriptors created by <em>timerfd_create()</em> are preserved across an <em>exec()</em> (unless the descriptors are marked close-on-exec, as described in <a href="ch27.xhtml#ch27lev1sec04">Section 27.4</a>), and armed timers will continue to generate timer expirations after the <em>exec()</em>.</p>
<h5 class="h5" id="ch23lev3sec06"><strong>Reading from the <em>timerfd</em> file descriptor</strong></h5>
<p class="noindenta">Once we have armed a timer with <em>timerfd_settime()</em>, we can use <em>read()</em> to read information about timer expirations from the associated file descriptor. For this purpose, the buffer given to <em>read()</em> must be large enough to hold an unsigned 8-byte integer (<em>uint64_t</em>).</p>
<p class="indent">If one or more expirations have occurred since the timer settings were last modified using <em>timerfd_settime()</em> or the last <em>read()</em> was performed, then <em>read()</em> returns immediately, and the returned buffer contains the number of expirations that have occurred. If no timer expirations have occurred, then <em>read()</em> blocks until the next expiration occurs. It is also possible to use the <em>fcntl()</em> <span class="literal">F_SETFL</span> operation (<a href="ch05.xhtml#ch05lev1sec03">Section 5.3</a>) to set the <span class="literal">O_NONBLOCK</span> flag for the file descriptor, so that reads are nonblocking, and will fail with the error <span class="literal">EAGAIN</span> if no timer expirations have occurred.</p>
<p class="indent">As stated earlier, a <em>timerfd</em> file descriptor can be monitored using <em>select()</em>, <em>poll()</em>, and <em>epoll</em>. If the timer has expired, then the file descriptor indicates as being readable.</p>
<h5 class="h5" id="ch23lev3sec07"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch23.xhtml#ch23ex8">Listing 23-8</a> demonstrates the use of the <em>timerfd</em> API. This program takes two command-line arguments. The first argument is mandatory, and specifies the initial time and interval for a timer. (This argument is interpreted using the <em>itimerspecFromStr()</em> function shown in <a href="ch23.xhtml#ch23ex6">Listing 23-6</a>.) The second argument, which is optional, specifies <span epub:type="pagebreak" id="page_510"/>the maximum number of expirations of the timer that the program should wait for before terminating; the default for this argument is 1.</p>
<p class="indent">The program creates a timer using <em>timerfd_create()</em>, and arms it using <em>timerfd_settime()</em>. It then loops, reading expiration notifications from the file descriptor until the specified number of expirations has been reached. After each <em>read()</em>, the program displays the time elapsed since the timer was started, the number of expirations read, and the total number of expirations so far.</p>
<p class="indent">In the following shell session log, the command-line arguments specify a timer with a 1-second initial value and 1-second interval, and a maximum of 100 expirations.</p>
<p class="programs">$ <span class="codestrong">./demo_timerfd 1:1 100</span><br/>1.000: expirations read: 1; total=1<br/>2.000: expirations read: 1; total=2<br/>3.000: expirations read: 1; total=3<br/><span class="font1">Type Control-Z to suspend program in background for a few seconds</span><br/>[1]+&#160;&#160;Stopped&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;./demo_timerfd 1:1 100<br/>$ <span class="codestrong">fg</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Resume program in foreground</span><br/>./demo_timerfd 1:1 100<br/>14.205: expirations read: 11; total=14&#160;&#160;&#160;&#160;<span class="font1">Multiple expirations since last read()</span><br/>15.000: expirations read: 1; total=15<br/>16.000: expirations read: 1; total=16<br/><span class="font1">Type Control-C to terminate the program</span></p>
<p class="noindent">From the above output, we can see that multiple timer expirations occurred while the program was suspended in the background, and all of these expirations were returned on the first <em>read()</em> after the program resumed execution.</p>
<p class="examplet"><a id="ch23ex8"/><strong>Listing 23-8:</strong> Using the <em>timerfd</em> API</p>
<p class="programsli">_____________________________________________________ <span class="codestrong">timers/demo_timerfd.c</span><br/><br/>#include &lt;sys/timerfd.h&gt;<br/>#include &lt;time.h&gt;<br/>#include &lt;stdint.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Definition of uint64_t */<br/>#include "itimerspec_from_str.h"&#160;&#160;&#160;&#160;&#160;&#160;/* Declares itimerspecFromStr() */<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct itimerspec ts;<br/>&#160;&#160;&#160;&#160;struct timespec start, now;<br/>&#160;&#160;&#160;&#160;int maxExp, fd, secs, nanosecs;<br/>&#160;&#160;&#160;&#160;uint64_t numExp, totalExp;<br/>&#160;&#160;&#160;&#160;ssize_t s;<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s secs[/nsecs][:int-secs[/int-nsecs]] [max-exp]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;itimerspecFromStr(argv[1], &#38;ts);<br/>&#160;&#160;&#160;&#160;maxExp = (argc &gt; 2) ? getInt(argv[2], GN_GT_0, "max-exp") : 1;<br/>&#160;&#160;&#160;&#160;fd = timerfd_create(CLOCK_REALTIME, 0);<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("timerfd_create");<br/><br/>&#160;&#160;&#160;&#160;if (timerfd_settime(fd, 0, &#38;ts, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("timerfd_settime");<br/><br/>&#160;&#160;&#160;&#160;if (clock_gettime(CLOCK_MONOTONIC, &#38;start) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("clock_gettime");<br/><br/>&#160;&#160;&#160;&#160;for (totalExp = 0; totalExp &lt; maxExp;) {<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Read number of expirations on the timer, and then display<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;time elapsed since timer was started, followed by number<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;of expirations read and total expirations so far. */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = read(fd, &#38;numExp, sizeof(uint64_t));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != sizeof(uint64_t))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("read");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;totalExp += numExp;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (clock_gettime(CLOCK_MONOTONIC, &#38;now) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("clock_gettime");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;secs = now.tv_sec - start.tv_sec;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nanosecs = now.tv_nsec - start.tv_nsec;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (nanosecs &lt; 0) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;secs--;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nanosecs += 1000000000;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%d.%03d: expirations read: %llu; total=%llu\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;secs, (nanosecs + 500000) / 1000000,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(unsigned long long) numExp, (unsigned long long) totalExp);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_____________________________________________________ <span class="codestrong">timers/demo_timerfd.c</span></p>
<h3 class="h3" id="ch23lev1sec08"><span epub:type="pagebreak" id="page_511"/><strong>23.8 Summary</strong></h3>
<p class="noindenta">A process can use <em>setitimer()</em> or <em>alarm()</em> to set a timer, so that it receives a signal after the passage of a specified amount of real or process time. One use of timers is to set an upper limit on the time for which a system call can block.</p>
<p class="indent">Applications that need to suspend execution for a specified interval of real time can use a variety of sleep functions for this purpose.</p>
<p class="indent">Linux 2.6 implements the POSIX.1b extensions that define an API for high-precision clocks and timers. POSIX.1b timers provide a number of advantages over traditional (<em>setitimer()</em>) UNIX timers. We can: create multiple timers; choose the signal that is delivered on timer expiration; retrieve the timer overrun count in order to <span epub:type="pagebreak" id="page_512"/>determine if a timer has expired multiple times since the last expiration notification; and choose to receive timer notifications via execution of a thread function instead of delivery of a signal.</p>
<p class="indent">The Linux-specific <em>timerfd</em> API provides a set of interfaces for creating timers that is similar to the POSIX timers API, but allows timer notifications to be read via a file descriptor. This file descriptor can be monitored using <em>select()</em>, <em>poll()</em>, and <em>epoll</em>.</p>
<h5 class="h5" id="ch23lev3sec08"><strong>Further information</strong></h5>
<p class="noindenta">Under the rationale for individual functions, SUSv3 provides useful notes on the (standard) timer and sleep interface described in this chapter. [<a href="bib.xhtml#bib28">Gallmeister, 1995</a>] discusses POSIX.1b clocks and timers.</p>
<h3 class="h3" id="ch23lev1sec09"><strong>23.9 Exercises</strong></h3>
<p class="exer"><a id="ch23exe1"/><strong>23-1.</strong>&#160;&#160;&#160;Although <em>alarm()</em> is implemented as a system call within the Linux kernel, this is redundant. Implement <em>alarm()</em> using <em>setitimer()</em>.</p>
<p class="exer"><a id="ch23exe2"/><strong>23-2.</strong>&#160;&#160;&#160;Try running the program in <a href="ch23.xhtml#ch23ex3">Listing 23-3</a> (<span class="literal">t_nanosleep.c</span>) in the background with a 60-second sleep interval, while using the following command to send as many <span class="literal">SIGINT</span> signals as possible to the background process:</p>
<p class="programs1">$ <span class="codestrong">while true; do kill -INT <span class="codeitalic">pid</span>; done</span></p>
<p class="exerp">You should observe that the program sleeps rather longer than expected. Replace the use of <em>nanosleep()</em> with the use of <em>clock_gettime()</em> (use a <span class="literal">CLOCK_REALTIME</span> clock) and <em>clock_nanosleep()</em> with the <span class="literal">TIMER_ABSTIME</span> flag. (This exercise requires Linux 2.6.) Repeat the test with the modified program and explain the difference.</p>
<p class="exer"><a id="ch23exe3"/><strong>23-3.</strong>&#160;&#160;&#160;Write a program to show that if the <em>evp</em> argument to <em>timer_create()</em> is specified as <span class="literal">NULL</span>, then this is equivalent to specifying <em>evp</em> as a pointer to a <em>sigevent</em> structure with <em>sigev_notify</em> set to <span class="literal">SIGEV_SIGNAL</span>, <em>sigev_signo</em> set to <span class="literal">SIGALRM</span>, and <em>si_value.sival_int</em> set to the timer ID.</p>
<p class="exer"><a id="ch23exe4"/><strong>23-4.</strong>&#160;&#160;&#160;Modify the program in <a href="ch23.xhtml#ch23ex5">Listing 23-5</a> (<span class="literal">ptmr_sigev_signal.c</span>) to use <em>sigwaitinfo()</em> instead of a signal handler.</p>
</body>
</html>
