<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_69"/><strong><span class="big">4</span></strong><br/><strong>FILE I/O: THE UNIVERSAL I/O MODEL</strong></h2>
<p class="noindenta">We now start to look in earnest at the system call API. Files are a good place to start, since they are central to the UNIX philosophy. The focus of this chapter is the system calls used for performing file input and output.</p>
<p class="indent">We introduce the concept of a file descriptor, and then look at the system calls that constitute the so-called universal I/O model. These are the system calls that open and close a file, and read and write data.</p>
<p class="indent">We focus on I/O on disk files. However, much of the material covered here is relevant for later chapters, since the same system calls are used for performing I/O on all types of files, such as pipes and terminals.</p>
<p class="indent"><a href="ch05.xhtml#ch05">Chapter 5</a> extends the discussion in this chapter with further details on file I/O. One other aspect of file I/O, buffering, is complex enough to deserve its own chapter. <a href="ch13.xhtml#ch13">Chapter 13</a> covers I/O buffering in the kernel and in the <em>stdio</em> library.</p>
<h3 class="h3" id="ch04lev1sec01"><strong>4.1 Overview</strong></h3>
<p class="noindenta">All system calls for performing I/O refer to open files using a <em>file descriptor</em>, a (usually small) nonnegative integer. File descriptors are used to refer to all types of open files, including pipes, FIFOs, sockets, terminals, devices, and regular files. Each process has its own set of file descriptors.</p>
<p class="indent">By convention, most programs expect to be able to use the three standard file descriptors listed in <a href="ch04.xhtml#ch4table1">Table 4-1</a>. These three descriptors are opened on the program&#8217;s <span epub:type="pagebreak" id="page_70"/>behalf by the shell, before the program is started. Or, more precisely, the program inherits copies of the shell&#8217;s file descriptors, and the shell normally operates with these three file descriptors always open. (In an interactive shell, these three file descriptors normally refer to the terminal under which the shell is running.) If I/O redirections are specified on a command line, then the shell ensures that the file descriptors are suitably modified before starting the program.</p>
<p class="tablecap"><a id="ch4table1"/><strong>Table 4-1:</strong> Standard file descriptors</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>File descriptor</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Purpose</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>POSIX name</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong><em>stdio</em> stream</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablec">0</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">standard input</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">STDIN_FILENO</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>stdin</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablec">1</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">standard output</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">STDOUT_FILENO</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>stdout</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="tablec">2</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">standard error</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">STDERR_FILENO</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table"><em>stderr</em></p></td>
</tr>
</tbody>
</table>
<p class="noindent">When referring to these file descriptors in a program, we can use either the numbers (0, 1, or 2) or, preferably, the POSIX standard names defined in <span class="literal">&lt;unistd.h&gt;</span>.</p>
<div class="block">
<p class="noindent">Although the variables <em>stdin</em>, <em>stdout</em>, and <em>stderr</em> initially refer to the process&#8217;s standard input, output, and error, they can be changed to refer to any file by using the <em>freopen()</em> library function. As part of its operation, <em>freopen()</em> may change the file descriptor underlying the reopened stream. In other words, after an <em>freopen()</em> on <em>stdout</em>, for example, it is no longer safe to assume that the underlying file descriptor is still 1.</p>
</div>
<p class="noindentb">The following are the four key system calls for performing file I/O (programming languages and software packages typically employ these calls only indirectly, via I/O libraries):</p>
<p class="bull">&#8226; <em>fd = open(pathname, flags, mode)</em> opens the file identified by <em>pathname</em>, returning a file descriptor used to refer to the open file in subsequent calls. If the file doesn&#8217;t exist, <em>open()</em> may create it, depending on the settings of the <em>flags</em> bit-mask argument. The <em>flags</em> argument also specifies whether the file is to be opened for reading, writing, or both. The <em>mode</em> argument specifies the permissions to be placed on the file if it is created by this call. If the <em>open()</em> call is not being used to create a file, this argument is ignored and can be omitted.</p>
<p class="bull">&#8226; <em>numread = read(fd, buffer, count)</em> reads at most <em>count</em> bytes from the open file referred to by <em>fd</em> and stores them in <em>buffer</em>. The <em>read()</em> call returns the number of bytes actually read. If no further bytes could be read (i.e., end-of-file was encountered), <em>read()</em> returns 0.</p>
<p class="bull">&#8226; <em>numwritten = write(fd, buffer, count)</em> writes up to <em>count</em> bytes from <em>buffer</em> to the open file referred to by <em>fd</em>. The <em>write()</em> call returns the number of bytes actually written, which may be less than <em>count</em>.</p>
<p class="bull">&#8226; <em>status = close(fd)</em> is called after all I/O has been completed, in order to release the file descriptor <em>fd</em> and its associated kernel resources.</p>
<p class="noindentt">Before we launch into the details of these system calls, we provide a short demonstration of their use in <a href="ch04.xhtml#ch4ex1">Listing 4-1</a>. This program is a simple version of the <em>cp(1)</em> command. It copies the contents of the existing file named in its first command-line argument to the new file named in its second command-line argument.</p>
<p class="noindent"><span epub:type="pagebreak" id="page_71"/>We can use the program in <a href="ch04.xhtml#ch4ex1">Listing 4-1</a> as follows:</p>
<p class="programs">$ <span class="codestrong">./copy oldfile newfile</span></p>
<p class="examplet"><a id="ch4ex1"/><strong>Listing 4-1:</strong> Using I/O system calls</p>
<p class="programsli">____________________________________________________________ <span class="codestrong">fileio/copy.c</span><br/><br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>#ifndef BUF_SIZE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allow "cc -D" to override definition */<br/>#define BUF_SIZE 1024<br/>#endif<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int inputFd, outputFd, openFlags;<br/>&#160;&#160;&#160;&#160;mode_t filePerms;<br/>&#160;&#160;&#160;&#160;ssize_t numRead;<br/>&#160;&#160;&#160;&#160;char buf[BUF_SIZE];<br/><br/>&#160;&#160;&#160;&#160;if (argc != 3 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s old-file new-file\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;/* Open input and output files */<br/><br/>&#160;&#160;&#160;&#160;inputFd = open(argv[1], O_RDONLY);<br/>&#160;&#160;&#160;&#160;if (inputFd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("opening file %s", argv[1]);<br/><br/>&#160;&#160;&#160;&#160;openFlags = O_CREAT | O_WRONLY | O_TRUNC;<br/>&#160;&#160;&#160;&#160;filePerms = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP |<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S_IROTH | S_IWOTH;&#160;&#160;&#160;&#160;&#160;&#160;/* rw-rw-rw- */<br/>&#160;&#160;&#160;&#160;outputFd = open(argv[2], openFlags, filePerms);<br/>&#160;&#160;&#160;&#160;if (outputFd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("opening file %s", argv[2]);<br/><br/>&#160;&#160;&#160;&#160;/* Transfer data until we encounter end of input or an error */<br/><br/>&#160;&#160;&#160;&#160;while ((numRead = read(inputFd, buf, BUF_SIZE)) &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (write(outputFd, buf, numRead) != numRead)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("couldn't write whole buffer");<br/>&#160;&#160;&#160;&#160;if (numRead == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("read");<br/><br/>&#160;&#160;&#160;&#160;if (close(inputFd) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close input");<br/>&#160;&#160;&#160;&#160;if (close(outputFd) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close output");<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>____________________________________________________________ <span class="codestrong">fileio/copy.c</span></p>
<h3 class="h3" id="ch04lev1sec02"><span epub:type="pagebreak" id="page_72"/><strong>4.2 Universality of I/O</strong></h3>
<p class="noindenta">One of the distinguishing features of the UNIX I/O model is the concept of <em>universality of I/O</em>. This means that the same four system calls&#8212;<em>open()</em>, <em>read()</em>, <em>write()</em>, and <em>close()</em>&#8212;are used to perform I/O on all types of files, including devices such as terminals. Consequently, if we write a program using only these system calls, that program will work on any type of file. For example, the following are all valid uses of the program in <a href="ch04.xhtml#ch4ex1">Listing 4-1</a>:</p>
<p class="programs">$ <span class="codestrong">./copy test test.old</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Copy a regular file</span><br/>$ <span class="codestrong">./copy a.txt /dev/tty</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Copy a regular file to this terminal</span><br/>$ <span class="codestrong">./copy /dev/tty b.txt</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Copy input from this terminal to a regular file</span><br/>$ <span class="codestrong">./copy /dev/pts/16 /dev/tty</span>&#160;&#160;&#160;&#160;<span class="font1">Copy input from another terminal</span></p>
<p class="noindent">Universality of I/O is achieved by ensuring that each file system and device driver implements the same set of I/O system calls. Because details specific to the file system or device are handled within the kernel, we can generally ignore device-specific factors when writing application programs. When access to specific features of a file system or device is required, a program can use the catchall <em>ioctl()</em> system call (<a href="ch04.xhtml#ch04lev1sec08">Section 4.8</a>), which provides an interface to features that fall outside the universal I/O model.</p>
<h3 class="h3" id="ch04lev1sec03"><strong>4.3 Opening a File: <em>open()</em></strong></h3>
<p class="noindenta">The <em>open()</em> system call either opens an existing file or creates and opens a new file.</p>
<div class="box">
<p class="programsa">#include &lt;sys/stat.h&gt;<br/>#include &lt;fcntl.h&gt;<br/><br/>int <span class="codestrong">open</span>(const char *<span class="font1">pathname</span>, int <span class="font1">flags</span>, ... /* mode_t <span class="font1">mode</span> */);</p>
<p class="right">Returns file descriptor on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The file to be opened is identified by the <em>pathname</em> argument. If <em>pathname</em> is a symbolic link, it is dereferenced. On success, <em>open()</em> returns a file descriptor that is used to refer to the file in subsequent system calls. If an error occurs, <em>open()</em> returns &#8211;1 and <em>errno</em> is set accordingly.</p>
<p class="indent">The <em>flags</em> argument is a bit mask that specifies the <em>access mode</em> for the file, using one of the constants shown in <a href="ch04.xhtml#ch4table2">Table 4-2</a>.</p>
<div class="block">
<p class="noindent">Early UNIX implementations used the numbers 0, 1, and 2 instead of the names shown in <a href="ch04.xhtml#ch4table2">Table 4-2</a>. Most modern UNIX implementations define these constants to have those values. Thus, we can see that <span class="literal">O_RDWR</span> is not equivalent to <span class="literal">O_RDONLY | O_WRONLY</span>; the latter combination is a logical error.</p>
</div>
<p class="noindent">When <em>open()</em> is used to create a new file, the <em>mode</em> bit-mask argument specifies the permissions to be placed on the file. (The <em>mode_t</em> data type used to type <em>mode</em> is an integer type specified in SUSv3.) If the <em>open()</em> call doesn&#8217;t specify <span class="literal">O_CREAT</span>, <em>mode</em> can be omitted.</p>
<p class="tablecap"><span epub:type="pagebreak" id="page_73"/><a id="ch4table2"/><strong>Table 4-2:</strong> File access modes</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Access mode</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_RDONLY</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Open the file for reading only</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_WRONLY</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Open the file for writing only</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">O_RDWR</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Open the file for both reading and writing</p></td>
</tr>
</tbody>
</table>
<p class="noindent">We describe file permissions in detail in <a href="ch15.xhtml#ch15lev1sec04">Section 15.4</a>. Later, we&#8217;ll see that the permissions actually placed on a new file depend not just on the <em>mode</em> argument, but also on the process umask (<a href="ch15.xhtml#ch15lev2sec10">Section 15.4.6</a>) and the (optionally present) default access control list (<a href="ch17.xhtml#ch17lev1sec06">Section 17.6</a>) of the parent directory. In the meantime, we&#8217;ll just note that the <em>mode</em> argument can be specified as a number (typically in octal) or, preferably, by ORing (<span class="literal">|</span>) together zero or more of the bit-mask constants listed in <a href="ch15.xhtml#ch15table4">Table 15-4</a>, on <a href="ch15.xhtml#page_295">page 295</a>.</p>
<p class="indent"><a href="ch04.xhtml#ch4ex2">Listing 4-2</a> shows examples of the use of <em>open()</em>, some of which employ additional <em>flags</em> bits that we describe shortly.</p>
<p class="examplet"><a id="ch4ex2"/><strong>Listing 4-2:</strong> Examples of the use of <em>open()</em></p>
<p class="programsli">______________________________________________________________________<br/><br/>&#160;&#160;&#160;&#160;/* Open existing file for reading */<br/><br/>&#160;&#160;&#160;&#160;fd = open("startup", O_RDONLY);<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open");<br/><br/>&#160;&#160;&#160;&#160;/* Open new or existing file for reading and writing, truncating to zero<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;bytes; file permissions read+write for owner, nothing for all others */<br/><br/>&#160;&#160;&#160;&#160;fd = open("myfile", O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open");<br/><br/>&#160;&#160;&#160;&#160;/* Open new or existing file for writing; writes should always<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;append to end of file */<br/><br/>&#160;&#160;&#160;&#160;fd = open("w.log", O_WRONLY | O_CREAT | O_APPEND,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S_IRUSR | S_IWUSR);<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open");<br/>______________________________________________________________________</p>
<h5 class="h5" id="ch04lev3sec01"><strong>File descriptor number returned by <em>open()</em></strong></h5>
<p class="noindenta">SUSv3 specifies that if <em>open()</em> succeeds, it is guaranteed to use the lowest-numbered unused file descriptor for the process. We can use this feature to ensure that a file is opened using a particular file descriptor. For example, the following sequence ensures that a file is opened using standard input (file descriptor 0).</p>
<p class="programs"><span epub:type="pagebreak" id="page_74"/>if (close(STDIN_FILENO) == -1)&#160;&#160;&#160;&#160;&#160;&#160;/* Close file descriptor 0 */<br/>&#160;&#160;&#160;&#160;errExit("close");<br/><br/>fd = open(pathname, O_RDONLY);<br/>if (fd == -1)<br/>&#160;&#160;&#160;&#160;errExit("open");</p>
<p class="noindent">Since file descriptor 0 is unused, <em>open()</em> is guaranteed to open the file using that descriptor. In <a href="ch05.xhtml#ch05lev1sec05">Section 5.5</a>, we look at the use of <em>dup2()</em> and <em>fcntl()</em> to achieve a similar result, but with more flexible control over the file descriptor used. In that section, we also show an example of why it can be useful to control the file descriptor on which a file is opened.</p>
<h4 class="h4" id="ch04lev2sec01"><strong>4.3.1 The <em>open() flags</em> Argument</strong></h4>
<p class="noindenta">In some of the example <em>open()</em> calls shown in <a href="ch04.xhtml#ch4ex2">Listing 4-2</a>, we included other bits (<span class="literal">O_CREAT</span>, <span class="literal">O_TRUNC</span>, and <span class="literal">O_APPEND</span>) in <em>flags</em> in addition to the file access mode. We now consider the <em>flags</em> argument in more detail. <a href="ch04.xhtml#ch4table3">Table 4-3</a> summarizes the full set of constants that can be bit-wise ORed (<span class="literal">|</span>) in <em>flags</em>. The final column indicates which of these constants are standardized in SUSv3 or SUSv4.</p>
<p class="tablecap"><a id="ch4table3"/><strong>Table 4-3:</strong> Values for the <em>flags</em> argument of <em>open()</em></p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Flag</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Purpose</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="tablec"><strong>SUS?</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_RDONLY</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Open for reading only</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">v3</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_WRONLY</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Open for writing only</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">v3</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">O_RDWR</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Open for reading and writing</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="tablec">v3</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_CLOEXEC</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Set the close-on-exec flag (since Linux 2.6.23)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">v4</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_CREAT</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Create file if it doesn&#8217;t already exist</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">v3</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_DIRECTORY</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Fail if <em>pathname</em> is not a directory</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">v4</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_EXCL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">With <span class="literal">O_CREAT</span>: create file exclusively</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">v3</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_LARGEFILE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Used on 32-bit systems to open large files</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_NOCTTY</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Don&#8217;t let <em>pathname</em> become the controlling terminal</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">v3</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_NOFOLLOW</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Don&#8217;t dereference symbolic links</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">v4</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">O_TRUNC</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Truncate existing file to zero length</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="tablec">v3</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_APPEND</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Writes are always appended to end of file</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">v3</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_ASYNC</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Generate a signal when I/O is possible</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_DIRECT</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">File I/O bypasses buffer cache</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_DSYNC</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Provide synchronized I/O data integrity (since Linux 2.6.33)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">v3</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_NOATIME</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Don&#8217;t update file last access time on <em>read()</em> (since Linux 2.6.8)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_NONBLOCK</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Open in nonblocking mode</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">v3</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">O_SYNC</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">Make file writes synchronous</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="tablec">v3</p></td>
</tr>
</tbody>
</table>
<p class="noindentb"><span epub:type="pagebreak" id="page_75"/>The constants in <a href="ch04.xhtml#ch4table3">Table 4-3</a> are divided into the following groups:</p>
<p class="bull">&#8226; <em>File access mode flags</em>: These are the <span class="literal">O_RDONLY</span>, <span class="literal">O_WRONLY</span>, and <span class="literal">O_RDWR</span> flags described earlier. Only one of these values should be specified in <em>flags</em>. The access mode can be retrieved using the <em>fcntl()</em> <span class="literal">F_GETFL</span> operation (<a href="ch05.xhtml#ch05lev1sec03">Section 5.3</a>).</p>
<p class="bull">&#8226; <em>File creation flags</em>: These are the flags shown in the second part of <a href="ch04.xhtml#ch4table3">Table 4-3</a>. They control various aspects of the behavior of the <em>open()</em> call, as well as options for subsequent I/O operations. These flags can&#8217;t be retrieved or changed.</p>
<p class="bull">&#8226; <em>Open file status flags</em>: These are the remaining flags in <a href="ch04.xhtml#ch4table3">Table 4-3</a>. They can be retrieved and modified using the <em>fcntl()</em> <span class="literal">F_GETFL</span> and <span class="literal">F_SETFL</span> operations (<a href="ch05.xhtml#ch05lev1sec03">Section 5.3</a>). These flags are sometimes simply called the <em>file status flags</em>.</p>
<div class="block">
<p class="noindent">Since kernel 2.6.22, the Linux-specific files in the directory <span class="literal">/proc/</span><em>PID</em><span class="literal">/fdinfo</span> can be read to obtain information about the file descriptors of any process on the system. There is one file in this directory for each of the process&#8217;s open file descriptors, with a name that matches the number of the descriptor. The <em>pos</em> field in this file shows the current file offset (<a href="ch04.xhtml#ch04lev1sec07">Section 4.7</a>). The <em>flags</em> field is an octal number that shows the file access mode flags and open file status flags. (To decode this number, we need to look at the numeric values of these flags in the C library header files.)</p>
</div>
<p class="noindentb">Details for the <em>flags</em> constants are as follows:</p>
<p class="term"><span class="literal">O_APPEND</span></p>
<p class="termlist">Writes are always appended to the end of the file. We discuss the significance of this flag in <a href="ch05.xhtml#ch05lev1sec01">Section 5.1</a>.</p>
<p class="term"><span class="literal">O_ASYNC</span></p>
<p class="termlist">Generate a signal when I/O becomes possible on the file descriptor returned by <em>open()</em>. This feature, termed <em>signal-driven I/O</em>, is available only for certain file types, such as terminals, FIFOs, and sockets. (The <span class="literal">O_ASYNC</span> flag is not specified in SUSv3; however, it, or the older synonym, <span class="literal">FASYNC</span>, is found on most UNIX implementations.) On Linux, specifying the <span class="literal">O_ASYNC</span> flag when calling <em>open()</em> has no effect. To enable signal-driven I/O, we must instead set this flag using the <em>fcntl()</em> <span class="literal">F_SETFL</span> operation (<a href="ch05.xhtml#ch05lev1sec03">Section 5.3</a>). (Several other UNIX implementations behave similarly.) Refer to <a href="ch63.xhtml#ch63lev1sec03">Section 63.3</a> for more information about the <span class="literal">O_ASYNC</span> flag.</p>
<p class="term"><span class="literal">O_CLOEXEC</span> (since Linux 2.6.23)</p>
<p class="termlist">Enable the close-on-exec flag (<span class="literal">FD_CLOEXEC</span>) for the new file descriptor. We describe the <span class="literal">FD_CLOEXEC</span> flag in <a href="ch27.xhtml#ch27lev1sec04">Section 27.4</a>. Using the <span class="literal">O_CLOEXEC</span> flag allows a program to avoid additional <em>fcntl()</em> <span class="literal">F_GETFD</span> and <span class="literal">F_SETFD</span> operations to set the close-on-exec flag. It is also necessary in multithreaded programs to avoid the race conditions that could occur using the latter technique. These races can occur when one thread opens a file descriptor and then tries to mark it close-on-exec at the same time as another thread does a <em>fork()</em> and then an <em>exec()</em> of an arbitrary program. (Suppose that the second thread manages to both <em>fork()</em> and <em>exec()</em> between the time the first thread opens the file descriptor and uses <em>fcntl()</em> to set the close-on-exec flag.) Such races <span epub:type="pagebreak" id="page_76"/>could result in open file descriptors being unintentionally passed to unsafe programs. (We say more about race conditions in <a href="ch05.xhtml#ch05lev1sec01">Section 5.1</a>.)</p>
<p class="term"><span class="literal">O_CREAT</span></p>
<p class="termlist">If the file doesn&#8217;t already exist, it is created as a new, empty file. This flag is effective even if the file is being opened only for reading. If we specify <span class="literal">O_CREAT</span>, then we must supply a <em>mode</em> argument in the <em>open()</em> call; otherwise, the permissions of the new file will be set to some random value from the stack.</p>
<p class="term"><span class="literal">O_DIRECT</span></p>
<p class="termlist">Allow file I/O to bypass the buffer cache. This feature is described in <a href="ch13.xhtml#ch13lev1sec06">Section 13.6</a>. The <span class="literal">_GNU_SOURCE</span> feature test macro must be defined in order to make this constant definition available from <span class="literal">&lt;fcntl.h&gt;</span>.</p>
<p class="term"><span class="literal">O_DIRECTORY</span></p>
<p class="termlist">Return an error (<em>errno</em> equals <span class="literal">ENOTDIR</span>) if <em>pathname</em> is not a directory. This flag is an extension designed specifically for implementing <em>opendir()</em> (<a href="ch18.xhtml#ch18lev1sec08">Section 18.8</a>). The <span class="literal">_GNU_SOURCE</span> feature test macro must be defined in order to make this constant definition available from <span class="literal">&lt;fcntl.h&gt;</span>.</p>
<p class="term"><span class="literal">O_DSYNC</span> (since Linux 2.6.33)</p>
<p class="termlist">Perform file writes according to the requirements of synchronized I/O data integrity completion. See the discussion of kernel I/O buffering in <a href="ch13.xhtml#ch13lev1sec03">Section 13.3</a>.</p>
<p class="term"><span class="literal">O_EXCL</span></p>
<p class="termlist">This flag is used in conjunction with <span class="literal">O_CREAT</span> to indicate that if the file already exists, it should not be opened; instead, <em>open()</em> should fail, with <em>errno</em> set to <span class="literal">EEXIST</span>. In other words, this flag allows the caller to ensure that it is the process creating the file. The check for existence and the creation of the file are performed <em>atomically</em>. We discuss the concept of atomicity in <a href="ch05.xhtml#ch05lev1sec01">Section 5.1</a>. When both <span class="literal">O_CREAT</span> and <span class="literal">O_EXCL</span> are specified in <em>flags</em>, <em>open()</em> fails (with the error <span class="literal">EEXIST</span>) if <em>pathname</em> is a symbolic link. SUSv3 requires this behavior so that a privileged application can create a file in a known location without there being a possibility that a symbolic link would cause the file to be created in a different location (e.g., a system directory), which would have security implications.</p>
<p class="term"><span class="literal">O_LARGEFILE</span></p>
<p class="termlist">Open the file with large file support. This flag is used on 32-bit systems in order to work with large files. Although it is not specified in SUSv3, the <span class="literal">O_LARGEFILE</span> flag is found on several other UNIX implementations. On 64-bit Linux implementations such as Alpha and IA-64, this flag has no effect. See <a href="ch05.xhtml#ch05lev1sec10">Section 5.10</a> for more information.</p>
<p class="term"><span class="literal">O_NOATIME</span> (since Linux 2.6.8)</p>
<p class="termlist">Don&#8217;t update the file last access time (the <em>st_atime</em> field described in <a href="ch15.xhtml#ch15lev1sec01">Section 15.1</a>) when reading from this file. To use this flag, the effective user ID of the calling process must match the owner of the file, or the process must be privileged (<span class="literal">CAP_FOWNER</span>); otherwise, <em>open()</em> fails with the error <span class="literal">EPERM</span>. <span epub:type="pagebreak" id="page_77"/>(In reality, for an unprivileged process, it is the process&#8217;s file-system user ID, rather than its effective user ID, that must match the user ID of the file when opening a file with the <span class="literal">O_NOATIME</span> flag, as described in <a href="ch09.xhtml#ch09lev1sec05">Section 9.5</a>.) This flag is a nonstandard Linux extension. To expose its definition from <span class="literal">&lt;fcntl.h&gt;</span>, we must define the <span class="literal">_GNU_SOURCE</span> feature test macro. The <span class="literal">O_NOATIME</span> flag is intended for use by indexing and backup programs. Its use can significantly reduce the amount of disk activity, because repeated disk seeks back and forth across the disk are not required to read the contents of a file and to update the last access time in the file&#8217;s i-node (<a href="ch14.xhtml#ch14lev1sec04">Section 14.4</a>). Functionality similar to <span class="literal">O_NOATIME</span> is available using the <span class="literal">MS_NOATIME</span> <em>mount()</em> flag (<a href="ch14.xhtml#ch14lev2sec01">Section 14.8.1</a>) and the <span class="literal">FS_NOATIME_FL</span> flag (<a href="ch15.xhtml#ch15lev1sec05">Section 15.5</a>).</p>
<p class="term"><span class="literal">O_NOCTTY</span></p>
<p class="termlist">If the file being opened is a terminal device, prevent it from becoming the controlling terminal. Controlling terminals are discussed in <a href="ch34.xhtml#ch34lev1sec04">Section 34.4</a>. If the file being opened is not a terminal, this flag has no effect.</p>
<p class="term"><span class="literal">O_NOFOLLOW</span></p>
<p class="termlist">Normally, <em>open()</em> dereferences <em>pathname</em> if it is a symbolic link. However, if the <span class="literal">O_NOFOLLOW</span> flag is specified, then <em>open()</em> fails (with <em>errno</em> set to <span class="literal">ELOOP</span>) if <em>pathname</em> is a symbolic link. This flag is useful, especially in privileged programs, for ensuring that <em>open()</em> doesn&#8217;t dereference a symbolic link. To expose the definition of this flag from <span class="literal">&lt;fcntl.h&gt;</span>, we must define the <span class="literal">_GNU_SOURCE</span> feature test macro.</p>
<p class="term"><span class="literal">O_NONBLOCK</span></p>
<p class="termlist">Open the file in nonblocking mode. See <a href="ch05.xhtml#ch05lev1sec09">Section 5.9</a>.</p>
<p class="term"><span class="literal">O_SYNC</span></p>
<p class="termlist">Open the file for synchronous I/O. See the discussion of kernel I/O buffering in <a href="ch13.xhtml#ch13lev1sec03">Section 13.3</a>.</p>
<p class="term"><span class="literal">O_TRUNC</span></p>
<p class="termlist">If the file already exists and is a regular file, then truncate it to zero length, destroying any existing data. On Linux, truncation occurs whether the file is being opened for reading or writing (in both cases, we must have write permission on the file). SUSv3 leaves the combination of <span class="literal">O_RDONLY</span> and <span class="literal">O_TRUNC</span> unspecified, but most other UNIX implementations behave in the same way as Linux.</p>
<h4 class="h4" id="ch04lev2sec02"><strong>4.3.2 Errors from <em>open()</em></strong></h4>
<p class="noindentab">If an error occurs while trying to open the file, <em>open()</em> returns &#8211;1, and <em>errno</em> identifies the cause of the error. The following are some possible errors that can occur (in addition to those already noted when describing the <em>flags</em> argument above):</p>
<p class="term"><span class="literal">EACCES</span></p>
<p class="termlist">The file permissions don&#8217;t allow the calling process to open the file in the mode specified by <em>flags</em>. Alternatively, because of directory permissions, the file could not be accessed, or the file did not exist and could not be created.</p>
<p class="term"><span epub:type="pagebreak" id="page_78"/><span class="literal">EISDIR</span></p>
<p class="termlist">The specified file is a directory, and the caller attempted to open it for writing. This isn&#8217;t allowed. (On the other hand, there are occasions when it can be useful to open a directory for reading. We consider an example in <a href="ch18.xhtml#ch18lev1sec11">Section 18.11</a>.)</p>
<p class="term"><span class="literal">EMFILE</span></p>
<p class="termlist">The process resource limit on the number of open file descriptors has been reached (<span class="literal">RLIMIT_NOFILE</span>, described in <a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a>).</p>
<p class="term"><span class="literal">ENFILE</span></p>
<p class="termlist">The system-wide limit on the number of open files has been reached.</p>
<p class="term"><span class="literal">ENOENT</span></p>
<p class="termlist">The specified file doesn&#8217;t exist, and <span class="literal">O_CREAT</span> was not specified, or <span class="literal">O_CREAT</span> was specified, and one of the directories in <em>pathname</em> doesn&#8217;t exist or is a symbolic link pointing to a nonexistent pathname (a dangling link).</p>
<p class="term"><span class="literal">EROFS</span></p>
<p class="termlist">The specified file is on a read-only file system and the caller tried to open it for writing.</p>
<p class="term"><span class="literal">ETXTBSY</span></p>
<p class="termlist">The specified file is an executable file (a program) that is currently executing. It is not permitted to modify (i.e., open for writing) the executable file associated with a running program. (We must first terminate the program in order to be able to modify the executable file.)</p>
<p class="noindentt">When we later describe other system calls or library functions, we generally won&#8217;t list the range of possible errors that may occur in the above fashion. (Such a list can be found in the corresponding manual page for each system call or library function.) We do so here for two reasons. One of these is that <em>open()</em> is the first system call that we describe in detail, and the above list illustrates that a system call or library function may fail for any of a number of reasons. Second, the specific reasons why <em>open()</em> may fail make an interesting list in themselves, illustrating a number of factors and checks that come into play when a file is accessed. (The above list is incomplete: see the <em>open(2)</em> manual page for more reasons why <em>open()</em> may fail.)</p>
<h4 class="h4" id="ch04lev2sec03"><strong>4.3.3 The <em>creat()</em> System Call</strong></h4>
<p class="noindenta">In early UNIX implementations, <em>open()</em> had only two arguments and could not be used to create a new file. Instead, the <em>creat()</em> system call was used to create and open a new file.</p>
<div class="box">
<p class="programsa">#include &lt;fcntl.h&gt;<br/><br/>int <span class="codestrong">creat</span>(const char *<span class="font1">pathname</span>, mode_t <span class="font1">mode</span>);</p>
<p class="right">Returns file descriptor, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>creat()</em> system call creates and opens a new file with the given <em>pathname</em>, or if the file already exists, opens the file and truncates it to zero length. As its function <span epub:type="pagebreak" id="page_79"/>result, <em>creat()</em> returns a file descriptor that can be used in subsequent system calls. Calling <em>creat()</em> is equivalent to the following <em>open()</em> call:</p>
<p class="programs">fd = open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);</p>
<p class="noindent">Because the <em>open() flags</em> argument provides greater control over how the file is opened (e.g., we can specify <span class="literal">O_RDWR</span> instead of <span class="literal">O_WRONLY</span>), <em>creat()</em> is now obsolete, although it may still be seen in older programs.</p>
<h3 class="h3" id="ch04lev1sec04"><strong>4.4 Reading from a File: <em>read()</em></strong></h3>
<p class="noindenta">The <em>read()</em> system call reads data from the open file referred to by the descriptor <em>fd</em>.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>ssize_t <span class="codestrong">read</span>(int <span class="font1">fd</span>, void *<span class="font1">buffer</span>, size_t <span class="font1">count</span>);</p>
<p class="right">Returns number of bytes read, 0 on EOF, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>count</em> argument specifies the maximum number of bytes to read. (The <em>size_t</em> data type is an unsigned integer type.) The <em>buffer</em> argument supplies the address of the memory buffer into which the input data is to be placed. This buffer must be at least <em>count</em> bytes long.</p>
<div class="block">
<p class="noindent">System calls don&#8217;t allocate memory for buffers that are used to return information to the caller. Instead, we must pass a pointer to a previously allocated memory buffer of the correct size. This contrasts with several library functions that <em>do</em> allocate memory buffers in order to return information to the caller.</p>
</div>
<p class="noindent">A successful call to <em>read()</em> returns the number of bytes actually read, or 0 if end-of-file is encountered. On error, the usual &#8211;1 is returned. The <em>ssize_t</em> data type is a signed integer type used to hold a byte count or a &#8211;1 error indication.</p>
<p class="indent">A call to <em>read()</em> may read less than the requested number of bytes. For a regular file, the probable reason for this is that we were close to the end of the file.</p>
<p class="indent">When <em>read()</em> is applied to other types of files&#8212;such as pipes, FIFOs, sockets, or terminals&#8212;there are also various circumstances where it may read fewer bytes than requested. For example, by default, a <em>read()</em> from a terminal reads characters only up to the next newline (<span class="literal">\n</span>) character. We consider these cases when we cover other file types in subsequent chapters.</p>
<p class="indent">Using <em>read()</em> to input a series of characters from, say, a terminal, we might expect the following code to work:</p>
<p class="programs">#define MAX_READ 20<br/>char buffer[MAX_READ];<br/><br/>if (read(STDIN_FILENO, buffer, MAX_READ) == -1)<br/>&#160;&#160;&#160;&#160;errExit("read");<br/>printf("The input data was: %s\n", buffer);</p>
<p class="noindent">The output from this piece of code is likely to be strange, since it will probably include characters in addition to the string actually entered. This is because <em>read()</em> <span epub:type="pagebreak" id="page_80"/>doesn&#8217;t place a terminating null byte at the end of the string that <em>printf()</em> is being asked to print. A moment&#8217;s reflection leads us to realize that this must be so, since <em>read()</em> can be used to read any sequence of bytes from a file. In some cases, this input might be text, but in other cases, the input might be binary integers or C structures in binary form. There is no way for <em>read()</em> to tell the difference, and so it can&#8217;t attend to the C convention of null terminating character strings. If a terminating null byte is required at the end of the input buffer, we must put it there explicitly:</p>
<p class="programs">char buffer[MAX_READ + 1];<br/>ssize_t numRead;<br/><br/>numRead = read(STDIN_FILENO, buffer, MAX_READ);<br/>if (numRead == -1)<br/>&#160;&#160;&#160;&#160;errExit("read");<br/><br/>buffer[numRead] = '\0';<br/>printf("The input data was: %s\n", buffer);</p>
<p class="noindent">Because the terminating null byte requires a byte of memory, the size of <em>buffer</em> must be at least one greater than the largest string we expect to read.</p>
<h3 class="h3" id="ch04lev1sec05"><strong>4.5 Writing to a File: <em>write()</em></strong></h3>
<p class="noindenta">The <em>write()</em> system call writes data to an open file.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>ssize_t <span class="codestrong">write</span>(int fd, const void *<span class="font1">buffer</span>, size_t <span class="font1">count</span>);</p>
<p class="right">Returns number of bytes written, or &#8211;1 on error</p>
</div>
<p class="noindent">The arguments to <em>write()</em> are similar to those for <em>read()</em>: <em>buffer</em> is the address of the data to be written; <em>count</em> is the number of bytes to write from <em>buffer</em>; and <em>fd</em> is a file descriptor referring to the file to which data is to be written.</p>
<p class="indent">On success, <em>write()</em> returns the number of bytes actually written; this may be less than <em>count</em>. For a disk file, possible reasons for such a <em>partial write</em> are that the disk was filled or that the process resource limit on file sizes was reached. (The relevant limit is <span class="literal">RLIMIT_FSIZE</span>, described in <a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a>.)</p>
<p class="indent">When performing I/O on a disk file, a successful return from <em>write()</em> doesn&#8217;t guarantee that the data has been transferred to disk, because the kernel performs buffering of disk I/O in order to reduce disk activity and expedite <em>write()</em> calls. We consider the details in <a href="ch13.xhtml#ch13">Chapter 13</a>.</p>
<h3 class="h3" id="ch04lev1sec06"><strong>4.6 Closing a File: <em>close()</em></strong></h3>
<p class="noindenta">The <em>close()</em> system call closes an open file descriptor, freeing it for subsequent reuse by the process. When a process terminates, all of its open file descriptors are automatically closed.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_81"/>#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">close</span>(int <span class="font1">fd</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">It is usually good practice to close unneeded file descriptors explicitly, since this makes our code more readable and reliable in the face of subsequent modifications. Furthermore, file descriptors are a consumable resource, so failure to close a file descriptor could result in a process running out of descriptors. This is a particularly important issue when writing long-lived programs that deal with multiple files, such as shells or network servers.</p>
<p class="indent">Just like every other system call, a call to <em>close()</em> should be bracketed with error-checking code, such as the following:</p>
<p class="programs">if (close(fd) == -1)<br/>&#160;&#160;&#160;&#160;errExit("close");</p>
<p class="noindent">This catches errors such as attempting to close an unopened file descriptor or close the same file descriptor twice, and catches error conditions that a specific file system may diagnose during a close operation.</p>
<div class="block">
<p class="noindent">NFS (Network File System) provides an example of an error that is specific to a file system. If an NFS commit failure occurs, meaning that the data did not reach the remote disk, then this error is propagated to the application as a failure in the <em>close()</em> call.</p>
</div>
<h3 class="h3" id="ch04lev1sec07"><strong>4.7 Changing the File Offset: <em>lseek()</em></strong></h3>
<p class="noindenta">For each open file, the kernel records a <em>file offset</em>, sometimes also called the <em>read-write offset</em> or <em>pointer</em>. This is the location in the file at which the next <em>read()</em> or <em>write()</em> will commence. The file offset is expressed as an ordinal byte position relative to the start of the file. The first byte of the file is at offset 0.</p>
<p class="indent">The file offset is set to point to the start of the file when the file is opened and is automatically adjusted by each subsequent call to <em>read()</em> or <em>write()</em> so that it points to the next byte of the file after the byte(s) just read or written. Thus, successive <em>read()</em> and <em>write()</em> calls progress sequentially through a file.</p>
<p class="indent">The <em>lseek()</em> system call adjusts the file offset of the open file referred to by the file descriptor <em>fd</em>, according to the values specified in <em>offset</em> and <em>whence</em>.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>off_t <span class="codestrong">lseek</span>(int <span class="font1">fd</span>, off_t <span class="font1">offset</span>, int <span class="font1">whence</span>);</p>
<p class="right">Returns new file offset if successful, or &#8211;1 on error</p>
</div>
<p class="noindentb"><span epub:type="pagebreak" id="page_82"/>The <em>offset</em> argument specifies a value in bytes. (The <em>off_t</em> data type is a signed integer type specified by SUSv3.) The <em>whence</em> argument indicates the base point from which <em>offset</em> is to be interpreted, and is one of the following values:</p>
<p class="term"><span class="literal">SEEK_SET</span></p>
<p class="termlist">The file offset is set <em>offset</em> bytes from the beginning of the file.</p>
<p class="term"><span class="literal">SEEK_CUR</span></p>
<p class="termlist">The file offset is adjusted by <em>offset</em> bytes relative to the current file offset.</p>
<p class="term"><span class="literal">SEEK_END</span></p>
<p class="termlist">The file offset is set to the size of the file plus <em>offset</em>. In other words, <em>offset</em> is interpreted with respect to the next byte after the last byte of the file.</p>
<p class="noindentt"><a href="ch04.xhtml#ch4fig1">Figure 4-1</a> shows how the <em>whence</em> argument is interpreted.</p>
<div class="block">
<p class="noindent">In earlier UNIX implementations, the integers 0, 1, and 2 were used, rather than the <span class="literal">SEEK_*</span> constants shown in the main text. Older versions of BSD used different names for these values: <span class="literal">L_SET</span>, <span class="literal">L_INCR</span>, and <span class="literal">L_XTND</span>.</p>
</div>
<div class="image"><img src="../images/f04-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch4fig1"/><strong>Figure 4-1:</strong> Interpreting the <em>whence</em> argument of <em>lseek()</em></p>
<p class="noindent">If <em>whence</em> is <span class="literal">SEEK_CUR</span> or <span class="literal">SEEK_END</span>, <em>offset</em> may be negative or positive; for <span class="literal">SEEK_SET</span>, <em>offset</em> must be nonnegative.</p>
<p class="indent">The return value from a successful <em>lseek()</em> is the new file offset. The following call retrieves the current location of the file offset without changing it:</p>
<p class="programs">curr = lseek(fd, 0, SEEK_CUR);</p>
<div class="block">
<p class="noindent">Some UNIX implementations (but not Linux) have the nonstandard <em>tell(fd)</em> function, which serves the same purpose as the above <em>lseek()</em> call.</p>
</div>
<p class="noindent">Here are some other examples of <em>lseek()</em> calls, along with comments indicating where the file offset is moved to:</p>
<p class="programs">lseek(fd, 0, SEEK_SET);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Start of file */<br/>lseek(fd, 0, SEEK_END);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Next byte after the end of the file */<br/>lseek(fd, -1, SEEK_END);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Last byte of file */<br/>lseek(fd, -10, SEEK_CUR);&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Ten bytes prior to current location */<br/>lseek(fd, 10000, SEEK_END);&#160;&#160;&#160;&#160;&#160;/* 10001 bytes past last byte of file */</p>
<p class="noindent">Calling <em>lseek()</em> simply adjusts the kernel&#8217;s record of the file offset associated with a file descriptor. It does not cause any physical device access.</p>
<p class="indent">We describe some further details of the relationship between file offsets, file descriptors, and open files in <a href="ch05.xhtml#ch05lev1sec04">Section 5.4</a>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_83"/>We can&#8217;t apply <em>lseek()</em> to all types of files. Applying <em>lseek()</em> to a pipe, FIFO, socket, or terminal is not permitted; <em>lseek()</em> fails, with <em>errno</em> set to <span class="literal">ESPIPE</span>. On the other hand, it is possible to apply <em>lseek()</em> to devices where it is sensible to do so. For example, it is possible to seek to a specified location on a disk or tape device.</p>
<div class="block">
<p class="noindent">The <em>l</em> in the name <em>lseek()</em> derives from the fact that the <em>offset</em> argument and the return value were both originally typed as <em>long</em>. Early UNIX implementations provided a <em>seek()</em> system call, which typed these values as <em>int</em>.</p>
</div>
<h5 class="h5" id="ch04lev3sec02"><strong>File holes</strong></h5>
<p class="noindenta">What happens if a program seeks past the end of a file, and then performs I/O? A call to <em>read()</em> will return 0, indicating end-of-file. Somewhat surprisingly, it is possible to write bytes at an arbitrary point past the end of the file.</p>
<p class="indent">The space in between the previous end of the file and the newly written bytes is referred to as a <em>file hole</em>. From a programming point of view, the bytes in a hole exist, and reading from the hole returns a buffer of bytes containing 0 (null bytes).</p>
<p class="indent">File holes don&#8217;t, however, take up any disk space. The file system doesn&#8217;t allocate any disk blocks for a hole until, at some later point, data is written into it. The main advantage of file holes is that a sparsely populated file consumes less disk space than would otherwise be required if the null bytes actually needed to be allocated in disk blocks. Core dump files (<a href="ch22.xhtml#ch22lev1sec01">Section 22.1</a>) are common examples of files that contain large holes.</p>
<div class="block">
<p class="noindent">The statement that file holes don&#8217;t consume disk space needs to be qualified slightly. On most file systems, file space is allocated in units of blocks (<a href="ch14.xhtml#ch14lev1sec03">Section 14.3</a>). The size of a block depends on the file system, but is typically something like 1024, 2048, or 4096 bytes. If the edge of a hole falls within a block, rather than on a block boundary, then a complete block is allocated to store the data in the other part of the block, and the part corresponding to the hole is filled with null bytes.</p>
</div>
<p class="noindent">Most native UNIX file systems support the concept of file holes, but many nonnative file systems (e.g., Microsoft&#8217;s VFAT) do not. On a file system that doesn&#8217;t support holes, explicit null bytes are written to the file.</p>
<p class="indent">The existence of holes means that a file&#8217;s nominal size may be larger than the amount of disk storage it utilizes (in some cases, considerably larger). Writing bytes into the middle of the file hole will decrease the amount of free disk space as the kernel allocates blocks to fill the hole, even though the file&#8217;s size doesn&#8217;t change. Such a scenario is uncommon, but nevertheless one to be aware of.</p>
<div class="block">
<p class="noindent">SUSv3 specifies a function, <em>posix_fallocate(fd, offset, len)</em>, that ensures that space is allocated on disk for the byte range specified by <em>offset</em> and <em>len</em> for the disk file referred to by the descriptor <em>fd</em>. This allows an application to be sure that a later <em>write()</em> to the file won&#8217;t fail because disk space is exhausted (which could otherwise occur if a hole in the file was filled in, or some other application consumed space on the disk before the full extent of the file was written). Historically, the <em>glibc</em> implementation of this function achieved the desired result by writing a 0 byte into each block in the specified range. Since version 2.6.23, Linux provides an <em>fallocate()</em> system call, which provides a more efficient way of ensuring that the necessary space is allocated, and the <em>glibc posix_fallocate()</em> implementation makes use of this system call when it is available.</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_84"/><a href="ch14.xhtml#ch14lev1sec04">Section 14.4</a> describes how holes are represented in a file, and <a href="ch15.xhtml#ch15lev1sec01">Section 15.1</a> describes the <em>stat()</em> system call, which can tell us the current size of a file, as well as the number of blocks actually allocated to the file.</p>
<h5 class="h5" id="ch04lev3sec03"><strong>Example program</strong></h5>
<p class="noindentab"><a href="ch04.xhtml#ch4ex3">Listing 4-3</a> demonstrates the use of <em>lseek()</em> in conjunction with <em>read()</em> and <em>write()</em>. The first command-line argument to this program is the name of a file to be opened. The remaining arguments specify I/O operations to be performed on the file. Each of these operations consists of a letter followed by an associated value (with no separating space):</p>
<p class="bull">&#8226; <span class="literal">s</span><em>offset</em>: Seek to byte <em>offset</em> from the start of the file.</p>
<p class="bull">&#8226; <span class="literal">r</span><em>length</em>: Read <em>length</em> bytes from the file, starting at the current file offset, and display them in text form.</p>
<p class="bull">&#8226; <span class="literal">R</span><em>length</em>: Read <em>length</em> bytes from the file, starting at the current file offset, and display them in hexadecimal.</p>
<p class="bull">&#8226; <span class="literal">w</span><em>str</em>: Write the string of characters specified in <em>str</em> at the current file offset.</p>
<p class="examplet"><a id="ch4ex3"/><strong>Listing 4-3:</strong> Demonstration of <em>read()</em>, <em>write()</em>, and <em>lseek()</em></p>
<p class="programsli">_________________________________________________________ <span class="codestrong">fileio/seek_io.c</span><br/><br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include &lt;ctype.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;size_t len;<br/>&#160;&#160;&#160;&#160;off_t offset;<br/>&#160;&#160;&#160;&#160;int fd, ap, j;<br/>&#160;&#160;&#160;&#160;char *buf;<br/>&#160;&#160;&#160;&#160;ssize_t numRead, numWritten;<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 3 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s file {r&lt;length&gt;|R&lt;length&gt;|w&lt;string&gt;|s&lt;offset&gt;}...\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;argv[0]);<br/><br/>&#160;&#160;&#160;&#160;fd = open(argv[1], O_RDWR | O_CREAT,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP |<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S_IROTH | S_IWOTH);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* rw-rw-rw- */<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open");<br/><br/>&#160;&#160;&#160;&#160;for (ap = 2; ap &lt; argc; ap++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (argv[ap][0]) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'r':&#160;&#160;&#160;/* Display bytes at current offset, as text */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'R':&#160;&#160;&#160;/* Display bytes at current offset, in hex */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;len = getLong(&#38;argv[ap][1], GN_ANY_BASE, argv[ap]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;buf = malloc(len);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (buf == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("malloc");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numRead = read(fd, buf, len);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("read");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead == 0) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s: end-of-file\n", argv[ap]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s: ", argv[ap]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (j = 0; j &lt; numRead; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argv[ap][0] == 'r')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%c", isprint((unsigned char) buf[j]) ?<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;buf[j] : '?');<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%02x ", (unsigned int) buf[j]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;free(buf);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'w':&#160;&#160;&#160;/* Write string at current offset */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numWritten = write(fd, &#38;argv[ap][1], strlen(&#38;argv[ap][1]));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numWritten == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("write");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s: wrote %ld bytes\n", argv[ap], (long) numWritten);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 's':&#160;&#160;&#160;/* Change file offset */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;offset = getLong(&#38;argv[ap][1], GN_ANY_BASE, argv[ap]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (lseek(fd, offset, SEEK_SET) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("lseek");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s: seek succeeded\n", argv[ap]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cmdLineErr("Argument must start with [rRws]: %s\n", argv[ap]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________________ <span class="codestrong">fileio/seek_io.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_85"/>The following shell session log demonstrates the use of the program in <a href="ch04.xhtml#ch4ex3">Listing 4-3</a>, showing what happens when we attempt to read bytes from a file hole:</p>
<p class="programs">$ <span class="codestrong">touch tfile</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create new, empty file</span><br/>$ <span class="codestrong">./seek_io tfile s100000 <span class="codeitalic">wabc</span></span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Seek to offset 100,000, write "abc"</span><br/>s100000: seek succeeded<br/>wabc: wrote 3 bytes<br/>$ <span class="codestrong">ls -l tfile</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Check size of file</span><br/>-rw-r--r--&#160;&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;users&#160;&#160;&#160;100003 Feb 10 10:35 tfile<br/>$ <span class="codestrong">./seek_io tfile s10000 R5</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Seek to offset 10,000, read 5 bytes from hole</span><br/>s10000: seek succeeded<br/>R5: 00 00 00 00 00&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Bytes in the hole contain 0</span></p>
<h3 class="h3" id="ch04lev1sec08"><span epub:type="pagebreak" id="page_86"/><strong>4.8 Operations Outside the Universal I/O Model: <em>ioctl()</em></strong></h3>
<p class="noindenta">The <em>ioctl()</em> system call is a general-purpose mechanism for performing file and device operations that fall outside the universal I/O model described earlier in this chapter.</p>
<div class="box">
<p class="programsa">#include &lt;sys/ioctl.h&gt;<br/><br/>int <span class="codestrong">ioctl</span>(int <span class="font1">fd</span>, int <span class="font1">request</span>, ... /* <span class="font1">argp</span> */);</p>
<p class="right">Value returned on success depends on <em>request</em>, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>fd</em> argument is an open file descriptor for the device or file upon which the control operation specified by <em>request</em> is to be performed. Device-specific header files define constants that can be passed in the <em>request</em> argument.</p>
<p class="indent">As indicated by the standard C ellipsis (<span class="literal">...</span>) notation, the third argument to <em>ioctl()</em>, which we label <em>argp</em>, can be of any type. The value of the <em>request</em> argument enables <em>ioctl()</em> to determine what type of value to expect in <em>argp</em>. Typically, <em>argp</em> is a pointer to either an integer or a structure; in some cases, it is unused.</p>
<p class="indent">We&#8217;ll see a number of uses for <em>ioctl()</em> in later chapters (see, for example, <a href="ch15.xhtml#ch15lev1sec05">Section 15.5</a>).</p>
<div class="block">
<p class="noindent">The only specification that SUSv3 makes for <em>ioctl()</em> is for operations to control STREAMS devices. (The STREAMS facility is a System V feature that is not supported by the mainline Linux kernel, although a few add-on implementations have been developed.) None of the other <em>ioctl()</em> operations described in this book is specified in SUSv3. However, the <em>ioctl()</em> call has been part of the UNIX system since early versions, and consequently several of the <em>ioctl()</em> operations that we describe are provided on many other UNIX implementations. As we describe each <em>ioctl()</em> operation, we note portability issues.</p>
</div>
<h3 class="h3" id="ch04lev1sec09"><strong>4.9 Summary</strong></h3>
<p class="noindenta">In order to perform I/O on a regular file, we must first obtain a file descriptor using <em>open()</em>. I/O is then performed using <em>read()</em> and <em>write()</em>. After performing all I/O, we should free the file descriptor and its associated resources using <em>close()</em>. These system calls can be used to perform I/O on all types of files.</p>
<p class="indent">The fact that all file types and device drivers implement the same I/O interface allows for universality of I/O, meaning that a program can typically be used with any type of file without requiring code that is specific to the file type.</p>
<p class="indent"><span epub:type="pagebreak" id="page_87"/>For each open file, the kernel maintains a file offset, which determines the location at which the next read or write will occur. The file offset is implicitly updated by reads and writes. Using <em>lseek()</em>, we can explicitly reposition the file offset to any location within the file or past the end of the file. Writing data at a position beyond the previous end of the file creates a hole in the file. Reads from a file hole return bytes containing zeros.</p>
<p class="indent">The <em>ioctl()</em> system call is a catchall for device and file operations that don&#8217;t fit into the standard file I/O model.</p>
<h3 class="h3" id="ch04lev1sec10"><strong>4.10 Exercises</strong></h3>
<p class="exer"><a id="ch4exe1"/><strong>4-1.</strong>&#160;&#160;&#160;&#160;&#160;The <em>tee</em> command reads its standard input until end-of-file, writing a copy of the input to standard output and to the file named in its command-line argument. (We show an example of the use of this command when we discuss FIFOs in <a href="ch44.xhtml#ch44lev1sec07">Section 44.7</a>.) Implement <em>tee</em> using I/O system calls. By default, <em>tee</em> overwrites any existing file with the given name. Implement the <em>&#8211;a</em> command-line option (<em>tee &#8211;a file</em>), which causes <em>tee</em> to append text to the end of a file if it already exists. (Refer to <a href="app02.xhtml#app02">Appendix B</a> for a description of the <em>getopt()</em> function, which can be used to parse command-line options.)</p>
<p class="exer"><a id="ch4exe2"/><strong>4-2.</strong>&#160;&#160;&#160;&#160;&#160;Write a program like <em>cp</em> that, when used to copy a regular file that contains holes (sequences of null bytes), also creates corresponding holes in the target file.<span epub:type="pagebreak" id="page_88"/></p>
</body>
</html>
