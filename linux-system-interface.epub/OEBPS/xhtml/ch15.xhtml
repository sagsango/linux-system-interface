<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch15"><span epub:type="pagebreak" id="page_279"/><strong><span class="big">15</span></strong><br/><strong>FILE ATTRIBUTES</strong></h2>
<p class="noindenta">In this chapter, we investigate various attributes of files (file metadata). We begin with a description of the <em>stat()</em> system call, which returns a structure containing many of these attributes, including file timestamps, file ownership, and file permissions. We then go on to look at various system calls used to change these attributes. (The discussion of file permissions continues in <a href="ch17.xhtml#ch17">Chapter 17</a>, where we look at access control lists.) We conclude the chapter with a discussion of i-node flags (also known as <em>ext2</em> extended file attributes), which control various aspects of the treatment of files by the kernel.</p>
<h3 class="h3" id="ch15lev1sec01"><strong>15.1 Retrieving File Information: <em>stat()</em></strong></h3>
<p class="noindenta">The <em>stat()</em>, <em>lstat()</em>, and <em>fstat()</em> system calls retrieve information about a file, mostly drawn from the file i-node.</p>
<div class="box">
<p class="programsa">#include &lt;sys/stat.h&gt;<br/><br/>int <span class="codestrong">stat</span>(const char *<span class="font1">pathname</span>, struct stat *<span class="font1">statbuf</span>);<br/>int <span class="codestrong">lstat</span>(const char *<span class="font1">pathname</span>, struct stat *<span class="font1">statbuf</span>);<br/>int <span class="codestrong">fstat</span>(int <span class="font1">fd</span>, struct stat *<span class="font1">statbuf</span>);</p>
<p class="right">All return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb"><span epub:type="pagebreak" id="page_280"/>These three system calls differ only in the way that the file is specified:</p>
<p class="bull">&#8226; <em>stat()</em> returns information about a named file;</p>
<p class="bull">&#8226; <em>lstat()</em> is similar to <em>stat()</em>, except that if the named file is a symbolic link, information about the link itself is returned, rather than the file to which the link points; and</p>
<p class="bull">&#8226; <em>fstat()</em> returns information about a file referred to by an open file descriptor.</p>
<p class="noindentt">The <em>stat()</em> and <em>lstat()</em> system calls don&#8217;t require permissions on the file itself. However, execute (search) permission is required on all of the parent directories specified in <em>pathname</em>. The <em>fstat()</em> system call always succeeds, if provided with a valid file descriptor.</p>
<p class="indent">All of these system calls return a <em>stat</em> structure in the buffer pointed to by <em>statbuf</em>. This structure has the following form:</p>
<p class="programs">struct stat {<br/>&#160;&#160;&#160;&#160;dev_t&#160;&#160;&#160;&#160;&#160;st_dev;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* IDs of device on which file resides */<br/>&#160;&#160;&#160;&#160;ino_t&#160;&#160;&#160;&#160;&#160;st_ino;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* I-node number of file */<br/>&#160;&#160;&#160;&#160;mode_t&#160;&#160;&#160;&#160;st_mode;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* File type and permissions */<br/>&#160;&#160;&#160;&#160;nlink_t&#160;&#160;&#160;st_nlink;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of (hard) links to file */<br/>&#160;&#160;&#160;&#160;uid_t&#160;&#160;&#160;&#160;&#160;st_uid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* User ID of file owner */<br/>&#160;&#160;&#160;&#160;gid_t&#160;&#160;&#160;&#160;&#160;st_gid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Group ID of file owner */<br/>&#160;&#160;&#160;&#160;dev_t&#160;&#160;&#160;&#160;&#160;st_rdev;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* IDs for device special files */<br/>&#160;&#160;&#160;&#160;off_t&#160;&#160;&#160;&#160;&#160;st_size;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Total file size (bytes) */<br/>&#160;&#160;&#160;&#160;blksize_t st_blksize;&#160;&#160;&#160;&#160;&#160;/* Optimal block size for I/O (bytes) */<br/>&#160;&#160;&#160;&#160;blkcnt_t&#160;&#160;st_blocks;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of (512B) blocks allocated */<br/>&#160;&#160;&#160;&#160;time_t&#160;&#160;&#160;&#160;st_atime;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Time of last file access */<br/>&#160;&#160;&#160;&#160;time_t&#160;&#160;&#160;&#160;st_mtime;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Time of last file modification */<br/>&#160;&#160;&#160;&#160;time_t&#160;&#160;&#160;&#160;st_ctime;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Time of last status change */<br/>};</p>
<p class="noindent">The various data types used to type the fields in the <em>stat</em> structure are all specified in SUSv3. See <a href="ch03.xhtml#ch03lev2sec04">Section 3.6.2</a> for further information about these types.</p>
<div class="block">
<p class="noindent">According to SUSv3, when <em>lstat()</em> is applied to a symbolic link, it needs to return valid information only in the <em>st_size</em> field and in the file type component (described shortly) of the <em>st_mode</em> field. None of the other fields (e.g., the time fields) need contain valid information. This gives an implementation the freedom to not maintain these fields, which may be done for efficiency reasons. In particular, the intent of earlier UNIX standards was to allow a symbolic link to be implemented either as an i-node or as an entry in a directory. Under the latter implementation, it is not possible to implement all of the fields required by the <em>stat</em> structure. (On all major contemporary UNIX implementations, symbolic links are implemented as i-nodes. See <a href="ch18.xhtml#ch18lev1sec02">Section 18.2</a> for further details.) On Linux, <em>lstat()</em> returns information in all of the <em>stat</em> fields when applied to a symbolic link. SUSv4 tightens the requirements on an implementation, requiring <em>lstat()</em> to return valid information in all fields of the <em>stat</em> structure except the permission bits of <em>st_mode</em>.</p>
</div>
<p class="noindent">In the following pages, we look at some of the <em>stat</em> structure fields in more detail, and finish with an example program that displays the entire <em>stat</em> structure.</p>
<h5 class="h5" id="ch15lev3sec01"><span epub:type="pagebreak" id="page_281"/><strong>Device IDs and i-node number</strong></h5>
<p class="noindenta">The <em>st_dev</em> field identifies the device on which the file resides. The <em>st_ino</em> field contains the i-node number of the file. The combination of <em>st_dev</em> and <em>st_ino</em> uniquely identifies a file across all file systems. The <em>dev_t</em> type records the major and minor IDs of a device (<a href="ch14.xhtml#ch14lev1sec01">Section 14.1</a>).</p>
<p class="indent">If this is the i-node for a device, then the <em>st_rdev</em> field contains the major and minor IDs of the device.</p>
<p class="indent">The major and minor IDs of a <em>dev_t</em> value can be extracted using two macros: <span class="literal">major()</span> and <span class="literal">minor()</span>. The header file required to obtain the declarations of these two macros varies across UNIX implementations. On Linux, they are exposed by <span class="literal">&lt;sys/sysmacros.h&gt;</span>.</p>
<p class="indent">The size of the integer values returned by <span class="literal">major()</span> and <span class="literal">minor()</span> varies across UNIX implementations. For portability, we always cast the returned values to <em>long</em> when printing them (see <a href="ch03.xhtml#ch03lev2sec04">Section 3.6.2</a>).</p>
<h5 class="h5" id="ch15lev3sec02"><strong>File ownership</strong></h5>
<p class="noindenta">The <em>st_uid</em> and <em>st_gid</em> fields identify, respectively, the owner (user ID) and group (group ID) to which the file belongs.</p>
<h5 class="h5" id="ch15lev3sec03"><strong>Link count</strong></h5>
<p class="noindenta">The <em>st_nlink</em> field is the number of (hard) links to the file. We describe links in detail in <a href="ch18.xhtml#ch18">Chapter 18</a>.</p>
<h5 class="h5" id="ch15lev3sec04"><strong>File type and permissions</strong></h5>
<p class="noindenta">The <em>st_mode</em> field is a bit mask serving the dual purpose of identifying the file type and specifying the file permissions. The bits of this field are laid out as shown in <a href="ch15.xhtml#ch15fig1">Figure 15-1</a>.</p>
<div class="image"><img src="../images/f15-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch15fig1"/><strong>Figure 15-1:</strong> Layout of <em>st_mode</em> bit mask</p>
<p class="noindent">The file type can be extracted from this field by ANDing (<span class="literal">&#38;</span>) with the constant <span class="literal">S_IFMT</span>. (On Linux, 4 bits are used for the file-type component of the <em>st_mode</em> field. However, because SUSv3 makes no specification about how the file type is represented, this detail may vary across implementations.) The resulting value can then be compared with a range of constants to determine the file type, like so:</p>
<p class="programs">if ((statbuf.st_mode &#38; S_IFMT) == S_IFREG)<br/>&#160;&#160;&#160;&#160;printf("regular file\n");</p>
<p class="noindent">Because this is a common operation, standard macros are provided to simplify the above to the following:</p>
<p class="programs">if (S_ISREG(statbuf.st_mode))<br/>&#160;&#160;&#160;&#160;printf("regular file\n");</p>
<p class="noindent"><span epub:type="pagebreak" id="page_282"/>The full set of file-type macros (defined in <span class="literal">&lt;sys/stat.h&gt;</span>) is shown in <a href="ch15.xhtml#ch15table1">Table 15-1</a>. All of the file-type macros in <a href="ch15.xhtml#ch15table1">Table 15-1</a> are specified in SUSv3 and appear on Linux. Some other UNIX implementations define additional file types (e.g., <span class="literal">S_IFDOOR</span>, for door files on Solaris). The type <span class="literal">S_IFLNK</span> is returned only by calls to <em>lstat()</em>, since calls to <em>stat()</em> always follow symbolic links.</p>
<p class="indent">The original POSIX.1 standard did not specify the constants shown in the first column of <a href="ch15.xhtml#ch15table1">Table 15-1</a>, although most of them appeared on most UNIX implementations. SUSv3 requires these constants.</p>
<div class="block">
<p class="noindent">In order to obtain the definitions of <span class="literal">S_IFSOCK</span> and <span class="literal">S_ISSOCK()</span> from <span class="literal">&lt;sys/stat.h&gt;</span>, we must either define the <span class="literal">_BSD_SOURCE</span> feature test macro or define <span class="literal">_XOPEN_SOURCE</span> with a value greater than or equal to 500. (The rules have varied somewhat across <em>glibc</em> versions: in some cases, <span class="literal">_XOPEN_SOURCE</span> must be defined with a value of 600 or greater.)</p>
</div>
<p class="tablecap"><a id="ch15table1"/><strong>Table 15-1:</strong> Macros for checking file types in the <em>st_mode</em> field of the <em>stat</em> structure</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Constant</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Test macro</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>File type</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_IFREG</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_ISREG()</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Regular file</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_IFDIR</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_ISDIR()</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Directory</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_IFCHR</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_ISCHR()</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Character device</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_IFBLK</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_ISBLK()</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Block device</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_IFIFO</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_ISFIFO()</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">FIFO or pipe</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_IFSOCK</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_ISSOCK()</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Socket</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">S_IFLNK</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">S_ISLNK()</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Symbolic link</p></td>
</tr>
</tbody>
</table>
<p class="noindent">The bottom 12 bits of the <em>st_mode</em> field define the permissions for the file. We describe the file permission bits in <a href="ch15.xhtml#ch15lev1sec04">Section 15.4</a>. For now, we simply note that the 9 least significant of the permission bits are the read, write, and execute permissions for each of the categories owner, group, and other.</p>
<h5 class="h5" id="ch15lev3sec05"><strong>File size, blocks allocated, and optimal I/O block size</strong></h5>
<p class="noindenta">For regular files, the <em>st_size</em> field is the total size of the file in bytes. For a symbolic link, this field contains the length (in bytes) of the pathname pointed to by the link. For a shared memory object (<a href="ch54.xhtml#ch54">Chapter 54</a>), this field contains the size of the object.</p>
<p class="indent">The <em>st_blocks</em> field indicates the total number of blocks allocated to the file, in 512-byte block units. This total includes space allocated for pointer blocks (see <a href="ch14.xhtml#ch14fig2">Figure 14-2</a>, on <a href="ch14.xhtml#page_258">page 258</a>). The choice of the 512-byte unit of measurement is historical&#8212;this is the smallest block size on any of the file systems that have been implemented under UNIX. More modern file systems use larger logical block sizes. For example, under <em>ext2</em>, the value in <em>st_blocks</em> is always a multiple of 2, 4, or 8, depending on whether the <em>ext2</em> logical block size is 1024, 2048, or 4096 bytes.</p>
<div class="block">
<p class="noindent">SUSv3 doesn&#8217;t define the units in which <em>st_blocks</em> is measured, allowing the possibility that an implementation uses a unit other than 512 bytes. Most UNIX implementations do use 512-byte units, but HP-UX 11 uses file system&#8211;specific units (e.g., 1024 bytes in some cases).</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_283"/>The <em>st_blocks</em> field records the number of disk blocks actually allocated. If the file contains holes (<a href="ch04.xhtml#ch04lev1sec07">Section 4.7</a>), this will be smaller than might be expected from the corresponding number of bytes (<em>st_size</em>) in the file. (The disk usage command, <em>du &#8211;k file</em>, displays the actual space allocated for a file, in kilobytes; that is, a figure calculated from the <em>st_blocks</em> value for the file, rather than the <em>st_size</em> value.)</p>
<p class="indent">The <em>st_blksize</em> field is somewhat misleadingly named. It is not the block size of the underlying file system, but rather the optimal block size (in bytes) for I/O on files on this file system. I/O in blocks smaller than this size is less efficient (refer to <a href="ch13.xhtml#ch13lev1sec01">Section 13.1</a>). A typical value returned in <em>st_blksize</em> is 4096.</p>
<h5 class="h5" id="ch15lev3sec06"><strong>File timestamps</strong></h5>
<p class="noindenta">The <em>st_atime</em>, <em>st_mtime</em>, and <em>st_ctime</em> fields contain, respectively, the times of last file access, last file modification, and last status change. These fields are of type <em>time_t</em>, the standard UNIX time format of seconds since the Epoch. We say more about these fields in <a href="ch15.xhtml#ch15lev1sec02">Section 15.2</a>.</p>
<h5 class="h5" id="ch15lev3sec07"><strong>Example program</strong></h5>
<p class="noindenta">The program in <a href="ch15.xhtml#ch15ex1">Listing 15-1</a> uses <em>stat()</em> to retrieve information about the file named on its command line. If the <em>&#8211;l</em> command-line option is specified, then the program instead uses <em>lstat()</em> so that we can retrieve information about a symbolic link instead of the file to which it refers. The program prints all fields of the returned <em>stat</em> structure. (For an explanation of why we cast the <em>st_size</em> and <em>st_blocks</em> fields to <em>long long</em>, see <a href="ch05.xhtml#ch05lev1sec10">Section 5.10</a>.) The <em>filePermStr()</em> function used by this program is shown in <a href="ch15.xhtml#ch15ex4">Listing 15-4</a>, on <a href="ch15.xhtml#page_296">page 296</a>.</p>
<p class="indent">Here is an example of the use of the program:</p>
<p class="programs">$ <span class="codestrong">echo 'All operating systems provide services for programs they run' &gt; apue</span><br/>$ <span class="codestrong">chmod g+s apue</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Turn on set-group-ID bit; affects last status change time</span><br/>$ <span class="codestrong">cat apue</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Affects last file access time</span><br/>All operating systems provide services for programs they run<br/>$ <span class="codestrong">./t_stat apue</span><br/>File type:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;regular file<br/>Device containing i-node: major=3&#160;&#160;&#160;minor=11<br/>I-node number:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;234363<br/>Mode:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;102644 (rw-r--r--)<br/>&#160;&#160;&#160;&#160;special bits set:&#160;&#160;&#160;&#160;&#160;set-GID<br/>Number of (hard) links:&#160;&#160;&#160;1<br/>Ownership:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;UID=1000&#160;&#160;&#160;GID=100<br/>File size:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;61 bytes<br/>Optimal I/O block size:&#160;&#160;&#160;4096 bytes<br/>512B blocks allocated:&#160;&#160;&#160;&#160;8<br/>Last file access:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Mon Jun&#160;&#160;8 09:40:07 2011<br/>Last file modification:&#160;&#160;&#160;Mon Jun&#160;&#160;8 09:39:25 2011<br/>Last status change:&#160;&#160;&#160;&#160;&#160;&#160;&#160;Mon Jun&#160;&#160;8 09:39:51 2011</p>
<p class="examplet"><span epub:type="pagebreak" id="page_284"/><a id="ch15ex1"/><strong>Listing 15-1:</strong> Retrieving and interpreting file <em>stat</em> information</p>
<p class="programsli">___________________________________________________________ <span class="codestrong">files/t_stat.c</span><br/><br/>#include &lt;sys/sysmacros.h&gt;<br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;time.h&gt;<br/>#include "file_perms.h"<br/>#include "tlpi_hdr.h"<br/><br/>static void<br/>displayStatInfo(const struct stat *sb)<br/>{<br/>&#160;&#160;&#160;&#160;printf("File type:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;");<br/><br/>&#160;&#160;&#160;&#160;switch (sb-&gt;st_mode &#38; S_IFMT) {<br/>&#160;&#160;&#160;&#160;case S_IFREG:&#160;&#160;printf("regular file\n");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;case S_IFDIR:&#160;&#160;printf("directory\n");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;case S_IFCHR:&#160;&#160;printf("character device\n");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;case S_IFBLK:&#160;&#160;printf("block device\n");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;case S_IFLNK:&#160;&#160;printf("symbolic (soft) link\n");&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;case S_IFIFO:&#160;&#160;printf("FIFO or pipe\n");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;case S_IFSOCK: printf("socket\n");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("unknown file type?\n");&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;printf("Device containing i-node: major=%ld&#160;&#160;&#160;minor=%ld\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) major(sb-&gt;st_dev), (long) minor(sb-&gt;st_dev));<br/><br/>&#160;&#160;&#160;&#160;printf("I-node number:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;%ld\n", (long) sb-&gt;st_ino);<br/><br/>&#160;&#160;&#160;&#160;printf("Mode:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;%lo (%s)\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(unsigned long) sb-&gt;st_mode, filePermStr(sb-&gt;st_mode, 0));<br/><br/>&#160;&#160;&#160;&#160;if (sb-&gt;st_mode &#38; (S_ISUID | S_ISGID | S_ISVTX))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;special bits set:&#160;&#160;&#160;&#160;&#160;%s%s%s\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(sb-&gt;st_mode &#38; S_ISUID) ? "set-UID " : "",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(sb-&gt;st_mode &#38; S_ISGID) ? "set-GID " : "",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(sb-&gt;st_mode &#38; S_ISVTX) ? "sticky " : "");<br/><br/>&#160;&#160;&#160;&#160;printf("Number of (hard) links:&#160;&#160;&#160;%ld\n", (long) sb-&gt;st_nlink);<br/><br/>&#160;&#160;&#160;&#160;printf("Ownership:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;UID=%ld&#160;&#160;&#160;GID=%ld\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) sb-&gt;st_uid, (long) sb-&gt;st_gid);<br/><br/>&#160;&#160;&#160;&#160;if (S_ISCHR(sb-&gt;st_mode) || S_ISBLK(sb-&gt;st_mode))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Device number (st_rdev): major=%ld; minor=%ld\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) major(sb-&gt;st_rdev), (long) minor(sb-&gt;st_rdev));<br/><br/>&#160;&#160;&#160;&#160;printf("File size:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;%lld bytes\n", (long long) sb-&gt;st_size);<br/>&#160;&#160;&#160;&#160;printf("Optimal I/O block size:&#160;&#160;&#160;%ld bytes\n", (long) sb-&gt;st_blksize);<br/>&#160;&#160;&#160;&#160;printf("512B blocks allocated:&#160;&#160;&#160;&#160;%lld\n", (long long) sb-&gt;st_blocks);<br/><br/>&#160;&#160;&#160;&#160;printf("Last file access:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;%s", ctime(&#38;sb-&gt;st_atime));<br/>&#160;&#160;&#160;&#160;printf("Last file modification:&#160;&#160;&#160;%s", ctime(&#38;sb-&gt;st_mtime));<br/>&#160;&#160;&#160;&#160;printf("Last status change:&#160;&#160;&#160;&#160;&#160;&#160;&#160;%s", ctime(&#38;sb-&gt;st_ctime));<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct stat sb;<br/>&#160;&#160;&#160;&#160;Boolean statLink;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* True if "-l" specified (i.e., use lstat) */<br/>&#160;&#160;&#160;&#160;int fname;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Location of filename argument in argv[] */<br/><br/>&#160;&#160;&#160;&#160;statLink = (argc &gt; 1) &#38;&#38; strcmp(argv[1], "-l") == 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Simple parsing for "-l" */<br/>&#160;&#160;&#160;&#160;fname = statLink ? 2 : 1;<br/><br/>&#160;&#160;&#160;&#160;if (fname &gt;= argc || (argc &gt; 1 &#38;&#38; strcmp(argv[1], "--help") == 0))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s [-l] file\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-l = use lstat() instead of stat()\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;if (statLink) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (lstat(argv[fname], &#38;sb) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("lstat");<br/>&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (stat(argv[fname], &#38;sb) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("stat");<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;displayStatInfo(&#38;sb);<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>___________________________________________________________ <span class="codestrong">files/t_stat.c</span></p>
<h3 class="h3" id="ch15lev1sec02"><span epub:type="pagebreak" id="page_285"/><strong>15.2 File Timestamps</strong></h3>
<p class="noindenta">The <em>st_atime</em>, <em>st_mtime</em>, and <em>st_ctime</em> fields of the <em>stat</em> structure contain file timestamps. These fields record, respectively, the times of last file access, last file modification, and last file status change (i.e., last change to the file&#8217;s i-node information). Timestamps are recorded in seconds since the Epoch (1 January 1970; see <a href="ch10.xhtml#ch10lev1sec01">Section 10.1</a>).</p>
<p class="indent">Most native Linux and UNIX file systems support all of the timestamp fields, but some non-UNIX file systems may not.</p>
<p class="indent"><a href="ch15.xhtml#ch15table2">Table 15-2</a> summarizes which of the timestamp fields (and in some cases, the analogous fields in the parent directory) are changed by various system calls and library functions described in this book. In the headings of this table, <em>a</em>, <em>m</em>, and <em>c</em> represent the <em>st_atime</em>, <em>st_mtime</em>, and <em>st_ctime</em> fields, respectively. In most cases, the relevant timestamp is set to the current time by the system call. The exceptions are <em>utime()</em> and similar calls (discussed in <a href="ch15.xhtml#ch15lev2sec01">Sections 15.2.1</a> and <a href="ch15.xhtml#ch15lev2sec02">15.2.2</a>), which can be used to explicitly set the last file access and modification times to arbitrary values.</p>
<p class="tablecap"><span epub:type="pagebreak" id="page_286"/><a id="ch15table2"/><strong>Table 15-2:</strong> Effect of various functions on file timestamps</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th" rowspan="2"><p class="tablec"><strong>Function</strong></p></td>
<td style="vertical-align: top;" class="table_th" colspan="3"><p class="tablec"><strong>File or directory</strong></p></td>
<td style="vertical-align: top;" class="table_th" colspan="3"><p class="tablec"><strong>Parent directory</strong></p></td>
<td style="vertical-align: middle;" class="table_th1" rowspan="2"><p class="tablec"><strong>Notes</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_th1"><p class="tablec"><strong>a</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="tablec"><strong>m</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong>c</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="tablec"><strong>a</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="tablec"><strong>m</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong>c</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>chmod()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Same for <em>fchmod()</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>chown()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Same for <em>lchown()</em> and <em>fchown()</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>exec()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>link()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Affects parent directory of second argument</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>mkdir()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>mkfifo()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>mknod()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>mmap()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>st_mtime</em> and <em>st_ctime</em> are changed only on updates to <span class="literal">MAP_SHARED</span> mapping</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>msync()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Changed only if file is modified</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>open()</em>, <em>creat()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">When creating new file</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>open()</em>, <em>creat()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">When truncating existing file</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>pipe()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>read()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Same for <em>readv()</em>, <em>pread()</em>, and <em>preadv()</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>readdir()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>readdir()</em> may buffer directory entries; timestamps updated only if directory is read</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>removexattr()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Same for <em>fremovexattr()</em> and <em>lremovexattr()</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>rename()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Affects timestamps in both parent directories; SUSv3 doesn&#8217;t specify file <em>st_ctime</em> change, but notes that some implementations do this</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>rmdir()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Same for <em>remove(directory)</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>sendfile()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Timestamp changed for input file</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>setxattr()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Same for <em>fsetxattr()</em> and <em>lsetxattr()</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>symlink()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Sets timestamps of link (not target file)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>truncate()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Same for <em>ftruncate()</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>unlink()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Same for <em>remove(file)</em>; file <em>st_ctime</em> changes if previous link count was &gt; 1</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>utime()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Same for <em>utimes()</em>, <em>futimes()</em>, <em>futimens()</em>, <em>lutimes()</em>, and <em>utimensat()</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><em>write()</em></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Same for <em>writev()</em>, <em>pwrite()</em>, and <em>pwritev()</em></p></td>
</tr>
</tbody>
</table>
<p class="noindent">In <a href="ch14.xhtml#ch14lev2sec01">Sections 14.8.1</a> and <a href="ch15.xhtml#ch15lev1sec05">15.5</a>, we describe <em>mount(2)</em> options and per-file flags that prevent updates to the last access time of a file. The <em>open()</em> <span class="literal">O_NOATIME</span> flag described in <a href="ch04.xhtml#ch04lev2sec01">Section 4.3.1</a> also serves a similar purpose. In some applications, this can be useful for performance reasons, since it reduces the number of disk operations that are required when a file is accessed.</p>
<div class="block">
<p class="noindent">Although most UNIX systems don&#8217;t record the creation time of a file, on recent BSD systems, this time is recorded in a <em>stat</em> field named <em>st_birthtime</em>.</p>
</div>
<h5 class="h5" id="ch15lev3sec08"><span epub:type="pagebreak" id="page_287"/><strong>Nanosecond timestamps</strong></h5>
<p class="noindenta">With version 2.6, Linux supports nanosecond resolution for the three timestamp fields of the <em>stat</em> structure. Nanosecond resolution improves the accuracy of programs that need to make decisions based on the relative order of file timestamps (e.g., <em>make(1)</em>).</p>
<p class="indent">SUSv3 doesn&#8217;t specify nanosecond timestamps for the <em>stat</em> structure, but SUSv4 adds this specification.</p>
<p class="indent">Not all file systems support nanosecond timestamps. <em>JFS</em>, <em>XFS</em>, <em>ext4</em>, and <em>Btrfs</em> do, but <em>ext2</em>, <em>ext3</em>, and <em>Reiserfs</em> do not.</p>
<p class="indent">Under the <em>glibc</em> API (since version 2.3), the timestamp fields are each defined as a <em>timespec</em> structure (we describe this structure when we discuss <em>utimensat()</em> later in this section), which represents a time in seconds and nanoseconds components. Suitable macro definitions make the seconds component of these structures visible using the traditional field names (<em>st_atime</em>, <em>st_mtime</em>, and <em>st_ctime</em>). The nanosecond components can be accessed using field names such as <em>st_atim.tv_nsec</em>, for the nanosecond component of the last file access time.</p>
<h4 class="h4" id="ch15lev2sec01"><strong>15.2.1 Changing File Timestamps with <em>utime()</em> and <em>utimes()</em></strong></h4>
<p class="noindenta">The last file access and modification timestamps stored in a file i-node can be explicitly changed using <em>utime()</em> or one of a related set of system calls. Programs such as <em>tar(1)</em> and <em>unzip(1)</em> use these system calls to reset file timestamps when unpacking an archive.</p>
<div class="box">
<p class="programsa">#include &lt;utime.h&gt;<br/><br/>int <span class="codestrong">utime</span>(const char *<span class="font1">pathname</span>, const struct utimbuf *<span class="font1">buf</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>pathname</em> argument identifies the file whose times we wish to modify. If <em>pathname</em> is a symbolic link, it is dereferenced. The <em>buf</em> argument can be either <span class="literal">NULL</span> or a pointer to a <em>utimbuf</em> structure:</p>
<p class="programs">struct utimbuf {<br/>&#160;&#160;&#160;&#160;time_t actime;&#160;&#160;&#160;&#160;&#160;&#160;/* Access time */<br/>&#160;&#160;&#160;&#160;time_t modtime;&#160;&#160;&#160;&#160;&#160;/* Modification time */<br/>};</p>
<p class="noindent">The fields in this structure measure time in seconds since the Epoch (<a href="ch10.xhtml#ch10lev1sec01">Section 10.1</a>).</p>
<p class="indentb">Two different cases determine how <em>utime()</em> works:</p>
<p class="bull">&#8226; If <em>buf</em> is specified as <span class="literal">NULL</span>, then both the last access and the last modification times are set to the current time. In this case, either the effective user ID of the process must match the file&#8217;s user ID (owner), the process must have write permission on the file (logical, since a process with write permission on a file could employ other system calls that would have the side effect of changing these file timestamps), or the process must be privileged (<span class="literal">CAP_FOWNER</span> or <span class="literal">CAP_DAC_OVERRIDE</span>). <span epub:type="pagebreak" id="page_288"/>(To be accurate, on Linux, it is the process&#8217;s file-system user ID, rather than its effective user ID, that is checked against the file&#8217;s user ID, as described in <a href="ch09.xhtml#ch09lev1sec05">Section 9.5</a>.)</p>
<p class="bull">&#8226; If <em>buf</em> is specified as pointer to a <em>utimbuf</em> structure, then the last file access and modification times are updated using the corresponding fields of this structure. In this case, the effective user ID of the process must match the file&#8217;s user ID (having write permission on the file is not sufficient) or the caller must be privileged (<span class="literal">CAP_FOWNER</span>).</p>
<p class="noindentt">To change just one of the file timestamps, we first use <em>stat()</em> to retrieve both times, use one of these times to initialize the <em>utimbuf</em> structure, and then set the other as desired. This is demonstrated in the following code, which makes the last modification time of a file the same as the last access time:</p>
<p class="programs">struct stat sb;<br/>struct utimbuf utb;<br/><br/>if (stat(pathname, &#38;sb) == -1)<br/>&#160;&#160;&#160;&#160;errExit("stat");<br/>utb.actime = sb.st_atime;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Leave access time unchanged */<br/>utb.modtime = sb.st_atime;<br/>if (utime(pathname, &#38;utb) == -1)<br/>&#160;&#160;&#160;&#160;errExit("utime");</p>
<p class="noindent">A successful call to <em>utime()</em> always sets the last status change time to the current time.</p>
<p class="indent">Linux also provides the BSD-derived <em>utimes()</em> system call, which performs a similar task to <em>utime()</em>.</p>
<div class="box">
<p class="programsa">#include &lt;sys/time.h&gt;<br/><br/>int <span class="codestrong">utimes</span>(const char *<span class="font1">pathname</span>, const struct timeval <span class="font1">tv[2]</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The most notable difference between <em>utime()</em> and <em>utimes()</em> is that <em>utimes()</em> allows time values to be specified with microsecond accuracy (the <em>timeval</em> structure is described in <a href="ch10.xhtml#ch10lev1sec01">Section 10.1</a>). This provides (partial) access to the nanosecond accuracy with which file timestamps are provided in Linux 2.6. The new file access time is specified in <em>tv[0]</em>, and the new modification time is specified in <em>tv[1]</em>.</p>
<div class="block">
<p class="noindent">An example of the use of <em>utimes()</em> is provided in the file <span class="literal">files/t_utimes.c</span> in the source code distribution for this book.</p>
</div>
<p class="noindent">The <em>futimes()</em> and <em>lutimes()</em> library functions perform a similar task to <em>utimes()</em>. They differ from <em>utimes()</em> in the argument used to specify the file whose timestamps are to be changed.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_289"/>#include &lt;sys/time.h&gt;<br/><br/>int <span class="codestrong">futimes</span>(int <span class="font1">fd</span>, const struct timeval <span class="font1">tv[2]</span>);<br/>int <span class="codestrong">lutimes</span>(const char *<span class="font1">pathname</span>, const struct timeval <span class="font1">tv[2]</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">With <em>futimes()</em>, the file is specified via an open file descriptor, <em>fd</em>.</p>
<p class="indent">With <em>lutimes()</em>, the file is specified via a pathname, with the difference from <em>utimes()</em> that if the pathname refers to a symbolic link, then the link is not dereferenced; instead, the timestamps of the link itself are changed.</p>
<p class="indent">The <em>futimes()</em> function is supported since <em>glibc</em> 2.3. The <em>lutimes()</em> function is supported since <em>glibc</em> 2.6.</p>
<h4 class="h4" id="ch15lev2sec02"><strong>15.2.2 Changing File Timestamps with <em>utimensat()</em> and <em>futimens()</em></strong></h4>
<p class="noindentab">The <em>utimensat()</em> system call (supported since kernel 2.6.22) and the <em>futimens()</em> library function (supported since <em>glibc</em> 2.6) provide extended functionality for setting a file&#8217;s last access and last modification timestamps. Among the advantages of these interfaces are the following:</p>
<p class="bull">&#8226; We can set timestamps with nanosecond precision. This improves on the microsecond precision provided by <em>utimes()</em>.</p>
<p class="bull">&#8226; It is possible to set the timestamps independently (i.e., one at a time). As shown earlier, to change just one of the timestamps using the older interfaces, we must first call <em>stat()</em> to retrieve the value of the other timestamp, and then specify the retrieved value along with the timestamp whose value we want to change. (This could lead to a race condition if another process performed an operation that updated the timestamp between these two steps.)</p>
<p class="bull">&#8226; We can independently set either of the timestamps to the current time. To change just one timestamp to the current time with the older interfaces, we need to employ a call to <em>stat()</em> to retrieve the setting of the timestamp whose value we wish to leave unchanged, and a call to <em>gettimeofday()</em> to obtain the current time.</p>
<p class="noindentt">These interfaces are not specified in SUSv3, but are included in SUSv4.</p>
<p class="indent">The <em>utimensat()</em> system call updates the timestamps of the file specified by <em>pathname</em> to the values specified in the array <em>times</em>.</p>
<div class="box">
<p class="programsa">#define _XOPEN_SOURCE 700&#160;&#160;&#160;&#160;&#160;/* Or define _POSIX_C_SOURCE &gt;= 200809 */<br/>#include &lt;sys/stat.h&gt;<br/><br/>int <span class="codestrong">utimensat</span>(int <span class="font1">dirfd</span>, const char *<span class="font1">pathname</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const struct timespec <span class="font1">times[2]</span>, int <span class="font1">flags</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_290"/>If <em>times</em> is specified as <span class="literal">NULL</span>, then both file timestamps are updated to the current time. If <em>times</em> is not <span class="literal">NULL</span>, then the new last access timestamp is specified in <em>times[0]</em> and the new last modification timestamp is specified in <em>times[1]</em>. Each of the elements of the array <em>times</em> is a structure of the following form:</p>
<p class="programs">struct timespec {<br/>&#160;&#160;&#160;&#160;time_t tv_sec;&#160;&#160;&#160;&#160;&#160;/* Seconds ('time_t' is an integer type) */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;tv_nsec;&#160;&#160;&#160;&#160;/* Nanoseconds */<br/>};</p>
<p class="noindent">The fields in this structure specify a time in seconds and nanoseconds since the Epoch (<a href="ch10.xhtml#ch10lev1sec01">Section 10.1</a>).</p>
<p class="indent">To set one of the timestamps to the current time, we specify the special value <span class="literal">UTIME_NOW</span> in the corresponding <em>tv_nsec</em> field. To leave one of the timestamps unchanged, we specify the special value <span class="literal">UTIME_OMIT</span> in the corresponding <em>tv_nsec</em> field. In both cases, the value in the corresponding <em>tv_sec</em> field is ignored.</p>
<p class="indent">The <em>dirfd</em> argument can either specify <span class="literal">AT_FDCWD</span>, in which case the <em>pathname</em> argument is interpreted as for <em>utimes()</em>, or it can specify a file descriptor referring to a directory. The purpose of the latter choice is described in <a href="ch18.xhtml#ch18lev1sec11">Section 18.11</a>.</p>
<p class="indent">The <em>flags</em> argument can be either 0, or <span class="literal">AT_SYMLINK_NOFOLLOW</span>, meaning that <em>pathname</em> should not be dereferenced if it is a symbolic link (i.e., the timestamps of the symbolic link itself should be changed). By contrast, <em>utimes()</em> always dereferences symbolic links.</p>
<p class="indent">The following code segment sets the last access time to the current time and leaves the last modification time unchanged:</p>
<p class="programs">struct timespec times[2];<br/><br/>times[0].tv_sec = 0;<br/>times[0].tv_nsec = UTIME_NOW;<br/>times[1].tv_sec = 0;<br/>times[1].tv_nsec = UTIME_OMIT;<br/>if (utimensat(AT_FDCWD, "myfile", times, 0) == -1)<br/>&#160;&#160;&#160;&#160;errExit("utimensat");</p>
<p class="noindent">The permission rules for changing timestamps with <em>utimensat()</em> (and <em>futimens()</em>) are similar to those for the older APIs, and are detailed in the <em>utimensat(2)</em> manual page.</p>
<p class="indent">The <em>futimens()</em> library function updates the timestamps of the file referred to by the open file descriptor <em>fd</em>.</p>
<div class="box">
<p class="programsa">#define _GNU_SOURCE<br/>#include &lt;sys/stat.h&gt;<br/><br/>int <span class="codestrong">futimens</span>(int <span class="font1">fd</span>, const struct timespec <span class="font1">times[2]</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>times</em> argument of <em>futimens()</em> is used in the same way as for <em>utimensat()</em>.</p>
<h3 class="h3" id="ch15lev1sec03"><span epub:type="pagebreak" id="page_291"/><strong>15.3 File Ownership</strong></h3>
<p class="noindenta">Each file has an associated user ID (UID) and group ID (GID). These IDs determine which user and group the file belongs to. We now look at the rules that determine the ownership of new files and describe the system calls used to change a file&#8217;s ownership.</p>
<h4 class="h4" id="ch15lev2sec03"><strong>15.3.1 Ownership of New Files</strong></h4>
<p class="noindenta">When a new file is created, its user ID is taken from the effective user ID of the process. The group ID of the new file may be taken from either the effective group ID of the process (equivalent to the System V default behavior) or the group ID of the parent directory (the BSD behavior). The latter possibility is useful for creating project directories in which all files belong to a particular group and are accessible to the members of that group. Which of the two values is used as the new file&#8217;s group ID is determined by various factors, including the type of file system on which the new file is created. We begin by describing the rules followed by <em>ext2</em> and a few other file systems.</p>
<div class="block">
<p class="noindent">To be accurate, on Linux, all uses of the terms <em>effective user</em> or <em>group ID</em> in this section should really be <em>file-system user</em> or <em>group ID</em> (<a href="ch09.xhtml#ch09lev1sec05">Section 9.5</a>).</p>
</div>
<p class="noindent">When an <em>ext2</em> file system is mounted, either the <em>&#8211;o grpid</em> (or the synonymous <em>&#8211;o bsdgroups</em>) option or the <em>&#8211;o nogrpid</em> (or the synonymous <em>&#8211;o sysvgroups</em>) option may be specified to the <em>mount</em> command. (If neither option is specified, the default is <em>&#8211;o nogrpid</em>.) If <em>&#8211;o grpid</em> is specified, then a new file always inherits its group ID from the parent directory. If <em>&#8211;o nogrpid</em> is specified, then, by default, a new file takes its group ID from the process&#8217;s effective group ID. However, if the set-group-ID bit is enabled for the directory (via <em>chmod g+s</em>), then the group ID of the file is inherited from the parent directory. These rules are summarized in <a href="ch15.xhtml#ch15table3">Table 15-3</a>.</p>
<div class="block">
<p class="noindent">In <a href="ch18.xhtml#ch18lev1sec06">Section 18.6</a>, we&#8217;ll see that when the set-group-ID bit is set on a directory, then it is also set on new subdirectories created within that directory. In this manner, the set-group-ID behavior described in the main text is propagated down through an entire directory tree.</p>
</div>
<p class="tablecap"><a id="ch15table3"/><strong>Table 15-3:</strong> Rules determining the group ownership of a newly created file</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>File system mount option</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Set-group-ID bit enabled on parent directory?</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Group ownership of new file taken from</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><em>&#8211;o grpid</em>, <em>&#8211;o bsdgroups</em></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">(ignored)</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">parent directory group ID</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1" rowspan="2"><p class="table"><em>&#8211;o nogrpid</em>, <em>&#8211;o sysvgroups</em> (<em>default</em>)</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">no</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">process effective group ID</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table">yes</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">parent directory group ID</p></td>
</tr>
</tbody>
</table>
<p class="noindent">At the time of writing, the only file systems that support the <em>grpid</em> and <em>nogrpid</em> mount options are <em>ext2</em>, <em>ext3</em>, <em>ext4</em>, and (since Linux 2.6.14) <em>XFS</em>. Other file systems follow the <em>nogrpid</em> rules.</p>
<h4 class="h4" id="ch15lev2sec04"><strong>15.3.2 Changing File Ownership: <em>chown()</em>, <em>fchown()</em>, and <em>lchown()</em></strong></h4>
<p class="noindenta">The <em>chown()</em>, <em>lchown()</em>, and <em>fchown()</em> system calls change the owner (user ID) and group (group ID) of a file.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_292"/>#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">chown</span>(const char *<span class="font1">pathname</span>, uid_t <span class="font1">owner</span>, gid_t <span class="font1">group</span>);<br/>int <span class="codestrong">lchown</span>(const char *<span class="font1">pathname</span>, uid_t <span class="font1">owner</span>, gid_t <span class="font1">group</span>);<br/>int <span class="codestrong">fchown</span>(int <span class="font1">fd</span>, uid_t <span class="font1">owner</span>, gid_t <span class="font1">group</span>);</p>
<p class="right">All return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb">The distinction between these three system calls is similar to the <em>stat()</em> family of system calls:</p>
<p class="bull">&#8226; <em>chown()</em> changes the ownership of the file named in the <em>pathname</em> argument;</p>
<p class="bull">&#8226; <em>lchown()</em> does the same, except that if <em>pathname</em> is a symbolic link, ownership of the link file is changed, rather than the file to which it refers; and</p>
<p class="bull">&#8226; <em>fchown()</em> changes the ownership of a file referred to by the open file descriptor, <em>fd</em>.</p>
<p class="noindentt">The <em>owner</em> argument specifies the new user ID for the file, and the <em>group</em> argument specifies the new group ID for the file. To change just one of the IDs, we can specify &#8211;1 for the other argument to leave that ID unchanged.</p>
<div class="block">
<p class="noindent">Prior to Linux 2.2, <em>chown()</em> did not dereference symbolic links. The semantics of <em>chown()</em> were changed with Linux 2.2, and the new <em>lchown()</em> system call was added to provide the behavior of the old <em>chown()</em> system call.</p>
</div>
<p class="noindent">Only a privileged (<span class="literal">CAP_CHOWN</span>) process may use <em>chown()</em> to change the user ID of a file. An unprivileged process can use <em>chown()</em> to change the group ID of a file that it owns (i.e., the process&#8217;s effective user ID matches the user ID of the file) to any of the groups of which they are a member. A privileged process can change the group ID of a file to any value.</p>
<p class="indent">If the owner or group of a file is changed, then the set-user-ID and set-group-ID permission bits are both turned off. This is a security precaution to ensure that a normal user could not enable the set-user-ID (or set-group-ID) bit on an executable file and then somehow make it owned by some privileged user (or group), thereby gaining that privileged identity when executing the file.</p>
<div class="block">
<p class="noindent">SUSv3 leaves it unspecified whether the set-user-ID and set-group-ID bits should be turned off when the superuser changes the owner or group of an executable file. Linux 2.0 did turn these bits off in this case, while some of the early 2.2 kernels (up to 2.2.12) did not. Later 2.2 kernels returned to the 2.0 behavior, where changes by the superuser are treated the same as everyone else, and this behavior is maintained in subsequent kernel versions.</p>
</div>
<p class="noindentb"><span epub:type="pagebreak" id="page_293"/>When changing the owner or group of a file, the set-group-ID permission bit is not turned off if the group-execute permission bit is already off or if we are changing the ownership of a directory. In both of these cases, the set-group-ID bit is being used for a purpose other than the creation of a set-group-ID program, and therefore it is undesirable to turn the bit off. These other uses of the set-group-ID bit are as follows:</p>
<p class="bull">&#8226; If the group-execute permission bit is off, then the set-group-ID permission bit is being used to enable mandatory file locking (discussed in <a href="ch55.xhtml#ch55lev1sec04">Section 55.4</a>).</p>
<p class="bull">&#8226; In the case of a directory, the set-group-ID bit is being used to control the ownership of new files created in the directory (<a href="ch15.xhtml#ch15lev2sec03">Section 15.3.1</a>).</p>
<p class="noindentt">The use of <em>chown()</em> is demonstrated in <a href="ch15.xhtml#ch15ex2">Listing 15-2</a>, a program that allows the user to change the owner and group of an arbitrary number of files, specified as command-line arguments. (This program uses the <em>userIdFromName()</em> and <em>groupIdFromName()</em> functions from <a href="ch08.xhtml#ch8ex1">Listing 8-1</a>, on <a href="ch08.xhtml#page_159">page 159</a>, to convert user and group names into corresponding numeric IDs.)</p>
<p class="examplet"><a id="ch15ex2"/><strong>Listing 15-2:</strong> Changing the owner and group of a file</p>
<p class="programsli">__________________________________________________________ <span class="codestrong">files/t_chown.c</span><br/><br/>#include &lt;pwd.h&gt;<br/>#include &lt;grp.h&gt;<br/>#include "ugid_functions.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declarations of userIdFromName()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;and groupIdFromName() */<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;uid_t uid;<br/>&#160;&#160;&#160;&#160;gid_t gid;<br/>&#160;&#160;&#160;&#160;int j;<br/>&#160;&#160;&#160;&#160;Boolean errFnd;<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 3 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s owner group [file...]\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;owner or group can be '-', "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"meaning leave unchanged\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;if (strcmp(argv[1], "-") == 0) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* "-" ==&gt; don't change owner */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;uid = -1;<br/>&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Turn user name into UID */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;uid = userIdFromName(argv[1]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (uid == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("No such user (%s)", argv[1]);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (strcmp(argv[2], "-") == 0) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* "-" ==&gt; don't change group */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;gid = -1;<br/>&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Turn group name into GID */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;gid = groupIdFromName(argv[2]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (gid == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("No group user (%s)", argv[1]);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;/* Change ownership of all files named in remaining arguments */<br/><br/>&#160;&#160;&#160;&#160;errFnd = FALSE;<br/>&#160;&#160;&#160;&#160;for (j = 3; j &lt; argc; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (chown(argv[j], uid, gid) == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("chown: %s", argv[j]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errFnd = TRUE;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(errFnd ? EXIT_FAILURE : EXIT_SUCCESS);<br/>}<br/>__________________________________________________________ <span class="codestrong">files/t_chown.c</span></p>
<h3 class="h3" id="ch15lev1sec04"><span epub:type="pagebreak" id="page_294"/><strong>15.4 File Permissions</strong></h3>
<p class="noindenta">In this section, we describe the permission scheme applied to files and directories. Although we talk about permissions here mainly as they apply to regular files and directories, the rules that we describe apply to all types of files, including devices, FIFOs, and UNIX domain sockets. Furthermore, the System V and POSIX interprocess communication objects (shared memory, semaphores, and message queues) also have permission masks, and the rules that apply for these objects are similar to those for files.</p>
<h4 class="h4" id="ch15lev2sec05"><strong>15.4.1 Permissions on Regular Files</strong></h4>
<p class="noindentab">As noted in <a href="ch15.xhtml#ch15lev1sec01">Section 15.1</a>, the bottom 12 bits of the <em>st_mode</em> field of the <em>stat</em> structure define the permissions for a file. The first 3 of these bits are special bits known as the set-user-ID, set-group-ID, and sticky bits (labeled U, G, and T, respectively, in <a href="ch15.xhtml#ch15fig1">Figure 15-1</a>). We say more about these bits in <a href="ch15.xhtml#ch15lev2sec09">Section 15.4.5</a>. The remaining 9 bits form the mask defining the permissions that are granted to various categories of users accessing the file. The file permissions mask divides the world into three categories:</p>
<p class="bull">&#8226; <em>Owner</em> (also known as <em>user</em>): The permissions granted to the owner of the file.</p>
<div class="block1">
<p class="noindent">The term <em>user</em> is used by commands such as <em>chmod(1)</em>, which uses the abbreviation <em>u</em> to refer to this permission category.</p>
</div>
<p class="bull">&#8226; <em>Group</em>: The permissions granted to users who are members of the file&#8217;s group.</p>
<p class="bull">&#8226; <em>Other</em>: The permissions granted to everyone else.</p>
<p class="noindenttb">Three permissions may be granted to each user category:</p>
<p class="bull">&#8226; <em>Read</em>: The contents of the file may be read.</p>
<p class="bull">&#8226; <em>Write</em>: The contents of the file may be changed.</p>
<p class="bull"><span epub:type="pagebreak" id="page_295"/>&#8226; <em>Execute</em>: The file may be executed (i.e., it is a program or a script). In order to execute a script file (e.g., a <em>bash</em> script), both read and execute permissions are required.</p>
<p class="noindentt">The permissions and ownership of a file can be viewed using the command <em>ls &#8211;l</em>, as in the following example:</p>
<p class="programs">$ <span class="codestrong">ls -l myscript.sh</span><br/>-<span class="codestrong">rwxr-x---</span>&#160;&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1667 Jan 15 09:22 myscript.sh</p>
<p class="noindent">In the above example, the file permissions are displayed as <span class="literal">rwxr-x---</span> (the initial hyphen preceding this string indicates the type of this file: a regular file). To interpret this string, we break these 9 characters into sets of 3 characters, which respectively indicate whether read, write, and execute permission are enabled. The first set indicates the permissions for owner, which has read, write, and execute permissions enabled. The next set indicates the permissions for group, which has read and execute enabled, but not write. The final set are the permissions for other, which doesn&#8217;t have any permissions enabled.</p>
<p class="indent">The <span class="literal">&lt;sys/stat.h&gt;</span> header file defines constants that can be ANDed (<span class="literal">&#38;</span>) with <em>st_mode</em> of the <em>stat</em> structure, in order to check whether particular permission bits are set. (These constants are also defined via the inclusion of <span class="literal">&lt;fcntl.h&gt;</span>, which prototypes the <em>open()</em> system call.) These constants are shown in <a href="ch15.xhtml#ch15table4">Table 15-4</a>.</p>
<p class="tablecap"><a id="ch15table4"/><strong>Table 15-4:</strong> Constants for file permission bits</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Constant</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Octal value</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Permission bit</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_ISUID</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tabler"><span class="literal">04000</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Set-user-ID</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_ISGID</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tabler"><span class="literal">02000</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Set-group-ID</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">S_ISVTX</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tabler"><span class="literal">01000</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Sticky</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_IRUSR</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tabler"><span class="literal">0400</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">User-read</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_IWUSR</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tabler"><span class="literal">0200</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">User-write</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">S_IXUSR</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tabler"><span class="literal">0100</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">User-execute</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_IRGRP</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tabler"><span class="literal">040</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Group-read</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_IWGRP</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tabler"><span class="literal">020</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Group-write</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">S_IXGRP</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tabler"><span class="literal">010</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Group-execute</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_IROTH</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tabler"><span class="literal">04</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Other-read</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">S_IWOTH</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tabler"><span class="literal">02</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Other-write</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">S_IXOTH</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="tabler"><span class="literal">01</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Other-execute</p></td>
</tr>
</tbody>
</table>
<p class="noindent">In addition to the constants shown in <a href="ch15.xhtml#ch15table4">Table 15-4</a>, three constants are defined to equate to masks for all three permissions for each of the categories owner, group, and other: <span class="literal">S_IRWXU</span> (0700), <span class="literal">S_IRWXG</span> (070), and <span class="literal">S_IRWXO</span> (07).</p>
<p class="indent">The header file in <a href="ch15.xhtml#ch15ex3">Listing 15-3</a> declares a function, <em>filePermStr()</em>, which, given a file permissions mask, returns a statically allocated string representation of that mask in the same style as is used by <em>ls(1)</em>.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_296"/><a id="ch15ex3"/><strong>Listing 15-3:</strong> Header file for <span class="literal">file_perms.c</span></p>
<p class="programsli">________________________________________________________<span class="codestrong">files/file_perms.h</span><br/><br/>#ifndef FILE_PERMS_H<br/>#define FILE_PERMS_H<br/><br/>#include &lt;sys/types.h&gt;<br/><br/>#define FP_SPECIAL 1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Include set-user-ID, set-group-ID, and sticky<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bit information in returned string */<br/><br/>char *filePermStr(mode_t perm, int flags);<br/><br/>#endif<br/>________________________________________________________<span class="codestrong">files/file_perms.h</span></p>
<p class="noindent">If the <span class="literal">FP_SPECIAL</span> flag is set in the <em>filePermStr() flags</em> argument, then the returned string includes the settings of the set-user-ID, set-group-ID, and sticky bits, again in the style of <em>ls(1)</em>.</p>
<p class="indent">The implementation of the <em>filePermStr()</em> function is shown in <a href="ch15.xhtml#ch15ex4">Listing 15-4</a>. We employ this function in the program in <a href="ch15.xhtml#ch15ex1">Listing 15-1</a>.</p>
<p class="examplet"><a id="ch15ex4"/><strong>Listing 15-4:</strong> Convert file permissions mask to string</p>
<p class="programsli">________________________________________________________<span class="codestrong">files/file_perms.c</span><br/><br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;stdio.h&gt;<br/>#include "file_perms.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Interface for this implementation */<br/><br/>#define STR_SIZE sizeof("rwxrwxrwx")<br/><br/>char *&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Return ls(1)-style string for file permissions mask */<br/>filePermStr(mode_t perm, int flags)<br/>{<br/>&#160;&#160;&#160;&#160;static char str[STR_SIZE];<br/><br/>&#160;&#160;&#160;&#160;snprintf(str, STR_SIZE, "%c%c%c%c%c%c%c%c%c",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(perm &#38; S_IRUSR) ? 'r' : '-', (perm &#38; S_IWUSR) ? 'w' : '-',<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(perm &#38; S_IXUSR) ?<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(((perm &#38; S_ISUID) &#38;&#38; (flags &#38; FP_SPECIAL)) ? 's' : 'x') :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(((perm &#38; S_ISUID) &#38;&#38; (flags &#38; FP_SPECIAL)) ? 'S' : '-'),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(perm &#38; S_IRGRP) ? 'r' : '-', (perm &#38; S_IWGRP) ? 'w' : '-',<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(perm &#38; S_IXGRP) ?<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(((perm &#38; S_ISGID) &#38;&#38; (flags &#38; FP_SPECIAL)) ? 's' : 'x') :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(((perm &#38; S_ISGID) &#38;&#38; (flags &#38; FP_SPECIAL)) ? 'S' : '-'),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(perm &#38; S_IROTH) ? 'r' : '-', (perm &#38; S_IWOTH) ? 'w' : '-',<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(perm &#38; S_IXOTH) ?<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(((perm &#38; S_ISVTX) &#38;&#38; (flags &#38; FP_SPECIAL)) ? 't' : 'x') :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(((perm &#38; S_ISVTX) &#38;&#38; (flags &#38; FP_SPECIAL)) ? 'T' : '-'));<br/><br/>&#160;&#160;&#160;&#160;return str;<br/>}<br/>________________________________________________________<span class="codestrong">files/file_perms.c</span></p>
<h4 class="h4" id="ch15lev2sec06"><span epub:type="pagebreak" id="page_297"/><strong>15.4.2 Permissions on Directories</strong></h4>
<p class="noindentab">Directories have the same permission scheme as files. However, the three permissions are interpreted differently:</p>
<p class="bull">&#8226; <em>Read</em>: The contents (i.e., the list of filenames) of the directory may be listed (e.g., by <em>ls</em>).</p>
<div class="block1">
<p class="noindent">If experimenting to verify the operation of the directory read permission bit, be aware that some Linux distributions alias the <em>ls</em> command to include flags (e.g., <em>&#8211;F</em>) that require access to i-node information for files in the directory, and this requires execute permission on the directory. To ensure that we are using an unadulterated <em>ls</em>, we can specify the full pathname of the command (<span class="literal">/bin/ls</span>) or precede the <em>ls</em> command with a backslash to prevent alias substitution.</p>
</div>
<p class="bull">&#8226; <em>Write</em>: Files may be created in and removed from the directory. Note that it is not necessary to have any permission on a file itself in order to be able to delete it.</p>
<p class="bull">&#8226; <em>Execute</em>: Files within the directory may be accessed. Execute permission on a directory is sometimes called <em>search</em> permission.</p>
<p class="noindentt">When accessing a file, execute permission is required on all of the directories listed in the pathname. For example, reading the file <span class="literal">/home/mtk/x</span> would require execute permission on <span class="literal">/</span>, <span class="literal">/home</span>, and <span class="literal">/home/mtk</span> (as well as read permission on the file <span class="literal">x</span> itself). If the current working directory is <span class="literal">/home/mtk/sub1</span> and we access the relative pathname <span class="literal">../sub2/x</span>, then we need execute permission on <span class="literal">/home/mtk</span> and <span class="literal">/home/mtk/sub2</span> (but not on <span class="literal">/</span> or <span class="literal">/home</span>).</p>
<p class="indent">Read permission on a directory only lets us view the list of filenames in the directory. We must have execute permission on the directory in order to access the contents or the i-node information of files in the directory.</p>
<p class="indent">Conversely, if we have execute permission on a directory, but not read permission, then we can access a file in the directory if we know its name, but we can&#8217;t list the contents of (i.e., the other filenames in) the directory. This is a simple and frequently used technique to control access to the contents of a public directory.</p>
<p class="indent">To add or remove files in a directory, we need both execute and write permissions on the directory.</p>
<h4 class="h4" id="ch15lev2sec07"><strong>15.4.3 Permission-Checking Algorithm</strong></h4>
<p class="noindenta">The kernel checks file permissions whenever we specify a pathname in a system call that accesses a file or directory. When the pathname given to the system call includes a directory prefix, then, in addition to checking for the required permissions on the file itself, the kernel also checks for execute permission on each of the directories in this prefix. Permission checks are made using the process&#8217;s effective user ID, effective group ID, and supplementary group IDs. (To be strictly accurate, for file permission checks on Linux, the file-system user and group IDs are used instead of the corresponding effective IDs, as described in <a href="ch09.xhtml#ch09lev1sec05">Section 9.5</a>.)</p>
<div class="block">
<p class="noindent">Once a file has been opened with <em>open()</em>, no permission checking is performed by subsequent system calls that work with the returned file descriptor (such as <em>read()</em>, <em>write()</em>, <em>fstat()</em>, <em>fcntl()</em>, and <em>mmap()</em>).</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_298"/>The rules applied by the kernel when checking permissions are as follows:</p>
<ol>
<li class="order"><p class="orderp">If the process is privileged, all access is granted.</p></li>
<li class="order"><p class="orderp">If the effective user ID of the process is the same as the user ID (owner) of the file, then access is granted according to the <em>owner</em> permissions on the file. For example, read access is granted if the owner-read permission bit is turned on in the file permissions mask; otherwise, read access is denied.</p></li>
<li class="order"><p class="orderp">If the effective group ID of the process or any of the process supplementary group IDs matches the group ID (group owner) of the file, then access is granted according to the <em>group</em> permissions on the file.</p></li>
<li class="order"><p class="orderp">Otherwise, access is granted according to the <em>other</em> permissions on the file.</p></li>
</ol>
<div class="block">
<p class="noindent">In the kernel code, the above tests are actually constructed so that the test to see whether a process is privileged is performed only if the process is not granted the permissions it needs via one of the other tests. This is done to avoid unnecessarily setting the <span class="literal">ASU</span> process accounting flag, which indicates that the process made use of superuser privileges (<a href="ch28.xhtml#ch28lev1sec01">Section 28.1</a>).</p>
</div>
<p class="noindent">The checks against owner, group, and other permissions are done in order, and checking stops as soon as the applicable rule is found. This can have an unexpected consequence: if, for example, the permissions for group exceed those of owner, then the owner will actually have fewer permissions on the file than members of the file&#8217;s group, as illustrated by the following example:</p>
<p class="programs">$ <span class="codestrong">echo 'Hello world' &gt; a.txt</span><br/>$ <span class="codestrong">ls -l a.txt</span><br/>-rw-r--r--&#160;&#160;&#160;1 mtk&#160;&#160;&#160;users&#160;&#160;&#160;&#160;12 Jun 18 12:26 a.txt<br/>$ <span class="codestrong">chmod u-rw a.txt</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Remove read and write permission from owner</span><br/>$ <span class="codestrong">ls -l a.txt</span><br/>----r--r--&#160;&#160;&#160;1 mtk&#160;&#160;&#160;users&#160;&#160;&#160;&#160;12 Jun 18 12:26 a.txt<br/>$ <span class="codestrong">cat a.txt</span><br/>cat: a.txt: Permission denied&#160;&#160;&#160;<span class="font1">Owner can no longer read file</span><br/>$ <span class="codestrong">su avr</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Become someone else&#8230;</span><br/>Password:<br/>$ <span class="codestrong">groups</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">who is in the group owning the file&#8230;</span><br/>users staff teach cs<br/>$ <span class="codestrong">cat a.txt</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">and thus can read the file</span><br/>Hello world</p>
<p class="noindent">Similar remarks apply if other grants more permissions than owner or group.</p>
<p class="indent">Since file permissions and ownership information are maintained within a file i-node, all filenames (links) that refer to the same i-node share this information.</p>
<p class="indent">Linux 2.6 provides access control lists (ACLs), which make it possible to define file permissions on a per-user and per-group basis. If a file has an ACL, then a modified version of the above algorithm is used. We describe ACLs in <a href="ch17.xhtml#ch17">Chapter 17</a>.</p>
<h5 class="h5" id="ch15lev3sec09"><strong>Permission checking for privileged processes</strong></h5>
<p class="noindenta">Above, we said that if a process is privileged, all access is granted when checking permissions. We need to add one proviso to this statement. For a file that is not a directory, Linux grants execute permission to a privileged process only if that permission is granted to at least one of the permission categories for the file. On some <span epub:type="pagebreak" id="page_299"/>other UNIX implementations, a privileged process can execute a file even when no permission category grants execute permission. When accessing a directory, a privileged process is always granted execute (search) permission.</p>
<div class="block">
<p class="noindent">We can rephrase our description of a privileged process in terms of two Linux process capabilities: <span class="literal">CAP_DAC_READ_SEARCH</span> and <span class="literal">CAP_DAC_OVERRIDE</span> (<a href="ch39.xhtml#ch39lev1sec02">Section 39.2</a>). A process with the <span class="literal">CAP_DAC_READ_SEARCH</span> capability always has read permission for any type of file, and always has read and execute permissions for a directory (i.e., can always access files in a directory and read the list of files in a directory). A process with the <span class="literal">CAP_DAC_OVERRIDE</span> capability always has read and write permissions for any type of file, and also has execute permission if the file is a directory or if execute permission is granted to at least one of the permission categories for the file.</p>
</div>
<h4 class="h4" id="ch15lev2sec08"><strong>15.4.4 Checking File Accessibility: <em>access()</em></strong></h4>
<p class="noindenta">As noted in <a href="ch15.xhtml#ch15lev2sec07">Section 15.4.3</a>, the <em>effective</em> user and group IDs, as well as supplementary group IDs, are used to determine the permissions a process has when accessing a file. It is also possible for a program (e.g., a set-user-ID or set-group-ID program) to check file accessibility based on the <em>real</em> user and group IDs of the process.</p>
<p class="indent">The <em>access()</em> system call checks the accessibility of the file specified in <em>pathname</em> based on a process&#8217;s real user and group IDs (and supplementary group IDs).</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">access</span>(const char *<span class="font1">pathname</span>, int <span class="font1">mode</span>);</p>
<p class="right">Returns 0 if all permissions are granted, otherwise &#8211;1</p>
</div>
<p class="noindent">If <em>pathname</em> is a symbolic link, <em>access()</em> dereferences it.</p>
<p class="indent">The <em>mode</em> argument is a bit mask consisting of one or more of the constants shown in <a href="ch15.xhtml#ch15table5">Table 15-5</a>, ORed (<span class="literal">|</span>) together. If all of the permissions specified in <em>mode</em> are granted on <em>pathname</em>, then <em>access()</em> returns 0; if at least one of the requested permissions is not available (or an error occurred), then <em>access()</em> returns &#8211;1.</p>
<p class="tablecap"><a id="ch15table5"/><strong>Table 15-5:</strong> <em>mode</em> constants for <em>access()</em></p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Constant</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">F_OK</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Does the file exist?</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">R_OK</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Can the file be read?</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">W_OK</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Can the file be written?</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">X_OK</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Can the file be executed?</p></td>
</tr>
</tbody>
</table>
<p class="noindent">The time gap between a call to <em>access()</em> and a subsequent operation on a file means that there is no guarantee that the information returned by <em>access()</em> will still be true at the time of the later operation (no matter how brief the interval). This situation could lead to security holes in some application designs.</p>
<p class="indent">Suppose, for example, that we have a set-user-ID-<em>root</em> program that uses <em>access()</em> to check that a file is accessible to the real user ID of the program, and, if so, performs an operation on the file (e.g., <em>open()</em> or <em>exec()</em>).</p>
<p class="indent"><span epub:type="pagebreak" id="page_300"/>The problem is that if the pathname given to <em>access()</em> is a symbolic link, and a malicious user manages to change the link so that it refers to a different file before the second step, then the set-user-ID-<em>root</em> may end up operating on a file for which the real user ID does not have permission. (This is an example of the type of time-of-check, time-of-use race condition described in <a href="ch38.xhtml#ch38lev1sec06">Section 38.6</a>.) For this reason, recommended practice is to avoid the use of <em>access()</em> altogether (see, for example, [<a href="bib.xhtml#bib08">Borisov, 2005</a>]). In the example just given, we can achieve this by temporarily changing the effective (or file system) user ID of the set-user-ID process, attempting the desired operation (e.g., <em>open()</em> or <em>exec()</em>), and then checking the return value and <em>errno</em> to determine whether the operation failed because of a permissions problem.</p>
<div class="block">
<p class="noindent">The GNU C library provides an analogous, nonstandard function, <em>euidaccess()</em> (or synonymously, <em>eaccess()</em>), that checks file access permissions using the effective user ID of the process.</p>
</div>
<h4 class="h4" id="ch15lev2sec09"><strong>15.4.5 Set-User-ID, Set-Group-ID, and Sticky Bits</strong></h4>
<p class="noindenta">As well as the 9 bits used for owner, group, and other permissions, the file permissions mask contains 3 additional bits, known as the <em>set-user-ID</em> (bit 04000), <em>set-group-ID</em> (bit 02000), and <em>sticky</em> (bit 01000) bits. We have already discussed the use of the set-user-ID and set-group-ID permission bits for creating privileged programs in <a href="ch09.xhtml#ch09lev1sec03">Section 9.3</a>. The set-group-ID bit also serves two other purposes that we describe elsewhere: controlling the group ownership of new files created in a directory mounted with the <em>nogrpid</em> option (<a href="ch15.xhtml#ch15lev2sec03">Section 15.3.1</a>), and enabling mandatory locking on a file (<a href="ch55.xhtml#ch55lev1sec04">Section 55.4</a>). In the remainder of this section, we limit our discussion to the use of the sticky bit.</p>
<p class="indent">On older UNIX implementations, the sticky bit was provided as a way of making commonly used programs run faster. If the sticky bit was set on a program file, then the first time the program was executed, a copy of the program text was saved in the swap area&#8212;thus it <em>sticks</em> in swap, and loads faster on subsequent executions. Modern UNIX implementations have more sophisticated memory-management systems, which have rendered this use of the sticky permission bit obsolete.</p>
<div class="block">
<p class="noindent">The name of the constant for the sticky permission bit shown in <a href="ch15.xhtml#ch15table4">Table 15-4</a>, <span class="literal">S_ISVTX</span>, derives from an alternative name for the sticky bit: the <em>saved-text</em> bit.</p>
</div>
<p class="noindent">In modern UNIX implementations (including Linux), the sticky permission bit serves another, quite different purpose. For directories, the sticky bit acts as the <em>restricted deletion</em> flag. Setting this bit on a directory means that an unprivileged process can unlink (<em>unlink()</em>, <em>rmdir()</em>) and rename (<em>rename()</em>) files in the directory only if it has write permission on the directory <em>and</em> owns either the file or the directory. (A process with the <span class="literal">CAP_FOWNER</span> capability can bypass the latter ownership check.) This makes it possible to create a directory that is shared by many users, who can each create and delete their own files in the directory but can&#8217;t delete files owned by other users. The sticky permission bit is commonly set on the <span class="literal">/tmp</span> directory for this reason.</p>
<p class="indent"><span epub:type="pagebreak" id="page_301"/>A file&#8217;s sticky permission bit is set via the <em>chmod</em> command (<em>chmod +t file</em>) or via the <em>chmod()</em> system call. If the sticky bit for a file is set, <em>ls &#8211;l</em> shows a lowercase or uppercase letter <em>T</em> in the other-execute permission field, depending on whether the other-execute permission bit is on or off, as in the following:</p>
<p class="programs">$ <span class="codestrong">touch tfile</span><br/>$ <span class="codestrong">ls -l tfile</span><br/>-rw-r--r--&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;0 Jun 23 14:44 tfile<br/>$ <span class="codestrong">chmod +t tfile</span><br/>$ <span class="codestrong">ls -l tfile</span><br/>-rw-r--r-T&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;0 Jun 23 14:44 tfile<br/>$ <span class="codestrong">chmod o+x tfile</span><br/>$ <span class="codestrong">ls -l tfile</span><br/>-rw-r--r-t&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;0 Jun 23 14:44 tfile</p>
<h4 class="h4" id="ch15lev2sec10"><strong>15.4.6 The Process File Mode Creation Mask: <em>umask()</em></strong></h4>
<p class="noindenta">We now consider in more detail the permissions that are placed on a newly created file or directory. For new files, the kernel uses the permissions specified in the <em>mode</em> argument to <em>open()</em> or <em>creat()</em>. For new directories, permissions are set according to the <em>mode</em> argument to <em>mkdir()</em>. However, these settings are modified by the file mode creation mask, also known simply as the <em>umask</em>. The umask is a process attribute that specifies which permission bits should always be turned <em>off</em> when new files or directories are created by the process.</p>
<p class="indent">Often, a process just uses the umask it inherits from its parent shell, with the (usually desirable) consequence that the user can control the umask of programs executed from the shell using the shell built-in command <em>umask</em>, which changes the umask of the shell process.</p>
<p class="indent">The initialization files for most shells set the default umask to the octal value 022 (<span class="literal">----w--w-</span>). This value specifies that write permission should always be turned off for group and other. Thus, assuming the <em>mode</em> argument in a call to <em>open()</em> is 0666 (i.e., read and write permitted for all users, which is typical), then new files are created with read and write permissions for owner, and only read permission for everyone else (displayed by <em>ls &#8211;l</em> as <span class="literal">rw-r--r--</span>). Correspondingly, assuming that the <em>mode</em> argument to <em>mkdir()</em> is specified as 0777 (i.e., all permissions granted to all users), new directories are created with all permissions granted for owner, and just read and execute permissions for group and other (i.e., <span class="literal">rwxr-xr-x</span>).</p>
<p class="indent">The <em>umask()</em> system call changes a process&#8217;s umask to the value specified in <em>mask</em>.</p>
<div class="box">
<p class="programsa">#include &lt;sys/stat.h&gt;<br/><br/>mode_t <span class="codestrong">umask</span>(mode_t <span class="font1">mask</span>);</p>
<p class="right">Always successfully returns the previous process umask</p>
</div>
<p class="noindent">The <em>mask</em> argument can be specified either as an octal number or by ORing (<span class="literal">|</span>) together the constants listed in <a href="ch15.xhtml#ch15table4">Table 15-4</a>.</p>
<p class="indent">A call to <em>umask()</em> is always successful, and returns the previous umask.</p>
<p class="indent"><span epub:type="pagebreak" id="page_302"/><a href="ch15.xhtml#ch15ex5">Listing 15-5</a> illustrates the use of <em>umask()</em> in conjunction with <em>open()</em> and <em>mkdir()</em>. When we run this program, we see the following:</p>
<p class="programs">$ <span class="codestrong">./t_umask</span><br/>Requested file perms: rw-rw----&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">This is what we asked for</span><br/>Process umask:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;----wx-wx&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">This is what we are denied</span><br/>Actual file perms:&#160;&#160;&#160;&#160;rw-r-----&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">So this is what we end up with</span><br/><br/>Requested dir. perms: rwxrwxrwx<br/>Process umask:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;----wx-wx<br/>Actual dir. perms:&#160;&#160;&#160;&#160;rwxr--r--</p>
<div class="block">
<p class="noindent">In <a href="ch15.xhtml#ch15ex5">Listing 15-5</a>, we employ the <em>mkdir()</em> and <em>rmdir()</em> system calls to create and remove a directory, and the <em>unlink()</em> system call to remove a file. We describe these system calls in <a href="ch18.xhtml#ch18">Chapter 18</a>.</p>
</div>
<p class="examplet"><a id="ch15ex5"/><strong>Listing 15-5:</strong> Using <em>umask()</em></p>
<p class="programsli">__________________________________________________________ <span class="codestrong">files/t_umask.c</span><br/><br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include "file_perms.h"<br/>#include "tlpi_hdr.h"<br/><br/>#define MYFILE "myfile"<br/>#define MYDIR "mydir"<br/>#define FILE_PERMS&#160;&#160;&#160;&#160;(S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP)<br/>#define DIR_PERMS&#160;&#160;&#160;&#160;&#160;(S_IRWXU | S_IRWXG | S_IRWXO)<br/>#define UMASK_SETTING (S_IWGRP | S_IXGRP | S_IWOTH | S_IXOTH)<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int fd;<br/>&#160;&#160;&#160;&#160;struct stat sb;<br/>&#160;&#160;&#160;&#160;mode_t u;<br/><br/>&#160;&#160;&#160;&#160;umask(UMASK_SETTING);<br/><br/>&#160;&#160;&#160;&#160;fd = open(MYFILE, O_RDWR | O_CREAT | O_EXCL, FILE_PERMS);<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open-%s", MYFILE);<br/>&#160;&#160;&#160;&#160;if (mkdir(MYDIR, DIR_PERMS) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mkdir-%s", MYDIR);<br/><br/>&#160;&#160;&#160;&#160;u = umask(0);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Retrieves (and clears) umask value */<br/><br/>&#160;&#160;&#160;&#160;if (stat(MYFILE, &#38;sb) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("stat-%s", MYFILE);<br/>&#160;&#160;&#160;&#160;printf("Requested file perms: %s\n", filePermStr(FILE_PERMS, 0));<br/>&#160;&#160;&#160;&#160;printf("Process umask:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;%s\n", filePermStr(u, 0));<br/>&#160;&#160;&#160;&#160;printf("Actual file perms:&#160;&#160;&#160;&#160;%s\n\n", filePermStr(sb.st_mode, 0));<br/>&#160;&#160;&#160;&#160;if (stat(MYDIR, &#38;sb) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("stat-%s", MYDIR);<br/>&#160;&#160;&#160;&#160;printf("Requested dir. perms: %s\n", filePermStr(DIR_PERMS, 0));<br/>&#160;&#160;&#160;&#160;printf("Process umask:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;%s\n", filePermStr(u, 0));<br/>&#160;&#160;&#160;&#160;printf("Actual dir. perms:&#160;&#160;&#160;&#160;%s\n", filePermStr(sb.st_mode, 0));<br/><br/>&#160;&#160;&#160;&#160;if (unlink(MYFILE) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("unlink-%s", MYFILE);<br/>&#160;&#160;&#160;&#160;if (rmdir(MYDIR) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("rmdir-%s", MYDIR);<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>__________________________________________________________ <span class="codestrong">files/t_umask.c</span></p>
<h4 class="h4" id="ch15lev2sec11"><span epub:type="pagebreak" id="page_303"/><strong>15.4.7 Changing File Permissions: <em>chmod()</em> and <em>fchmod()</em></strong></h4>
<p class="noindenta">The <em>chmod()</em> and <em>fchmod()</em> system calls change the permissions of a file.</p>
<div class="box">
<p class="programsa">#include &lt;sys/stat.h&gt;<br/><br/>int <span class="codestrong">chmod</span>(const char *<span class="font1">pathname</span>, mode_t <span class="font1">mode</span>);<br/>int <span class="codestrong">fchmod</span>(int <span class="font1">fd</span>, mode_t <span class="font1">mode</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>chmod()</em> system call changes the permissions of the file named in <em>pathname</em>. If this argument is a symbolic link, <em>chmod()</em> changes the permissions of the file to which it refers, rather than the permissions of the link itself. (A symbolic link is always created with read, write, and execute permissions enabled for all users, and these permission can&#8217;t be changed. These permissions are ignored when dereferencing the link.)</p>
<p class="indent">The <em>fchmod()</em> system call changes the permissions on the file referred to by the open file descriptor <em>fd</em>.</p>
<p class="indent">The <em>mode</em> argument specifies the new permissions of the file, either numerically (octal) or as a mask formed by ORing (<span class="literal">|</span>) the permission bits listed in <a href="ch15.xhtml#ch15table4">Table 15-4</a>. In order to change the permissions on a file, either the process must be privileged (<span class="literal">CAP_FOWNER</span>) or its effective user ID must match the owner (user ID) of the file. (To be strictly accurate, on Linux, for an unprivileged process, it is the process&#8217;s file-system user ID, rather than its effective user ID, that must match the user ID of the file, as described in <a href="ch09.xhtml#ch09lev1sec05">Section 9.5</a>.)</p>
<p class="indent">To set the permissions on a file so that only read permission is granted to all users, we could use the following call:</p>
<p class="programs">if (chmod("myfile", S_IRUSR | S_IRGRP | S_IROTH) == -1)<br/>&#160;&#160;&#160;&#160;errExit("chmod");<br/>/* Or equivalently: chmod("myfile", 0444); */</p>
<p class="noindent"><span epub:type="pagebreak" id="page_304"/>In order to modify selected bits of the file permissions, we first retrieve the existing permissions using <em>stat()</em>, tweak the bits we want to change, and then use <em>chmod()</em> to update the permissions:</p>
<p class="programs">struct stat sb;<br/>mode_t mode;<br/><br/>if (stat("myfile", &#38;sb) == -1)<br/>&#160;&#160;&#160;&#160;errExit("stat");<br/>mode = (sb.st_mode | S_IWUSR) &#38; ~S_IROTH;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* owner-write on, other-read off, remaining bits unchanged */<br/>if (chmod("myfile", mode) == -1)<br/>&#160;&#160;&#160;&#160;errExit("chmod");</p>
<p class="noindent">The above is equivalent to the following shell command:</p>
<p class="programs">$ <span class="codestrong">chmod u+w,o-r myfile</span></p>
<p class="noindent">In <a href="ch15.xhtml#ch15lev2sec03">Section 15.3.1</a>, we noted that if a directory resides on an <em>ext2</em> system mounted with the <em>&#8211;o bsdgroups</em> option, or on one mounted with the <em>&#8211;o sysvgroups</em> option <em>and</em> the set-group-ID permission bit is turned on for the directory, then a newly created file in the directory takes its ownership from the parent directory, not the effective group ID of the creating process. It may be the case that the group ID of such a file doesn&#8217;t match any of the group IDs of the creating process. For this reason, when an unprivileged process (one that doesn&#8217;t have the <span class="literal">CAP_FSETID</span> capability) calls <em>chmod()</em> (or <em>fchmod()</em>) on a file whose group ID is not equal to the effective group ID or any of the supplementary group IDs of the process, the kernel always clears the set-group-ID permission bit. This is a security measure designed to prevent a user from creating a set-group-ID program for a group of which they are not a member. The following shell commands show the attempted exploit that this measure prevents:</p>
<p class="programs">$ <span class="codestrong">mount | grep test</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Hmmm,</span> /test <span class="font1">is mounted with &#8211;o bsdgroups</span><br/>/dev/sda9 on /test type ext3 (rw,bsdgroups)<br/>$ <span class="codestrong">ls -ld /test</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Directory has GID root, writable by anyone</span><br/>drwxrwxrwx&#160;&#160;&#160;3 root&#160;&#160;&#160;root&#160;&#160;&#160;&#160;4096 Jun 30 20:11 /test<br/>$ <span class="codestrong">id</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">I'm an ordinary user, not part of root group</span><br/>uid=1000(mtk) gid=100(users) groups=100(users),101(staff),104(teach)<br/>$ <span class="codestrong">cd /test</span><br/>$ <span class="codestrong">cp ~/myprog .</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Copy some mischievous program here</span><br/>$ <span class="codestrong">ls -l myprog</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Hey! It's in the root group!</span><br/>-rwxr-xr-x&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;root&#160;&#160;&#160;19684 Jun 30 20:43 myprog<br/>$ <span class="codestrong">chmod g+s myprog</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Can I make it set-group-ID to root?</span><br/>$ <span class="codestrong">ls -l myprog</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Hmm, no&#8230;</span><br/>-rwxr-xr-x&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;root&#160;&#160;&#160;19684 Jun 30 20:43 myprog</p>
<h3 class="h3" id="ch15lev1sec05"><strong>15.5 I-node Flags (<em>ext2</em> Extended File Attributes)</strong></h3>
<p class="noindenta">Some Linux file systems allow various <em>i-node flags</em> to be set on files and directories. This feature is a nonstandard Linux extension.</p>
<div class="block">
<p class="noindent">The modern BSDs provide a similar feature to i-node flags in the form of file flags set using <em>chflags(1)</em> and <em>chflags(2)</em>.</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_305"/>The first Linux file system to support i-node flags was <em>ext2</em>, and these flags are sometimes referred to as <em>ext2 extended file attributes</em>. Subsequently, support for i-node flags has been added on other file systems, including <em>Btrfs</em>, <em>ext3</em>, <em>ext4</em>, <em>Reiserfs</em> (since Linux 2.4.19), <em>XFS</em> (since Linux 2.4.25 and 2.6), and <em>JFS</em> (since Linux 2.6.17).</p>
<div class="block">
<p class="noindent">The range of i-node flags supported varies somewhat across file systems. In order to use i-node flags on a <em>Reiserfs</em> file system, we must use the <em>mount &#8211;o attrs</em> option when mounting the file system.</p>
</div>
<p class="noindent">From the shell, i-node flags can be set and viewed using the <em>chattr</em> and <em>lsattr</em> commands, as shown in the following example:</p>
<p class="programs">$ <span class="codestrong">lsattr myfile</span><br/>-------- myfile<br/>$ <span class="codestrong">sudo chattr +ai myfile</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Turn on Append Only and Immutable flags</span><br/>$ <span class="codestrong">lsattr myfile</span><br/>----ia-- myfile</p>
<p class="noindent">Within a program, i-node flags can be retrieved and modified using the <em>ioctl()</em> system call, as detailed shortly.</p>
<p class="indent">I-node flags can be set on both regular files and directories. Most i-node flags are intended for use with regular files, although some of them also (or only) have meaning for directories. <a href="ch15.xhtml#ch15table6">Table 15-6</a> summarizes the range of available i-node flags, showing the corresponding flag name (defined in <span class="literal">&lt;linux/fs.h&gt;</span>) that is used from programs in <em>ioctl()</em> calls, and the option letter that is used with the <em>chattr</em> command.</p>
<div class="block">
<p class="noindent">Before Linux 2.6.19, the <span class="literal">FS_*</span> constants shown in <a href="ch15.xhtml#ch15table6">Table 15-6</a> were not defined in <span class="literal">&lt;linux/fs.h&gt;</span>. Instead, there was a set of file system&#8211;specific header files that defined file system&#8211;specific constant names, all with the same value. Thus, <em>ext2</em> had <span class="literal">EXT2_APPEND_FL</span>, defined in <span class="literal">&lt;linux/ext2_fs.h&gt;</span>; <em>Reiserfs</em> had <span class="literal">REISERFS_APPEND_FL</span>, defined with the same value in <span class="literal">&lt;linux/reiser_fs.h&gt;</span>; and so on. Since each of the header files defines the corresponding constants with the same value, on older systems that don&#8217;t provide the definitions in <span class="literal">&lt;linux/fs.h&gt;</span>, it is possible to include any of the header files and use the file system&#8211;specific names.</p>
</div>
<p class="tablecap"><a id="ch15table6"/><strong>Table 15-6:</strong> I-node flags</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Constant</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong><em>chattr</em> option</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Purpose</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">FS_APPEND_FL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">a</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Append only (privilege required)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">FS_COMPR_FL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">c</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Enable file compression (not implemented)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">FS_DIRSYNC_FL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">D</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Synchronous directory updates (since Linux 2.6)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">FS_IMMUTABLE_FL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">i</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Immutable (privilege required)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">FS_JOURNAL_DATA_FL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">j</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Enable data journaling (privilege required)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">FS_NOATIME_FL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">A</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Don&#8217;t update file last access time</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">FS_NODUMP_FL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">d</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">No dump</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">FS_NOTAIL_FL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">t</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">No tail packing</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">FS_SECRM_FL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">s</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Secure deletion (not implemented)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">FS_SYNC_FL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">S</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Synchronous file (and directory) updates</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">FS_TOPDIR_FL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">T</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Treat as top-level directory for Orlov (since Linux 2.6)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">FS_UNRM_FL</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec"><span class="literal">u</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">File can be undeleted (not implemented)</p></td>
</tr>
</tbody>
</table>
<p class="noindentb"><span epub:type="pagebreak" id="page_306"/>The various <span class="literal">FS_*</span> flags and their meanings are as follows:</p>
<p class="term"><span class="literal">FS_APPEND_FL</span></p>
<p class="termlist">The file can be opened for writing only if the <span class="literal">O_APPEND</span> flag is specified (thus forcing all file updates to append to the end of the file). This flag could be used for a log file, for example. Only privileged (<span class="literal">CAP_LINUX_IMMUTABLE</span>) processes can set this flag.</p>
<p class="term"><span class="literal">FS_COMPR_FL</span></p>
<p class="termlist">Store the file on disk in a compressed format. This feature is not implemented as a standard part of any of the major native Linux file systems. (There are packages that implement this feature for <em>ext2</em> and <em>ext3</em>.) Given the low cost of disk storage, the CPU overhead involved in compression and decompression, and the fact that compressing a file means that it is no longer a simple matter to randomly access the file&#8217;s contents (via <em>lseek()</em>), file compression is undesirable for many applications.</p>
<p class="term"><span class="literal">FS_DIRSYNC_FL</span> (since Linux 2.6)</p>
<p class="termlist">Make directory updates (e.g., <em>open(pathname, O_CREAT)</em>, <em>link()</em>, <em>unlink()</em>, and <em>mkdir()</em>) synchronous. This is analogous to the synchronous file update mechanism described in <a href="ch13.xhtml#ch13lev1sec03">Section 13.3</a>. As with synchronous file updates, there is a performance impact associated with synchronous directory updates. This setting can be applied only to directories. (The <span class="literal">MS_DIRSYNC</span> mount flag described in <a href="ch14.xhtml#ch14lev2sec01">Section 14.8.1</a> provides similar functionality, but on a per-mount basis.)</p>
<p class="term"><span class="literal">FS_IMMUTABLE_FL</span></p>
<p class="termlist">Make the file immutable. File data can&#8217;t be updated (<em>write()</em> and <em>truncate()</em>) and metadata changes are prevented (e.g., <em>chmod()</em>, <em>chown()</em>, <em>unlink()</em>, <em>link()</em>, <em>rename()</em>, <em>rmdir()</em>, <em>utime()</em>, <em>setxattr()</em>, and <em>removexattr()</em>). Only privileged (<span class="literal">CAP_LINUX_IMMUTABLE</span>) processes can set this flag for a file. When this flag is set, even a privileged process can&#8217;t change the file contents or metadata.</p>
<p class="term"><span class="literal">FS_JOURNAL_DATA_FL</span></p>
<p class="termlist">Enable journaling of data. This flag is supported only on the <em>ext3</em> and <em>ext4</em> file systems. These file systems provide three levels of journaling: <em>journal</em>, <em>ordered</em>, and <em>writeback</em>. All modes journal updates to file metadata, but the <em>journal</em> mode additionally journals updates to file data. On a file system that is journaling in <em>ordered</em> or <em>writeback</em> mode, a privileged (<span class="literal">CAP_SYS_RESOURCE</span>) process can enable journaling of data updates on a per-file basis by setting this flag. (The <em>mount(8)</em> manual page describes the difference between the <em>ordered</em> and <em>writeback</em> modes.)</p>
<p class="term"><span class="literal">FS_NOATIME_FL</span></p>
<p class="termlist">Don&#8217;t update the file last access time when the file is accessed. This eliminates the need to update the file&#8217;s i-node each time the file is accessed, thus improving I/O performance (see the description of the <span class="literal">MS_NOATIME</span> flag in <a href="ch14.xhtml#ch14lev2sec01">Section 14.8.1</a>).</p>
<p class="term"><span epub:type="pagebreak" id="page_307"/><span class="literal">FS_NODUMP_FL</span></p>
<p class="termlist">Don&#8217;t include this file in backups made using <em>dump(8)</em>. The effect of this flag is dependent on the <em>&#8211;h</em> option described in the <em>dump(8)</em> manual page.</p>
<p class="term"><span class="literal">FS_NOTAIL_FL</span></p>
<p class="termlist">Disable tail packing. This flag is supported only on the <em>Reiserfs</em> file system. It disables the <em>Reiserfs</em> tail-packing feature, which tries to pack small files (and the final fragment of larger files) into the same disk block as the file metadata. Tail packing can also be disabled for an entire <em>Reiserfs</em> file system by mounting it with the <em>mount &#8211;o notail</em> option.</p>
<p class="term"><span class="literal">FS_SECRM_FL</span></p>
<p class="termlist">Delete the file securely. The intended purpose of this unimplemented feature is that, when removed, a file is securely deleted, meaning that it is first overwritten to prevent a disk-scanning program from reading or re-creating it. (The issue of truly secure deletion is rather complex: it can actually require multiple writes on magnetic media to securely erase previously recorded data; see [<a href="bib.xhtml#bib39">Gutmann, 1996</a>].)</p>
<p class="term"><span class="literal">FS_SYNC_FL</span></p>
<p class="termlist">Make file updates synchronous. When applied to files, this flag causes writes to the file to be synchronous (as though the <span class="literal">O_SYNC</span> flag was specified on all opens of this file). When applied to a directory, this flag has the same effect as the synchronous directory updates flag described above.</p>
<p class="term"><span class="literal">FS_TOPDIR_FL</span> (since Linux 2.6)</p>
<p class="termlist">This marks a directory for special treatment under the <em>Orlov</em> block-allocation strategy. The Orlov strategy is a BSD-inspired modification of the <em>ext2</em> block-allocation strategy that tries to improve the chances that related files (e.g., the files within a single directory) are placed close to each other on disk, which can improve disk seek times. For details, see [<a href="bib.xhtml#bib15">Corbet, 2002</a>] and [<a href="bib.xhtml#bib51">Kumar, et al. 2008</a>]. <span class="literal">FS_TOPDIR_FL</span> has an effect only for <em>ext2</em> and its descendants, <em>ext3</em> and <em>ext4</em>.</p>
<p class="term"><span class="literal">FS_UNRM_FL</span></p>
<p class="termlist">Allow this file to be recovered (undeleted) if it is deleted. This feature is not implemented, since it is possible to implement file-recovery mechanisms outside the kernel.</p>
<p class="noindenttb">Generally, when i-node flags are set on a directory, they are automatically inherited by new files and subdirectories created in that directory. There are exceptions to this rule:</p>
<p class="bull">&#8226; The <span class="literal">FS_DIRSYNC_FL</span> (<em>chattr +D</em>) flag, which can be applied only to a directory, is inherited only by subdirectories created in that directory.</p>
<p class="bull">&#8226; When the <span class="literal">FS_IMMUTABLE_FL</span> (<em>chattr +i</em>) flag is applied to a directory, it is not inherited by files and subdirectories created within that directory, since this flag prevents new entries being added to the directory.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_308"/>Within a program, i-node flags can be retrieved and modified using the <em>ioctl()</em> <span class="literal">FS_IOC_GETFLAGS</span> and <span class="literal">FS_IOC_SETFLAGS</span> operations. (These constants are defined in <span class="literal">&lt;linux/fs.h&gt;</span>.) The following code shows how to enable the <span class="literal">FS_NOATIME_FL</span> flag on the file referred to by the open file descriptor <em>fd</em>:</p>
<p class="programs">int attr;<br/><br/>if (ioctl(fd, FS_IOC_GETFLAGS, &#38;attr) == -1)&#160;&#160;&#160;&#160;/* Fetch current flags */<br/>&#160;&#160;&#160;&#160;errExit("ioctl");<br/>attr |= FS_NOATIME_FL;<br/>if (ioctl(fd, FS_IOC_SETFLAGS, &#38;attr) == -1)&#160;&#160;&#160;&#160;/* Update flags */<br/>&#160;&#160;&#160;&#160;errExit("ioctl");</p>
<p class="noindent">In order to change the i-node flags of a file, either the effective user ID of the process must match the user ID (owner) of the file, or the process must be privileged (<span class="literal">CAP_FOWNER</span>). (To be strictly accurate, on Linux, for an unprivileged process it is the process&#8217;s file-system user ID, rather than its effective user ID, that must match the user ID of the file, as described in <a href="ch09.xhtml#ch09lev1sec05">Section 9.5</a>.)</p>
<h3 class="h3" id="ch15lev1sec06"><strong>15.6 Summary</strong></h3>
<p class="noindenta">The <em>stat()</em> system call retrieves information about a file (metadata), most of which is drawn from the file i-node. This information includes file ownership, file permissions, and file timestamps.</p>
<p class="indent">A program can update a file&#8217;s last access time and last modification time using <em>utime()</em>, <em>utimes()</em>, and various similar interfaces.</p>
<p class="indent">Each file has an associated user ID (owner) and group ID, as well as a set of permission bits. For permissions purposes, file users are divided into three categories: <em>owner</em> (also known as <em>user</em>), <em>group</em>, and <em>other</em>. Three permissions may be granted to each category of user: <em>read</em>, <em>write</em>, and <em>execute</em>. The same scheme is used with directories, although the permission bits have slightly different meanings. The <em>chown()</em> and <em>chmod()</em> system calls change the ownership and permissions of a file. The <em>umask()</em> system call sets a mask of permission bits that are always turned off when the calling process creates a file.</p>
<p class="indent">Three additional permission bits are used for files and directories. The set-user-ID and set-group-ID permission bits can be applied to program files to create programs that cause the executing process to gain privilege by assuming a different effective user or group identity (that of the program file). For directories residing on file systems mounted using the <em>nogrpid</em> (<em>sysvgroups</em>) option, the set-group-ID permission bit can be used to control whether new files created in the directory inherit their group ID from the process&#8217;s effective group ID or from the parent directory&#8217;s group ID. When applied to directories, the sticky permission bit acts as the restricted deletion flag.</p>
<p class="indent">I-node flags control the various behaviors of files and directories. Although originally defined for <em>ext2</em>, these flags are now supported on several other file systems.</p>
<h3 class="h3" id="ch15lev1sec07"><span epub:type="pagebreak" id="page_309"/><strong>15.7 Exercises</strong></h3>
<p class="exer"><a id="ch15exe1"/><strong>15-1.</strong>&#160;&#160;&#160;<a href="ch15.xhtml#ch15lev1sec04">Section 15.4</a> contained several statements about the permissions required for various file-system operations. Use shell commands or write programs to verify or answer the following:</p>
<p class="olista1">a) Removing all owner permissions from a file denies the file owner access, even though group and other do have access.</p>
<p class="olista1">b) On a directory with read permission but not execute permission, the names of files in the directory can be listed, but the files themselves can&#8217;t be accessed, regardless of the permissions on them.</p>
<p class="olista1">c) What permissions are required on the parent directory and the file itself in order to create a new file, open a file for reading, open a file for writing, and delete a file? What permissions are required on the source and target directory to rename a file? If the target file of a rename operation already exists, what permissions are required on that file? How does setting the sticky permission bit (<em>chmod +t</em>) of a directory affect renaming and deletion operations?</p>
<p class="exer"><a id="ch15exe2"/><strong>15-2.</strong>&#160;&#160;&#160;Do you expect any of a file&#8217;s three timestamps to be changed by the <em>stat()</em> system call? If not, explain why.</p>
<p class="exer"><a id="ch15exe3"/><strong>15-3.</strong>&#160;&#160;&#160;On a system running Linux 2.6, modify the program in <a href="ch15.xhtml#ch15ex1">Listing 15-1</a> (<span class="literal">t_stat.c</span>) so that the file timestamps are displayed with nanosecond accuracy.</p>
<p class="exer"><a id="ch15exe4"/><strong>15-4.</strong>&#160;&#160;&#160;The <em>access()</em> system call checks permissions using the process&#8217;s real user and group IDs. Write a corresponding function that performs the checks according to the process&#8217;s effective user and group IDs.</p>
<p class="exer"><a id="ch15exe5"/><strong>15-5.</strong>&#160;&#160;&#160;As noted in <a href="ch15.xhtml#ch15lev2sec10">Section 15.4.6</a>, <em>umask()</em> always sets the process umask and, at the same time, returns a copy of the old umask. How can we obtain a copy of the current process umask while leaving it unchanged?</p>
<p class="exer"><a id="ch15exe6"/><strong>15-6.</strong>&#160;&#160;&#160;The <em>chmod a+rX file</em> command enables read permission for all categories of user, and likewise enables execute permission for all categories of user if <em>file</em> is a directory or execute permission is enabled for any of the user categories for <em>file</em>, as demonstrated in the following example:</p>
<p class="programs1">$ <span class="codestrong">ls -ld dir file prog</span><br/>dr--------&#160;&#160;2 mtk users&#160;&#160;&#160;&#160;48 May&#160;&#160;4 12:28 dir<br/>-r--------&#160;&#160;1 mtk users 19794 May&#160;&#160;4 12:22 file<br/>-r-x------&#160;&#160;1 mtk users 19336 May&#160;&#160;4 12:21 prog<br/>$ <span class="codestrong">chmod a+rX dir file prog</span><br/>$ <span class="codestrong">ls -ld dir file prog</span><br/>dr-xr-xr-x&#160;&#160;2 mtk users&#160;&#160;&#160;&#160;48 May&#160;&#160;4 12:28 dir<br/>-r--r--r--&#160;&#160;1 mtk users 19794 May&#160;&#160;4 12:22 file<br/>-r-xr-xr-x&#160;&#160;1 mtk users 19336 May&#160;&#160;4 12:21 prog</p>
<p class="exerp">Write a program that uses <em>stat()</em> and <em>chmod()</em> to perform the equivalent of <em>chmod a+rX</em>.</p>
<p class="exer"><a id="ch15exe7"/><strong>15-7.</strong>&#160;&#160;&#160;Write a simple version of the <em>chattr(1)</em> command, which modifies file i-node flags. See the <em>chattr(1)</em> man page for details of the <em>chattr</em> command-line interface. (You don&#8217;t need to implement the <em>&#8211;R</em>, <em>&#8211;V</em>, and <em>&#8211;v</em> options.)<span epub:type="pagebreak" id="page_310"/></p>
</body>
</html>
