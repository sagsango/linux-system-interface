<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch39"><span epub:type="pagebreak" id="page_797"/><strong><span class="big">39</span></strong><br/><strong>CAPABILITIES</strong></h2>
<p class="noindenta">This chapter describes the Linux capabilities scheme, which divides the traditional all-or-nothing UNIX privilege scheme into individual capabilities that can be independently enabled or disabled. Using capabilities allows a program to perform some privileged operations, while preventing it from performing others.</p>
<h3 class="h3" id="ch39lev1sec01"><strong>39.1 Rationale for Capabilities</strong></h3>
<p class="noindenta">The traditional UNIX privilege scheme divides processes into two categories: those whose effective user ID is 0 (superuser), which bypass all privilege checks, and all other processes, which are subject to privilege checking according to their user and group IDs.</p>
<p class="indent">The coarse granularity of this scheme is a problem. If we want to allow a process to perform some operation that is permitted only to the superuser&#8212;for example, changing the system time&#8212;then we must run that process with an effective user ID of 0. (If an unprivileged user needs to perform such operations, this is typically implemented using a set-user-ID-<em>root</em> program.) However, this grants the process privileges to perform a host of other actions as well&#8212;for example, bypassing all permission checks when accessing files&#8212;thus opening the door for a range of security breaches if the program behaves in unexpected ways (which may be the consequence of unforeseen circumstances, or because of deliberate manipulation by a malicious user). The traditional way of dealing with this problem was outlined in <a href="ch38.xhtml#ch38">Chapter 38</a>: we drop effective privileges (i.e., change from an effective user ID of 0, while maintaining 0 in the saved set-user-ID) and temporarily reacquire them only when needed.</p>
<p class="indent"><span epub:type="pagebreak" id="page_798"/>The Linux capability scheme refines the handling of this problem. Rather than using a single privilege (i.e., effective user ID of 0) when performing security checks in the kernel, the superuser privilege is divided into distinct units, called <em>capabilities</em>. Each privileged operation is associated with a particular capability, and a process can perform that operation only if it has the corresponding capability (regardless of its effective user ID). Put another way, everywhere in this book that we talk about a privileged process on Linux, what we really mean is a process that has the relevant capability for performing a particular operation.</p>
<p class="indent">Most of the time, the Linux capability scheme is invisible to us. The reason for this is that when an application that is unaware of capabilities assumes an effective user ID of 0, the kernel grants that process the complete range of capabilities.</p>
<p class="indent">The Linux capabilities implementation is based on the POSIX 1003.1e draft standard (<em><a href="http://wt.tuxomania.net/publications/posix.1e/">http://wt.tuxomania.net/publications/posix.1e/</a></em>). This standardization effort foundered in the late 1990s before it was completed, but various capabilities implementations are nevertheless based on the draft standard. (Some of the capabilities listed in <a href="ch39.xhtml#ch39table1">Table 39-1</a> are defined in the POSIX.1e draft, but many are Linux extensions.)</p>
<div class="block">
<p class="noindent">Capability schemes are provided in a few other UNIX implementations, such as in Sun&#8217;s Solaris 10 and earlier Trusted Solaris releases, SGI&#8217;s Trusted Irix, and as part of the TrustedBSD project for FreeBSD ([<a href="bib.xhtml#bib109">Watson, 2000</a>]). Similar schemes exist in some other operating systems; for example, the privilege mechanism in Digital&#8217;s VMS system.</p>
</div>
<h3 class="h3" id="ch39lev1sec02"><strong>39.2 The Linux Capabilities</strong></h3>
<p class="noindenta"><a href="ch39.xhtml#ch39table1">Table 39-1</a> lists the Linux capabilities and provides an abbreviated (and incomplete) guide to the operations to which they apply.</p>
<h3 class="h3" id="ch39lev1sec03"><strong>39.3 Process and File Capabilities</strong></h3>
<p class="noindenta">Each process has three associated capability sets&#8212;termed <em>permitted</em>, <em>effective</em>, and <em>inheritable</em>&#8212;that can contain zero or more of the capabilities listed in <a href="ch39.xhtml#ch39table1">Table 39-1</a>. Each file can likewise have three associated capability sets, with the same names. (For reasons that will become evident, the file effective capability set is really just a single bit that is either enabled or disabled.) We go into the details of each of these capability sets in the following sections.</p>
<h4 class="h4" id="ch39lev2sec01"><strong>39.3.1 Process Capabilities</strong></h4>
<p class="noindentab">For each process, the kernel maintains three capability sets (implemented as bit masks) in which zero or more of the capabilities specified in <a href="ch39.xhtml#ch39table1">Table 39-1</a> are enabled. The three sets are as follows:</p>
<p class="bull">&#8226; <em>Permitted</em>: These are the capabilities that a process <em>may</em> employ. The permitted set is a limiting superset for the capabilities that can be added to the effective and inheritable sets. If a process drops a capability from its permitted set, it can never reacquire that capability (unless it execs a program that once more confers the capability).</p>
<p class="bull"><span epub:type="pagebreak" id="page_799"/>&#8226; <em>Effective</em>: These are the capabilities used by the kernel to perform privilege checking for the process. As long as it maintains a capability in its permitted set, a process can temporarily disable the capability by dropping it from the effective set, and then later restoring it to that set.</p>
<p class="bull">&#8226; <em>Inheritable</em>: These are capabilities that may be carried over to the permitted set when a program is execed by this process.</p>
<p class="noindentt">We can view hexadecimal representations of the three capability sets for any process in the three fields <span class="literal">CapInh</span>, <span class="literal">CapPrm</span>, and <span class="literal">CapEff</span> in the Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/status</span> file.</p>
<div class="block">
<p class="noindent">The <em>getpcaps</em> program (part of the <em>libcap</em> package described in <a href="ch39.xhtml#ch39lev1sec07">Section 39.7</a>) can be used to display the capabilities of a process in an easier-to-read format.</p>
</div>
<p class="noindent">A child process produced via <em>fork()</em> inherits copies of its parent&#8217;s capability sets. We describe the treatment of capability sets during an <em>exec()</em> in <a href="ch39.xhtml#ch39lev1sec05">Section 39.5</a>.</p>
<div class="block">
<p class="noindent">In reality, capabilities are a per-thread attribute that can be adjusted independently for each of the threads in a process. The capabilities of a specific thread within a multithreaded process are shown in the <span class="literal">/proc/</span><em>PID</em><span class="literal">/task/</span><em>TID</em><span class="literal">/status</span> file. The <span class="literal">/proc/</span><em>PID</em><span class="literal">/status</span> file shows the capabilities of the main thread.</p>
<p class="indent">Before kernel 2.6.25, Linux represented capability sets using 32 bits. The addition of further capabilities in kernel 2.6.25 required a move to 64-bit sets.</p>
</div>
<h4 class="h4" id="ch39lev2sec02"><strong>39.3.2 File Capabilities</strong></h4>
<p class="noindentab">If a file has associated capability sets, then these sets are used to determine the capabilities that are given to a process if it execs that file. There are three file capability sets:</p>
<p class="bull">&#8226; <em>Permitted</em>: This is a set of capabilities that may be added to the process&#8217;s permitted set during an <em>exec()</em>, regardless of the process&#8217;s existing capabilities.</p>
<p class="bull">&#8226; <em>Effective</em>: This is just a single bit. If it is enabled, then, during an <em>exec()</em>, the capabilities that are enabled in the process&#8217;s new permitted set are also enabled in the process&#8217;s new effective set. If the file effective bit is disabled, then, after an <em>exec()</em>, the process&#8217;s new effective set is initially empty.</p>
<p class="bull">&#8226; <em>Inheritable</em>: This set is masked against the process&#8217;s inheritable set to determine a set of capabilities that are to be enabled in the process&#8217;s permitted set after an <em>exec()</em>.</p>
<p class="noindentt"><a href="ch39.xhtml#ch39lev1sec05">Section 39.5</a> provides details of how file capabilities are used during an <em>exec()</em>.</p>
<div class="block">
<p class="noindent">The permitted and inheritable file capabilities were formerly known as <em>forced</em> and <em>allowed</em>. Those terms are now obsolete, but they are still informative. The permitted file capabilities are the ones that are <em>forced</em> into the process&#8217;s permitted set during an <em>exec()</em>, regardless of the process&#8217;s existing capabilities. The inheritable file capabilities are the ones that the file <em>allows</em> into the process&#8217;s permitted set during an <em>exec()</em>, if those capabilities are also enabled in the process&#8217;s inheritable capability set.</p>
<p class="indent">The capabilities associated with a file are stored in a <em>security</em> extended attribute (<a href="ch16.xhtml#ch16lev1sec01">Section 16.1</a>) named <em>security.capability</em>. The <span class="literal">CAP_SETFCAP</span> capability is required to update this extended attribute.</p>
</div>
<p class="tablecap"><span epub:type="pagebreak" id="page_800"/><a id="ch39table1"/><strong>Table 39-1:</strong> Operations permitted by each Linux capability</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Capability</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Permits process to</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_AUDIT_CONTROL</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">(Since Linux 2.6.11) Enable and disable kernel audit logging; change filtering rules for auditing; retrieve auditing status and filtering rules</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_AUDIT_WRITE</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">(Since Linux 2.6.11) Write records to the kernel auditing log</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_CHOWN</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Change file&#8217;s user ID (owner) or change file&#8217;s group ID to a group of which process is not a member (<em>chown()</em>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_DAC_OVERRIDE</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Bypass file read, write, and execute permission checks (DAC is an abbreviation for discretionary access control); read contents of <span class="literal">cwd</span>, <span class="literal">exe</span>, and <span class="literal">root</span> symbolic links in <span class="literal">/proc/</span><em>PID</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_DAC_READ_SEARCH</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Bypass file read permission checks and directory read and execute (search) permission checks</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_FOWNER</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Generally ignore permission checks on operations that normally require the process&#8217;s file-system user ID to match the file&#8217;s user ID (<em>chmod()</em>, <em>utime()</em>); set i-node flags on arbitrary files; set and modify ACLs on arbitrary files; ignore effect of directory sticky bit when deleting files (<em>unlink()</em>, <em>rmdir()</em>, <em>rename()</em>); specify <span class="literal">O_NOATIME</span> flag for arbitrary files in <em>open()</em> and <em>fcntl(F_SETFL)</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_FSETID</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Modify a file without having the kernel turn off set-user-ID and set-group-ID bits (<em>write()</em>, <em>truncate()</em>); enable set-group-ID bit for a file whose group ID doesn&#8217;t match the process&#8217;s file-system group ID or supplementary group IDs (<em>chmod()</em>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_IPC_LOCK</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Override memory-locking restrictions (<em>mlock()</em>, <em>mlockall()</em>, <em>shmctl(SHM_LOCK)</em>, <em>shmctl(SHM_UNLOCK)</em>); employ <em>shmget()</em> <span class="literal">SHM_HUGETLB</span> flag and <em>mmap()</em> <span class="literal">MAP_HUGETLB</span> flag.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_IPC_OWNER</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Bypass permission checks for operations on System V IPC objects</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_KILL</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Bypass permission checks for sending signals (<em>kill()</em>, <em>sigqueue()</em>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_LEASE</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">(Since Linux 2.4) Establish leases on arbitrary files (<em>fcntl(F_SETLEASE)</em>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_LINUX_IMMUTABLE</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Set append and immutable i-node flags</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_MAC_ADMIN</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">(Since Linux 2.6.25) Configure or make state changes for mandatory access control (MAC) (implemented by some Linux security modules)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_MAC_OVERRIDE</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">(Since Linux 2.6.25) Override MAC (implemented by some Linux security modules)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_MKNOD</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">(Since Linux 2.4) Use <em>mknod()</em> to create devices</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_NET_ADMIN</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Perform various network-related operations (e.g., setting privileged socket options, enabling multicasting, configuring network interfaces, and modifying routing tables)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_NET_BIND_SERVICE</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Bind to privileged socket ports</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_NET_BROADCAST</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">(Unused) Perform socket broadcasts and listen to multicasts</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_NET_RAW</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Use raw and packet sockets</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_SETGID</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Make arbitrary changes to process group IDs (<em>setgid()</em>, <em>setegid()</em>, <em>setregid()</em>, <em>setresgid()</em>, <em>setfsgid()</em>, <em>setgroups()</em>, <em>initgroups()</em>); forge group ID when passing credentials via UNIX domain socket (<span class="literal">SCM_CREDENTIALS</span>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_SETFCAP</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">(Since Linux 2.6.24) Set file capabilities</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span epub:type="pagebreak" id="page_801"/><span class="literal">CAP_SETPCAP</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">If file capabilities are not supported, grant and remove capabilities in the process&#8217;s permitted set to or from any other process (including self); if file capabilities are supported, add any capability in the process&#8217;s capability bounding set to its inheritable set, drop capabilities from the bounding set, and change <em>securebits</em> flags</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_SETUID</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Make arbitrary changes to process user IDs (<em>setuid()</em>, <em>seteuid()</em>, <em>setreuid()</em>, <em>setresuid()</em>, <em>setfsuid()</em>); forge user ID when passing credentials via UNIX domain socket (<span class="literal">SCM_CREDENTIALS</span>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_SYS_ADMIN</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Exceed <span class="literal">/proc/sys/fs/file-max</span> limit in system calls that open files (e.g., <em>open()</em>, <em>shm_open()</em>, <em>pipe()</em>, <em>socket()</em>, <em>accept()</em>, <em>exec()</em>, <em>acct()</em>, <em>epoll_create()</em>); perform various system administration operations, including <em>quotactl()</em> (control disk quotas), <em>mount()</em> and <em>umount()</em>, <em>swapon()</em> and <em>swapoff()</em>, <em>pivot_root()</em>, <em>sethostname()</em> and <em>setdomainname()</em>; perform various <em>syslog(2)</em> operations; override <span class="literal">RLIMIT_NPROC</span> resource limit (<em>fork()</em>); call <em>lookup_dcookie()</em>; set <em>trusted</em> and <em>security</em> extended attributes; perform <span class="literal">IPC_SET</span> and <span class="literal">IPC_RMID</span> operations on arbitrary System V IPC objects; forge process ID when passing credentials via UNIX domain socket (<span class="literal">SCM_CREDENTIALS</span>); use <em>ioprio_set()</em> to assign <span class="literal">IOPRIO_CLASS_RT</span> scheduling class; employ <span class="literal">TIOCCONS</span> <em>ioctl()</em>; employ namespace-creation flags with <em>clone()</em> and <em>unshare()</em>; perform <span class="literal">KEYCTL_CHOWN</span> and <span class="literal">KEYCTL_SETPERM</span> <em>keyctl()</em> operations; administer <em>random(4)</em> device; various device-specific operations</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_SYS_BOOT</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Use <em>reboot()</em> to reboot the system; call <em>kexec_load()</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_SYS_CHROOT</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Use <em>chroot()</em> to set process root directory</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_SYS_MODULE</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Load and unload kernel modules (<em>init_module()</em>, <em>delete_module()</em>, <em>create_module()</em>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_SYS_NICE</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Raise nice value (<em>nice()</em>, <em>setpriority()</em>); change nice value for arbitrary processes (<em>setpriority()</em>); set <span class="literal">SCHED_RR</span> and <span class="literal">SCHED_FIFO</span> realtime scheduling policies for calling process; reset <span class="literal">SCHED_RESET_ON_FORK</span> flag; set scheduling policies and priorities for arbitrary processes (<em>sched_setscheduler()</em>, <em>sched_setparam()</em>); set I/O scheduling class and priority for arbitrary processes (<em>ioprio_set()</em>); set CPU affinity for arbitrary processes (<em>sched_setaffinity()</em>); use <em>migrate_pages()</em> to migrate arbitrary processes and allow processes to be migrated to arbitrary nodes; apply <em>move_pages()</em> to arbitrary processes; use <span class="literal">MPOL_MF_MOVE_ALL</span> flag with <em>mbind()</em> and <em>move_pages()</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_SYS_PACCT</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Use <em>acct()</em> to enable or disable process accounting</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_SYS_PTRACE</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Trace arbitrary processes using <em>ptrace()</em>; access <span class="literal">/proc/</span><em>PID</em><span class="literal">/environ</span> for arbitrary processes; apply <em>get_robust_list()</em> to arbitrary processes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_SYS_RAWIO</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Perform operations on I/O ports using <em>iopl()</em> and <em>ioperm()</em>; access <span class="literal">/proc/kcore</span>; open <span class="literal">/dev/mem</span> and <span class="literal">/dev/kmem</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_SYS_RESOURCE</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Use reserved space on file systems; make <em>ioctl()</em> calls controlling <em>ext3</em> journaling; override disk quota limits; increase hard resource limits (<em>setrlimit()</em>); override <span class="literal">RLIMIT_NPROC</span> resource limit (<em>fork()</em>); raise <em>msg_qbytes</em> limit for a System V message queue above limit in <span class="literal">/proc/sys/kernel/msgmnb</span>; bypass various POSIX message queue limits defined by files under <span class="literal">/proc/sys/fs/mqueue</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CAP_SYS_TIME</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Modify system clock (<em>settimeofday()</em>, <em>stime()</em>, <em>adjtime()</em>, <em>adjtimex()</em>); set hardware clock</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">CAP_SYS_TTY_CONFIG</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Perform virtual hangup of terminal or pseudoterminal using <em>vhangup()</em></p></td>
</tr>
</tbody>
</table>
<h4 class="h4" id="ch39lev2sec03"><span epub:type="pagebreak" id="page_802"/><strong>39.3.3 Purpose of the Process Permitted and Effective Capability Sets</strong></h4>
<p class="noindenta">The <em>process permitted</em> capability set defines the capabilities that a process <em>may</em> employ. The <em>process effective</em> capability set defines the capabilities that are currently in effect for the process&#8212;that is, the set of capabilities that the kernel uses when checking whether the process has the necessary privilege to perform a particular operation.</p>
<p class="indent">The permitted capability set imposes an upper bound on the effective set. A process can <em>raise</em> a capability in its effective set only if that capability is in the permitted set. (The terms <em>add</em> to and <em>set</em> are sometimes used synonymously with <em>raise</em>. The converse operation is <em>drop</em>, or synonymously, <em>remove</em> or <em>clear</em>.)</p>
<div class="block">
<p class="noindent">The relationship between the effective and permitted capability sets is analogous to that between the effective user ID and the saved set-user-ID for a set-user-ID-<em>root</em> program. Dropping a capability from the effective set is analogous to temporarily dropping an effective user ID of 0, while maintaining 0 in the saved set-user-ID. Dropping a capability from both the effective and permitted capability sets is analogous to permanently dropping superuser privileges by setting both the effective user ID and the saved set-user-ID to nonzero values.</p>
</div>
<h4 class="h4" id="ch39lev2sec04"><strong>39.3.4 Purpose of the File Permitted and Effective Capability Sets</strong></h4>
<p class="noindenta">The <em>file permitted</em> capability set provides a mechanism by which an executable file can give capabilities to a process. It specifies a group of capabilities that are to be assigned to the process&#8217;s permitted capability set during an <em>exec()</em>.</p>
<p class="indentb">The <em>file effective</em> capability set is a single flag (bit) that is either enabled or disabled. To understand why this set consists of just a single bit, we need to consider the two cases that occur when a program is execed:</p>
<p class="bull">&#8226; The program may be <em>capability-dumb</em>, meaning that it doesn&#8217;t know about capabilities (i.e., it is designed as a traditional set-user-ID-<em>root</em> program). Such a program won&#8217;t know that it needs to raise capabilities in its effective set in order to be able to perform privileged operations. For such programs, an <em>exec()</em> should have the effect that all of the process&#8217;s new permitted capabilities are automatically also assigned to its effective set. This result is achieved by enabling the file effective bit.</p>
<p class="bull">&#8226; The program may be <em>capability-aware</em>, meaning that it has been designed with the capabilities framework in mind, and it will make the appropriate system calls (discussed later) to raise and drop capabilities in its effective set. For such programs, least-privilege considerations mean that, after an <em>exec()</em>, all capabilities should initially be disabled in the process&#8217;s effective capability set. This result is achieved by disabling the file effective capability bit.</p>
<h4 class="h4" id="ch39lev2sec05"><strong>39.3.5 Purpose of the Process and File Inheritable Sets</strong></h4>
<p class="noindentab">At first glance, the use of permitted and effective sets for processes and files might seem a sufficient framework for a capabilities system. However, there are some situations where they do not suffice. For example, what if a process performing an <em>exec()</em> wants to preserve some of its current capabilities across the <em>exec()</em>? It might <span epub:type="pagebreak" id="page_803"/>appear that the capabilities implementation could provide this feature simply by preserving the process&#8217;s permitted capabilities across an <em>exec()</em>. However, this approach would not handle the following cases:</p>
<p class="bull">&#8226; Performing the <em>exec()</em> might require certain privileges (e.g., <span class="literal">CAP_DAC_OVERRIDE</span>) that we don&#8217;t want to preserve across the <em>exec()</em>.</p>
<p class="bull">&#8226; Suppose that we explicitly dropped some permitted capabilities that we didn&#8217;t want to preserve across the <em>exec()</em>, but then the <em>exec()</em> failed. In this case, the program might need some of the permitted capabilities that it has already (irrevocably) dropped.</p>
<p class="noindentt">For these reasons, a process&#8217;s permitted capabilities are not preserved across an <em>exec()</em>. Instead, another capability set is introduced: the <em>inheritable set</em>. The inheritable set provides a mechanism by which a process can preserve some of its capabilities across an <em>exec()</em>.</p>
<p class="indent">The <em>process inheritable</em> capability set specifies a group of capabilities that may be assigned to the process&#8217;s permitted capability set during an <em>exec()</em>. The corresponding <em>file inheritable</em> set is masked (ANDed) against the process inherited capability set to determine the capabilities that are actually added to the process&#8217;s permitted capability set during an <em>exec()</em>.</p>
<div class="block">
<p class="noindent">There is a further, philosophical reason for not simply preserving the process permitted capability set across an <em>exec()</em>. The idea of the capabilities system is that all privileges given to a process are granted or controlled by the file that the process execs. Although the process inheritable set specifies capabilities that are passed across an <em>exec()</em>, these capabilities are masked by the file inheritable set.</p>
</div>
<h4 class="h4" id="ch39lev2sec06"><strong>39.3.6 Assigning and Viewing File Capabilities from the Shell</strong></h4>
<p class="noindenta">The <em>setcap(8)</em> and <em>getcap(8)</em> commands, contained in the <em>libcap</em> package described in <a href="ch39.xhtml#ch39lev1sec07">Section 39.7</a>, can be used to manipulate file capabilities sets. We demonstrate the use of these commands with a short example using the standard <em>date(1)</em> program. (This program is an example of a capability-dumb application according to the definition in <a href="ch39.xhtml#ch39lev2sec04">Section 39.3.4</a>.) When run with privilege, <em>date(1)</em> can be used to change the system time. The <em>date</em> program is not set-user-ID-<em>root</em>, so normally the only way to run it with privilege is to become the superuser.</p>
<p class="indent">We begin by displaying the current system time, and then try to change the time as an unprivileged user:</p>
<p class="programs">$ <span class="codestrong">date</span><br/>Tue Dec 28 15:54:08 CET 2010<br/>$ <span class="codestrong">date -s '2018-02-01 21:39'</span><br/>date: cannot set date: Operation not permitted<br/>Thu Feb&#160;&#160;1 21:39:00 CET 2018</p>
<p class="noindent">Above, we see that the <em>date</em> command failed to change the system time, but nevertheless displayed its argument in the standard format.</p>
<p class="indent"><span epub:type="pagebreak" id="page_804"/>Next, we become the superuser, which allows us to successfully change the system time:</p>
<p class="programs">$ <span class="codestrong">sudo date -s '2018-02-01 21:39'</span><br/>root's password:<br/>Thu Feb&#160;&#160;1 21:39:00 CET 2018<br/>$ <span class="codestrong">date</span><br/>Thu Feb&#160;&#160;1 21:39:02 CET 2018</p>
<p class="noindent">We now make a copy of the <em>date</em> program and assign it the capability that it needs:</p>
<p class="programs">$ <span class="codestrong">whereis -b date</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Find location of date binary</span><br/>date: /bin/date<br/>$ <span class="codestrong">cp /bin/date .</span><br/>$ <span class="codestrong">sudo setcap "cap_sys_time=pe" date</span><br/>root's password:<br/>$ <span class="codestrong">getcap date</span><br/>date = cap_sys_time+ep</p>
<p class="noindent">The <em>setcap</em> command shown above assigns the <span class="literal">CAP_SYS_TIME</span> capability to the permitted (<em>p</em>) and effective (<em>e</em>) capability sets of the executable file. We then used the <em>getcap</em> command to verify the capabilities assigned to the file. (The syntax used by <em>setcap</em> and <em>getcap</em> for representing capability sets is described in the <em>cap_from_text(3)</em> manual page provided in the <em>libcap</em> package.)</p>
<p class="indent">The file capabilities of our copy of the <em>date</em> program allow the program to be used by unprivileged users to set the system time:</p>
<p class="programs">$ <span class="codestrong">./date -s '2010-12-28 15:55'</span><br/>Tue Dec 28 15:55:00 CET 2010<br/>$ <span class="codestrong">date</span><br/>Tue Dec 28 15:55:02 CET 2010</p>
<h3 class="h3" id="ch39lev1sec04"><strong>39.4 The Modern Capabilities Implementation</strong></h3>
<p class="noindentab">A complete implementation of capabilities requires the following:</p>
<p class="bull">&#8226; For each privileged operation, the kernel should check whether the process has the relevant capability, rather than checking for an effective (or file system) user ID of 0.</p>
<p class="bull">&#8226; The kernel must provide system calls allowing a process&#8217;s capabilities to be retrieved and modified.</p>
<p class="bull">&#8226; The kernel must support the notion of attaching capabilities to an executable file, so that the process gains the associated capabilities when that file is execed. This is analogous to the set-user-ID bit, but allows the independent specification of all capabilities on the executable file. In addition, the system must provide a set of programming interfaces and commands for setting and viewing the capabilities attached to an executable file.</p>
<p class="noindentt">Up to and including kernel 2.6.23, Linux met only the first two of these requirements. Since kernel 2.6.24, it is possible to attach capabilities to a file. Various <span epub:type="pagebreak" id="page_805"/>other features were added in kernels 2.6.25 and 2.6.26 in order to complete the capabilities implementation.</p>
<p class="indent">For most of our discussion of capabilities, we&#8217;ll focus on the modern implementation. In <a href="ch39.xhtml#ch39lev1sec10">Section 39.10</a>, we consider how the implementation differed before file capabilities were introduced. Furthermore, file capabilities are an optional kernel component in modern kernels, but for the main part of our discussion, we&#8217;ll assume that this component is enabled. Later, we&#8217;ll describe the differences that occur if file capabilities are not enabled. (In several respects, the behavior is similar to that of Linux in kernels before 2.6.24, where file capabilities were not implemented.)</p>
<p class="indent">In the following sections, we go into more detail on the Linux capabilities implementation.</p>
<h3 class="h3" id="ch39lev1sec05"><strong>39.5 Transformation of Process Capabilities During <em>exec()</em></strong></h3>
<p class="noindenta">During an <em>exec()</em>, the kernel sets new capabilities for the process based on the process&#8217;s current capabilities and the capability sets of the file being executed. The kernel calculates the new capabilities of the process using the following rules:</p>
<p class="programs">P'(permitted) = (P(inheritable) &#38; F(inheritable)) | (F(permitted) &#38; cap_bset)<br/><br/>P'(effective) = F(effective) ? P'(permitted) : 0<br/><br/>P'(inheritable) = P(inheritable)</p>
<p class="noindent">In the above rules, <em>P</em> denotes the value of a capability set prior to the <em>exec()</em>, <em>P&#8217;</em> denotes the value of a capability set after the <em>exec()</em>, and <em>F</em> denotes a file capability set. The identifier <em>cap_bset</em> denotes the value of the capability bounding set. Note that <em>exec()</em> leaves the process inheritable capability set unchanged.</p>
<h4 class="h4" id="ch39lev2sec07"><strong>39.5.1 Capability Bounding Set</strong></h4>
<p class="noindentab">The capability bounding set is a security mechanism that is used to limit the capabilities that a process can gain during an <em>exec()</em>. This set is used as follows:</p>
<p class="bull">&#8226; During an <em>exec()</em>, the capability bounding set is ANDed with the file permitted capabilities to determine the permitted capabilities that are to be granted to the new program. In other words, an executable file&#8217;s permitted capability set can&#8217;t grant a permitted capability to a process if the capability is not in the bounding set.</p>
<p class="bull">&#8226; The capability bounding set is a limiting superset for the capabilities that can be added to the process&#8217;s inheritable set. This means that, unless the capability is in the bounding set, a process can&#8217;t add one of its permitted capabilities to its inheritable set and then&#8212;via the first of the capability transformation rules described above&#8212;have that capability preserved in its permitted set when it execs a file that has the capability in its inheritable set.</p>
<p class="noindentt">The capability bounding set is a per-process attribute that is inherited by a child created via <em>fork()</em>, and preserved across an <em>exec()</em>. On a kernel that supports file capabilities, <em>init</em> (the ancestor of all processes) starts with a capability bounding set that contains all capabilities.</p>
<p class="indent"><span epub:type="pagebreak" id="page_806"/>If a process has the <span class="literal">CAP_SETPCAP</span> capability, then it can (irreversibly) remove capabilities from its bounding set using the <em>prctl()</em> <span class="literal">PR_CAPBSET_DROP</span> operation. (Dropping a capability from the bounding set doesn&#8217;t affect the process permitted, effective, and inheritable capability sets.) A process can determine if a capability is in its bounding set using the <em>prctl()</em> <span class="literal">PR_CAPBSET_READ</span> operation.</p>
<div class="block">
<p class="noindent">More precisely, the capability bounding set is a per-thread attribute. Starting with Linux 2.6.26, this attribute is displayed as the <span class="literal">CapBnd</span> field in the Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/task/</span><em>TID</em><span class="literal">/status</span> file. The <span class="literal">/proc/</span><em>PID</em><span class="literal">/status</span> file shows the bounding set of a process&#8217;s main thread.</p>
</div>
<h4 class="h4" id="ch39lev2sec08"><strong>39.5.2 Preserving <em>root</em> Semantics</strong></h4>
<p class="noindentab">In order to preserve the traditional semantics for the <em>root</em> user (i.e., <em>root</em> has all privileges) when executing a file, any capability sets associated with the file are ignored. Instead, for the purposes of the algorithm shown in <a href="ch39.xhtml#ch39lev1sec05">Section 39.5</a>, the file capability sets are notionally defined as follows during an <em>exec()</em>:</p>
<p class="bull">&#8226; If a set-user-ID-<em>root</em> program is being execed, or the real or effective user ID of the process calling <em>exec()</em> is 0, then the file inheritable and permitted sets are defined to be all ones.</p>
<p class="bull">&#8226; If a set-user-ID-<em>root</em> program is being execed, or the effective user ID of the process calling <em>exec()</em> is 0, then the file effective bit is defined to be set.</p>
<p class="noindentt">Assuming that we are execing a set-user-ID-<em>root</em> program, these notional definitions of the file capability sets mean that the calculation of the process&#8217;s new permitted and effective capability sets in <a href="ch39.xhtml#ch39lev1sec05">Section 39.5</a> simplifies to the following:</p>
<p class="programs">P'(permitted) = P(inheritable) | cap_bset<br/>P'(effective) = P'(permitted)</p>
<h3 class="h3" id="ch39lev1sec06"><strong>39.6 Effect on Process Capabilities of Changing User IDs</strong></h3>
<p class="noindenta">To preserve compatibility with the traditional meanings for transitions between 0 and nonzero user IDs, the kernel does the following when changing process user IDs (using <em>setuid()</em>, and so on):</p>
<ol>
<li class="order"><p class="orderp">If the real user ID, effective user ID, or saved set-user-ID previously had the value 0 and, as a result of the changes to the user IDs, all three of these IDs have a nonzero value, then the permitted and effective capability sets are cleared (i.e., all capabilities are permanently dropped).</p></li>
<li class="order"><p class="orderp">If the effective user ID is changed from 0 to a nonzero value, then the effective capability set is cleared (i.e., the effective capabilities are dropped, but those in the permitted set can be raised again).</p></li>
<li class="order"><p class="orderp">If the effective user ID is changed from a nonzero value to 0, then the permitted capability set is copied into the effective capability set (i.e., all permitted capabilities become effective).</p></li>
<li class="order"><p class="orderp"><span epub:type="pagebreak" id="page_807"/>If the file-system user ID is changed from 0 to a nonzero value, then the following file-related capabilities are cleared from the effective capability set: <span class="literal">CAP_CHOWN</span>, <span class="literal">CAP_DAC_OVERRIDE</span>, <span class="literal">CAP_DAC_READ_SEARCH</span>, <span class="literal">CAP_FOWNER</span>, <span class="literal">CAP_FSETID</span>, <span class="literal">CAP_LINUX_IMMUTABLE</span> (since Linux 2.6.30), <span class="literal">CAP_MAC_OVERRIDE</span>, and <span class="literal">CAP_MKNOD</span> (since Linux 2.6.30). Conversely, if the file-system user ID is changed from a nonzero value to 0, then any of these capabilities that are enabled in the permitted set are enabled in the effective set. These manipulations are done to maintain the traditional semantics for manipulations of the Linux-specific file-system user ID.</p></li>
</ol>
<h3 class="h3" id="ch39lev1sec07"><strong>39.7 Changing Process Capabilities Programmatically</strong></h3>
<p class="noindenta">A process can raise or drop capabilities from its capability sets using either the <em>capset()</em> system call or, preferably, the <em>libcap</em> API, which we describe below. Changes to process capabilities are subject to the following rules:</p>
<ol>
<li class="order"><p class="orderp">If the process doesn&#8217;t have the <span class="literal">CAP_SETPCAP</span> capability in its effective set, then the new <em>inheritable</em> set must be a subset of the combination (union) of the existing inheritable and permitted sets.</p></li>
<li class="order"><p class="orderp">The new <em>inheritable</em> set must be a subset of the combination (union) of the existing inheritable set and the capability bounding set.</p></li>
<li class="order"><p class="orderp">The new <em>permitted</em> set must be a subset of the existing permitted set. In other words, a process can&#8217;t grant itself permitted capabilities that it doesn&#8217;t have. Put another way, a capability dropped from the permitted set can&#8217;t be reacquired.</p></li>
<li class="order"><p class="orderp">The new <em>effective</em> set is allowed to contain only capabilities that are also in the new permitted set.</p></li>
</ol>
<h5 class="h5" id="ch39lev3sec01"><strong>The <em>libcap</em> API</strong></h5>
<p class="noindenta">Up to this point, we have deliberately not shown the prototype of the <em>capset()</em> system call, or its counterpart <em>capget()</em>, which retrieves a process&#8217;s capabilities. This is because the use of these system calls should be avoided. Instead, the functions in the <em>libcap</em> library should be employed. These functions provide an interface that conforms with the withdrawn draft POSIX 1003.1e standard, along with some Linux extensions.</p>
<p class="indent">For reasons of space, we don&#8217;t describe the <em>libcap</em> API in detail. As an overview, we note that programs employing these functions typically carry out the following steps:</p>
<ol>
<li class="order"><p class="orderp">Use the <em>cap_get_proc()</em> function to retrieve a copy of the process&#8217;s current capability sets from the kernel and place it in a structure that the function allocates in user space. (Alternatively, we may use the <em>cap_init()</em> function to create a new, empty capability set structure.) In the <em>libcap</em> API, the <em>cap_t</em> data type is a pointer used to refer to such structures.</p></li>
<li class="order"><p class="orderp">Use the <em>cap_set_flag()</em> function to update the user-space structure to raise (<span class="literal">CAP_SET</span>) and drop (<span class="literal">CAP_CLEAR</span>) capabilities from the permitted, effective, and inheritable sets stored in the user-space structure retrieved in the previous step.</p></li>
<li class="order"><p class="orderp"><span epub:type="pagebreak" id="page_808"/>Use the <em>cap_set_proc()</em> function to pass the user-space structure back to the kernel in order to change the process&#8217;s capabilities.</p></li>
<li class="order"><p class="orderp">Use the <em>cap_free()</em> function to free the structure that was allocated by the <em>libcap</em> API in the first step.</p></li>
</ol>
<div class="block">
<p class="noindent">At the time of writing, work is in progress on <em>libcap-ng</em>, a new, improved capabilities library API. Details can be found at <em><a href="https://people.redhat.com/sgrubb/libcap-ng/">https://people.redhat.com/sgrubb/libcap-ng/</a></em>.</p>
</div>
<h5 class="h5" id="ch39lev3sec02"><strong>Example program</strong></h5>
<p class="noindenta">In <a href="ch08.xhtml#ch8ex2">Listing 8-2</a>, on <a href="ch08.xhtml#page_164">page 164</a>, we presented a program that authenticates a username plus password against the standard password database. We noted that the program requires privilege in order to read the shadow password file, which is protected to prevent reading by users other than <em>root</em> or members of the <em>shadow</em> group. The traditional way of providing this program with the privileges that it requires would be to run it under a <em>root</em> login or to make it a set-user-ID-<em>root</em> program. We now present a modified version of this program that employs capabilities and the <em>libcap</em> API.</p>
<p class="indent">In order to read the shadow password file as a normal user, we need to bypass the standard file permission checks. Scanning the capabilities listed in <a href="ch39.xhtml#ch39table1">Table 39-1</a>, we see that the appropriate capability is <span class="literal">CAP_DAC_READ_SEARCH</span>. Our modified version of the password authentication program is shown in <a href="ch39.xhtml#ch39ex1">Listing 39-1</a>. This program uses the <em>libcap</em> API to raise <span class="literal">CAP_DAC_READ_SEARCH</span> in its effective capability set just before accessing the shadow password file, and then drops the capability again immediately after this access. In order for an unprivileged user to employ the program, we must set this capability in the file permitted capability set, as shown in the following shell session:</p>
<p class="programs">$ <span class="codestrong">sudo setcap "cap_dac_read_search=p" check_password_caps</span><br/>root's password:<br/>$ <span class="codestrong">getcap check_password_caps</span><br/>check_password_caps = cap_dac_read_search+p<br/>$ <span class="codestrong">./check_password_caps</span><br/>Username: <span class="codestrong">mtk</span><br/>Password:<br/>Successfully authenticated: UID=1000</p>
<p class="examplet"><a id="ch39ex1"/><strong>Listing 39-1:</strong> A capability-aware program that authenticates a user</p>
<p class="programsli">_________________________________________________ <span class="codestrong">cap/check_password_caps.c</span><br/><br/>#define _BSD_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get getpass() declaration from &lt;unistd.h&gt; */<br/>#define _XOPEN_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get crypt() declaration from &lt;unistd.h&gt; */<br/>#include &lt;sys/capability.h&gt;<br/>#include &lt;unistd.h&gt;<br/>#include &lt;limits.h&gt;<br/>#include &lt;pwd.h&gt;<br/>#include &lt;shadow.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>/* Change setting of capability in caller's effective capabilities */<br/><br/>static int<br/>modifyCap(int capability, int setting)<br/><span epub:type="pagebreak" id="page_809"/>{<br/>&#160;&#160;&#160;&#160;cap_t caps;<br/>&#160;&#160;&#160;&#160;cap_value_t capList[1];<br/><br/>&#160;&#160;&#160;&#160;/* Retrieve caller's current capabilities */<br/><br/>&#160;&#160;&#160;&#160;caps = cap_get_proc();<br/>&#160;&#160;&#160;&#160;if (caps == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/>&#160;&#160;&#160;&#160;/* Change setting of 'capability' in the effective set of 'caps'. The<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;third argument, 1, is the number of items in the array 'capList'. */<br/><br/>&#160;&#160;&#160;&#160;capList[0] = capability;<br/>&#160;&#160;&#160;&#160;if (cap_set_flag(caps, CAP_EFFECTIVE, 1, capList, setting) == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cap_free(caps);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;/* Push modified capability sets back to kernel, to change<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;caller's capabilities */<br/><br/>&#160;&#160;&#160;&#160;if (cap_set_proc(caps) == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cap_free(caps);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;/* Free the structure that was allocated by libcap */<br/><br/>&#160;&#160;&#160;&#160;if (cap_free(caps) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>static int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Raise capability in caller's effective set */<br/>raiseCap(int capability)<br/>{<br/>&#160;&#160;&#160;&#160;return modifyCap(capability, CAP_SET);<br/>}<br/><br/>/* An analogous dropCap() (unneeded in this program), could be<br/>&#160;&#160;&#160;defined as: modifyCap(capability, CAP_CLEAR); */<br/><br/>static int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Drop all capabilities from all sets */<br/>dropAllCaps(void)<br/>{<br/>&#160;&#160;&#160;&#160;cap_t empty;<br/>&#160;&#160;&#160;&#160;int s;<br/><br/>&#160;&#160;&#160;&#160;empty = cap_init();<br/>&#160;&#160;&#160;&#160;if (empty == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/>&#160;&#160;&#160;&#160;s = cap_set_proc(empty);<br/><span epub:type="pagebreak" id="page_810"/>&#160;&#160;&#160;&#160;if (cap_free(empty) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/>&#160;&#160;&#160;&#160;return s;<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;char *username, *password, *encrypted, *p;<br/>&#160;&#160;&#160;&#160;struct passwd *pwd;<br/>&#160;&#160;&#160;&#160;struct spwd *spwd;<br/>&#160;&#160;&#160;&#160;Boolean authOk;<br/>&#160;&#160;&#160;&#160;size_t len;<br/>&#160;&#160;&#160;&#160;long lnmax;<br/><br/>&#160;&#160;&#160;&#160;lnmax = sysconf(_SC_LOGIN_NAME_MAX);<br/>&#160;&#160;&#160;&#160;if (lnmax == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If limit is indeterminate */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lnmax = 256;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* make a guess */<br/><br/>&#160;&#160;&#160;&#160;username = malloc(lnmax);<br/>&#160;&#160;&#160;&#160;if (username == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("malloc");<br/><br/>&#160;&#160;&#160;&#160;printf("Username: ");<br/>&#160;&#160;&#160;&#160;fflush(stdout);<br/>&#160;&#160;&#160;&#160;if (fgets(username, lnmax, stdin) == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Exit on EOF */<br/><br/>&#160;&#160;&#160;&#160;len = strlen(username);<br/>&#160;&#160;&#160;&#160;if (username[len - 1] == '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;username[len - 1] = '\0';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Remove trailing '\n' */<br/><br/>&#160;&#160;&#160;&#160;pwd = getpwnam(username);<br/>&#160;&#160;&#160;&#160;if (pwd == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("couldn't get password record");<br/><br/>&#160;&#160;&#160;&#160;/* Only raise CAP_DAC_READ_SEARCH for as long as we need it */<br/><br/>&#160;&#160;&#160;&#160;if (raiseCap(CAP_DAC_READ_SEARCH) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("raiseCap() failed");<br/><br/>&#160;&#160;&#160;&#160;spwd = getspnam(username);<br/>&#160;&#160;&#160;&#160;if (spwd == NULL &#38;&#38; errno == EACCES)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("no permission to read shadow password file");<br/><br/>&#160;&#160;&#160;&#160;/* At this point, we won't need any more capabilities,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;so drop all capabilities from all sets */<br/><br/>&#160;&#160;&#160;&#160;if (dropAllCaps() == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("dropAllCaps() failed");<br/><br/>&#160;&#160;&#160;&#160;if (spwd != NULL)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If there is a shadow password record */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pwd-&gt;pw_passwd = spwd-&gt;sp_pwdp;&#160;&#160;&#160;&#160;&#160;/* Use the shadow password */<br/><br/><span epub:type="pagebreak" id="page_811"/>&#160;&#160;&#160;&#160;password = getpass("Password: ");<br/><br/>&#160;&#160;&#160;&#160;/* Encrypt password and erase cleartext version immediately */<br/><br/>&#160;&#160;&#160;&#160;encrypted = crypt(password, pwd-&gt;pw_passwd);<br/>&#160;&#160;&#160;&#160;for (p = password; *p != '\0'; )<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*p++ = '\0';<br/><br/>&#160;&#160;&#160;&#160;if (encrypted == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("crypt");<br/><br/>&#160;&#160;&#160;&#160;authOk = strcmp(encrypted, pwd-&gt;pw_passwd) == 0;<br/>&#160;&#160;&#160;&#160;if (!authOk) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Incorrect password\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;printf("Successfully authenticated: UID=%ld\n", (long) pwd-&gt;pw_uid);<br/><br/>&#160;&#160;&#160;&#160;/* Now do authenticated work... */<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________ <span class="codestrong">cap/check_password_caps.c</span></p>
<h3 class="h3" id="ch39lev1sec08"><strong>39.8 Creating Capabilities-Only Environments</strong></h3>
<p class="noindentab">In the preceding pages, we have described various ways in which a process with the user ID 0 (<em>root</em>) is treated specially with respect to capabilities:</p>
<p class="bull">&#8226; When a process with one or more user IDs that equal 0 sets all of its user IDs to nonzero values, its permitted and effective capability sets are cleared. (See <a href="ch39.xhtml#ch39lev1sec06">Section 39.6</a>.)</p>
<p class="bull">&#8226; When a process with an effective user ID of 0 changes that user ID to a nonzero value, it loses its effective capabilities. When the reverse change is made, the permitted capability set is copied to the effective set. A similar procedure is followed for a subset of capabilities when the process&#8217;s file-system user ID is switched between 0 and nonzero values. (See <a href="ch39.xhtml#ch39lev1sec06">Section 39.6</a>.)</p>
<p class="bull">&#8226; If a process with real or effective user ID of <em>root</em> execs a program, or any process execs a set-user-ID-<em>root</em> program, then the file inheritable and permitted sets are notionally defined to be all ones. If the process&#8217;s effective user ID is 0, or it is execing a set-user-ID-<em>root</em> program, then the file effective bit is notionally defined to be 1. (See <a href="ch39.xhtml#ch39lev2sec08">Section 39.5.2</a>.) In the usual cases (i.e., both the real and effective user ID are <em>root</em>, or a set-user-ID-<em>root</em> program is being execed), this means the process gets all capabilities in its permitted and effective sets.</p>
<p class="noindentt">In a fully capability-based system, the kernel would not need to perform any of these special treatments of <em>root</em>. There would be no set-user-ID-<em>root</em> programs, and file capabilities would be used to grant just the minimum capabilities that a program requires.</p>
<p class="indent"><span epub:type="pagebreak" id="page_812"/>Since existing applications aren&#8217;t engineered to make use of the file-capabilities infrastructure, the kernel must maintain the traditional handling of processes with the user ID 0. Nevertheless, we may want an application to run in a purely capability-based environment in which <em>root</em> gets none of the special treatments described above. Starting with kernel 2.6.26, and if file capabilities are enabled in the kernel, Linux provides the <em>securebits</em> mechanism, which controls a set of per-process flags that enable or disable each of the three special treatments for <em>root</em>. (To be precise, the <em>securebits</em> flags are actually a per-thread attribute.)</p>
<p class="indent">The <em>securebits</em> mechanism controls the flags shown in <a href="ch39.xhtml#ch39table2">Table 39-2</a>. The flags exist as related pairs of a <em>base</em> flag and a corresponding <em>locked</em> flag. Each of the base flags controls one of the special treatments of <em>root</em> described above. Setting the corresponding locked flag is a one-time operation that prevents further changes to the associated base flag&#8212;once set, the locked flag can&#8217;t be unset.</p>
<p class="tablecap"><a id="ch39table2"/><strong>Table 39-2:</strong> The <em>securebits</em> flags</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Flag</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Meaning if set</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SECBIT_KEEP_CAPS</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Don&#8217;t drop permitted capabilities when a process with one or more 0 user IDs sets all of its user IDs to nonzero values. This flag has an effect only if <span class="literal">SECBIT_NO_SETUID_FIXUP</span> is not also set. This flag is cleared on an <em>exec()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SECBIT_NO_SETUID_FIXUP</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Don&#8217;t change capabilities when effective or file-system user IDs are switched between 0 and nonzero values.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">SECBIT_NOROOT</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">If a process with a real or effective user ID of 0 does an <em>exec()</em>, or it execs a set-user-ID-<em>root</em> program, don&#8217;t grant it capabilities (unless the executable has file capabilities).</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SECBIT_KEEP_CAPS_LOCKED</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Lock <span class="literal">SECBIT_KEEP_CAPS</span>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SECBIT_NO_SETUID_FIXUP_LOCKED</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Lock <span class="literal">SECBIT_NO_SETUID_FIXUP</span>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">SECBIT_NOROOT_LOCKED</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Lock <span class="literal">SECBIT_NOROOT</span>.</p></td>
</tr>
</tbody>
</table>
<p class="noindent">The <em>securebits</em> flag settings are inherited in a child created by <em>fork()</em>. All of the flag settings are preserved during <em>exec()</em>, except <span class="literal">SECBIT_KEEP_CAPS</span>, which is cleared for historical compatibility with the <span class="literal">PR_SET_KEEPCAPS</span> setting, described below.</p>
<p class="indent">A process can retrieve the <em>securebits</em> flags using the <em>prctl()</em> <span class="literal">PR_GET_SECUREBITS</span> operation. If a process has the <span class="literal">CAP_SETPCAP</span> capability, it can modify the <em>securebits</em> flags using the <em>prctl()</em> <span class="literal">PR_SET_SECUREBITS</span> operations. A purely capability-based application can irreversibly disable special treatment of <em>root</em> for the calling process and all of its descendants using the following call:</p>
<p class="programs">if (prctl(PR_SET_SECUREBITS,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* SECBIT_KEEP_CAPS off */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SECBIT_NO_SETUID_FIXUP | SECBIT_NO_SETUID_FIXUP_LOCKED |<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SECBIT_NOROOT | SECBIT_NOROOT_LOCKED)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;== -1)<br/>&#160;&#160;&#160;&#160;errExit("prctl");</p>
<p class="noindent">After this call, the only way in which this process and its descendants can obtain capabilities is by executing programs that have file capabilities.</p>
<h5 class="h5" id="ch39lev3sec03"><span epub:type="pagebreak" id="page_813"/><span class="literal"><span class="codestrong">SECBIT_KEEP_CAPS</span></span> <strong>and the <em>prctl()</em></strong> <span class="literal"><span class="codestrong">PR_SET_KEEPCAPS</span></span> <strong>operation</strong></h5>
<p class="noindenta">The <span class="literal">SECBIT_KEEP_CAPS</span> flag prevents capabilities from being dropped when a process with one or more user IDs with the value 0 sets all of its user IDs to nonzero values. Roughly speaking, <span class="literal">SECBIT_KEEP_CAPS</span> provides half of the functionality provided by <span class="literal">SECBIT_NO_SETUID_FIXUP</span>. (As noted in <a href="ch39.xhtml#ch39table2">Table 39-2</a>, <span class="literal">SECBIT_KEEP_CAPS</span> has an effect only if <span class="literal">SECBIT_NO_SETUID_FIXUP</span> is not set.) This flag exists to provide a <em>securebits</em> flag that mirrors the older <em>prctl()</em> <span class="literal">PR_SET_KEEPCAPS</span> operation, which controls the same attribute. (The one difference between the two mechanisms is that a process doesn&#8217;t need the <span class="literal">CAP_SETPCAP</span> capability to employ the <em>prctl()</em> <span class="literal">PR_SET_KEEPCAPS</span> operation.)</p>
<div class="block">
<p class="noindent">Earlier, we noted that all of the <em>securebits</em> flags are preserved during an <em>exec()</em>, except <span class="literal">SECBIT_KEEP_CAPS</span>. The setting of the <span class="literal">SECBIT_KEEP_CAPS</span> bit was made the converse of the other <em>securebits</em> settings in order to maintain consistency with the treatment of the attribute set by the <em>prctl()</em> <span class="literal">PR_SET_KEEPCAPS</span> operation.</p>
</div>
<p class="noindent">The <em>prctl()</em> <span class="literal">PR_SET_KEEPCAPS</span> operation is designed for use by set-user-ID-<em>root</em> programs running on older kernels that don&#8217;t support file capabilities. Such programs can still improve their security by programmatically dropping and raising capabilities as required (refer to <a href="ch39.xhtml#ch39lev1sec10">Section 39.10</a>).</p>
<p class="indent">However, even if such a set-user-ID-<em>root</em> program drops all capabilities except those that it requires, it still maintains two important privileges: the ability to access files owned by <em>root</em> and the ability to regain capabilities by execing a program (<a href="ch39.xhtml#ch39lev2sec08">Section 39.5.2</a>). The only way of permanently dropping these privileges is to set all of the process&#8217;s user IDs to nonzero values. But doing that normally results in the clearing of the permitted and effective capability sets (see the four points in <a href="ch39.xhtml#ch39lev1sec06">Section 39.6</a> concerning the effect of user ID changes on capabilities). This defeats the purpose, which is to permanently drop user ID 0, while maintaining some capabilities. To allow this possibility, the <em>prctl()</em> <span class="literal">PR_SET_KEEPCAPS</span> operation can be used to set the process attribute that prevents the permitted capability set from being cleared when all user IDs are changed to a nonzero value. (The process&#8217;s effective capability set is always cleared in this case, regardless of the setting of the &#8220;keep capabilities&#8221; attribute.)</p>
<h3 class="h3" id="ch39lev1sec09"><strong>39.9 Discovering the Capabilities Required by a Program</strong></h3>
<p class="noindentab">Suppose we have a program that is unaware of capabilities and that is provided only in binary form, or we have a program whose source code is too large for us to easily read to determine which capabilities might be required to run it. If the program requires privileges, but shouldn&#8217;t be a set-user-ID-<em>root</em> program, then how can we determine the permitted capabilities to assign to the executable file with <em>setcap(8)</em>? There are two ways to answer this question:</p>
<p class="bull">&#8226; Use <em>strace(1)</em> (<a href="app01.xhtml#app01">Appendix A</a>) to see which system call fails with the error <span class="literal">EPERM</span>, the error used to indicate the lack of a required capability. By consulting the system call&#8217;s manual page or the kernel source code, we can then deduce what capability is required. This approach isn&#8217;t perfect, because an <span class="literal">EPERM</span> error can occasionally be generated for other reasons, some of which may have nothing to do with the capability requirements for the program. Furthermore, programs may legitimately make a system call that requires privilege, and then <span epub:type="pagebreak" id="page_814"/>change their behavior after determining that they don&#8217;t have privilege for a particular operation. It can sometimes be difficult to distinguish such &#8220;false positives&#8221; when trying to determine the capabilities that an executable really does need.</p>
<p class="bull">&#8226; Use a kernel probe to produce monitoring output when the kernel is asked to perform capability checks. An example of how to do this is provided in [<a href="bib.xhtml#bib40">Hallyn, 2007</a>], an article written by one of the developers of file capabilities. For each request to check a capability, the probe shown in the article logs the kernel function that was called, the capability that was requested, and the name of the requesting program. Although this approach requires more work than the use of <em>strace(1)</em>, it can also help us more accurately determine the capabilities that a program requires.</p>
<h3 class="h3" id="ch39lev1sec10"><strong>39.10 Older Kernels and Systems Without File Capabilities</strong></h3>
<p class="noindentab">In this section, we describe various differences in the implementation of capabilities in older kernels. We also describe the differences that occur on kernels where file capabilities are not supported. There are two scenarios where Linux doesn&#8217;t support file capabilities:</p>
<p class="bull">&#8226; Before Linux 2.6.24, file capabilities were not implemented.</p>
<p class="bull">&#8226; In Linux kernel versions 2.6.24 through to 2.6.32, file capabilities can be disabled if the kernel is built without the <span class="literal">CONFIG_SECURITY_FILE_CAPABILITIES</span> option. (This also disables the securebits mechanism described in <a href="ch39.xhtml#ch39lev1sec08">Section 39.8</a>.)</p>
<div class="block">
<p class="noindent">Although Linux introduced capabilities and allowed them to be attached to processes starting with kernel 2.2, the implementation of file capabilities appeared only several years later. The reasons that file capabilities remained unimplemented for so long were matters of policy, rather than technical difficulties. (Extended attributes, described in <a href="ch16.xhtml#ch16">Chapter 16</a>, which are used to implement file capabilities, had been available since kernel 2.6.) The weight of opinion among kernel developers was that requiring system administrators to set and monitor different sets of capabilities&#8212;some of whose consequences are subtle but far-reaching&#8212;for each privileged program would create an unmanageably complex administration task. By contrast, system administrators are familiar with the existing UNIX privilege model, know to treat set-user-ID programs with due caution, and can locate the set-user-ID and set-group-ID programs on a system using simple <em>find</em> commands. Nevertheless, the developers of file capabilities made the case that file capabilities could be made administratively workable, and eventually provided a convincing enough argument that file capabilities were integrated into the kernel.</p>
</div>
<h5 class="h5" id="ch39lev3sec04"><strong>The</strong> <span class="literal"><span class="codestrong">CAP_SETPCAP</span></span> <strong>capability</strong></h5>
<p class="noindenta">On kernels that don&#8217;t support file capabilities (i.e., any kernel before 2.6.24, and kernels since 2.6.24 with file capabilities disabled), the semantics of the <span class="literal">CAP_SETPCAP</span> capability are different. Subject to rules that are analogous to those described in <a href="ch39.xhtml#ch39lev1sec07">Section 39.7</a>, a process that has the <span class="literal">CAP_SETPCAP</span> capability in its effective set can theoretically change the capabilities of processes other than itself. Changes can be made to the capabilities of another process, all of the members of a specified process <span epub:type="pagebreak" id="page_815"/>group, or all processes on the system except <em>init</em> and the caller itself. The final case excludes <em>init</em> because it is fundamental to the operation of the system. It also excludes the caller because the caller may be attempting to remove capabilities from every other process on the system, and we don&#8217;t want to remove the capabilities from the calling process itself.</p>
<p class="indent">However, changing the capabilities of other processes is only a theoretical possibility. On older kernels, and on modern kernels where support for file capabilities is disabled, the capability bounding set (discussed next) always masks out the <span class="literal">CAP_SETPCAP</span> capability.</p>
<h5 class="h5" id="ch39lev3sec05"><strong>The capability bounding set</strong></h5>
<p class="noindenta">Since Linux 2.6.25, the capability bounding set is a per-process attribute. However, on older kernels, the capability bounding set is a system-wide attribute that affects all processes on the system. The system-wide capability bounding set is initialized so that it always masks out <span class="literal">CAP_SETPCAP</span> (described above).</p>
<div class="block">
<p class="noindent">On kernels after 2.6.25, removing capabilities from the per-process bounding set is supported only if file capabilities are enabled in the kernel. In that case, <em>init</em>, the ancestor of all processes, starts with a bounding set containing all capabilities, and a copy of that bounding set is inherited by other processes created on the system. If file capabilities are disabled, then, because of the differences in the semantics of <span class="literal">CAP_SETPCAP</span> described above, <em>init</em> starts with a bounding set that contains all capabilities except <span class="literal">CAP_SETPCAP</span>.</p>
</div>
<p class="noindent">There is one further change in the semantics of the capability bounding set in Linux 2.6.25. As noted earlier (<a href="ch39.xhtml#ch39lev2sec07">Section 39.5.1</a>), on Linux 2.6.25 and later, the per-process capability bounding set acts as a limiting superset for the capabilities that can be added to the process&#8217;s inheritable set. In Linux 2.6.24 and earlier, the systemwide capability bounding set doesn&#8217;t have this masking effect. (It is not needed, because these kernels don&#8217;t support file capabilities.)</p>
<p class="indent">The system-wide capability bounding set is accessible via the Linux-specific <span class="literal">/proc/sys/kernel/cap-bound</span> file. A process must have the <span class="literal">CAP_SYS_MODULE</span> capability to be able to change the contents of <span class="literal">cap-bound</span>. However, only the <em>init</em> process can turn bits on in this mask; other privileged processes can only turn bits off. The upshot of these limitations is that on a system where file capabilities are not supported, we can never give the <span class="literal">CAP_SETPCAP</span> capability to a process. This is reasonable, since that capability can be used to subvert the entire kernel privilege-checking system. (In the unlikely case that we want to change this limitation, we must either load a kernel module that changes the value in the set, modify the source code of the <em>init</em> program, or change the initialization of the capability bounding set in the kernel source code and perform a kernel rebuild.)</p>
<div class="block">
<p class="noindent">Confusingly, although it is a bit mask, the value in the system-wide <span class="literal">cap-bound</span> file is displayed as a signed decimal number. For example, the initial value of this file is &#8211;257. This is the two&#8217;s complement interpretation of the bit mask with all bits except <em>(1 &lt;&lt; 8)</em> turned on (i.e., in binary, 11111111 11111111 11111110 11111111); <span class="literal">CAP_SETPCAP</span> has the value 8.</p>
</div>
<h5 class="h5" id="ch39lev3sec06"><span epub:type="pagebreak" id="page_816"/><strong>Using capabilities within a program on a system without file capabilities</strong></h5>
<p class="noindenta">Even on a system that doesn&#8217;t support file capabilities, we can nevertheless employ capabilities to improve the security of a program. We do this as follows:</p>
<ol>
<li class="order"><p class="orderp">Run the program in a process with an effective user ID of 0 (typically a set-user-ID-<em>root</em> program). Such a process is granted all capabilities (except <span class="literal">CAP_SETPCAP</span>, as noted earlier) in its permitted and effective sets.</p></li>
<li class="order"><p class="orderp">On program startup, use the <em>libcap</em> API to drop all capabilities from the effective set, and drop all capabilities except those that we may later need from the permitted set.</p></li>
<li class="order"><p class="orderp">Employ the call <em>prctl(PR_SET_KEEPCAPS, 1)</em> so that the next step does not drop capabilities (see <a href="ch39.xhtml#ch39lev1sec08">Section 39.8</a>).</p></li>
<li class="order"><p class="orderp">Set all user IDs to nonzero values, to prevent the process from accessing files owned by <em>root</em> or gaining capabilities by doing an <em>exec()</em>.</p>
<div class="block1b">
<p class="noindent">We could replace the two preceding steps by a single step that sets the <span class="literal">SECBIT_NOROOT</span> flag, if we want to prevent the process from regaining privileges on an <em>exec()</em>, but must allow it to access files owned by <em>root</em>. (Of course, allowing access to files owned by <em>root</em> leaves open the risk of some security vulnerability.)</p>
</div></li>
<li class="order"><p class="orderp">During the rest of the program&#8217;s lifetime, use the <em>libcap</em> API to raise and drop the remaining permitted capabilities from the effective set as needed in order to perform privileged tasks.</p></li>
</ol>
<p class="noindent">Some applications built for Linux kernels before version 2.6.24 employed this approach.</p>
<div class="block">
<p class="noindent">Among the kernel developers who argued against the implementation of capabilities for executable files, one of the perceived virtues of the approach described in the main text was that the developer of an application knows which capabilities an executable requires. By contrast, a system administrator may not be able to easily determine this information.</p>
</div>
<h3 class="h3" id="ch39lev1sec11"><strong>39.11 Summary</strong></h3>
<p class="noindenta">The Linux capabilities scheme divides privileged operations into distinct categories, and allows a process to be granted some capabilities, while being denied others. This scheme represents an improvement over the traditional all-or-nothing privilege mechanism, whereby a process has either privileges to perform all operations (user ID 0) or no privileges (nonzero user ID). Since kernel 2.6.24, Linux supports attaching capabilities to files, so that a process can gain selected capabilities by execing a program.</p>
<h3 class="h3" id="ch39lev1sec12"><strong>39.12 Exercise</strong></h3>
<p class="exer"><a id="ch39exe1"/><strong>39-1.</strong>&#160;&#160;&#160;Modify the program in <a href="ch35.xhtml#ch35ex2">Listing 35-2</a> (<span class="literal">sched_set.c</span>, on <a href="ch35.xhtml#page_743">page 743</a>) to use file capabilities, so that it can be used by an unprivileged user.</p>
</body>
</html>
