<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch54"><span epub:type="pagebreak" id="page_1107"/><strong><span class="big">54</span></strong><br/><strong>POSIX SHARED MEMORY</strong></h2>
<p class="noindentab">In previous chapters, we looked at two techniques that allow unrelated processes to share memory regions in order to perform IPC: System V shared memory (<a href="ch48.xhtml#ch48">Chapter 48</a>) and shared file mappings (<a href="ch49.xhtml#ch49lev2sec02">Section 49.4.2</a>). Both of these techniques have potential drawbacks:</p>
<p class="bull">&#8226; The System V shared memory model, which uses keys and identifiers, is not consistent with the standard UNIX I/O model, which uses filenames and descriptors. This difference means that we require an entirely new set of system calls and commands for working with System V shared memory segments.</p>
<p class="bull">&#8226; Using a shared file mapping for IPC requires the creation of a disk file, even if we are not interested in having a persistent backing store for the shared region. Aside from the inconvenience of needing to create the file, this technique incurs some file I/O overhead.</p>
<p class="noindentt">Because of these drawbacks, POSIX.1b defined a new shared memory API: POSIX shared memory, which is the subject of this chapter.</p>
<div class="block">
<p class="noindent">POSIX talks about shared memory <em>objects</em>, while System V talks about shared memory <em>segments</em>. These differences in terminology are historical&#8212;both terms are used for referring to regions of memory shared between processes.</p>
</div>
<h3 class="h3" id="ch54lev1sec01"><span epub:type="pagebreak" id="page_1108"/><strong>54.1 Overview</strong></h3>
<p class="noindenta">POSIX shared memory allows us to share a mapped region between unrelated processes without needing to create a corresponding mapped file. POSIX shared memory is supported on Linux since kernel 2.4.</p>
<p class="indent">SUSv3 doesn&#8217;t specify any of the details of how POSIX shared memory is to be implemented. In particular, there is no requirement for the use of a (real or virtual) file system to identify shared memory objects, although many UNIX implementations do employ a file system for this purpose. Some UNIX implementations create the names for shared memory objects as files in a special location in the standard file system. Linux uses a dedicated <em>tmpfs</em> file system (<a href="ch14.xhtml#ch14lev1sec10">Section 14.10</a>) mounted under the directory <span class="literal">/dev/shm</span> (<span class="literal">/run/shm</span> on some systems). This file system has kernel persistence&#8212;the shared memory objects that it contains will persist even if no process currently has them open, but they will be lost if the system is shut down.</p>
<div class="block">
<p class="noindent">The total amount of memory in all POSIX shared memory regions on the system is limited by the size of the underlying <em>tmpfs</em> file system. This file system is typically mounted at boot time with some default size (e.g., 256 MB). If necessary, the superuser can change the size of the file system by remounting it using the command <em>mount &#8211;o remount,size=&lt;num-bytes&gt;</em>.</p>
</div>
<p class="noindent">To use a POSIX shared memory object, we perform two steps:</p>
<ol>
<li class="order"><p class="orderp">Use the <em>shm_open()</em> function to open an object with a specified name. (We described the rules governing the naming of POSIX shared memory objects in <a href="ch51.xhtml#ch51lev1sec01">Section 51.1</a>.) The <em>shm_open()</em> function is analogous to the <em>open()</em> system call. It either creates a new shared memory object or opens an existing object. As its function result, <em>shm_open()</em> returns a file descriptor referring to the object.</p></li>
<li class="order"><p class="orderp">Pass the file descriptor obtained in the previous step in a call to <em>mmap()</em> that specifies <span class="literal">MAP_SHARED</span> in the <em>flags</em> argument. This maps the shared memory object into the process&#8217;s virtual address space. As with other uses of <em>mmap()</em>, once we have mapped the object, we can close the file descriptor without affecting the mapping. However, we may need to keep the file descriptor open for subsequent use in calls to <em>fstat()</em> and <em>ftruncate()</em> (see <a href="ch54.xhtml#ch54lev1sec02">Section 54.2</a>).</p></li>
</ol>
<div class="block2">
<p class="noindent">The relationship between <em>shm_open()</em> and <em>mmap()</em> for POSIX shared memory is analogous to that between <em>shmget()</em> and <em>shmat()</em> for System V shared memory. The origin of the two-step process (<em>shm_open()</em> plus <em>mmap()</em>) for using POSIX shared memory objects instead of the use of a single function that performs both tasks is historical. When the POSIX committee added this feature, the <em>mmap()</em> call already existed ([<a href="bib.xhtml#bib90">Stevens, 1999</a>]). In effect, all that we are doing is replacing calls to <em>open()</em> with calls to <em>shm_open()</em>, with the difference that using <em>shm_open()</em> doesn&#8217;t require the creation of a file in a disk-based file system.</p>
</div>
<p class="noindent">Since a shared memory object is referred to using a file descriptor, we can usefully employ various file descriptor system calls already defined in the UNIX system (e.g., <em>ftruncate()</em>), rather than needing new special-purpose system calls (as is required for System V shared memory).</p>
<h3 class="h3" id="ch54lev1sec02"><span epub:type="pagebreak" id="page_1109"/><strong>54.2 Creating Shared Memory Objects</strong></h3>
<p class="noindenta">The <em>shm_open()</em> function creates and opens a new shared memory object or opens an existing object. The arguments to <em>shm_open()</em> are analogous to those for <em>open()</em>.</p>
<div class="box">
<p class="programsa">#include &lt;fcntl.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Defines O_* constants */<br/>#include &lt;sys/stat.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Defines mode constants */<br/>#include &lt;sys/mman.h&gt;<br/><br/>int <span class="codestrong">shm_open</span>(const char *<span class="font1">name</span>, int <span class="font1">oflag</span>, mode_t <span class="font1">mode</span>);</p>
<p class="right">Returns file descriptor on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>name</em> argument identifies the shared memory object to be created or opened. The <em>oflag</em> argument is a mask of bits that modify the behavior of the call. The values that can be included in this mask are summarized in <a href="ch54.xhtml#ch54table1">Table 54-1</a>.</p>
<p class="tablecap"><a id="ch54table1"/><strong>Table 54-1:</strong> Bit values for the <em>shm_open() oflag</em> argument</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Flag</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_CREAT</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Create object if it doesn&#8217;t already exist</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">O_EXCL</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">With <span class="literal">O_CREAT</span>, create object exclusively</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_RDONLY</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Open for read-only access</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">O_RDWR</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Open for read-write access</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">O_TRUNC</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Truncate object to zero length</p></td>
</tr>
</tbody>
</table>
<p class="noindent">One of the purposes of the <em>oflag</em> argument is to determine whether we are opening an existing shared memory object or creating and opening a new object. If <em>oflag</em> doesn&#8217;t include <span class="literal">O_CREAT</span>, we are opening an existing object. If <span class="literal">O_CREAT</span> is specified, then the object is created if it doesn&#8217;t already exist. Specifying <span class="literal">O_EXCL</span> in conjunction with <span class="literal">O_CREAT</span> is a request to ensure that the caller is the creator of the object; if the object already exists, an error results (<span class="literal">EEXIST</span>).</p>
<p class="indent">The <em>oflag</em> argument also indicates the kind of access that the calling process will make to the shared memory object, by specifying exactly one of the values <span class="literal">O_RDONLY</span> or <span class="literal">O_RDWR</span>.</p>
<p class="indent">The remaining flag value, <span class="literal">O_TRUNC</span>, causes a successful open of an existing shared memory object to truncate the object to a length of zero.</p>
<div class="block">
<p class="noindent">On Linux, truncation occurs even on a read-only open. However, SUSv3 says that the result of using <span class="literal">O_TRUNC</span> with a read-only open is undefined, so we can&#8217;t portably rely on a specific behavior in this case.</p>
</div>
<p class="noindent">When a new shared memory object is created, its ownership and group ownership are taken from the effective user and group IDs of the process calling <em>shm_open()</em>, and the object permissions are set according to the value supplied in the <em>mode</em> bit-mask argument. The bit values for <em>mode</em> are the same as for files (<a href="ch15.xhtml#ch15table4">Table 15-4</a>, on <a href="ch15.xhtml#page_295">page 295</a>). As with the <em>open()</em> system call, the permissions mask in <em>mode</em> is masked <span epub:type="pagebreak" id="page_1110"/>against the process umask (<a href="ch15.xhtml#ch15lev2sec10">Section 15.4.6</a>). Unlike <em>open()</em>, the <em>mode</em> argument is always required for a call to <em>shm_open()</em>; if we are not creating a new object, this argument should be specified as 0.</p>
<p class="indent">The close-on-exec flag (<span class="literal">FD_CLOEXEC</span>, <a href="ch27.xhtml#ch27lev1sec04">Section 27.4</a>) is set on the file descriptor returned by <em>shm_open()</em>, so that the file descriptor is automatically closed if the process performs an <em>exec()</em>. (This is consistent with the fact that mappings are unmapped when an <em>exec()</em> is performed.)</p>
<p class="indent">When a new shared memory object is created, it initially has zero length. This means that, after creating a new shared memory object, we normally call <em>ftruncate()</em> (<a href="ch05.xhtml#ch05lev1sec08">Section 5.8</a>) to set the size of the object before calling <em>mmap()</em>. Following the <em>mmap()</em> call, we may also use <em>ftruncate()</em> to expand or shrink the shared memory object as desired, bearing in mind the points discussed in <a href="ch49.xhtml#ch49lev2sec03">Section 49.4.3</a>.</p>
<p class="indent">When a shared memory object is extended, the newly added bytes are automatically initialized to 0.</p>
<p class="indent">At any point, we can apply <em>fstat()</em> (<a href="ch15.xhtml#ch15lev1sec01">Section 15.1</a>) to the file descriptor returned by <em>shm_open()</em> in order to obtain a <em>stat</em> structure whose fields contain information about the shared memory object, including its size (<em>st_size</em>), permissions (<em>st_mode</em>), owner (<em>st_uid</em>), and group (<em>st_gid</em>). (These are the only fields that SUSv3 requires <em>fstat()</em> to set in the <em>stat</em> structure, although Linux also returns meaningful information in the time fields, as well as various other less useful information in the remaining fields.)</p>
<p class="indent">The permissions and ownership of a shared memory object can be changed using <em>fchmod()</em> and <em>fchown()</em>, respectively.</p>
<h5 class="h5" id="ch54lev3sec01"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch54.xhtml#ch54ex1">Listing 54-1</a> provides a simple example of the use of <em>shm_open()</em>, <em>ftruncate()</em>, and <em>mmap()</em>. This program creates a shared memory object whose size is specified by a command-line argument, and maps the object into the process&#8217;s virtual address space. (The mapping step is redundant, since we don&#8217;t actually do anything with the shared memory, but it serves to demonstrate the use of <em>mmap()</em>.) The program permits the use of command-line options to select flags (<span class="literal">O_CREAT</span> and <span class="literal">O_EXCL</span>) for the <em>shm_open()</em> call.</p>
<p class="indent">In the following example, we use this program to create a 10,000-byte shared memory object, and then use <em>ls</em> to show this object in <span class="literal">/dev/shm</span>:</p>
<p class="programs">$ <span class="codestrong">./pshm_create -c /demo_shm 10000</span><br/>$ <span class="codestrong">ls -l /dev/shm</span><br/>total 0<br/>-rw-------&#160;&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;&#160;&#160;10000 Jun 20 11:31 demo_shm</p>
<p class="examplet"><a id="ch54ex1"/><strong>Listing 54-1:</strong> Creating a POSIX shared memory object</p>
<p class="programsli">_______________________________________________________ <span class="codestrong">pshm/pshm_create.c</span><br/><br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include &lt;sys/mman.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/><span epub:type="pagebreak" id="page_1111"/>static void<br/>usageError(const char *progName)<br/>{<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "Usage: %s [-cx] name size [octal-perms]\n", progName);<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-c&#160;&#160;&#160;Create shared memory (O_CREAT)\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-x&#160;&#160;&#160;Create exclusively (O_EXCL)\n");<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int flags, opt, fd;<br/>&#160;&#160;&#160;&#160;mode_t perms;<br/>&#160;&#160;&#160;&#160;size_t size;<br/>&#160;&#160;&#160;&#160;void *addr;<br/><br/>&#160;&#160;&#160;&#160;flags = O_RDWR;<br/>&#160;&#160;&#160;&#160;while ((opt = getopt(argc, argv, "cx")) != -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (opt) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'c':&#160;&#160;&#160;flags |= O_CREAT;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'x':&#160;&#160;&#160;flags |= O_EXCL;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;usageError(argv[0]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (optind + 1 &gt;= argc)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0]);<br/><br/>&#160;&#160;&#160;&#160;size = getLong(argv[optind + 1], GN_ANY_BASE, "size");<br/>&#160;&#160;&#160;&#160;perms = (argc &lt;= optind + 2) ? (S_IRUSR | S_IWUSR) :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;getLong(argv[optind + 2], GN_BASE_8, "octal-perms");<br/><br/>&#160;&#160;&#160;&#160;/* Create shared memory object and set its size */<br/><br/>&#160;&#160;&#160;&#160;fd = shm_open(argv[optind], flags, perms);<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("shm_open");<br/><br/>&#160;&#160;&#160;&#160;if (ftruncate(fd, size) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("ftruncate");<br/><br/>&#160;&#160;&#160;&#160;/* Map shared memory object */<br/><br/>&#160;&#160;&#160;&#160;addr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);<br/>&#160;&#160;&#160;&#160;if (addr == MAP_FAILED)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mmap");<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_______________________________________________________ <span class="codestrong">pshm/pshm_create.c</span></p>
<h3 class="h3" id="ch54lev1sec03"><span epub:type="pagebreak" id="page_1112"/><strong>54.3 Using Shared Memory Objects</strong></h3>
<p class="noindenta"><a href="ch54.xhtml#ch54ex2">Listing 54-2</a> and <a href="ch54.xhtml#ch54ex3">Listing 54-3</a> demonstrate the use of a shared memory object to transfer data from one process to another. The program in <a href="ch54.xhtml#ch54ex2">Listing 54-2</a> copies the string contained in its second command-line argument into the existing shared memory object named in its first command-line argument. Before mapping the object and performing the copy, the program uses <em>ftruncate()</em> to resize the shared memory object to be the same length as the string that is to be copied.</p>
<p class="examplet"><a id="ch54ex2"/><strong>Listing 54-2:</strong> Copying data into a POSIX shared memory object</p>
<p class="programsli">________________________________________________________ <span class="codestrong">pshm/pshm_write.c</span><br/><br/>#include &lt;fcntl.h&gt;<br/>#include &lt;sys/mman.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int fd;<br/>&#160;&#160;&#160;&#160;size_t len;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Size of shared memory object */<br/>&#160;&#160;&#160;&#160;char *addr;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 3 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s shm-name string\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;fd = shm_open(argv[1], O_RDWR, 0);&#160;&#160;&#160;&#160;&#160;&#160;/* Open existing object */<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("shm_open");<br/><br/>&#160;&#160;&#160;&#160;len = strlen(argv[2]);<br/>&#160;&#160;&#160;&#160;if (ftruncate(fd, len) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Resize object to hold string */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("ftruncate");<br/>&#160;&#160;&#160;&#160;printf("Resized to %ld bytes\n", (long) len);<br/><br/>&#160;&#160;&#160;&#160;addr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);<br/>&#160;&#160;&#160;&#160;if (addr == MAP_FAILED)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mmap");<br/><br/>&#160;&#160;&#160;&#160;if (close(fd) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* 'fd' is no longer needed */<br/><br/>&#160;&#160;&#160;&#160;printf("copying %ld bytes\n", (long) len);<br/>&#160;&#160;&#160;&#160;memcpy(addr, argv[2], len);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Copy string to shared memory */<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>________________________________________________________ <span class="codestrong">pshm/pshm_write.c</span></p>
<p class="noindent">The program in <a href="ch54.xhtml#ch54ex3">Listing 54-3</a> displays the string in the existing shared memory object named in its command-line argument on standard output. After calling <em>shm_open()</em>, the program uses <em>fstat()</em> to determine the size of the shared memory and uses that size in the call to <em>mmap()</em> that maps the object and in the <em>write()</em> call that prints the string.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1113"/><a id="ch54ex3"/><strong>Listing 54-3:</strong> Copying data from a POSIX shared memory object</p>
<p class="programsli">_________________________________________________________ <span class="codestrong">pshm/pshm_read.c</span><br/><br/>#include &lt;fcntl.h&gt;<br/>#include &lt;sys/mman.h&gt;<br/>#include &lt;sys/stat.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int fd;<br/>&#160;&#160;&#160;&#160;char *addr;<br/>&#160;&#160;&#160;&#160;struct stat sb;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s shm-name\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;fd = shm_open(argv[1], O_RDONLY, 0);&#160;&#160;&#160;&#160;/* Open existing object */<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("shm_open");<br/><br/>&#160;&#160;&#160;&#160;/* Use shared memory object size as length argument for mmap()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;and as number of bytes to write() */<br/><br/>&#160;&#160;&#160;&#160;if (fstat(fd, &#38;sb) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fstat");<br/><br/>&#160;&#160;&#160;&#160;addr = mmap(NULL, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);<br/>&#160;&#160;&#160;&#160;if (addr == MAP_FAILED)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mmap");<br/><br/>&#160;&#160;&#160;&#160;if (close(fd) == -1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* 'fd' is no longer needed */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close");<br/><br/>&#160;&#160;&#160;&#160;write(STDOUT_FILENO, addr, sb.st_size);<br/>&#160;&#160;&#160;&#160;printf("\n");<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________________ <span class="codestrong">pshm/pshm_read.c</span></p>
<p class="noindent">The following shell session demonstrates the use of the programs in <a href="ch54.xhtml#ch54ex2">Listing 54-2</a> and <a href="ch54.xhtml#ch54ex3">Listing 54-3</a>. We first create a zero-length shared memory object using the program in <a href="ch54.xhtml#ch54ex1">Listing 54-1</a>.</p>
<p class="programs">$ <span class="codestrong">./pshm_create -c /demo_shm 0</span><br/>$ <span class="codestrong">ls -l /dev/shm</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Check the size of object</span><br/>total 4<br/>-rw-------&#160;&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;0 Jun 21 13:33 demo_shm</p>
<p class="noindent">We then use the program in <a href="ch54.xhtml#ch54ex2">Listing 54-2</a> to copy a string into the shared memory object:</p>
<p class="programs">$ <span class="codestrong">./pshm_write /demo_shm 'hello'</span><br/>$ <span class="codestrong">ls -l /dev/shm</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Check that object has changed in size</span><br/>total 4<br/>-rw-------&#160;&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;5 Jun 21 13:33 demo_shm</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1114"/>From the output, we can see that the program resized the shared memory object so that it is large enough to hold the specified string.</p>
<p class="indent">Finally, we use the program in <a href="ch54.xhtml#ch54ex3">Listing 54-3</a> to display the string in the shared memory object:</p>
<p class="programs">$ <span class="codestrong">./pshm_read /demo_shm</span><br/>hello</p>
<p class="noindent">Applications must typically use some synchronization technique to allow processes to coordinate their access to shared memory. In the example shell session shown here, the coordination was provided by the user running the programs one after the other. Typically, applications would instead use a synchronization primitive (e.g., semaphores) to coordinate access to a shared memory object.</p>
<h3 class="h3" id="ch54lev1sec04"><strong>54.4 Removing Shared Memory Objects</strong></h3>
<p class="noindenta">SUSv3 requires that POSIX shared memory objects have at least kernel persistence; that is, they continue to exist until they are explicitly removed or the system is rebooted. When a shared memory object is no longer required, it should be removed using <em>shm_unlink()</em>.</p>
<div class="box">
<p class="programsa">#include &lt;sys/mman.h&gt;<br/><br/>int <span class="codestrong">shm_unlink</span>(const char *<span class="font1">name</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>shm_unlink()</em> function removes the shared memory object specified by <em>name</em>. Removing a shared memory object doesn&#8217;t affect existing mappings of the object (which will remain in effect until the corresponding processes call <em>munmap()</em> or terminate), but prevents further <em>shm_open()</em> calls from opening the object. Once all processes have unmapped the object, the object is removed, and its contents are lost.</p>
<p class="indent">The program in <a href="ch54.xhtml#ch54ex4">Listing 54-4</a> uses <em>shm_unlink()</em> to remove the shared memory object specified in the program&#8217;s command-line argument.</p>
<p class="examplet"><a id="ch54ex4"/><strong>Listing 54-4:</strong> Using <em>shm_unlink()</em> to unlink a POSIX shared memory object</p>
<p class="programsli">_______________________________________________________ <span class="codestrong">pshm/pshm_unlink.c</span><br/><br/>#include &lt;fcntl.h&gt;<br/>#include &lt;sys/mman.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s shm-name\n", argv[0]);<br/>&#160;&#160;&#160;&#160;if (shm_unlink(argv[1]) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("shm_unlink");<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_______________________________________________________ <span class="codestrong">pshm/pshm_unlink.c</span></p>
<h3 class="h3" id="ch54lev1sec05"><span epub:type="pagebreak" id="page_1115"/><strong>54.5 Comparisons Between Shared Memory APIs</strong></h3>
<p class="noindentab">By now, we have considered a number of different techniques for sharing memory regions between unrelated processes:</p>
<p class="bull">&#8226; System V shared memory (<a href="ch48.xhtml#ch48">Chapter 48</a>);</p>
<p class="bull">&#8226; shared file mappings (<a href="ch49.xhtml#ch49lev2sec02">Section 49.4.2</a>); and</p>
<p class="bull">&#8226; POSIX shared memory objects (the subject of this chapter).</p>
<div class="block">
<p class="noindent">Many of the points that we make in this section are also relevant for shared anonymous mappings (<a href="ch49.xhtml#ch49lev1sec07">Section 49.7</a>), which are used for sharing memory between processes that are related via <em>fork()</em>.</p>
</div>
<p class="noindentb">A number of points apply to all of these techniques:</p>
<p class="bull">&#8226; They provide fast IPC, and applications typically must use a semaphore (or other synchronization primitive) to synchronize access to the shared region.</p>
<p class="bull">&#8226; Once the shared memory region has been mapped into the process&#8217;s virtual address space, it looks just like any other part of the process&#8217;s memory space.</p>
<p class="bull">&#8226; The system places the shared memory regions within the process virtual address space in a similar manner. We outlined this placement while describing System V shared memory in <a href="ch48.xhtml#ch48lev1sec05">Section 48.5</a>. The Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/maps</span> file lists information about all types of shared memory regions.</p>
<p class="bull">&#8226; Assuming that we don&#8217;t attempt to map a shared memory region at a fixed address, we should ensure that all references to locations in the region are calculated as offsets (rather than pointers), since the region may be located at different virtual addresses within different processes (<a href="ch48.xhtml#ch48lev1sec06">Section 48.6</a>).</p>
<p class="bull">&#8226; The functions described in <a href="ch50.xhtml#ch50">Chapter 50</a> that operate on regions of virtual memory can be applied to shared memory regions created using any of these techniques.</p>
<p class="noindenttb">There are also a few notable differences between the techniques for shared memory:</p>
<p class="bull">&#8226; The fact that the contents of a shared file mapping are synchronized with the underlying mapped file means that the data stored in a shared memory region can persist across system restarts.</p>
<p class="bull">&#8226; System V and POSIX shared memory use different mechanisms to identify and refer to a shared memory object. System V uses its own scheme of keys and identifiers, which doesn&#8217;t fit with the standard UNIX I/O model and requires separate system calls (e.g., <em>shmctl()</em>) and commands (<em>ipcs</em> and <em>ipcrm</em>). By contrast, POSIX shared memory employs names and file descriptors, and consequently shared memory objects can be examined and manipulated using a variety of existing UNIX system calls (e.g., <em>fstat()</em> and <em>fchmod()</em>).</p>
<p class="bull"><span epub:type="pagebreak" id="page_1116"/>&#8226; The size of a System V shared memory segment is fixed at the time of creation (via <em>shmget()</em>). By contrast, for a mapping backed by a file or by a POSIX shared memory object, we can use <em>ftruncate()</em> to adjust the size of the underlying object, and then re-create the mapping using <em>munmap()</em> and <em>mmap()</em> (or the Linux-specific <em>mremap()</em>).</p>
<p class="bull">&#8226; Historically, System V shared memory was more widely available than <em>mmap()</em> and POSIX shared memory, although most UNIX implementations now provide all of these techniques.</p>
<p class="noindentt">With the exception of the final point regarding portability, the differences listed above are advantages in favor of shared file mappings and POSIX shared memory objects. Thus, in new applications, one of these interfaces may be preferable to System V shared memory. Which one we choose depends on whether or not we require a persistent backing store. Shared file mappings provide such a store; POSIX shared memory objects allow us to avoid the overhead of using a disk file when a backing store is not required.</p>
<h3 class="h3" id="ch54lev1sec06"><strong>54.6 Summary</strong></h3>
<p class="noindenta">A POSIX shared memory object is used to share a region of memory between unrelated processes without creating an underlying disk file. To do this, we replace the call to <em>open()</em> that normally precedes <em>mmap()</em> with a call to <em>shm_open()</em>. The <em>shm_open()</em> call creates a file in a memory-based file system, and we can employ traditional file descriptor system calls to perform various operations on this virtual file. In particular, <em>ftruncate()</em> must be used to set the size of the shared memory object, since initially it has a length of zero.</p>
<p class="indent">We have now described three techniques for sharing memory regions between unrelated processes: System V shared memory, shared file mappings, and POSIX shared memory objects. There are several similarities between the three techniques. There are also some important differences, and, except for the issue of portability, these differences favor shared file mappings and POSIX shared memory objects.</p>
<h3 class="h3" id="ch54lev1sec07"><strong>54.7 Exercise</strong></h3>
<p class="exer"><a id="ch54exe1"/><strong>54-1.</strong>&#160;&#160;&#160;Rewrite the programs in <a href="ch48.xhtml#ch48ex2">Listing 48-2</a> (<span class="literal">svshm_xfr_writer.c</span>) and <a href="ch48.xhtml#ch48ex3">Listing 48-3</a> (<span class="literal">svshm_xfr_reader.c</span>) to use POSIX shared memory objects instead of System V shared memory.</p>
</body>
</html>
