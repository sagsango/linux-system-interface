<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch46"><span epub:type="pagebreak" id="page_937"/><strong><span class="big">46</span></strong><br/><strong>SYSTEM V MESSAGE QUEUES</strong></h2>
<p class="noindentab">This chapter describes System V message queues. Message queues allow processes to exchange data in the form of messages. Although message queues are similar to pipes and FIFOs in some respects, they also differ in important ways:</p>
<p class="bull">&#8226; The handle used to refer to a message queue is the identifier returned by a call to <em>msgget()</em>. These identifiers are not the same as the file descriptors used for most other forms of I/O on UNIX systems.</p>
<p class="bull">&#8226; Communication via message queues is message-oriented; that is, the reader receives whole messages, as written by the writer. It is not possible to read part of a message, leaving the remainder in the queue, or to read multiple messages at a time. This contrasts with pipes, which provide an undifferentiated stream of bytes (i.e., with pipes, the reader can read an arbitrary number of bytes at a time, irrespective of the size of data blocks written by the writer).</p>
<p class="bull">&#8226; In addition to containing data, each message has an integer <em>type</em>. Messages can be retrieved from a queue in first-in, first-out order or retrieved by type.</p>
<p class="noindentt">At the end of this chapter (<a href="ch46.xhtml#ch46lev1sec09">Section 46.9</a>), we summarize a number of limitations of System V message queues. These limitations lead us to the conclusion that, where possible, new applications should avoid the use of System V message queues in favor of other IPC mechanisms such as FIFOs, POSIX message queues, and sockets. However, when message queues were initially devised, these alternative mechanisms were unavailable or were not widespread across UNIX implementations. <span epub:type="pagebreak" id="page_938"/>Consequently, there are various existing applications that employ message queues, and this fact forms one of the primary motivations for describing them.</p>
<h3 class="h3" id="ch46lev1sec01"><strong>46.1 Creating or Opening a Message Queue</strong></h3>
<p class="noindenta">The <em>msgget()</em> system call creates a new message queue or obtains the identifier of an existing queue.</p>
<div class="box">
<p class="programsa">#include &lt;sys/types.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* For portability */<br/>#include &lt;sys/msg.h&gt;<br/><br/>int <span class="codestrong">msgget</span>(key_t <span class="font1">key</span>, int <span class="font1">msgflg</span>);</p>
<p class="right">Returns message queue identifier on success, or &#8211;1 on error</p>
</div>
<p class="noindentb">The <em>key</em> argument is a key generated using one of the methods described in <a href="ch45.xhtml#ch45lev1sec02">Section 45.2</a> (i.e., usually the value <span class="literal">IPC_PRIVATE</span> or a key returned by <em>ftok()</em>). The <em>msgflg</em> argument is a bit mask that specifies the permissions (<a href="ch15.xhtml#ch15table4">Table 15-4</a>, on <a href="ch15.xhtml#page_295">page 295</a>) to be placed on a new message queue or checked against an existing queue. In addition, zero or more of the following flags can be ORed (<span class="literal">|</span>) in <em>msgflg</em> to control the operation of <em>msgget()</em>:</p>
<p class="term"><span class="literal">IPC_CREAT</span></p>
<p class="termlist">If no message queue with the specified <em>key</em> exists, create a new queue.</p>
<p class="term"><span class="literal">IPC_EXCL</span></p>
<p class="termlist">If <span class="literal">IPC_CREAT</span> was also specified, and a queue with the specified <em>key</em> already exists, fail with the error <span class="literal">EEXIST</span>.</p>
<p class="noindentt">These flags are described in more detail in <a href="ch45.xhtml#ch45lev1sec01">Section 45.1</a>.</p>
<p class="indent">The <em>msgget()</em> system call begins by searching the set of all existing message queues for one with the specified key. If a matching queue is found, the identifier of that queue is returned (unless both <span class="literal">IPC_CREAT</span> and <span class="literal">IPC_EXCL</span> were specified in <em>msgflg</em>, in which case an error is returned). If no matching queue was found and <span class="literal">IPC_CREAT</span> was specified in <em>msgflg</em>, a new queue is created and its identifier is returned.</p>
<p class="indent">The program in <a href="ch46.xhtml#ch46ex1">Listing 46-1</a> provides a command-line interface to the <em>msgget()</em> system call. The program permits the use of command-line options and arguments to specify all possibilities for the <em>key</em> and <em>msgflg</em> arguments to <em>msgget()</em>. Details of the command format accepted by this program are shown in the <em>usageError()</em> function. Upon successful queue creation, the program prints the queue identifier. We demonstrate the use of this program in <a href="ch46.xhtml#ch46lev2sec02">Section 46.2.2</a>.</p>
<p class="examplet"><a id="ch46ex1"/><strong>Listing 46-1:</strong> Using <em>msgget()</em></p>
<p class="programsli">______________________________________________________ <span class="codestrong">svmsg/svmsg_create.c</span><br/><br/>#include &lt;sys/types.h&gt;<br/>#include &lt;sys/ipc.h&gt;<br/>#include &lt;sys/msg.h&gt;<br/>#include &lt;sys/stat.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/><span epub:type="pagebreak" id="page_939"/>static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Print usage info, then exit */<br/>usageError(const char *progName, const char *msg)<br/>{<br/>&#160;&#160;&#160;&#160;if (msg != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(stderr, "%s", msg);<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "Usage: %s [-cx] {-f pathname | -k key | -p} "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"[octal-perms]\n", progName);<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-c&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Use IPC_CREAT flag\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-x&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Use IPC_EXCL flag\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-f pathname&#160;&#160;Generate key using ftok()\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-k key&#160;&#160;&#160;&#160;&#160;&#160;&#160;Use 'key' as key\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-p&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Use IPC_PRIVATE key\n");<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int numKeyFlags;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Counts -f, -k, and -p options */<br/>&#160;&#160;&#160;&#160;int flags, msqid, opt;<br/>&#160;&#160;&#160;&#160;unsigned int perms;<br/>&#160;&#160;&#160;&#160;long lkey;<br/>&#160;&#160;&#160;&#160;key_t key;<br/><br/>&#160;&#160;&#160;&#160;/* Parse command-line options and arguments */<br/><br/>&#160;&#160;&#160;&#160;numKeyFlags = 0;<br/>&#160;&#160;&#160;&#160;flags = 0;<br/><br/>&#160;&#160;&#160;&#160;while ((opt = getopt(argc, argv, "cf:k:px")) != -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (opt) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'c':<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flags |= IPC_CREAT;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'f':&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* -f pathname */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;key = ftok(optarg, 1);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (key == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("ftok");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numKeyFlags++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'k':&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* -k key (octal, decimal or hexadecimal) */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sscanf(optarg, "%li", &#38;lkey) != 1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cmdLineErr("-k option requires a numeric argument\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;key = lkey;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numKeyFlags++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'p':<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;key = IPC_PRIVATE;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numKeyFlags++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'x':<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flags |= IPC_EXCL;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0], "Bad option\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (numKeyFlags != 1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0], "Exactly one of the options -f, -k, "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"or -p must be supplied\n");<br/><br/>&#160;&#160;&#160;&#160;perms = (optind == argc) ? (S_IRUSR | S_IWUSR) :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;getInt(argv[optind], GN_BASE_8, "octal-perms");<br/><br/>&#160;&#160;&#160;&#160;msqid = msgget(key, flags | perms);<br/>&#160;&#160;&#160;&#160;if (msqid == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msgget");<br/><br/>&#160;&#160;&#160;&#160;printf("%d\n", msqid);<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>______________________________________________________ <span class="codestrong">svmsg/svmsg_create.c</span></p>
<h3 class="h3" id="ch46lev1sec02"><span epub:type="pagebreak" id="page_940"/><strong>46.2 Exchanging Messages</strong></h3>
<p class="noindenta">The <em>msgsnd()</em> and <em>msgrcv()</em> system calls perform I/O on message queues. The first argument to both system calls (<em>msqid</em>) is a message queue identifier. The second argument, <em>msgp</em>, is a pointer to a programmer-defined structure used to hold the message being sent or received. This structure has the following general form:</p>
<p class="programs">struct mymsg {<br/>&#160;&#160;&#160;&#160;long mtype;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Message type */<br/>&#160;&#160;&#160;&#160;char mtext[];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Message body */<br/>}</p>
<p class="noindent">This definition is really just shorthand for saying that the first part of a message contains the message type, specified as a long integer, while the remainder of the message is a programmer-defined structure of arbitrary length and content; it need not be an array of characters. Thus, the <em>msgp</em> argument is typed as <em>void *</em> to allow it to be a pointer to any type of structure.</p>
<p class="indent">A zero-length <em>mtext</em> field is permitted, and is sometimes useful if the information to be conveyed can be encoded solely in the message type or if the existence of a message is in itself sufficient information for the receiving process.</p>
<h4 class="h4" id="ch46lev2sec01"><strong>46.2.1 Sending Messages</strong></h4>
<p class="noindenta">The <em>msgsnd()</em> system call writes a message to a message queue.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_941"/>#include &lt;sys/types.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* For portability */<br/>#include &lt;sys/msg.h&gt;<br/><br/>int <span class="codestrong">msgsnd</span>(int <span class="font1">msqid</span>, const void *<span class="font1">msgp</span>, size_t <span class="font1">msgsz</span>, int <span class="font1">msgflg</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">To send a message with <em>msgsnd()</em>, we must set the <em>mtype</em> field of the message structure to a value greater than 0 (we see how this value is used when we discuss <em>msgrcv()</em> in the next section) and copy the desired information into the programmer-defined <em>mtext</em> field. The <em>msgsz</em> argument specifies the number of bytes contained in the <em>mtext</em> field.</p>
<div class="block">
<p class="noindent">When sending messages with <em>msgsnd()</em>, there is no concept of a partial write as with <em>write()</em>. This is why a successful <em>msgsnd()</em> needs only to return 0, rather than the number of bytes sent.</p>
</div>
<p class="noindentb">The final argument, <em>msgflg</em>, is a bit mask of flags controlling the operation of <em>msgsnd()</em>. Only one such flag is defined:</p>
<p class="term"><span class="literal">IPC_NOWAIT</span></p>
<p class="termlist">Perform a nonblocking send. Normally, if a message queue is full, <em>msgsnd()</em> blocks until enough space has become available to allow the message to be placed on the queue. However, if this flag is specified, then <em>msgsnd()</em> returns immediately with the error <span class="literal">EAGAIN</span>.</p>
<p class="noindentt">A <em>msgsnd()</em> call that is blocked because the queue is full may be interrupted by a signal handler. In this case, <em>msgsnd()</em> always fails with the error <span class="literal">EINTR</span>. (As noted in <a href="ch21.xhtml#ch21lev1sec05">Section 21.5</a>, <em>msgsnd()</em> is among those system calls that are never automatically restarted, regardless of the setting of the <span class="literal">SA_RESTART</span> flag when the signal handler is established.)</p>
<p class="indent">Writing a message to a message queue requires write permission on the queue.</p>
<p class="indent">The program in <a href="ch46.xhtml#ch46ex2">Listing 46-2</a> provides a command-line interface to the <em>msgsnd()</em> system call. The command-line format accepted by this program is shown in the <em>usageError()</em> function. Note that this program doesn&#8217;t use the <em>msgget()</em> system call. (We noted that a process doesn&#8217;t need to use a <em>get</em> call in order to access an IPC object in <a href="ch45.xhtml#ch45lev1sec01">Section 45.1</a>.) Instead, we specify the message queue by providing its identifier as a command-line argument. We demonstrate the use of this program in <a href="ch46.xhtml#ch46lev2sec02">Section 46.2.2</a>.</p>
<p class="examplet"><a id="ch46ex2"/><strong>Listing 46-2:</strong> Using <em>msgsnd()</em> to send a message</p>
<p class="programsli">_______________________________________________________ <span class="codestrong">svmsg/svmsg_send.c</span><br/><br/>#include &lt;sys/types.h&gt;<br/>#include &lt;sys/msg.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>#define MAX_MTEXT 1024<br/><br/>struct mbuf {<br/>&#160;&#160;&#160;&#160;long mtype;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Message type */<br/>&#160;&#160;&#160;&#160;char mtext[MAX_MTEXT];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Message body */<br/>};<br/><span epub:type="pagebreak" id="page_942"/><br/>static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Print (optional) message, then usage description */<br/>usageError(const char *progName, const char *msg)<br/>{<br/>&#160;&#160;&#160;&#160;if (msg != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(stderr, "%s", msg);<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "Usage: %s [-n] msqid msg-type [msg-text]\n", progName);<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-n&#160;&#160;&#160;&#160;&#160;&#160;&#160;Use IPC_NOWAIT flag\n");<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int msqid, flags, msgLen;<br/>&#160;&#160;&#160;&#160;struct mbuf msg;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Message buffer for msgsnd() */<br/>&#160;&#160;&#160;&#160;int opt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Option character from getopt() */<br/><br/>&#160;&#160;&#160;&#160;/* Parse command-line options and arguments */<br/><br/>&#160;&#160;&#160;&#160;flags = 0;<br/>&#160;&#160;&#160;&#160;while ((opt = getopt(argc, argv, "n")) != -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (opt == 'n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flags |= IPC_NOWAIT;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0], NULL);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; optind + 2 || argc &gt; optind + 3)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0], "Wrong number of arguments\n");<br/><br/>&#160;&#160;&#160;&#160;msqid = getInt(argv[optind], 0, "msqid");<br/>&#160;&#160;&#160;&#160;msg.mtype = getInt(argv[optind + 1], 0, "msg-type");<br/><br/>&#160;&#160;&#160;&#160;if (argc &gt; optind + 2) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* 'msg-text' was supplied */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msgLen = strlen(argv[optind + 2]) + 1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (msgLen &gt; MAX_MTEXT)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cmdLineErr("msg-text too long (max: %d characters)\n", MAX_MTEXT);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;memcpy(msg.mtext, argv[optind + 2], msgLen);<br/><br/>&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* No 'msg-text' ==&gt; zero-length msg */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msgLen = 0;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;/* Send message */<br/><br/>&#160;&#160;&#160;&#160;if (msgsnd(msqid, &#38;msg, msgLen, flags) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msgsnd");<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_______________________________________________________ <span class="codestrong">svmsg/svmsg_send.c</span></p>
<h4 class="h4" id="ch46lev2sec02"><span epub:type="pagebreak" id="page_943"/><strong>46.2.2 Receiving Messages</strong></h4>
<p class="noindenta">The <em>msgrcv()</em> system call reads (and removes) a message from a message queue, and copies its contents into the buffer pointed to by <em>msgp</em>.</p>
<div class="box">
<p class="programsa">#include &lt;sys/types.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;/* For portability */<br/>#include &lt;sys/msg.h&gt;<br/><br/>ssize_t <span class="codestrong">msgrcv</span>(int <span class="font1">msqid</span>, void *<span class="font1">msgp</span>, size_t <span class="font1">maxmsgsz</span>, long <span class="font1">msgtyp</span>, int <span class="font1">msgflg</span>);</p>
<p class="right">Returns number of bytes copied into <em>mtext</em> field, or &#8211;1 on error</p>
</div>
<p class="noindent">The maximum space available in the <em>mtext</em> field of the <em>msgp</em> buffer is specified by the argument <em>maxmsgsz</em>. If the body of the message to be removed from the queue exceeds <em>maxmsgsz</em> bytes, then no message is removed from the queue, and <em>msgrcv()</em> fails with the error <span class="literal">E2BIG</span>. (This default behavior can be changed using the <span class="literal">MSG_NOERROR</span> flag described shortly.)</p>
<p class="indentb">Messages need not be read in the order in which they were sent. Instead, we can select messages according to the value in the <em>mtype</em> field. This selection is controlled by the <em>msgtyp</em> argument, as follows:</p>
<p class="bull">&#8226; If <em>msgtyp</em> equals 0, the first message from the queue is removed and returned to the calling process.</p>
<p class="bull">&#8226; If <em>msgtyp</em> is greater than 0, the first message in the queue whose <em>mtype</em> equals <em>msgtyp</em> is removed and returned to the calling process. By specifying different values for <em>msgtyp</em>, multiple processes can read from a message queue without racing to read the same messages. One useful technique is to have each process select messages matching its process ID.</p>
<p class="bull">&#8226; If <em>msgtyp</em> is less than 0, treat the waiting messages as a <em>priority queue</em>. The first message of the lowest <em>mtype</em> less than or equal to the absolute value of <em>msgtyp</em> is removed and returned to the calling process.</p>
<p class="noindentt">An example helps clarify the behavior when <em>msgtyp</em> is less than 0. Suppose that we have a message queue containing the sequence of messages shown in <a href="ch46.xhtml#ch46fig1">Figure 46-1</a> and we performed a series of <em>msgrcv()</em> calls of the following form:</p>
<p class="programs">msgrcv(id, &#38;msg, maxmsgsz, -300, 0);</p>
<p class="noindent">These <em>msgrcv()</em> calls would retrieve messages in the order 2 (type 100), 5 (type 100), 3 (type 200), and 1 (type 300). A further call would block, since the type of the remaining message (400) exceeds 300.</p>
<p class="indentb">The <em>msgflg</em> argument is a bit mask formed by ORing together zero or more of the following flags:</p>
<p class="term"><span class="literal">IPC_NOWAIT</span></p>
<p class="termlist">Perform a nonblocking receive. Normally, if no message matching <em>msgtyp</em> is in the queue, <em>msgrcv()</em> blocks until such a message becomes available. Specifying the <span class="literal">IPC_NOWAIT</span> flag causes <em>msgrcv()</em> to instead return immediately <span epub:type="pagebreak" id="page_944"/>with the error <span class="literal">ENOMSG</span>. (The error <span class="literal">EAGAIN</span> would be more consistent, as occurs on a nonblocking <em>msgsnd()</em> or a nonblocking read from a FIFO. However, failing with <span class="literal">ENOMSG</span> is historical behavior, and required by SUSv3.)</p>
<p class="term"><span class="literal">MSG_EXCEPT</span></p>
<p class="termlist">This flag has an effect only if <em>msgtyp</em> is greater than 0, in which case it forces the complement of the usual operation; that is, the first message from the queue whose <em>mtype</em> is <em>not</em> equal to <em>msgtyp</em> is removed from the queue and returned to the caller. This flag is Linux-specific, and is made available from <span class="literal">&lt;sys/msg.h&gt;</span> only if <span class="literal">_GNU_SOURCE</span> is defined. Performing a series of calls of the form <em>msgrcv(id, &#38;msg, maxmsgsz, 100, MSG_EXCEPT)</em> on the message queue shown in <a href="ch46.xhtml#ch46fig1">Figure 46-1</a> would retrieve messages in the order 1, 3, 4, and then block.</p>
<p class="term"><span class="literal">MSG_NOERROR</span></p>
<p class="termlist">By default, if the size of the <em>mtext</em> field of the message exceeds the space available (as defined by the <em>maxmsgsz</em> argument), <em>msgrcv()</em> fails. If the <span class="literal">MSG_NOERROR</span> flag is specified, then <em>msgrcv()</em> instead removes the message from the queue, truncates its <em>mtext</em> field to <em>maxmsgsz</em> bytes, and returns it to the caller. The truncated data is lost.</p>
<p class="noindentt">Upon successful completion, <em>msgrcv()</em> returns the size of the <em>mtext</em> field of the received message; on error, &#8211;1 is returned.</p>
<div class="image"><img src="../images/f46-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch46fig1"/><strong>Figure 46-1:</strong> Example of a message queue containing messages of different types</p>
<p class="noindent">As with <em>msgsnd()</em>, if a blocked <em>msgrcv()</em> call is interrupted by a signal handler, then the call fails with the error <span class="literal">EINTR</span>, regardless of the setting of the <span class="literal">SA_RESTART</span> flag when the signal handler was established.</p>
<p class="indent">Reading a message from a message queue requires read permission on the queue.</p>
<h5 class="h5" id="ch46lev3sec01"><strong>Example program</strong></h5>
<p class="noindenta">The program in <a href="ch46.xhtml#ch46ex3">Listing 46-3</a> provides a command-line interface to the <em>msgrcv()</em> system call. The command-line format accepted by this program is shown in the <em>usageError()</em> function. Like the program in <a href="ch46.xhtml#ch46ex2">Listing 46-2</a>, which demonstrated the use of <em>msgsnd()</em>, this program doesn&#8217;t use the <em>msgget()</em> system call, but instead expects a message queue identifier as its command-line argument.</p>
<p class="indent"><span epub:type="pagebreak" id="page_945"/>The following shell session demonstrates the use of the programs in <a href="ch46.xhtml#ch46ex1">Listing 46-1</a>, <a href="ch46.xhtml#ch46ex2">Listing 46-2</a>, and <a href="ch46.xhtml#ch46ex3">Listing 46-3</a>. We begin by creating a message queue using the <span class="literal">IPC_PRIVATE</span> key, and then write three messages with different types to the queue:</p>
<p class="programs">$ <span class="codestrong">./svmsg_create -p</span><br/>32769&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">ID of message queue</span><br/>$ <span class="codestrong">./svmsg_send 32769 20 "I hear and I forget."</span><br/>$ <span class="codestrong">./svmsg_send 32769 10 "I see and I remember."</span><br/>$ <span class="codestrong">./svmsg_send 32769 30 "I do and I understand."</span></p>
<p class="noindent">We then use the program in <a href="ch46.xhtml#ch46ex3">Listing 46-3</a> to read messages with a type less than or equal to 20 from the queue:</p>
<p class="programs">$ <span class="codestrong">./svmsg_receive -t -20 32769</span><br/>Received: type=10; length=22; body=I see and I remember.<br/>$ <span class="codestrong">./svmsg_receive -t -20 32769</span><br/>Received: type=20; length=21; body=I hear and I forget.<br/>$ <span class="codestrong">./svmsg_receive -t -20 32769</span></p>
<p class="noindent">The last of the above commands blocked, because there was no message in the queue whose type was less than or equal to 20. So, we continue by typing <em>Control-C</em> to terminate the command, and then execute a command that reads a message of any type from the queue:</p>
<p class="programs"><span class="font1">Type Control-C to terminate program</span><br/>$ <span class="codestrong">./svmsg_receive 32769</span><br/>Received: type=30; length=23; body=I do and I understand.</p>
<p class="examplet"><a id="ch46ex3"/><strong>Listing 46-3:</strong> Using <em>msgrcv()</em> to read a message</p>
<p class="programsli">_____________________________________________________ <span class="codestrong">svmsg/svmsg_receive.c</span><br/><br/>#define _GNU_SOURCE&#160;&#160;&#160;&#160;&#160;/* Get definition of MSG_EXCEPT */<br/>#include &lt;sys/types.h&gt;<br/>#include &lt;sys/msg.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>#define MAX_MTEXT 1024<br/><br/>struct mbuf {<br/>&#160;&#160;&#160;&#160;long mtype;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Message type */<br/>&#160;&#160;&#160;&#160;char mtext[MAX_MTEXT];&#160;&#160;&#160;&#160;&#160;/* Message body */<br/>};<br/><br/>static void<br/>usageError(const char *progName, const char *msg)<br/>{<br/>&#160;&#160;&#160;&#160;if (msg != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(stderr, "%s", msg);<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "Usage: %s [options] msqid [max-bytes]\n", progName);<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "Permitted options are:\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-e&#160;&#160;&#160;&#160;&#160;&#160;&#160;Use MSG_NOERROR flag\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-t type&#160;&#160;Select message of given type\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-n&#160;&#160;&#160;&#160;&#160;&#160;&#160;Use IPC_NOWAIT flag\n");<br/><br/><span epub:type="pagebreak" id="page_946"/><br/>#ifdef MSG_EXCEPT<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-x&#160;&#160;&#160;&#160;&#160;&#160;&#160;Use MSG_EXCEPT flag\n");<br/>#endif<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int msqid, flags, type;<br/>&#160;&#160;&#160;&#160;ssize_t msgLen;<br/>&#160;&#160;&#160;&#160;size_t maxBytes;<br/>&#160;&#160;&#160;&#160;struct mbuf msg;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Message buffer for msgrcv() */<br/>&#160;&#160;&#160;&#160;int opt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Option character from getopt() */<br/><br/>&#160;&#160;&#160;&#160;/* Parse command-line options and arguments */<br/><br/>&#160;&#160;&#160;&#160;flags = 0;<br/>&#160;&#160;&#160;&#160;type = 0;<br/>&#160;&#160;&#160;&#160;while ((opt = getopt(argc, argv, "ent:x")) != -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (opt) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'e':&#160;&#160;&#160;&#160;&#160;&#160;&#160;flags |= MSG_NOERROR;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'n':&#160;&#160;&#160;&#160;&#160;&#160;&#160;flags |= IPC_NOWAIT;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 't':&#160;&#160;&#160;&#160;&#160;&#160;&#160;type = atoi(optarg);&#160;&#160;&#160;&#160;break;<br/>#ifdef MSG_EXCEPT<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'x':&#160;&#160;&#160;&#160;&#160;&#160;&#160;flags |= MSG_EXCEPT;&#160;&#160;&#160;&#160;break;<br/>#endif<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0], NULL);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; optind + 1 || argc &gt; optind + 2)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0], "Wrong number of arguments\n");<br/><br/>&#160;&#160;&#160;&#160;msqid = getInt(argv[optind], 0, "msqid");<br/>&#160;&#160;&#160;&#160;maxBytes = (argc &gt; optind + 1) ?<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;getInt(argv[optind + 1], 0, "max-bytes") : MAX_MTEXT;<br/><br/>&#160;&#160;&#160;&#160;/* Get message and display on stdout */<br/><br/>&#160;&#160;&#160;&#160;msgLen = msgrcv(msqid, &#38;msg, maxBytes, type, flags);<br/>&#160;&#160;&#160;&#160;if (msgLen == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msgrcv");<br/><br/>&#160;&#160;&#160;&#160;printf("Received: type=%ld; length=%ld", msg.mtype, (long) msgLen);<br/>&#160;&#160;&#160;&#160;if (msgLen &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("; body=%s", msg.mtext);<br/>&#160;&#160;&#160;&#160;printf("\n");<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_____________________________________________________ <span class="codestrong">svmsg/svmsg_receive.c</span></p>
<h3 class="h3" id="ch46lev1sec03"><span epub:type="pagebreak" id="page_947"/><strong>46.3 Message Queue Control Operations</strong></h3>
<p class="noindenta">The <em>msgctl()</em> system call performs control operations on the message queue identified by <em>msqid</em>.</p>
<div class="box">
<p class="programsa">#include &lt;sys/types.h&gt;&#160;&#160;&#160;&#160;&#160;/* For portability */<br/>#include &lt;sys/msg.h&gt;<br/><br/>int <span class="codestrong">msgctl</span>(int <span class="font1">msqid</span>, int <span class="font1">cmd</span>, struct msqid_ds *<span class="font1">buf</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb">The <em>cmd</em> argument specifies the operation to be performed on the queue. It can be one of the following:</p>
<p class="term"><span class="literal">IPC_RMID</span></p>
<p class="termlist">Immediately remove the message queue object and its associated <em>msqid_ds</em> data structure. All messages remaining in the queue are lost, and any blocked reader or writer processes are immediately awakened, with <em>msgsnd()</em> or <em>msgrcv()</em> failing with the error <span class="literal">EIDRM</span>. The third argument to <em>msgctl()</em> is ignored for this operation.</p>
<p class="term"><span class="literal">IPC_STAT</span></p>
<p class="termlist">Place a copy of the <em>msqid_ds</em> data structure associated with this message queue in the buffer pointed to by <em>buf</em>. We describe the <em>msqid_ds</em> structure in <a href="ch46.xhtml#ch46lev1sec04">Section 46.4</a>.</p>
<p class="term"><span class="literal">IPC_SET</span></p>
<p class="termlist">Update selected fields of the <em>msqid_ds</em> data structure associated with this message queue using values provided in the buffer pointed to by <em>buf</em>.</p>
<p class="noindentt">Further details about these operations, including the privileges and permissions required by the calling process, are described in <a href="ch45.xhtml#ch45lev1sec03">Section 45.3</a>. We describe some other values for <em>cmd</em> in <a href="ch46.xhtml#ch46lev1sec06">Section 46.6</a>.</p>
<p class="indent">The program in <a href="ch46.xhtml#ch46ex4">Listing 46-4</a> demonstrates the use of <em>msgctl()</em> to delete a message queue.</p>
<p class="examplet"><a id="ch46ex4"/><strong>Listing 46-4:</strong> Deleting System V message queues</p>
<p class="programsli">_________________________________________________________ <span class="codestrong">svmsg/svmsg_rm.c</span><br/><br/>#include &lt;sys/types.h&gt;<br/>#include &lt;sys/msg.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int j;<br/>&#160;&#160;&#160;&#160;if (argc &gt; 1 &#38;&#38; strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s [msqid...]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;for (j = 1; j &lt; argc; j++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (msgctl(getInt(argv[j], 0, "msqid"), IPC_RMID, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msgctl %s", argv[j]);<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________________ <span class="codestrong">svmsg/svmsg_rm.c</span></p>
<h3 class="h3" id="ch46lev1sec04"><span epub:type="pagebreak" id="page_948"/><strong>46.4 Message Queue Associated Data Structure</strong></h3>
<p class="noindenta">Each message queue has an associated <em>msqid_ds</em> data structure of the following form:</p>
<p class="programs">struct msqid_ds {<br/>&#160;&#160;&#160;&#160;struct ipc_perm msg_perm;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Ownership and permissions */<br/>&#160;&#160;&#160;&#160;time_t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msg_stime;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Time of last msgsnd() */<br/>&#160;&#160;&#160;&#160;time_t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msg_rtime;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Time of last msgrcv() */<br/>&#160;&#160;&#160;&#160;time_t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msg_ctime;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Time of last change */<br/>&#160;&#160;&#160;&#160;unsigned long&#160;&#160;&#160;__msg_cbytes;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of bytes in queue */<br/>&#160;&#160;&#160;&#160;msgqnum_t&#160;&#160;&#160;&#160;&#160;&#160;&#160;msg_qnum;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of messages in queue */<br/>&#160;&#160;&#160;&#160;msglen_t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msg_qbytes;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Maximum bytes in queue */<br/>&#160;&#160;&#160;&#160;pid_t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msg_lspid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* PID of last msgsnd() */<br/>&#160;&#160;&#160;&#160;pid_t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msg_lrpid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* PID of last msgrcv() */<br/>};</p>
<div class="block">
<p class="noindent">The purpose of the abbreviated spelling <em>msq</em> in the name <em>msqid_ds</em> is to confuse the programmer. This is the only message queue interface employing this spelling.</p>
</div>
<p class="noindent">The <em>msgqnum_t</em> and <em>msglen_t</em> data types&#8212;used to type the <em>msg_qnum</em> and <em>msg_qbytes</em> fields&#8212;are unsigned integer types specified in SUSv3.</p>
<p class="indentb">The fields of the <em>msqid_ds</em> structure are implicitly updated by the various message queue system calls, and certain fields can be explicitly updated using the <em>msgctl()</em> <span class="literal">IPC_SET</span> operation. The details are as follows:</p>
<p class="term"><em>msg_perm</em></p>
<p class="termlist">When the message queue is created, the fields of this substructure are initialized as described in <a href="ch45.xhtml#ch45lev1sec03">Section 45.3</a>. The <em>uid</em>, <em>gid</em>, and <em>mode</em> subfields can be updated via <span class="literal">IPC_SET</span>.</p>
<p class="term"><em>msg_stime</em></p>
<p class="termlist">When the queue is created, this field is set to 0; each later successful <em>msgsnd()</em> sets this field to the current time. This field and the other timestamp fields in the <em>msqid_ds</em> structure are typed as <em>time_t</em>; they store time in seconds since the Epoch.</p>
<p class="term"><em>msg_rtime</em></p>
<p class="termlist">This field is set to 0 when the message queue is created, and then set to the current time on each successful <em>msgrcv()</em>.</p>
<p class="term"><span epub:type="pagebreak" id="page_949"/><em>msg_ctime</em></p>
<p class="termlist">This field is set to the current time when the message queue is created and whenever an <span class="literal">IPC_SET</span> operation is successfully performed.</p>
<p class="term"><em>__msg_cbytes</em></p>
<p class="termlist">This field is set to 0 when the message queue is created, and then adjusted during each successful <em>msgsnd()</em> and <em>msgrcv()</em> to reflect the total number of bytes contained in the <em>mtext</em> fields of all messages in the queue.</p>
<p class="term"><em>msg_qnum</em></p>
<p class="termlist">When the message queue is created, this field is set to 0. It is then incremented by each successful <em>msgsnd()</em> and decremented by each successful <em>msgrcv()</em> to reflect the total number of messages in the queue.</p>
<p class="term"><em>msg_qbytes</em></p>
<p class="termlist">The value in this field defines an upper limit on the number of bytes in the <em>mtext</em> fields of all messages in the message queue. This field is initialized to the value of the <span class="literal">MSGMNB</span> limit when the queue is created. A privileged (<span class="literal">CAP_SYS_RESOURCE</span>) process can use the <span class="literal">IPC_SET</span> operation to adjust <em>msg_qbytes</em> to any value in the range 0 to <span class="literal">INT_MAX</span> (2,147,483,647) bytes. An unprivileged process can adjust <em>msg_qbytes</em> to any value in the range 0 to <span class="literal">MSGMNB</span>. A privileged user can modify the value contained in the Linux-specific <span class="literal">/proc/sys/kernel/msgmnb</span> file in order to change the initial <em>msg_qbytes</em> setting for all subsequently created message queues, as well as the upper limit for subsequent changes to <em>msg_qbytes</em> by unprivileged processes. We say more about message queue limits in <a href="ch46.xhtml#ch46lev1sec05">Section 46.5</a>.</p>
<p class="term"><em>msg_lspid</em></p>
<p class="termlist">This field is set to 0 when the queue is created, and then set to the process ID of the calling process on each successful <em>msgsnd()</em>.</p>
<p class="term"><em>msg_lrpid</em></p>
<p class="termlist">This field is set to 0 when the message queue is created, and then set to the process ID of the calling process on each successful <em>msgrcv()</em>.</p>
<p class="noindentt">All of the above fields are specified by SUSv3, with the exception of <em>__msg_cbytes</em>. Nevertheless, most UNIX implementations provide an equivalent of the <em>__msg_cbytes</em> field.</p>
<p class="indent">The program in <a href="ch46.xhtml#ch46ex5">Listing 46-5</a> demonstrates the use of the <span class="literal">IPC_STAT</span> and <span class="literal">IPC_SET</span> operations to modify the <em>msg_qbytes</em> setting of a message queue.</p>
<p class="examplet"><a id="ch46ex5"/><strong>Listing 46-5:</strong> Changing the <em>msg_qbytes</em> setting of a System V message queue</p>
<p class="programsli">____________________________________________________ <span class="codestrong">svmsg/svmsg_chqbytes.c</span><br/><br/>#include &lt;sys/types.h&gt;<br/>#include &lt;sys/msg.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct msqid_ds ds;<br/>&#160;&#160;&#160;&#160;int msqid;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 3 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s msqid max-bytes\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;/* Retrieve copy of associated data structure from kernel */<br/><br/>&#160;&#160;&#160;&#160;msqid = getInt(argv[1], 0, "msqid");<br/>&#160;&#160;&#160;&#160;if (msgctl(msqid, IPC_STAT, &#38;ds) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msgctl");<br/><br/>&#160;&#160;&#160;&#160;ds.msg_qbytes = getInt(argv[2], 0, "max-bytes");<br/><br/>&#160;&#160;&#160;&#160;/* Update associated data structure in kernel */<br/><br/>&#160;&#160;&#160;&#160;if (msgctl(msqid, IPC_SET, &#38;ds) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msgctl");<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>____________________________________________________ <span class="codestrong">svmsg/svmsg_chqbytes.c</span></p>
<h3 class="h3" id="ch46lev1sec05"><span epub:type="pagebreak" id="page_950"/><strong>46.5 Message Queue Limits</strong></h3>
<p class="noindenta">Most UNIX implementations impose various limits on the operation of System V message queues. Here, we describe the limits under Linux and note a few differences from other UNIX implementations.</p>
<p class="indentb">The following limits are enforced on Linux. The system call affected by the limit and the error that results if the limit is reached are noted in parentheses.</p>
<p class="term"><span class="literal">MSGMNI</span></p>
<p class="termlist">This is a system-wide limit on the number of message queue identifiers (in other words, message queues) that can be created. (<em>msgget()</em>, <span class="literal">ENOSPC</span>)</p>
<p class="term"><span class="literal">MSGMAX</span></p>
<p class="termlist">This is a system-wide limit specifying the maximum number of (<em>mtext</em>) bytes that can be written in a single message. (<em>msgsnd()</em>, <span class="literal">EINVAL</span>)</p>
<p class="term"><span class="literal">MSGMNB</span></p>
<p class="termlist">This is the maximum number of (<em>mtext</em>) bytes that can be held in a message queue at one time. This limit is a system-wide parameter that is used to initialize the <em>msg_qbytes</em> field of the <em>msqid_ds</em> data structure associated with this message queue. Subsequently, the <em>msg_qbytes</em> value can be modified on a per-queue basis, as described in <a href="ch46.xhtml#ch46lev1sec04">Section 46.4</a>. If a queue&#8217;s <em>msg_qbytes</em> limit is reached, then <em>msgsnd()</em> blocks, or fails with the error <span class="literal">EAGAIN</span> if <span class="literal">IPC_NOWAIT</span> was set.</p>
<p class="noindenttb">Some UNIX implementations also define the following further limits:</p>
<p class="term"><span class="literal">MSGTQL</span></p>
<p class="termlist">This is a system-wide limit on the number of messages that can be placed on all message queues on the system.</p>
<p class="term"><span class="literal">MSGPOOL</span></p>
<p class="termlist">This is a system-wide limit on the size of the buffer pool that is used to hold data in all message queues on the system.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_951"/>Although Linux doesn&#8217;t impose either of the above limits, it does limit the number of messages on an individual queue to the value specified by the queue&#8217;s <em>msg_qbytes</em> setting. This limitation is relevant only if we are writing zero-length messages to a queue. It has the effect that the limit on the number of zero-length messages is the same as the limit on the number of 1-byte messages that can be written to the queue. This is necessary to prevent an infinite number of zero-length messages being written to the queue. Although they contain no data, each zero-length message consumes a small amount of memory for system bookkeeping overhead.</p>
<p class="indent">At system startup, the message queue limits are set to default values. These defaults have varied somewhat across kernel versions. (Some distributors&#8217; kernels set different defaults from those provided by vanilla kernels.) On Linux, the limits can be viewed or changed via files in the <span class="literal">/proc</span> file system. <a href="ch46.xhtml#ch46table1">Table 46-1</a> shows the <span class="literal">/proc</span> file corresponding to each limit. As an example, here are the default limits that we see for Linux 2.6.31 on one x86-32 system:</p>
<p class="programs">$ <span class="codestrong">cd /proc/sys/kernel</span><br/>$ <span class="codestrong">cat msgmni</span><br/>748<br/>$ <span class="codestrong">cat msgmax</span><br/>8192<br/>$ <span class="codestrong">cat msgmnb</span><br/>16384</p>
<p class="tablecap"><a id="ch46table1"/><strong>Table 46-1:</strong> System V message queue limits</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Limit</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Ceiling value (x86-32)</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Corresponding file in</strong> <span class="literal"><span class="codestrong">/proc/sys/kernel</span></span></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MSGMNI</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">32768 (IPCMNI)</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">msgmni</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MSGMAX</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Depends on available memory</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">msgmax</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">MSGMNB</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">2147483647 (INT_MAX)</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table"><span class="literal">msgmnb</span></p></td>
</tr>
</tbody>
</table>
<p class="noindent">The ceiling value column of <a href="ch46.xhtml#ch46table1">Table 46-1</a> shows the maximum value to which each limit can be raised on the x86-32 architecture. Note that although the <span class="literal">MSGMNB</span> limit can be raised to the value <span class="literal">INT_MAX</span>, some other limit (e.g., lack of memory) will be reached before a message queue can be loaded with so much data.</p>
<p class="indent">The Linux-specific <em>msgctl()</em> <span class="literal">IPC_INFO</span> operation retrieves a structure of type <em>msginfo</em>, which contains the values of the various message queue limits:</p>
<p class="programs">struct msginfo buf;<br/><br/>msgctl(0, IPC_INFO, (struct msqid_ds *) &#38;buf);</p>
<p class="noindent">Details about <span class="literal">IPC_INFO</span> and the <em>msginfo</em> structure can be found in the <em>msgctl(2)</em> manual page.</p>
<h3 class="h3" id="ch46lev1sec06"><strong>46.6 Displaying All Message Queues on the System</strong></h3>
<p class="noindentab">In <a href="ch45.xhtml#ch45lev1sec07">Section 45.7</a>, we looked at one way to obtain a list of all of the IPC objects on the system: via a set of files in the <span class="literal">/proc</span> file system. We now look at a second method of obtaining the same information: via a set of Linux-specific IPC <em>ctl</em> (<em>msgctl()</em>, <em>semctl()</em>, <span epub:type="pagebreak" id="page_952"/>and <em>shmctl()</em>) operations. (The <em>ipcs</em> program employs these operations.) These operations are as follows:</p>
<p class="bull">&#8226; <span class="literal">MSG_INFO</span>, <span class="literal">SEM_INFO</span>, and <span class="literal">SHM_INFO</span>: The <span class="literal">MSG_INFO</span> operation serves two purposes. First, it returns a structure detailing resources consumed by all message queues on the system. Second, as the function result of the <em>ctl</em> call, it returns the index of the maximum item in the <em>entries</em> array pointing to data structures for the message queue objects (see <a href="ch45.xhtml#ch45fig1">Figure 45-1</a>, on <a href="ch45.xhtml#page_932">page 932</a>). The <span class="literal">SEM_INFO</span> and <span class="literal">SHM_INFO</span> operations perform an analogous task for semaphore sets and shared memory segments, respectively. We must define the <span class="literal">_GNU_SOURCE</span> feature test macro to obtain the definitions of these three constants from the corresponding System V IPC header files.</p>
<div class="block1">
<p class="noindent">An example showing the use of <span class="literal">MSG_INFO</span> to retrieve a <em>msginfo</em> structure containing information about resources used by all message queue objects is provided in the file <span class="literal">svmsg/svmsg_info.c</span> in the source code distribution for this book.</p>
</div>
<p class="bull">&#8226; <span class="literal">MSG_STAT</span>, <span class="literal">SEM_STAT</span>, and <span class="literal">SHM_STAT</span>: Like the <span class="literal">IPC_STAT</span> operation, these operations retrieve the associated data structure for an IPC object. However, they differ in two respects. First, instead of expecting an IPC identifier as the first argument of the <em>ctl</em> call, these operations expect an index into the <em>entries</em> array. Second, if the operation is successful, then, as its function result, the <em>ctl</em> call returns the identifier of the IPC object corresponding to that index. We must define the <span class="literal">_GNU_SOURCE</span> feature test macro to obtain the definitions of these three constants from the corresponding System V IPC header files.</p>
<p class="noindentt">To list all message queues on the system, we can do the following:</p>
<ol>
<li class="order"><p class="orderp">Use a <span class="literal">MSG_INFO</span> operation to find out the maximum index (<em>maxind</em>) of the <em>entries</em> array for message queues.</p></li>
<li class="order"><p class="orderp">Perform a loop for all values from 0 up to and including <em>maxind</em>, employing a <span class="literal">MSG_STAT</span> operation for each value. During this loop, we ignore the errors that may occur if an item of the <em>entries</em> array is empty (<span class="literal">EINVAL</span>) or if we don&#8217;t have permissions on the object to which it refers (<span class="literal">EACCES</span>).</p></li>
</ol>
<p class="noindent"><a href="ch46.xhtml#ch46ex6">Listing 46-6</a> provides an implementation of the above steps for message queues. The following shell session log demonstrates the use of this program:</p>
<p class="programs">$ <span class="codestrong">./svmsg_ls</span><br/>maxind: 4<br/><br/>index&#160;&#160;&#160;&#160;&#160;ID&#160;&#160;&#160;&#160;&#160;&#160;&#160;key&#160;&#160;&#160;&#160;&#160;&#160;messages<br/>&#160;&#160;&#160;2&#160;&#160;&#160;&#160;98306&#160;&#160;0x00000000&#160;&#160;&#160;&#160;&#160;&#160;&#160;0<br/>&#160;&#160;&#160;4&#160;&#160;&#160;163844&#160;&#160;0x000004d2&#160;&#160;&#160;&#160;&#160;&#160;&#160;2<br/>$ <span class="codestrong">ipcs -q</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Check above against output of ipcs</span><br/><br/>------ Message Queues --------<br/>key&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msqid&#160;&#160;&#160;&#160;&#160;&#160;owner&#160;&#160;&#160;&#160;perms&#160;&#160;&#160;&#160;used-bytes&#160;&#160;&#160;messages<br/>0x00000000 98306&#160;&#160;&#160;&#160;&#160;&#160;mtk&#160;&#160;&#160;&#160;&#160;&#160;600&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0<br/>0x000004d2 163844&#160;&#160;&#160;&#160;&#160;mtk&#160;&#160;&#160;&#160;&#160;&#160;600&#160;&#160;&#160;&#160;&#160;&#160;12&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2</p>
<p class="examplet"><span epub:type="pagebreak" id="page_953"/><a id="ch46ex6"/><strong>Listing 46-6:</strong> Displaying all System V message queues on the system</p>
<p class="programsli">_________________________________________________________ <span class="codestrong">svmsg/svmsg_ls.c</span><br/><br/>#define _GNU_SOURCE<br/>#include &lt;sys/types.h&gt;<br/>#include &lt;sys/msg.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int maxind, ind, msqid;<br/>&#160;&#160;&#160;&#160;struct msqid_ds ds;<br/>&#160;&#160;&#160;&#160;struct msginfo msginfo;<br/><br/>&#160;&#160;&#160;&#160;/* Obtain size of kernel 'entries' array */<br/><br/>&#160;&#160;&#160;&#160;maxind = msgctl(0, MSG_INFO, (struct msqid_ds *) &#38;msginfo);<br/>&#160;&#160;&#160;&#160;if (maxind == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msgctl-MSG_INFO");<br/><br/>&#160;&#160;&#160;&#160;printf("maxind: %d\n\n", maxind);<br/>&#160;&#160;&#160;&#160;printf("index&#160;&#160;&#160;&#160;&#160;id&#160;&#160;&#160;&#160;&#160;&#160;&#160;key&#160;&#160;&#160;&#160;&#160;&#160;messages\n");<br/><br/>&#160;&#160;&#160;&#160;/* Retrieve and display information from each element of 'entries' array */<br/><br/>&#160;&#160;&#160;&#160;for (ind = 0; ind &lt;= maxind; ind++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msqid = msgctl(ind, MSG_STAT, &#38;ds);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (msqid == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno != EINVAL &#38;&#38; errno != EACCES)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("msgctl-MSG_STAT");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Unexpected error */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Ignore this item */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%4d %8d 0x%08lx %7ld\n", ind, msqid,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(unsigned long) ds.msg_perm.__key, (long) ds.msg_qnum);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________________ <span class="codestrong">svmsg/svmsg_ls.c</span></p>
<h3 class="h3" id="ch46lev1sec07"><strong>46.7 Client-Server Programming with Message Queues</strong></h3>
<p class="noindentab">In this section, we consider two of various possible designs for client-server applications using System V message queues:</p>
<p class="bull">&#8226; The use of a single message queue for exchanging messages in both directions between server and client.</p>
<p class="bull">&#8226; The use of separate message queues for the server and for each client. The server&#8217;s queue is used to receive incoming client requests, and responses are sent to clients via the individual client queues.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_954"/>Which approach we choose depends on the requirements of our application. We next consider some of the factors that may influence our choice.</p>
<h5 class="h5" id="ch46lev3sec02"><strong>Using a single message queue for server and clients</strong></h5>
<p class="noindentab">Using a single message queue may be suitable when the messages exchanged between servers and clients are small. However, note the following points:</p>
<p class="bull">&#8226; Since multiple processes may attempt to read messages at the same time, we must use the message type (<em>mtype</em>) field to allow each process to select only those messages intended for it. One way to accomplish this is to use the client&#8217;s process ID as the message type for messages sent from the server to the client. The client can send its process ID as part of its message(s) to the server. Furthermore, messages to the server must also be distinguished by a unique message type. For this purpose, we can use the number 1, which, being the process ID of the permanently running <em>init</em> process, can never be the process ID of a client process. (An alternative would be to use the server&#8217;s process ID as the message type; however, it is difficult for the clients to obtain this information.) This numbering scheme is shown in <a href="ch46.xhtml#ch46fig2">Figure 46-2</a>.</p>
<p class="bull">&#8226; Message queues have a limited capacity. This has the potential to cause a couple of problems. One of these is that multiple simultaneous clients could fill the message queue, resulting in a deadlock situation, where no new client requests can be submitted and the server is blocked from writing any responses. The other problem is that a poorly behaved or intentionally malicious client may fail to read responses from the server. This can lead to the queue becoming clogged with unread messages, preventing any communication between clients and server. (Using two queues&#8212;one for messages from clients to the server, and the other for messages from the server to the clients&#8212;would solve the first of these problems, but not the second.)</p>
<div class="image"><img src="../images/f46-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch46fig2"/><strong>Figure 46-2:</strong> Using a single message queue for client-server IPC</p>
<h5 class="h5" id="ch46lev3sec03"><strong>Using one message queue per client</strong></h5>
<p class="noindentab">Using one message queue per client (as well as one for the server) is preferable where large messages need to be exchanged, or where there is potential for the <span epub:type="pagebreak" id="page_955"/>problems listed above when using a single message queue. Note the following points regarding this approach:</p>
<p class="bull">&#8226; Each client must create its own message queue (typically using the <span class="literal">IPC_PRIVATE</span> key) and inform the server of the queue&#8217;s identifier, usually by transmitting the identifier as part of the client&#8217;s message(s) to the server.</p>
<p class="bull">&#8226; There is a system-wide limit (<span class="literal">MSGMNI</span>) on the number of message queues, and the default value for this limit is quite low on some systems. If we expect to have a large number of simultaneous clients, we may need to raise this limit.</p>
<p class="bull">&#8226; The server should allow for the possibility that the client&#8217;s message queue no longer exists (perhaps because the client prematurely deleted it).</p>
<p class="noindentt">We say more about using one message queue per client in the next section.</p>
<h3 class="h3" id="ch46lev1sec08"><strong>46.8 A File-Server Application Using Message Queues</strong></h3>
<p class="noindenta">In this section, we describe a client-server application that uses one message queue per client. The application is a simple file server. The client sends a request message to the server&#8217;s message queue asking for the contents of a named file. The server responds by returning the file contents as a series of messages to the client&#8217;s private message queue. <a href="ch46.xhtml#ch46fig3">Figure 46-3</a> provides an overview of the application.</p>
<p class="indent">Because the server performs no authentication of the client, any user that can run the client can obtain any of the files accessible to the server. A more sophisticated server would require some type of authentication from the client before serving the requested file.</p>
<div class="image"><img src="../images/f46-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch46fig3"/><strong>Figure 46-3:</strong> Client-server IPC using one message queue per client</p>
<h5 class="h5" id="ch46lev3sec04"><strong>Common header file</strong></h5>
<p class="noindenta"><a href="ch46.xhtml#ch46ex7">Listing 46-7</a> is the header file included by both the server and the client. This header defines the well-known key to be used for the server&#8217;s message queue <span epub:type="pagebreak" id="page_956"/>(<span class="literal">SERVER_KEY</span>), and defines the formats of the messages to be passed between the client and the server.</p>
<p class="indent">The <em>requestMsg</em> structure defines the format of the request sent from the client to the server. In this structure, the <em>mtext</em> component consists of two fields: the identifier of the client&#8217;s message queue and the pathname of the file requested by the client. The constant <span class="literal">REQ_MSG_SIZE</span> equates to the combined size of these two fields and is used as the <em>msgsz</em> argument in calls to <em>msgsnd()</em> using this structure.</p>
<p class="indent">The <em>responseMsg</em> structure defines the format of the response messages sent from the server back to the client. The <em>mtype</em> field is used in response messages to supply information about the message content, as defined by the <span class="literal">RESP_MT_*</span> constants.</p>
<p class="examplet"><a id="ch46ex7"/><strong>Listing 46-7:</strong> Header file for <span class="literal">svmsg_file_server.c</span> and <span class="literal">svmsg_file_client.c</span></p>
<p class="programsli">_______________________________________________________ <span class="codestrong">svmsg/svmsg_file.h</span><br/><br/>#include &lt;sys/types.h&gt;<br/>#include &lt;sys/msg.h&gt;<br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;stddef.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* For definition of offsetof() */<br/>#include &lt;limits.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include &lt;signal.h&gt;<br/>#include &lt;sys/wait.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>#define SERVER_KEY 0x1aaaaaa1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Key for server's message queue */<br/><br/>struct requestMsg {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Requests (client to server) */<br/>&#160;&#160;&#160;&#160;long mtype;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Unused */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;clientId;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* ID of client's message queue */<br/>&#160;&#160;&#160;&#160;char pathname[PATH_MAX];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* File to be returned */<br/>};<br/><br/>/* REQ_MSG_SIZE computes size of 'mtext' part of 'requestMsg' structure.<br/>&#160;&#160;&#160;We use offsetof() to handle the possibility that there are padding<br/>&#160;&#160;&#160;bytes between the 'clientId' and 'pathname' fields. */<br/><br/>#define REQ_MSG_SIZE (offsetof(struct requestMsg, pathname) - \<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;offsetof(struct requestMsg, clientId) + PATH_MAX)<br/><br/>#define RESP_MSG_SIZE 8192<br/><br/>struct responseMsg {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Responses (server to client) */<br/>&#160;&#160;&#160;&#160;long mtype;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* One of RESP_MT_* values below */<br/>&#160;&#160;&#160;&#160;char data[RESP_MSG_SIZE];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* File content / response message */<br/>};<br/><br/>/* Types for response messages sent from server to client */<br/><br/>#define RESP_MT_FAILURE 1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* File couldn't be opened */<br/>#define RESP_MT_DATA&#160;&#160;&#160;&#160;2&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Message contains file data */<br/>#define RESP_MT_END&#160;&#160;&#160;&#160;&#160;3&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* File data complete */<br/>_______________________________________________________ <span class="codestrong">svmsg/svmsg_file.h</span></p>
<h5 class="h5" id="ch46lev3sec05"><span epub:type="pagebreak" id="page_957"/><strong>Server program</strong></h5>
<p class="noindentab"><a href="ch46.xhtml#ch46ex8">Listing 46-8</a> is the server program for the application. Note the following points about the server:</p>
<p class="bull">&#8226; The server is designed to handle requests concurrently. A concurrent server design is preferable to the iterative design employed in <a href="ch44.xhtml#ch44ex7">Listing 44-7</a> (<a href="ch44.xhtml#page_912">page 912</a>), since we want to avoid the possibility that a client request for a large file would cause all other client requests to wait.</p>
<p class="bull">&#8226; Each client request is handled by creating a child process that serves the requested file <span class="ent">&#x2467;</span>. In the meantime, the main server process waits upon further client requests. Note the following points about the server child:</p>
<p class="dash1">&#8211; Since the child produced via <em>fork()</em> inherits a copy of the parent&#8217;s stack, it thus obtains a copy of the request message read by the main server process.</p>
<p class="dash1">&#8211; The server child terminates after handling its associated client request <span class="ent">&#x2468;</span>.</p>
<p class="bull">&#8226; In order to avoid the creation of zombie processes (<a href="ch26.xhtml#ch26lev1sec02">Section 26.2</a>), the server establishes a handler for <span class="literal">SIGCHLD</span> <span class="ent">&#x2465;</span> and calls <em>waitpid()</em> within this handler <span class="ent">&#x2460;</span>.</p>
<p class="bull">&#8226; The <em>msgrcv()</em> call in the parent server process may block, and consequently be interrupted by the <span class="literal">SIGCHLD</span> handler. To handle this possibility, a loop is used to restart the call if it fails with the <span class="literal">EINTR</span> error <span class="ent">&#x2466;</span>.</p>
<p class="bull">&#8226; The server child executes the <em>serveRequest()</em> function <span class="ent">&#x2461;</span>, which sends three message types back to the client. A response with an <em>mtype</em> of <span class="literal">RESP_MT_FAILURE</span> indicates that the server could not open the requested file <span class="ent">&#x2462;</span>; <span class="literal">RESP_MT_DATA</span> is used for a series of messages containing file data <span class="ent">&#x2463;</span>; and <span class="literal">RESP_MT_END</span> (with a zero-length <em>data</em> field) is used to indicate that transmission of file data is complete <span class="ent">&#x2464;</span>.</p>
<p class="noindentt">We consider a number of ways to improve and extend the server program in <a href="ch46.xhtml#ch46exe4">Exercise 46-4</a>.</p>
<p class="examplet"><a id="ch46ex8"/><strong>Listing 46-8:</strong> A file server using System V message queues</p>
<p class="programsli">_________________________________________________ <span class="codestrong">svmsg/svmsg_file_server.c</span><br/><br/>&#160;&#160;&#160;#include "svmsg_file.h"<br/><br/>&#160;&#160;&#160;static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* SIGCHLD handler */<br/>&#160;&#160;&#160;grimReaper(int sig)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int savedErrno;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;savedErrno = errno;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* waitpid() might change 'errno' */<br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;while (waitpid(-1, NULL, WNOHANG) &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;errno = savedErrno;<br/>&#160;&#160;&#160;}<br/><br/><span epub:type="pagebreak" id="page_958"/>&#160;&#160;&#160;static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Executed in child process: serve a single client */<br/><span class="ent">&#x2461;</span> serveRequest(const struct requestMsg *req)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int fd;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;ssize_t numRead;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct responseMsg resp;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;fd = open(req-&gt;pathname, O_RDONLY);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (fd == -1) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Open failed: send error text */<br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;resp.mtype = RESP_MT_FAILURE;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;snprintf(resp.data, sizeof(resp.data), "%s", "Couldn't open");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msgsnd(req-&gt;clientId, &#38;resp, strlen(resp.data) + 1, 0);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* and terminate */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Transmit file contents in messages with type RESP_MT_DATA. We don't<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;diagnose read() and msgsnd() errors since we can't notify client. */<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;resp.mtype = RESP_MT_DATA;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;while ((numRead = read(fd, resp.data, RESP_MSG_SIZE)) &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (msgsnd(req-&gt;clientId, &#38;resp, numRead, 0) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Send a message of type RESP_MT_END to signify end-of-file */<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;resp.mtype = RESP_MT_END;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;msgsnd(req-&gt;clientId, &#38;resp, 0, 0);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Zero-length mtext */<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct requestMsg req;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;pid_t pid;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;ssize_t msgLen;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int serverId;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sigaction sa;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create server message queue */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;serverId = msgget(SERVER_KEY, IPC_CREAT | IPC_EXCL |<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S_IRUSR | S_IWUSR | S_IWGRP);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (serverId == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msgget");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Establish SIGCHLD handler to reap terminated children */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_flags = SA_RESTART;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_handler = grimReaper;<br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGCHLD, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Read requests, handle each in a separate child process */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (;;) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msgLen = msgrcv(serverId, &#38;req, REQ_MSG_SIZE, 0, 0);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (msgLen == -1) {<br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno == EINTR)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Interrupted by SIGCHLD handler? */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* ... then restart msgrcv() */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("msgrcv");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Some other error */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* ... so terminate loop */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/><span class="ent">&#x2467;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pid = fork();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create child process */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (pid == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("fork");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (pid == 0) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child handles request */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;serveRequest(&#38;req);<br/><span class="ent">&#x2468;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent loops to receive next client request */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If msgrcv() or fork() fails, remove server MQ and exit */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (msgctl(serverId, IPC_RMID, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msgctl");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;}<br/>_________________________________________________ <span class="codestrong">svmsg/svmsg_file_server.c</span></p>
<h5 class="h5" id="ch46lev3sec06"><span epub:type="pagebreak" id="page_959"/><strong>Client program</strong></h5>
<p class="noindentab"><a href="ch46.xhtml#ch46ex9">Listing 46-9</a> is the client program for the application. Note the following:</p>
<p class="bull">&#8226; The client creates a message queue with the <span class="literal">IPC_PRIVATE</span> key <span class="ent">&#x2461;</span> and uses <em>atexit()</em> <span class="ent">&#x2462;</span> to establish an exit handler <span class="ent">&#x2460;</span> to ensure that the queue is deleted when the client exits.</p>
<p class="bull">&#8226; The client passes the identifier for its queue, as well as the pathname of the file to be served, in a request to the server <span class="ent">&#x2463;</span>.</p>
<p class="bull">&#8226; The client handles the possibility that the first response message sent by the server may be a failure notification (<em>mtype</em> equals <span class="literal">RESP_MT_FAILURE</span>) by printing the text of the error message returned by the server and exiting <span class="ent">&#x2464;</span>.</p>
<p class="bull">&#8226; If the file is successfully opened, then the client loops <span class="ent">&#x2465;</span>, receiving a series of messages containing the file contents (<em>mtype</em> equals <span class="literal">RESP_MT_DATA</span>). The loop is terminated by receipt of an end-of-file message (<em>mtype</em> equals <span class="literal">RESP_MT_END</span>).</p>
<p class="noindentt">This simple client doesn&#8217;t handle various possibilities resulting from failures in the server. We consider some improvements in <a href="ch46.xhtml#ch46exe5">Exercise 46-5</a>.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_960"/><a id="ch46ex9"/><strong>Listing 46-9:</strong> Client for file server using System V message queues</p>
<p class="programsli">_________________________________________________ <span class="codestrong">svmsg/svmsg_file_client.c</span><br/><br/>&#160;&#160;&#160;#include "svmsg_file.h"<br/><br/>&#160;&#160;&#160;static int clientId;<br/><br/>&#160;&#160;&#160;static void<br/>&#160;&#160;&#160;removeQueue(void)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (msgctl(clientId, IPC_RMID, NULL) == -1)<br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msgctl");<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct requestMsg req;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct responseMsg resp;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int serverId, numMsgs;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;ssize_t msgLen, totBytes;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s pathname\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (strlen(argv[1]) &gt; sizeof(req.pathname) - 1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cmdLineErr("pathname too long (max: %ld bytes)\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) sizeof(req.pathname) - 1);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get server's queue identifier; create queue for response */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;serverId = msgget(SERVER_KEY, S_IWUSR);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (serverId == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msgget - server message queue");<br/><br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;clientId = msgget(IPC_PRIVATE, S_IRUSR | S_IWUSR | S_IWGRP);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (clientId == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msgget - client message queue");<br/><br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;if (atexit(removeQueue) != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("atexit");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Send message asking for file named in argv[1] */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;req.mtype = 1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Any type will do */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;req.clientId = clientId;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;strncpy(req.pathname, argv[1], sizeof(req.pathname) - 1);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;req.pathname[sizeof(req.pathname) - 1] = '\0';<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Ensure string is terminated */<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;if (msgsnd(serverId, &#38;req, REQ_MSG_SIZE, 0) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msgsnd");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get first response, which may be failure notification */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;msgLen = msgrcv(clientId, &#38;resp, RESP_MSG_SIZE, 0, 0);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (msgLen == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msgrcv");<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;if (resp.mtype == RESP_MT_FAILURE) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s\n", resp.data);&#160;&#160;&#160;&#160;&#160;&#160;/* Display msg from server */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* File was opened successfully by server; process messages<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(including the one already received) containing file data */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;totBytes = msgLen;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Count first message */<br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;for (numMsgs = 1; resp.mtype == RESP_MT_DATA; numMsgs++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msgLen = msgrcv(clientId, &#38;resp, RESP_MSG_SIZE, 0, 0);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (msgLen == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msgrcv");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;totBytes += msgLen;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Received %ld bytes (%d messages)\n", (long) totBytes, numMsgs);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;}<br/>_________________________________________________ <span class="codestrong">svmsg/svmsg_file_client.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_961"/>The following shell session demonstrates the use of the programs in <a href="ch46.xhtml#ch46ex8">Listing 46-8</a> and <a href="ch46.xhtml#ch46ex9">Listing 46-9</a>:</p>
<p class="programs">$ <span class="codestrong">./svmsg_file_server &#38;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Run server in background</span><br/>[1] 9149<br/>$ <span class="codestrong">wc -c /etc/services</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Show size of file that client will request</span><br/>764360 /etc/services<br/>$ <span class="codestrong">./svmsg_file_client /etc/services</span><br/>Received 764360 bytes (95 messages)&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Bytes received matches size above</span><br/>$ <span class="codestrong">kill %1</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Terminate server</span><br/>[1]+&#160;&#160;Terminated&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;./svmsg_file_server</p>
<h3 class="h3" id="ch46lev1sec09"><strong>46.9 Disadvantages of System V Message Queues</strong></h3>
<p class="noindenta">UNIX systems provide a number of mechanisms for transmitting data from one process to another on the same system, either in the form of an undelimited byte stream (pipes, FIFOs, and UNIX domain stream sockets) or as delimited messages (System V message queues, POSIX message queues, and UNIX domain datagram sockets).</p>
<p class="indent">A distinctive feature of System V message queues is the ability to attach a numeric type to each message. This provides for two possibilities that may be useful <span epub:type="pagebreak" id="page_962"/>to applications: reading processes may select messages by type, or they may employ a priority-queue strategy so that higher-priority messages (i.e., those with lower message type values) are read first.</p>
<p class="indentb">However, System V message queues have a number of disadvantages:</p>
<p class="bull">&#8226; Message queues are referred to by identifiers, rather than the file descriptors used by most other UNIX I/O mechanisms. This means that a variety of file descriptor&#8211;based I/O techniques described in <a href="ch63.xhtml#ch63">Chapter 63</a> (e.g., <em>select()</em>, <em>poll()</em>, and <em>epoll</em>) can&#8217;t be applied to message queues. Furthermore, writing programs that simultaneously handle inputs from both message queues and file descriptor&#8211;based I/O mechanisms requires code that is more complex than code that deals with file descriptors alone. (We look at one way of combining the two I/O models in <a href="ch63.xhtml#ch63exe3">Exercise 63-3</a>.)</p>
<p class="bull">&#8226; The use of keys, rather than filenames, to identify message queues results in additional programming complexity and also requires the use of <em>ipcs</em> and <em>ipcrm</em> instead of <em>ls</em> and <em>rm</em>. The <em>ftok()</em> function usually generates a unique key, but it is not guaranteed to do so. Employing the <span class="literal">IPC_PRIVATE</span> key guarantees a unique queue identifier, but leaves us with the task of making that identifier visible to other processes that require it.</p>
<p class="bull">&#8226; Message queues are connectionless, and the kernel doesn&#8217;t maintain a count of the number of processes referring to the queue as is done with pipes, FIFOs, and sockets. Consequently, it can be difficult to answer the following questions:</p>
<p class="dash1">&#8211; When is it safe for an application to delete a message queue? (Premature deletion of the queue results in immediate loss of data, regardless of whether any process might later be interested in reading from the queue.)</p>
<p class="dash1">&#8211; How can an application ensure that an unused queue is deleted?</p>
<p class="bull">&#8226; There are limits on the total number of message queues, the size of messages, and the capacity of individual queues. These limits are configurable, but if an application operates outside the range of the default limits, this requires extra work when installing the application.</p>
<p class="noindentt">In summary, System V message queues are often best avoided. In situations where we require the facility to select messages by type, we should consider alternatives. POSIX message queues (<a href="ch52.xhtml#ch52">Chapter 52</a>) are one such alternative. As a further alternative, solutions involving multiple file descriptor&#8211;based communication channels may provide functionality similar to selecting messages by type, while at the same time allowing the use of the alternative I/O models described in <a href="ch63.xhtml#ch63">Chapter 63</a>. For example, if we need to transmit &#8220;normal&#8221; and &#8220;priority&#8221; messages, we could use a pair of FIFOs or UNIX domain sockets for the two message types, and then employ <em>select()</em> or <em>poll()</em> to monitor file descriptors for both channels.</p>
<h3 class="h3" id="ch46lev1sec10"><strong>46.10 Summary</strong></h3>
<p class="noindenta">System V message queues allow processes to communicate by exchanging messages consisting of a numeric type plus a body containing arbitrary data. The distinguishing features of message queues are that message boundaries are preserved and that <span epub:type="pagebreak" id="page_963"/>the receiver(s) can select messages by type, rather than reading messages in first-in, first-out order.</p>
<p class="indent">Various factors led us to conclude that other IPC mechanisms are usually preferable to System V message queues. One major difficulty is that message queues are not referred to using file descriptors. This means that we can&#8217;t employ various alternative I/O models with message queues; in particular, it is complex to simultaneously monitor both message queues and file descriptors to see if I/O is possible. Furthermore, the fact that message queues are connectionless (i.e., not reference counted) makes it difficult for an application to know when a queue may be deleted safely.</p>
<h3 class="h3" id="ch46lev1sec11"><strong>46.11 Exercises</strong></h3>
<p class="exer"><a id="ch46exe1"/><strong>46-1.</strong>&#160;&#160;&#160;Experiment with the programs in <a href="ch46.xhtml#ch46ex1">Listing 46-1</a> (<span class="literal">svmsg_create.c</span>), <a href="ch46.xhtml#ch46ex2">Listing 46-2</a> (<span class="literal">svmsg_send.c</span>), and <a href="ch46.xhtml#ch46ex3">Listing 46-3</a> (<span class="literal">svmsg_receive.c</span>) to confirm your understanding of the <em>msgget()</em>, <em>msgsnd()</em>, and <em>msgrcv()</em> system calls.</p>
<p class="exer"><a id="ch46exe2"/><strong>46-2.</strong>&#160;&#160;&#160;Recode the sequence-number client-server application of <a href="ch44.xhtml#ch44lev1sec08">Section 44.8</a> to use System V message queues. Use a single message queue to transmit messages from both client to server and server to client. Employ the conventions for message types described in <a href="ch46.xhtml#ch46lev1sec08">Section 46.8</a>.</p>
<p class="exer"><a id="ch46exe3"/><strong>46-3.</strong>&#160;&#160;&#160;In the client-server application of <a href="ch46.xhtml#ch46lev1sec08">Section 46.8</a>, why does the client pass the identifier of its message queue in the body of the message (in the <em>clientId</em> field), rather than in the message type (<em>mtype</em>)?</p>
<p class="exer"><a id="ch46exe4"/><strong>46-4.</strong>&#160;&#160;&#160;Make the following changes to the client-server application of <a href="ch46.xhtml#ch46lev1sec08">Section 46.8</a>:</p>
<p class="olista1">a) Replace the use of a hard-coded message queue key with code in the server that uses <span class="literal">IPC_PRIVATE</span> to generate a unique identifier, and then writes this identifier to a well-known file. The client must read the identifier from this file. The server should remove this file if it terminates.</p>
<p class="olista1">b) In the <em>serveRequest()</em> function of the server program, system call errors are not diagnosed. Add code that logs errors using <em>syslog()</em> (<a href="ch37.xhtml#ch37lev1sec05">Section 37.5</a>).</p>
<p class="olista1">c) Add code to the server so that it becomes a daemon on startup (<a href="ch37.xhtml#ch37lev1sec02">Section 37.2</a>).</p>
<p class="olista1">d) In the server, add a handler for <span class="literal">SIGTERM</span> and <span class="literal">SIGINT</span> that performs a tidy exit. The handler should remove the message queue and (if the earlier part of this exercise was implemented) the file created to hold the server&#8217;s message queue identifier. Include code in the handler to terminate the server by disestablishing the handler, and then once more raising the same signal that invoked the handler (see <a href="ch26.xhtml#ch26lev2sec04">Section 26.1.4</a> for the rationale and steps required for this task).</p>
<p class="olista1">e) The server child doesn&#8217;t handle the possibility that the client may terminate prematurely, in which case the server child would fill the client&#8217;s message queue, and then block indefinitely. Modify the server to handle this possibility by establishing a timeout when calling <em>msgsnd()</em>, as described in <a href="ch23.xhtml#ch23lev1sec03">Section 23.3</a>. If the server child deems that the client has disappeared, it should attempt <span epub:type="pagebreak" id="page_964"/>to delete the client&#8217;s message queue, and then exit (after perhaps logging a message via <em>syslog()</em>).</p>
<p class="exer"><a id="ch46exe5"/><strong>46-5.</strong>&#160;&#160;&#160;The client shown in <a href="ch46.xhtml#ch46ex9">Listing 46-9</a> (<span class="literal">svmsg_file_client.c</span>) doesn&#8217;t handle various possibilities for failure in the server. In particular, if the server message queue fills up (perhaps because the server terminated and the queue was filled by other clients), then the <em>msgsnd()</em> call will block indefinitely. Similarly, if the server fails to send a response to the client, then the <em>msgrcv()</em> call will block indefinitely. Add code to the client that sets timeouts (<a href="ch23.xhtml#ch23lev1sec03">Section 23.3</a>) on these calls. If either call times out, then the program should report an error to the user and terminate.</p>
<p class="exer"><a id="ch46exe6"/><strong>46-6.</strong>&#160;&#160;&#160;Write a simple chat application (similar to <em>talk(1)</em>, but without the <em>curses</em> interface) using System V messages queues. Use a single message queue for each client.</p>
</body>
</html>
