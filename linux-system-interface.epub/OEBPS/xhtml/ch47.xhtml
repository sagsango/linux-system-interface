<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch47"><span epub:type="pagebreak" id="page_965"/><strong><span class="big">47</span></strong><br/><strong>SYSTEM V SEMAPHORES</strong></h2>
<p class="noindenta">This chapter describes System V semaphores. Unlike the IPC mechanisms described in previous chapters, System V semaphores are not used to transfer data between processes. Instead, they allow processes to synchronize their actions. One common use of a semaphore is to synchronize access to a block of shared memory, in order to prevent one process from accessing the shared memory at the same time as another process is updating it.</p>
<p class="indentb">A semaphore is a kernel-maintained integer whose value is restricted to being greater than or equal to 0. Various operations (i.e., system calls) can be performed on a semaphore, including the following:</p>
<p class="bull">&#8226; setting the semaphore to an absolute value;</p>
<p class="bull">&#8226; adding a number to the current value of the semaphore;</p>
<p class="bull">&#8226; subtracting a number from the current value of the semaphore; and</p>
<p class="bull">&#8226; waiting for the semaphore value to be equal to 0.</p>
<p class="noindentt">The last two of these operations may cause the calling process to block. When lowering a semaphore value, the kernel blocks any attempt to decrease the value below 0. Similarly, waiting for a semaphore to equal 0 blocks the calling process if the semaphore value is not currently 0. In both cases, the calling process remains blocked until some other process alters the semaphore to a value that allows the operation to proceed, at which point the kernel wakes the blocked process. <a href="ch47.xhtml#ch47fig1">Figure 47-1</a> shows <span epub:type="pagebreak" id="page_966"/>the use of a semaphore to synchronize the actions of two processes that alternately move the semaphore value between 0 and 1.</p>
<div class="image"><img src="../images/f47-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch47fig1"/><strong>Figure 47-1:</strong> Using a semaphore to synchronize two processes</p>
<p class="noindent">In terms of controlling the actions of a process, a semaphore has no meaning in and of itself. Its meaning is determined only by the associations given to it by the processes using the semaphore. Typically, processes agree on a convention that associates a semaphore with a shared resource, such as a region of shared memory. Other uses of semaphores are also possible, such as synchronization between parent and child processes after <em>fork()</em>. (In <a href="ch24.xhtml#ch24lev1sec05">Section 24.5</a>, we looked at the use of signals to accomplish the same task.)</p>
<h3 class="h3" id="ch47lev1sec01"><strong>47.1 Overview</strong></h3>
<p class="noindentab">The general steps for using a System V semaphore are the following:</p>
<p class="bull">&#8226; Create or open a semaphore set using <em>semget()</em>.</p>
<p class="bull">&#8226; Initialize the semaphores in the set using the <em>semctl()</em> <span class="literal">SETVAL</span> or <span class="literal">SETALL</span> operation. (Only one process should do this.)</p>
<p class="bull">&#8226; Perform operations on semaphore values using <em>semop()</em>. The processes using the semaphore typically use these operations to indicate acquisition and release of a shared resource.</p>
<p class="bull">&#8226; When all processes have finished using the semaphore set, remove the set using the <em>semctl()</em> <span class="literal">IPC_RMID</span> operation. (Only one process should do this.)</p>
<p class="noindentt">Most operating systems provide some type of semaphore primitive for use in application programs. However, System V semaphores are rendered unusually complex by the fact that they are allocated in groups called <em>semaphore sets</em>. The number of semaphores in a set is specified when the set is created using the <em>semget()</em> system <span epub:type="pagebreak" id="page_967"/>call. While it is common to operate on a single semaphore at a time, the <em>semop()</em> system call allows us to atomically perform a group of operations on multiple semaphores in the same set.</p>
<p class="indent">Because System V semaphores are created and initialized in separate steps, race conditions can result if two processes try to perform these steps at the same time. Describing this race condition and how to avoid it requires that we describe <em>semctl()</em> before describing <em>semop()</em>, which means that there is quite a lot of material to cover before we have all of the details required to fully understand semaphores.</p>
<p class="indentb">In the meantime, we provide <a href="ch47.xhtml#ch47ex1">Listing 47-1</a> as a simple example of the use of the various semaphore system calls. This program operates in two modes:</p>
<p class="bull">&#8226; Given a single integer command-line argument, the program creates a new semaphore set containing a single semaphore, and initializes the semaphore to the value supplied in the command-line argument. The program displays the identifier of the new semaphore set.</p>
<p class="bull">&#8226; Given two command-line arguments, the program interprets them as (in order) the identifier of an existing semaphore set and a value to be added to the first semaphore (numbered 0) in that set. The program carries out the specified operation on that semaphore. To enable us to monitor the semaphore operation, the program prints messages before and after the operation. Each of these messages begins with the process ID, so that we can distinguish the output of multiple instances of the program.</p>
<p class="noindentt">The following shell session log demonstrates the use of the program in <a href="ch47.xhtml#ch47ex1">Listing 47-1</a>. We begin by creating a semaphore that is initialized to 0:</p>
<p class="programs">$ <span class="codestrong">./svsem_demo 0</span><br/>Semaphore ID = 98307&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">ID of new semaphore set</span></p>
<p class="noindent">We then execute a background command that tries to decrease the semaphore value by 2:</p>
<p class="programs">$ <span class="codestrong">./svsem_demo 98307 -2 &#38;</span><br/>23338: about to semop at 10:19:42<br/>[1] 23338</p>
<p class="noindent">This command blocked, because the value of the semaphore can&#8217;t be decreased below 0. Now, we execute a command that adds 3 to the semaphore value:</p>
<p class="programs">$ <span class="codestrong">./svsem_demo 98307 +3</span><br/>23339: about to semop at&#160;&#160;10:19:55<br/>23339: semop completed at 10:19:55<br/>23338: semop completed at 10:19:55<br/>[1]+&#160;&#160;Done&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;./svsem_demo 98307 -2</p>
<p class="noindent">The semaphore increment operation succeeded immediately, and caused the semaphore decrement operation in the background command to proceed, since that operation could now be performed without leaving the semaphore&#8217;s value below 0.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_968"/><a id="ch47ex1"/><strong>Listing 47-1:</strong> Creating and operating on System V semaphores</p>
<p class="programsli">_______________________________________________________ <span class="codestrong">svsem/svsem_demo.c</span><br/><br/>#include &lt;sys/types.h&gt;<br/>#include &lt;sys/sem.h&gt;<br/>#include &lt;sys/stat.h&gt;<br/>#include "curr_time.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declaration of currTime() */<br/>#include "semun.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Definition of semun union */<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int semid;<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 2 || argc &gt; 3 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s init-value\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"&#160;&#160;&#160;or: %s semid operation\n", argv[0], argv[0]);<br/><br/>&#160;&#160;&#160;&#160;if (argc == 2) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create and initialize semaphore */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;union semun arg;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;semid = semget(IPC_PRIVATE, 1, S_IRUSR | S_IWUSR);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (semid == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semid");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;arg.val = getInt(argv[1], 0, "init-value");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (semctl(semid, /* semnum= */ 0, SETVAL, arg) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semctl");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Semaphore ID = %d\n", semid);<br/><br/>&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Perform an operation on first semaphore */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sembuf sop;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Structure defining operation */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;semid = getInt(argv[1], 0, "semid");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sop.sem_num = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Specifies first semaphore in set */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sop.sem_op = getInt(argv[2], 0, "operation");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Add, subtract, or wait for 0 */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sop.sem_flg = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* No special options for operation */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%ld: about to semop at %s\n", (long) getpid(), currTime("%T"));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (semop(semid, &#38;sop, 1) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semop");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%ld: semop completed at %s\n", (long) getpid(), currTime("%T"));<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_______________________________________________________ <span class="codestrong">svsem/svsem_demo.c</span></p>
<h3 class="h3" id="ch47lev1sec02"><span epub:type="pagebreak" id="page_969"/><strong>47.2 Creating or Opening a Semaphore Set</strong></h3>
<p class="noindenta">The <em>semget()</em> system call creates a new semaphore set or obtains the identifier of an existing set.</p>
<div class="box">
<p class="programsa">#include &lt;sys/types.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;/* For portability */<br/>#include &lt;sys/sem.h&gt;<br/><br/>int <span class="codestrong">semget</span>(key_t <span class="font1">key</span>, int <span class="font1">nsems</span>, int <span class="font1">semflg</span>);</p>
<p class="right">Returns semaphore set identifier on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>key</em> argument is a key generated using one of the methods described in <a href="ch45.xhtml#ch45lev1sec02">Section 45.2</a> (i.e., usually the value <span class="literal">IPC_PRIVATE</span> or a key returned by <em>ftok()</em>).</p>
<p class="indent">If we are using <em>semget()</em> to create a new semaphore set, then <em>nsems</em> specifies the number of semaphores in that set, and must be greater than 0. If we are using <em>semget()</em> to obtain the identifier of an existing set, then <em>nsems</em> must be less than or equal to the size of the set (or the error <span class="literal">EINVAL</span> results). It is not possible to change the number of semaphores in an existing set.</p>
<p class="indentb">The <em>semflg</em> argument is a bit mask specifying the permissions to be placed on a new semaphore set or checked against an existing set. These permissions are specified in the same manner as for files (<a href="ch15.xhtml#ch15table4">Table 15-4</a>, on <a href="ch15.xhtml#page_295">page 295</a>). In addition, zero or more of the following flags can be ORed (<span class="literal">|</span>) in <em>semflg</em> to control the operation of <em>semget()</em>:</p>
<p class="term"><span class="literal">IPC_CREAT</span></p>
<p class="termlist">If no semaphore set with the specified <em>key</em> exists, create a new set.</p>
<p class="term"><span class="literal">IPC_EXCL</span></p>
<p class="termlist">If <span class="literal">IPC_CREAT</span> was also specified, and a semaphore set with the specified <em>key</em> already exists, fail with the error <span class="literal">EEXIST</span>.</p>
<p class="noindentt">These flags are described in more detail in <a href="ch45.xhtml#ch45lev1sec01">Section 45.1</a>.</p>
<p class="indent">On success, <em>semget()</em> returns the identifier for the new or existing semaphore set. Subsequent system calls referring to individual semaphores must specify both the semaphore set identifier and the number of the semaphore within that set. The semaphores within a set are numbered starting at 0.</p>
<h3 class="h3" id="ch47lev1sec03"><strong>47.3 Semaphore Control Operations</strong></h3>
<p class="noindenta">The <em>semctl()</em> system call performs a variety of control operations on a semaphore set or on an individual semaphore within a set.</p>
<div class="box">
<p class="programsa">#include &lt;sys/types.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;/* For portability */<br/>#include &lt;sys/sem.h&gt;<br/><br/>int <span class="codestrong">semctl</span>(int <span class="font1">semid</span>, int <span class="font1">semnum</span>, int <span class="font1">cmd</span>, ... /* union semun <span class="font1">arg</span> */);</p>
<p class="right">Returns nonnegative integer on success (see text); returns &#8211;1 on error</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_970"/>The <em>semid</em> argument is the identifier of the semaphore set on which the operation is to be performed. For those operations performed on a single semaphore, the <em>semnum</em> argument identifies a particular semaphore within the set. For other operations, this argument is ignored, and we can specify it as 0. The <em>cmd</em> argument specifies the operation to be performed.</p>
<p class="indent">Certain operations require a fourth argument to <em>semctl()</em>, which we refer to by the name <em>arg</em> in the remainder of this section. This argument is a union defined as shown in <a href="ch47.xhtml#ch47ex2">Listing 47-2</a>. We must explicitly define this union in our programs. We do this in our example programs by including the header file in <a href="ch47.xhtml#ch47ex2">Listing 47-2</a>.</p>
<div class="block">
<p class="noindent">Although placing the definition of the <em>semun</em> union in a standard header file would be sensible, SUSv3 requires the programmer to explicitly define it instead. Nevertheless, some UNIX implementations do provide this definition in <span class="literal">&lt;sys/sem.h&gt;</span>. Older versions of <em>glibc</em> (up to and including version 2.0) also provided this definition. In conformance with SUSv3, more recent versions of <em>glibc</em> do not, and the macro <span class="literal">_SEM_SEMUN_UNDEFINED</span> is defined with the value 1 in <span class="literal">&lt;sys/sem.h&gt;</span> to indicate this fact (i.e., an application compiled against <em>glibc</em> can test this macro to determine if the program must itself define the <em>semun</em> union).</p>
</div>
<p class="examplet"><a id="ch47ex2"/><strong>Listing 47-2:</strong> Definition of the <em>semun</em> union</p>
<p class="programsli">____________________________________________________________ <span class="codestrong">svsem/semun.h</span><br/><br/>#ifndef SEMUN_H<br/>#define SEMUN_H&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Prevent accidental double inclusion */<br/><br/>#include &lt;sys/types.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* For portability */<br/>#include &lt;sys/sem.h&gt;<br/><br/>union semun {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Used in calls to semctl() */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;val;<br/>&#160;&#160;&#160;&#160;struct semid_ds *&#160;&#160;&#160;buf;<br/>&#160;&#160;&#160;&#160;unsigned short *&#160;&#160;&#160;&#160;array;<br/>#if defined(__linux__)<br/>&#160;&#160;&#160;&#160;struct seminfo *&#160;&#160;&#160;&#160;__buf;<br/>#endif<br/>};<br/><br/>#endif<br/>____________________________________________________________ <span class="codestrong">svsem/semun.h</span></p>
<p class="noindent">SUSv2 and SUSv3 specify that the final argument to <em>semctl()</em> is optional. However, a few (mainly older) UNIX implementations (and older versions of <em>glibc</em>) prototyped <em>semctl()</em> as follows:</p>
<p class="programs">int semctl(int semid, int semnum, int cmd, union semun arg);</p>
<p class="noindent">This meant that the fourth argument was required even in the cases where it is not actually used (e.g., the <span class="literal">IPC_RMID</span> and <span class="literal">GETVAL</span> operations described below). For full portability, we specify a dummy final argument to <em>semctl()</em> in those calls where it is not required.</p>
<p class="indent">In the remainder of this section, we consider the various control operations that can be specified for <em>cmd</em>.</p>
<h5 class="h5" id="ch47lev3sec01"><span epub:type="pagebreak" id="page_971"/><strong>Generic control operations</strong></h5>
<p class="noindentab">The following operations are the same ones that can be applied to other types of System V IPC objects. In each case, the <em>semnum</em> argument is ignored. Further details about these operations, including the privileges and permissions required by the calling process, are provided in <a href="ch45.xhtml#ch45lev1sec03">Section 45.3</a>.</p>
<p class="term"><span class="literal">IPC_RMID</span></p>
<p class="termlist">Immediately remove the semaphore set and its associated <em>semid_ds</em> data structure. Any processes blocked in <em>semop()</em> calls waiting on semaphores in this set are immediately awakened, with <em>semop()</em> reporting the error <span class="literal">EIDRM</span>. The <em>arg</em> argument is not required.</p>
<p class="term"><span class="literal">IPC_STAT</span></p>
<p class="termlist">Place a copy of the <em>semid_ds</em> data structure associated with this semaphore set in the buffer pointed to by <em>arg.buf</em>. We describe the <em>semid_ds</em> structure in <a href="ch47.xhtml#ch47lev1sec04">Section 47.4</a>.</p>
<p class="term"><span class="literal">IPC_SET</span></p>
<p class="termlist">Update selected fields of the <em>semid_ds</em> data structure associated with this semaphore set using values in the buffer pointed to by <em>arg.buf</em>.</p>
<h5 class="h5" id="ch47lev3sec02"><strong>Retrieving and initializing semaphore values</strong></h5>
<p class="noindentab">The following operations retrieve or initialize the value(s) of an individual semaphore or of all semaphores in a set. Retrieving a semaphore value requires read permission on the semaphore, while initializing the value requires alter (write) permission.</p>
<p class="term"><span class="literal">GETVAL</span></p>
<p class="termlist">As its function result, <em>semctl()</em> returns the value of the <em>semnum</em>-th semaphore in the semaphore set specified by <em>semid</em>. The <em>arg</em> argument is not required.</p>
<p class="term"><span class="literal">SETVAL</span></p>
<p class="termlist">The value of the <em>semnum</em>-th semaphore in the set referred to by <em>semid</em> is initialized to the value specified in <em>arg.val</em>.</p>
<p class="term"><span class="literal">GETALL</span></p>
<p class="termlist">Retrieve the values of all of the semaphores in the set referred to by <em>semid</em>, placing them in the array pointed to by <em>arg.array</em>. The programmer must ensure that this array is of sufficient size. (The number of semaphores in a set can be obtained from the <em>sem_nsems</em> field of the <em>semid_ds</em> data structure retrieved by an <span class="literal">IPC_STAT</span> operation.) The <em>semnum</em> argument is ignored. An example of the use of the <span class="literal">GETALL</span> operation is provided in <a href="ch47.xhtml#ch47ex3">Listing 47-3</a>.</p>
<p class="term"><span class="literal">SETALL</span></p>
<p class="termlist">Initialize all semaphores in the set referred to by <em>semid</em>, using the values supplied in the array pointed to by <em>arg.array</em>. The <em>semnum</em> argument is ignored. <a href="ch47.xhtml#ch47ex4">Listing 47-4</a> demonstrates the use of the <span class="literal">SETALL</span> operation.</p>
<p class="noindentt">If another process is waiting to perform an operation on the semaphore(s) modified by the <span class="literal">SETVAL</span> or <span class="literal">SETALL</span> operations, and the change(s) made would permit that operation to proceed, then the kernel wakes up that process.</p>
<p class="indent"><span epub:type="pagebreak" id="page_972"/>Changing the value of a semaphore with <span class="literal">SETVAL</span> or <span class="literal">SETALL</span> clears the undo entries for that semaphore in all processes. We describe semaphore undo entries in <a href="ch47.xhtml#ch47lev1sec08">Section 47.8</a>.</p>
<p class="indent">Note that the information returned by <span class="literal">GETVAL</span> and <span class="literal">GETALL</span> may already be out of date by the time the calling process comes to use it. Any program that depends on the information returned by these operations being unchanged may be subject to time-of-check, time-of-use race conditions (<a href="ch38.xhtml#ch38lev1sec06">Section 38.6</a>).</p>
<h5 class="h5" id="ch47lev3sec03"><strong>Retrieving per-semaphore information</strong></h5>
<p class="noindentab">The following operations return (via the function result value) information about the <em>semnum</em>-th semaphore of the set referred to by <em>semid</em>. For all of these operations, read permission is required on the semaphore set, and the <em>arg</em> argument is not required.</p>
<p class="term"><span class="literal">GETPID</span></p>
<p class="termlist">Return the process ID of the last process to perform a <em>semop()</em> on this semaphore; this is referred to as the <em>sempid</em> value. If no process has yet performed a <em>semop()</em> on this semaphore, 0 is returned.</p>
<p class="term"><span class="literal">GETNCNT</span></p>
<p class="termlist">Return the number of processes currently waiting for the value of this semaphore to increase; this is referred to as the <em>semncnt</em> value.</p>
<p class="term"><span class="literal">GETZCNT</span></p>
<p class="termlist">Return the number of processes currently waiting for the value of this semaphore to become 0; this is referred to as the <em>semzcnt</em> value.</p>
<p class="noindentt">As with the <span class="literal">GETVAL</span> and <span class="literal">GETALL</span> operations described above, the information returned by the <span class="literal">GETPID</span>, <span class="literal">GETNCNT</span>, and <span class="literal">GETZCNT</span> operations may already be out of date by the time the calling process comes to use it.</p>
<p class="indent"><a href="ch47.xhtml#ch47ex3">Listing 47-3</a> demonstrates the use of these three operations.</p>
<h3 class="h3" id="ch47lev1sec04"><strong>47.4 Semaphore Associated Data Structure</strong></h3>
<p class="noindenta">Each semaphore set has an associated <em>semid_ds</em> data structure of the following form:</p>
<p class="programs">struct semid_ds {<br/>&#160;&#160;&#160;&#160;struct ipc_perm sem_perm;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Ownership and permissions */<br/>&#160;&#160;&#160;&#160;time_t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sem_otime;&#160;&#160;&#160;&#160;&#160;&#160;/* Time of last semop() */<br/>&#160;&#160;&#160;&#160;time_t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sem_ctime;&#160;&#160;&#160;&#160;&#160;&#160;/* Time of last change */<br/>&#160;&#160;&#160;&#160;unsigned long&#160;&#160;&#160;sem_nsems;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of semaphores in set */<br/>};</p>
<div class="block">
<p class="noindent">SUSv3 requires all of the fields that we show in the <em>semid_ds</em> structure. Some other UNIX implementations include additional nonstandard fields. On Linux 2.4 and later, the <em>sem_nsems</em> field is typed as <em>unsigned long</em>. SUSv3 specifies the type of this field as <em>unsigned short</em>, and it is so defined in Linux 2.2 and on most other UNIX implementations.</p>
</div>
<p class="noindentb"><span epub:type="pagebreak" id="page_973"/>The fields of the <em>semid_ds</em> structure are implicitly updated by various semaphore system calls, and certain subfields of the <em>sem_perm</em> field can be explicitly updated using the <em>semctl()</em> <span class="literal">IPC_SET</span> operation. The details are as follows:</p>
<p class="term"><em>sem_perm</em></p>
<p class="termlist">When the semaphore set is created, the fields of this substructure are initialized as described in <a href="ch45.xhtml#ch45lev1sec03">Section 45.3</a>. The <em>uid</em>, <em>gid</em>, and <em>mode</em> subfields can be updated via <span class="literal">IPC_SET</span>.</p>
<p class="term"><em>sem_otime</em></p>
<p class="termlist">This field is set to 0 when the semaphore set is created, and then set to the current time on each successful <em>semop()</em>, or when the semaphore value is modified as a consequence of a <span class="literal">SEM_UNDO</span> operation (<a href="ch47.xhtml#ch47lev1sec08">Section 47.8</a>). This field and <em>sem_ctime</em> are typed as <em>time_t</em>, and store time in seconds since the Epoch.</p>
<p class="term"><em>sem_ctime</em></p>
<p class="termlist">This field is set to the current time when the semaphore set is created and on each successful <span class="literal">IPC_SET</span>, <span class="literal">SETALL</span>, or <span class="literal">SETVAL</span> operation. (On some UNIX implementations, the <span class="literal">SETALL</span> and <span class="literal">SETVAL</span> operations don&#8217;t modify <em>sem_ctime</em>.)</p>
<p class="term"><em>sem_nsems</em></p>
<p class="termlist">When the set is created, this field is initialized to the number of semaphores in the set.</p>
<p class="noindentt">In the remainder of this section, we show two example programs that make use of the <em>semid_ds</em> data structure and some of the <em>semctl()</em> operations described in <a href="ch47.xhtml#ch47lev1sec03">Section 47.3</a>. We demonstrate the use of both of these programs in <a href="ch47.xhtml#ch47lev1sec06">Section 47.6</a>.</p>
<h5 class="h5" id="ch47lev3sec04"><strong>Monitoring a semaphore set</strong></h5>
<p class="noindenta">The program in <a href="ch47.xhtml#ch47ex3">Listing 47-3</a> makes use of various <em>semctl()</em> operations to display information about the existing semaphore set whose identifier is provided as its command-line argument. The program first displays the time fields from the <em>semid_ds</em> data structure. Then, for each semaphore in the set, the program displays the semaphore&#8217;s current value, as well as its <em>sempid</em>, <em>semncnt</em>, and <em>semzcnt</em> values.</p>
<p class="examplet"><a id="ch47ex3"/><strong>Listing 47-3:</strong> A semaphore monitoring program</p>
<p class="programsli">________________________________________________________ <span class="codestrong">svsem/svsem_mon.c</span><br/><br/>#include &lt;sys/types.h&gt;<br/>#include &lt;sys/sem.h&gt;<br/>#include &lt;time.h&gt;<br/>#include "semun.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Definition of semun union */<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct semid_ds ds;<br/>&#160;&#160;&#160;&#160;union semun arg, dummy;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Fourth argument for semctl() */<br/>&#160;&#160;&#160;&#160;int semid, j;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s semid\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;semid = getInt(argv[1], 0, "semid");<br/><br/>&#160;&#160;&#160;&#160;arg.buf = &#38;ds;<br/>&#160;&#160;&#160;&#160;if (semctl(semid, 0, IPC_STAT, arg) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semctl");<br/><br/>&#160;&#160;&#160;&#160;printf("Semaphore changed: %s", ctime(&#38;ds.sem_ctime));<br/>&#160;&#160;&#160;&#160;printf("Last semop():&#160;&#160;&#160;&#160;&#160;&#160;%s", ctime(&#38;ds.sem_otime));<br/><br/>&#160;&#160;&#160;&#160;/* Display per-semaphore information */<br/><br/>&#160;&#160;&#160;&#160;arg.array = calloc(ds.sem_nsems, sizeof(arg.array[0]));<br/>&#160;&#160;&#160;&#160;if (arg.array == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("calloc");<br/>&#160;&#160;&#160;&#160;if (semctl(semid, 0, GETALL, arg) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semctl-GETALL");<br/><br/>&#160;&#160;&#160;&#160;printf("Sem #&#160;&#160;Value&#160;&#160;SEMPID&#160;&#160;SEMNCNT&#160;&#160;SEMZCNT\n");<br/><br/>&#160;&#160;&#160;&#160;for (j = 0; j &lt; ds.sem_nsems; j++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%3d&#160;&#160;&#160;%5d&#160;&#160;&#160;%5d&#160;&#160;%5d&#160;&#160;&#160;&#160;%5d\n", j, arg.array[j],<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;semctl(semid, j, GETPID, dummy),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;semctl(semid, j, GETNCNT, dummy),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;semctl(semid, j, GETZCNT, dummy));<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>________________________________________________________ <span class="codestrong">svsem/svsem_mon.c</span></p>
<h5 class="h5" id="ch47lev3sec05"><span epub:type="pagebreak" id="page_974"/><strong>Initializing all semaphores in a set</strong></h5>
<p class="noindenta">The program in <a href="ch47.xhtml#ch47ex4">Listing 47-4</a> provides a command-line interface for initializing all of the semaphores in an existing set. The first command-line argument is the identifier of the semaphore set to be initialized. The remaining command-line arguments specify the values to which the semaphores are to be initialized (there must be as many of these arguments as there are semaphores in the set).</p>
<p class="examplet"><a id="ch47ex4"/><strong>Listing 47-4:</strong> Using the <span class="literal">SETALL</span> operation to initialize a System V semaphore set</p>
<p class="programsli">_____________________________________________________ <span class="codestrong">svsem/svsem_setall.c</span><br/><br/>#include &lt;sys/types.h&gt;<br/>#include &lt;sys/sem.h&gt;<br/>#include "semun.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Definition of semun union */<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct semid_ds ds;<br/>&#160;&#160;&#160;&#160;union semun arg;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Fourth argument for semctl() */<br/>&#160;&#160;&#160;&#160;int j, semid;<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 3 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s semid val...\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;semid = getInt(argv[1], 0, "semid");<br/><br/>&#160;&#160;&#160;&#160;/* Obtain size of semaphore set */<br/><br/>&#160;&#160;&#160;&#160;arg.buf = &#38;ds;<br/>&#160;&#160;&#160;&#160;if (semctl(semid, 0, IPC_STAT, arg) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semctl");<br/><br/>&#160;&#160;&#160;&#160;if (ds.sem_nsems != argc - 2)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cmdLineErr("Set contains %ld semaphores, but %d values were supplied\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) ds.sem_nsems, argc - 2);<br/><br/>&#160;&#160;&#160;&#160;/* Set up array of values; perform semaphore initialization */<br/><br/>&#160;&#160;&#160;&#160;arg.array = calloc(ds.sem_nsems, sizeof(arg.array[0]));<br/>&#160;&#160;&#160;&#160;if (arg.array == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("calloc");<br/><br/>&#160;&#160;&#160;&#160;for (j = 2; j &lt; argc; j++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;arg.array[j - 2] = getInt(argv[j], 0, "val");<br/><br/>&#160;&#160;&#160;&#160;if (semctl(semid, 0, SETALL, arg) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semctl-SETALL");<br/>&#160;&#160;&#160;&#160;printf("Semaphore values changed (PID=%ld)\n", (long) getpid());<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_____________________________________________________ <span class="codestrong">svsem/svsem_setall.c</span></p>
<h3 class="h3" id="ch47lev1sec05"><span epub:type="pagebreak" id="page_975"/><strong>47.5 Semaphore Initialization</strong></h3>
<p class="noindenta">According to SUSv3, an implementation is not required to initialize the values of the semaphores in a set created by <em>semget()</em>. Instead, the programmer must explicitly initialize the semaphores using the <em>semctl()</em> system call. (On Linux, the semaphores returned by <em>semget()</em> are in fact initialized to 0, but we can&#8217;t portably rely on this.) As stated earlier, the fact that semaphore creation and initialization must be performed by separate system calls, instead of in a single atomic step, leads to possible race conditions when initializing a semaphore. In this section, we detail the nature of the race and look at a method of avoiding it based on an idea described in [<a href="bib.xhtml#bib90">Stevens, 1999</a>].</p>
<p class="indent">Suppose that we have an application consisting of multiple peer processes employing a semaphore to coordinate their actions. Since no single process is guaranteed to be the first to use the semaphore (this is what is meant by the term <em>peer</em>), each process must be prepared to create and initialize the semaphore if it doesn&#8217;t already exist. For this purpose, we might consider employing the code shown in <a href="ch47.xhtml#ch47ex5">Listing 47-5</a>.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_976"/><a id="ch47ex5"/><strong>Listing 47-5:</strong> Incorrectly initializing a System V semaphore</p>
<p class="programsli">________________________________________________ <span class="font1">from</span> <span class="codestrong">svsem/svsem_bad_init.c</span><br/><br/>&#160;&#160;&#160;&#160;/* Create a set containing 1 semaphore */<br/><br/>&#160;&#160;&#160;&#160;semid = semget(key, 1, IPC_CREAT | IPC_EXCL | perms);<br/><br/>&#160;&#160;&#160;&#160;if (semid != -1) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Successfully created the semaphore */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;union semun arg;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* XXXX */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;arg.val = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Initialize semaphore */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (semctl(semid, 0, SETVAL, arg) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semctl");<br/><br/>&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* We didn't create the semaphore */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno != EEXIST) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Unexpected error from semget() */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semget");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;semid = semget(key, 1, perms);&#160;&#160;/* Retrieve ID of existing set */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (semid == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semget");<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;/* Now perform some operation on the semaphore */<br/><br/>&#160;&#160;&#160;&#160;sops[0].sem_op = 1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Add 1... */<br/>&#160;&#160;&#160;&#160;sops[0].sem_num = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* to semaphore 0 */<br/>&#160;&#160;&#160;&#160;sops[0].sem_flg = 0;<br/>&#160;&#160;&#160;&#160;if (semop(semid, sops, 1) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semop");<br/>________________________________________________ <span class="font1">from</span> <span class="codestrong">svsem/svsem_bad_init.c</span></p>
<p class="noindent">The problem with the code in <a href="ch47.xhtml#ch47ex5">Listing 47-5</a> is that if two processes execute it at the same time, then the sequence shown in <a href="ch47.xhtml#ch47fig2">Figure 47-2</a> could occur, if the first process&#8217;s time slice happens to expire at the point marked <span class="literal">XXXX</span> in the code. This sequence is problematic for two reasons. First, process B performs a <em>semop()</em> on an uninitialized semaphore (i.e., one whose value is arbitrary). Second, the <em>semctl()</em> call in process A overwrites the changes made by process B.</p>
<p class="indent">The solution to this problem relies on a historical, and now standardized, feature of the initialization of the <em>sem_otime</em> field in the <em>semid_ds</em> data structure associated with the semaphore set. When a semaphore set is first created, the <em>sem_otime</em> field is initialized to 0, and it is changed only by a subsequent <em>semop()</em> call. We can exploit this feature to eliminate the race condition described above. We do this by inserting extra code to force the second process (i.e., the one that does not create the semaphore) to wait until the first process has both initialized the semaphore <em>and</em> executed a <em>semop()</em> call that updates the <em>sem_otime</em> field, but does not modify the semaphore&#8217;s value. The modified code is shown in <a href="ch47.xhtml#ch47ex6">Listing 47-6</a>.</p>
<div class="block">
<p class="noindent">Unfortunately, the solution to the initialization problem described in the main text doesn&#8217;t work on all UNIX implementations. In some versions of the modern BSD derivatives, <em>semop()</em> doesn&#8217;t update the <em>sem_otime</em> field.</p>
</div>
<p class="examplet"><span epub:type="pagebreak" id="page_977"/><a id="ch47ex6"/><strong>Listing 47-6:</strong> Initializing a System V semaphore</p>
<p class="programsli">_______________________________________________ <span class="font1">from</span> <span class="codestrong">svsem/svsem_good_init.c</span><br/><br/>&#160;&#160;&#160;semid = semget(key, 1, IPC_CREAT | IPC_EXCL | perms);<br/><br/>&#160;&#160;&#160;if (semid != -1) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Successfully created the semaphore */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;union semun arg;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sembuf sop;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;arg.val = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* So initialize it to 0 */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (semctl(semid, 0, SETVAL, arg) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semctl");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Perform a "no-op" semaphore operation - changes sem_otime<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;so other processes can see we've initialized the set. */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sop.sem_num = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Operate on semaphore 0 */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sop.sem_op = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for value to equal 0 */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sop.sem_flg = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (semop(semid, &#38;sop, 1) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semop");<br/><br/>&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* We didn't create the semaphore set */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;const int MAX_TRIES = 10;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int j;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;union semun arg;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct semid_ds ds;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno != EEXIST) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Unexpected error from semget() */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semget");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;semid = semget(key, 1, perms);&#160;&#160;/* Retrieve ID of existing set */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (semid == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semget");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait until another process has called semop() */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;arg.buf = &#38;ds;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (j = 0; j &lt; MAX_TRIES; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (semctl(semid, 0, IPC_STAT, arg) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semctl");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (ds.sem_otime != 0)&#160;&#160;&#160;&#160;&#160;&#160;/* semop() performed? */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Yes, quit loop */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep(1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If not, wait and retry */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (ds.sem_otime == 0) /* Loop ran to completion! */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("Existing semaphore not initialized");<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;/* Now perform some operation on the semaphore */<br/>_______________________________________________ <span class="font1">from</span> <span class="codestrong">svsem/svsem_good_init.c</span></p>
<p class="noindent">We can use variations of the technique shown in <a href="ch47.xhtml#ch47ex6">Listing 47-6</a> to ensure that multiple semaphores in a set are correctly initialized, or that a semaphore is initialized to a nonzero value.</p>
<p class="indent"><span epub:type="pagebreak" id="page_978"/>This rather complex solution to the race problem is not required in all applications. We don&#8217;t need it if one process is guaranteed to be able to create and initialize the semaphore before any other processes attempt to use it. This would be the case, for example, if a parent creates and initializes the semaphore before creating child processes with which it shares the semaphore. In such cases, it is sufficient for the first process to follow its <em>semget()</em> call by a <em>semctl()</em> <span class="literal">SETVAL</span> or <span class="literal">SETALL</span> operation.</p>
<div class="image"><img src="../images/f47-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch47fig2"/><strong>Figure 47-2:</strong> Two processes racing to initialize the same semaphore</p>
<h3 class="h3" id="ch47lev1sec06"><strong>47.6 Semaphore Operations</strong></h3>
<p class="noindenta">The <em>semop()</em> system call performs one or more operations on the semaphores in the semaphore set identified by <em>semid</em>.</p>
<div class="box">
<p class="programsa">#include &lt;sys/types.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* For portability */<br/>#include &lt;sys/sem.h&gt;<br/><br/>int <span class="codestrong">semop</span>(int <span class="font1">semid</span>, struct sembuf *<span class="font1">sops</span>, size_t <span class="font1">nsops</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_979"/>The <em>sops</em> argument is a pointer to an array that contains the operations to be performed, and <em>nsops</em> gives the size of this array (which must contain at least one element). The operations are performed atomically and in array order. The elements of the <em>sops</em> array are structures of the following form:</p>
<p class="programs">struct sembuf {<br/>&#160;&#160;&#160;&#160;unsigned short sem_num;&#160;&#160;&#160;&#160;/* Semaphore number */<br/>&#160;&#160;&#160;&#160;short&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sem_op;&#160;&#160;&#160;&#160;&#160;/* Operation to be performed */<br/>&#160;&#160;&#160;&#160;short&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sem_flg;&#160;&#160;&#160;&#160;/* Operation flags (IPC_NOWAIT and SEM_UNDO) */<br/>};</p>
<p class="noindentb">The <em>sem_num</em> field identifies the semaphore within the set upon which the operation is to be performed. The <em>sem_op</em> field specifies the operation to be performed:</p>
<p class="bull">&#8226; If <em>sem_op</em> is greater than 0, the value of <em>sem_op</em> is added to the semaphore value. As a result, other processes waiting to decrease the semaphore value may be awakened and perform their operations. The calling process must have alter (write) permission on the semaphore.</p>
<p class="bull">&#8226; If <em>sem_op</em> equals 0, the value of the semaphore is checked to see whether it currently equals 0. If it does, the operation completes immediately; otherwise, <em>semop()</em> blocks until the semaphore value becomes 0. The calling process must have read permission on the semaphore.</p>
<p class="bull">&#8226; If <em>sem_op</em> is less than 0, decrease the value of the semaphore by the absolute value of <em>sem_op</em>. If the current value of the semaphore is greater than or equal to the absolute value of <em>sem_op</em>, the operation completes immediately. Otherwise, <em>semop()</em> blocks until the semaphore value has been increased to a level that permits the operation to be performed without resulting in a negative value. The calling process must have alter permission on the semaphore.</p>
<p class="noindentt">Semantically, increasing the value of a semaphore corresponds to making a resource available so that others can use it, while decreasing the value of a semaphore corresponds to reserving a resource for (exclusive) use by this process. When decreasing the value of a semaphore, the operation is blocked if the semaphore value is too low&#8212;that is, if some other process has already reserved the resource.</p>
<p class="indentb">When a <em>semop()</em> call blocks, the process remains blocked until one of the following occurs:</p>
<p class="bull">&#8226; Another process modifies the value of the semaphore such that the requested operation can proceed.</p>
<p class="bull">&#8226; A signal interrupts the <em>semop()</em> call. In this case, the error <span class="literal">EINTR</span> results. (As noted in <a href="ch21.xhtml#ch21lev1sec05">Section 21.5</a>, <em>semop()</em> is never automatically restarted after being interrupted by a signal handler.)</p>
<p class="bull">&#8226; Another process deletes the semaphore referred to by <em>semid</em>. In this case, <em>semop()</em> fails with the error <span class="literal">EIDRM</span>.</p>
<p class="noindentt">We can prevent <em>semop()</em> from blocking when performing an operation on a particular semaphore by specifying the <span class="literal">IPC_NOWAIT</span> flag in the corresponding <em>sem_flg</em> field. In this case, if <em>semop()</em> would have blocked, it instead fails with the error <span class="literal">EAGAIN</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_980"/>While it is usual to operate on a single semaphore at a time, it is possible to make a <em>semop()</em> call that performs operations on multiple semaphores in a set. The key point to note is that this group of operations is performed atomically; that is, <em>semop()</em> either performs all of the operations immediately, if possible, or blocks until it would be possible to perform all of the operations simultaneously.</p>
<div class="block">
<p class="noindent">Few systems document the fact that <em>semop()</em> performs operations in array order, although all systems known to the author do so, and a few applications depend on this behavior. SUSv4 adds text that explicitly requires this behavior.</p>
</div>
<p class="noindent"><a href="ch47.xhtml#ch47ex7">Listing 47-7</a> demonstrates the use of <em>semop()</em> to perform operations on three semaphores in a set. The operations on semaphores 0 and 2 may not be able to proceed immediately, depending on the current values of the semaphores. If the operation on semaphore 0 can&#8217;t be performed immediately, then none of the requested operations is performed, and <em>semop()</em> blocks. On the other hand, if the operation on semaphore 0 could be performed immediately, but the operation on semaphore 2 could not, then&#8212;because the <span class="literal">IPC_NOWAIT</span> flag was specified&#8212;none of the requested operations is performed, and <em>semop()</em> returns immediately with the error <span class="literal">EAGAIN</span>.</p>
<p class="indent">The <em>semtimedop()</em> system call performs the same task as <em>semop()</em>, except that the <em>timeout</em> argument specifies an upper limit on the time for which the call will block.</p>
<div class="box">
<p class="programsa">#define _GNU_SOURCE<br/>#include &lt;sys/types.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* For portability */<br/>#include &lt;sys/sem.h&gt;<br/><br/>int <span class="codestrong">semtimedop</span>(int <span class="font1">semid</span>, struct sembuf *<span class="font1">sops</span>, size_t <span class="font1">nsops</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct timespec *<span class="font1">timeout</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>timeout</em> argument is a pointer to a <em>timespec</em> structure (<a href="ch23.xhtml#ch23lev2sec02">Section 23.4.2</a>), which allows a time interval to be expressed as a number of seconds and nanoseconds. If the specified time interval expires before it is possible to complete the semaphore operation, <em>semtimedop()</em> fails with the error <span class="literal">EAGAIN</span>. If <em>timeout</em> is specified as <span class="literal">NULL</span>, <em>semtimedop()</em> is exactly the same as <em>semop()</em>.</p>
<p class="indent">The <em>semtimedop()</em> system call is provided as a more efficient method of setting a timeout on a semaphore operation than using <em>setitimer()</em> plus <em>semop()</em>. The small performance benefit that this confers is significant for certain applications (notably, some database systems) that need to frequently perform such operations. However, <em>semtimedop()</em> is not specified in SUSv3 and is present on only a few other UNIX implementations.</p>
<div class="block">
<p class="noindent">The <em>semtimedop()</em> system call appeared as a new feature in Linux 2.6 and was subsequently back-ported into Linux 2.4, starting with kernel 2.4.22.</p>
</div>
<p class="examplet"><span epub:type="pagebreak" id="page_981"/><a id="ch47ex7"/><strong>Listing 47-7:</strong> Using <em>semop()</em> to perform operations on multiple System V semaphores</p>
<p class="programsli">______________________________________________________________________<br/><br/>&#160;&#160;&#160;struct sembuf sops[3];<br/><br/>&#160;&#160;&#160;sops[0].sem_num = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Subtract 1 from semaphore 0 */<br/>&#160;&#160;&#160;sops[0].sem_op = -1;<br/>&#160;&#160;&#160;sops[0].sem_flg = 0;<br/><br/>&#160;&#160;&#160;sops[1].sem_num = 1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Add 2 to semaphore 1 */<br/>&#160;&#160;&#160;sops[1].sem_op = 2;<br/>&#160;&#160;&#160;sops[1].sem_flg = 0;<br/><br/>&#160;&#160;&#160;sops[2].sem_num = 2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for semaphore 2 to equal 0 */<br/>&#160;&#160;&#160;sops[2].sem_op = 0;<br/>&#160;&#160;&#160;sops[2].sem_flg = IPC_NOWAIT;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* But don't block if operation<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;can't be performed immediately */<br/>&#160;&#160;&#160;if (semop(semid, sops, 3) == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno == EAGAIN)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Semaphore 2 would have blocked */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Operation would have blocked\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semop");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Some other error */<br/>&#160;&#160;&#160;}<br/>______________________________________________________________________</p>
<h5 class="h5" id="ch47lev3sec06"><strong>Example program</strong></h5>
<p class="noindenta">The program in <a href="ch47.xhtml#ch47ex8">Listing 47-8</a> provides a command-line interface to the <em>semop()</em> system call. The first argument to this program is the identifier of the semaphore set upon which operations are to be performed.</p>
<p class="indentb">Each of the remaining command-line arguments specifies a group of semaphore operations to be performed in a single <em>semop()</em> call. The operations within a single command-line argument are delimited by commas. Each operation has one of the following forms:</p>
<p class="bull">&#8226; <em>semnum</em><span class="literal">+</span><em>value</em>: add <em>value</em> to semaphore <em>semnum</em>.</p>
<p class="bull">&#8226; <em>semnum</em><span class="literal">-</span><em>value</em>: subtract <em>value</em> from semaphore <em>semnum</em>.</p>
<p class="bull">&#8226; <em>semnum</em><span class="literal">=0</span>: test semaphore <em>semnum</em> to see if it equals 0.</p>
<p class="noindentt">At the end of each operation, we can optionally include an <em>n</em>, a <em>u</em>, or both. The letter <em>n</em> means include <span class="literal">IPC_NOWAIT</span> in the <em>sem_flg</em> value for this operation. The letter <em>u</em> means include <span class="literal">SEM_UNDO</span> in <em>sem_flg</em>. (We describe the <span class="literal">SEM_UNDO</span> flag in <a href="ch47.xhtml#ch47lev1sec08">Section 47.8</a>.)</p>
<p class="indent">The following command line specifies two <em>semop()</em> calls on the semaphore set whose identifier is 0:</p>
<p class="programs">$ <span class="codestrong">./svsem_op 0 0=0 0-1,1-2n</span></p>
<p class="noindent">The first command-line argument specifies a <em>semop()</em> call that waits until semaphore zero equals 0. The second argument specifies a <em>semop()</em> call that subtracts 1 from semaphore 0, and subtracts 2 from semaphore 1. For the operation on semaphore 0, <em>sem_flg</em> is 0; for the operation on semaphore 1, <em>sem_flg</em> is <span class="literal">IPC_NOWAIT</span>.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_982"/><a id="ch47ex8"/><strong>Listing 47-8:</strong> Performing System V semaphore operations with <em>semop()</em></p>
<p class="programsli">_________________________________________________________ <span class="codestrong">svsem/svsem_op.c</span><br/><br/>#include &lt;sys/types.h&gt;<br/>#include &lt;sys/sem.h&gt;<br/>#include &lt;ctype.h&gt;<br/>#include "curr_time.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declaration of currTime() */<br/>#include "tlpi_hdr.h"<br/><br/>#define MAX_SEMOPS 1000&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Maximum operations that we permit for<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;a single semop() */<br/><br/>static void<br/>usageError(const char *progName)<br/>{<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "Usage: %s semid op[,op...] ...\n\n", progName);<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "'op' is either: &lt;sem#&gt;{+|-}&lt;value&gt;[n][u]\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;or: &lt;sem#&gt;=0[n]\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;&#160;&#160;&#160;\"n\" means include IPC_NOWAIT in 'op'\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;&#160;&#160;&#160;\"u\" means include SEM_UNDO in 'op'\n\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "The operations in each argument are "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"performed in a single semop() call\n\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "e.g.: %s 12345 0+1,1-2un\n", progName);<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;&#160;&#160;%s 12345 0=0n 1+1,2-1u 1=0\n", progName);<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}<br/><br/>/* Parse comma-delimited operations in 'arg', returning them in the<br/>&#160;&#160;&#160;array 'sops'. Return number of operations as function result. */<br/><br/>static int<br/>parseOps(char *arg, struct sembuf sops[])<br/>{<br/>&#160;&#160;&#160;&#160;char *comma, *sign, *remaining, *flags;<br/>&#160;&#160;&#160;&#160;int numOps;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of operations in 'arg' */<br/><br/>&#160;&#160;&#160;&#160;for (numOps = 0, remaining = arg; ; numOps++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numOps &gt;= MAX_SEMOPS)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cmdLineErr("Too many operations (maximum=%d): \"%s\"\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MAX_SEMOPS, arg);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (*remaining == '\0')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("Trailing comma or empty argument: \"%s\"", arg);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (!isdigit((unsigned char) *remaining))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cmdLineErr("Expected initial digit: \"%s\"\n", arg);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sops[numOps].sem_num = strtol(remaining, &#38;sign, 10);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (*sign == '\0' || strchr("+-=", *sign) == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cmdLineErr("Expected '+', '-', or '=' in \"%s\"\n", arg);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (!isdigit((unsigned char) *(sign + 1)))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cmdLineErr("Expected digit after '%c' in \"%s\"\n", *sign, arg);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sops[numOps].sem_op = strtol(sign + 1, &#38;flags, 10);<br/><br/><span epub:type="pagebreak" id="page_983"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (*sign == '-')&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Reverse sign of operation */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sops[numOps].sem_op = - sops[numOps].sem_op;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (*sign == '=')&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Should be '=0' */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sops[numOps].sem_op != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cmdLineErr("Expected \"=0\" in \"%s\"\n", arg);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sops[numOps].sem_flg = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (;; flags++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (*flags == 'n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sops[numOps].sem_flg |= IPC_NOWAIT;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (*flags == 'u')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sops[numOps].sem_flg |= SEM_UNDO;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (*flags != ',' &#38;&#38; *flags != '\0')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cmdLineErr("Bad trailing character (%c) in \"%s\"\n", *flags, arg);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;comma = strchr(remaining, ',');<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (comma == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* No comma --&gt; no more ops */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;remaining = comma + 1;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;return numOps + 1;<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct sembuf sops[MAX_SEMOPS];<br/>&#160;&#160;&#160;&#160;int ind, nsops;<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0]);<br/><br/>&#160;&#160;&#160;&#160;for (ind = 2; argv[ind] != NULL; ind++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nsops = parseOps(argv[ind], sops);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%5ld, %s: about to semop() [%s]\n", (long) getpid(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;currTime("%T"), argv[ind]);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (semop(getInt(argv[1], 0, "semid"), sops, nsops) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semop (PID=%ld)", (long) getpid());<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%5ld, %s: semop() completed [%s]\n", (long) getpid(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;currTime("%T"), argv[ind]);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________________ <span class="codestrong">svsem/svsem_op.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_984"/>Using the program in <a href="ch47.xhtml#ch47ex8">Listing 47-8</a>, along with various others shown in this chapter, we can study the operation of System V semaphores, as demonstrated in the following shell session. We begin by using a program that creates a semaphore set containing two semaphores, which we initialize to 1 and 0:</p>
<p class="programs">$ <span class="codestrong">./svsem_create -p 2</span><br/>32769&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">ID of semaphore set</span><br/>$ <span class="codestrong">./svsem_setall 32769 1 0</span><br/>Semaphore values changed (PID=3658)</p>
<div class="block">
<p class="noindent">We don&#8217;t show the code of the <span class="literal">svsem/svsem_create.c</span> program in this chapter, but it is provided in the source code distribution for this book. This program performs the same function for semaphores as the program in <a href="ch46.xhtml#ch46ex1">Listing 46-1</a> (on <a href="ch46.xhtml#page_938">page 938</a>) performs for message queues; that is, it creates a semaphore set. The only notable difference is that <span class="literal">svsem_create.c</span> takes an additional argument specifying the size of the semaphore set to be created.</p>
</div>
<p class="noindent">Next, we start three background instances of the program in <a href="ch47.xhtml#ch47ex8">Listing 47-8</a> to perform <em>semop()</em> operations on the semaphore set. The program prints messages before and after each semaphore operation. These messages include the time, so that we can see when each operation starts and when it completes, and the process ID, so that we can track the operation of multiple instances of the program. The first command makes a request to decrease both semaphores by 1:</p>
<p class="programs">$ <span class="codestrong">./svsem_op 32769 0-1,1-1 &#38;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Operation 1</span><br/>&#160;3659, 16:02:05: about to semop()&#160;&#160;[0-1,1-1]<br/>[1] 3659</p>
<p class="noindent">In the above output, we see that the program printed a message saying that the <em>semop()</em> operation is about to be performed, but did not print any further messages, because the <em>semop()</em> call blocks. The call blocks because semaphore 1 has the value 0.</p>
<p class="indent">Next, we execute a command that makes a request to decrease semaphore 1 by 1:</p>
<p class="programs">$ <span class="codestrong">./svsem_op 32769 1-1 &#38;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Operation 2</span><br/>&#160;3660, 16:02:22: about to semop()&#160;&#160;[1-1]<br/>[2] 3660</p>
<p class="noindent">This command also blocks. Next, we execute a command that waits for the value of semaphore 0 to equal 0:</p>
<p class="programs">$ <span class="codestrong">./svsem_op 32769 0=0 &#38;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Operation 3</span><br/>&#160;3661, 16:02:27: about to semop()&#160;&#160;[0=0]<br/>[3] 3661</p>
<p class="noindent">Again, this command blocks, in this case because the value of semaphore 0 is currently 1.</p>
<p class="indent">Now, we use the program in <a href="ch47.xhtml#ch47ex3">Listing 47-3</a> to inspect the semaphore set:</p>
<p class="programs">$ <span class="codestrong">./svsem_mon 32769</span><br/>Semaphore changed: Sun Jul 25 16:01:53 2010<br/>Last semop():&#160;&#160;&#160;&#160;&#160;&#160;Thu Jan&#160;&#160;1 01:00:00 1970<br/>Sem #&#160;&#160;Value&#160;&#160;SEMPID&#160;&#160;SEMNCNT&#160;&#160;SEMZCNT<br/>&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;1&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1<br/>&#160;&#160;1&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;2&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0</p>
<p class="noindent"><span epub:type="pagebreak" id="page_985"/>When a semaphore set is created, the <em>sem_otime</em> field of the associated <em>semid_ds</em> data structure is initialized to 0. A calendar time value of 0 corresponds to the Epoch (<a href="ch10.xhtml#ch10lev1sec01">Section 10.1</a>), and <em>ctime()</em> displays this as 1 AM, 1 January 1970, since the local timezone is Central Europe, one hour ahead of UTC.</p>
<p class="indent">Examining the output further, we can see that, for semaphore 0, the <em>semncnt</em> value is 1 because operation 1 is waiting to decrease the semaphore value, and <em>semzcnt</em> is 1 because operation 3 is waiting for this semaphore to equal 0. For semaphore 1, the <em>semncnt</em> value of 2 reflects the fact that operation 1 and operation 2 are waiting to decrease the semaphore value.</p>
<p class="indent">Next, we try a nonblocking operation on the semaphore set. This operation waits for semaphore 0 to equal 0. Since this operation can&#8217;t be immediately performed, <em>semop()</em> fails with the error <span class="literal">EAGAIN</span>:</p>
<p class="programs">$ <span class="codestrong">./svsem_op 32769 0=0n</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Operation 4</span><br/>&#160;3673, 16:03:13: about to semop()&#160;&#160;[0=0n]<br/>ERROR [EAGAIN/EWOULDBLOCK Resource temporarily unavailable] semop (PID=3673)</p>
<p class="noindent">Now we add 1 to semaphore 1. This causes two of the earlier blocked operations (1 and 3) to unblock:</p>
<p class="programs">$ <span class="codestrong">./svsem_op 32769 1+1</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Operation 5</span><br/>&#160;3674, 16:03:29: about to semop()&#160;&#160;[1+1]<br/>&#160;3659, 16:03:29: semop() completed [0-1,1-1]&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Operation 1 completes</span><br/>&#160;3661, 16:03:29: semop() completed [0=0]&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Operation 3 completes</span><br/>&#160;3674, 16:03:29: semop() completed [1+1]&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Operation 5 completes</span><br/>[1]&#160;&#160;&#160;Done&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;./svsem_op 32769 0-1,1-1<br/>[3]+&#160;&#160;Done&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;./svsem_op 32769 0=0</p>
<p class="noindent">When we use our monitoring program to inspect the state of the semaphore set, we see that the <em>sem_otime</em> field of the associated <em>semid_ds</em> data structure has been updated, and the <em>sempid</em> values of both semaphores have been updated. We also see that the <em>semncnt</em> value for semaphore 1 is 1, since operation 2 is still blocked, waiting to decrease the value of this semaphore:</p>
<p class="programs">$ <span class="codestrong">./svsem_mon 32769</span><br/>Semaphore changed: Sun Jul 25 16:01:53 2010<br/>Last semop():&#160;&#160;&#160;&#160;&#160;&#160;Sun Jul 25 16:03:29 2010<br/>Sem #&#160;&#160;Value&#160;&#160;SEMPID&#160;&#160;SEMNCNT&#160;&#160;SEMZCNT<br/>&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;3661&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0<br/>&#160;&#160;1&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;3659&#160;&#160;&#160;&#160;&#160;&#160;1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0</p>
<p class="noindent">From the above output, we see that the <em>sem_otime</em> value has been updated. We also see that semaphore 0 was last operated on by process ID 3661 (operation 3) and semaphore 1 was last operated on by process ID 3659 (operation 1).</p>
<p class="indent">Finally, we remove the semaphore set. This causes the still blocked operation 2 to fail with the error <span class="literal">EIDRM</span>:</p>
<p class="programs">$ <span class="codestrong">./svsem_rm 32769</span><br/>ERROR [EIDRM Identifier removed] semop (PID=3660)</p>
<div class="block">
<p class="noindent">We don&#8217;t show the source code for the <span class="literal">svsem/svsem_rm.c</span> program in this chapter, but it is provided in the source code distribution for this book. This program removes the semaphore set identified by its command-line argument.</p>
</div>
<h3 class="h3" id="ch47lev1sec07"><span epub:type="pagebreak" id="page_986"/><strong>47.7 Handling of Multiple Blocked Semaphore Operations</strong></h3>
<p class="noindenta">If multiple processes are blocked trying to decrease the value of a semaphore by the same amount, then it is indeterminate which process will be permitted to perform the operation first when it becomes possible (i.e., which process is able to perform the operation will depend on vagaries of the kernel process scheduling algorithm).</p>
<p class="indent">On the other hand, if processes are blocked trying to decrease a semaphore value by different amounts, then the requests are served in the order in which they become possible. Suppose that a semaphore currently has the value 0, and process A requests to decrease the semaphore&#8217;s value by 2, and then process B requests to decrease the value by 1. If a third process then adds 1 to the semaphore, process B would be the first to unblock and perform its operation, even though process A was the first to request an operation against the semaphore. In poorly designed applications, such scenarios can lead to <em>starvation</em>, whereby a process remains blocked forever because the state of the semaphore is never such that the requested operation proceeds. Continuing our example, we can envisage scenarios where multiple processes adjust the semaphore in such a way that its value is never more than 1, with the result that process A remains blocked forever.</p>
<p class="indent">Starvation can also occur if a process is blocked trying to perform operations on multiple semaphores. Consider the following scenario, performed on a pair of semaphores, both of which initially have the value 0:</p>
<ol>
<li class="order"><p class="orderp">Process A makes a request to subtract 1 from semaphores 0 and 1 (<em>blocks</em>).</p></li>
<li class="order"><p class="orderp">Process B makes a request to subtract 1 from semaphore 0 (<em>blocks</em>).</p></li>
<li class="order"><p class="orderp">Process C adds 1 to semaphore 0.</p></li>
</ol>
<p class="noindent">At this point, process B unblocks and completes its request, even though it placed its request later than process A. Again, it is possible to devise scenarios in which process A is starved while other processes adjust and block on the values of the individual semaphores.</p>
<h3 class="h3" id="ch47lev1sec08"><strong>47.8 Semaphore Undo Values</strong></h3>
<p class="noindenta">Suppose that, having adjusted the value of a semaphore (e.g., decreased the semaphore value so that it is now 0), a process then terminates, either deliberately or accidentally. By default, the semaphore&#8217;s value is left unchanged. This may constitute a problem for other processes using the semaphore, since they may be blocked waiting on that semaphore&#8212;that is, waiting for the now-terminated process to undo the change it made.</p>
<p class="indent">To avoid such problems, we can employ the <span class="literal">SEM_UNDO</span> flag when changing the value of a semaphore via <em>semop()</em>. When this flag is specified, the kernel records the effect of the semaphore operation, and then undoes the operation if the process terminates. The undo happens regardless of whether the process terminates normally or abnormally.</p>
<p class="indent"><span epub:type="pagebreak" id="page_987"/>The kernel doesn&#8217;t need to keep a record of all operations performed using <span class="literal">SEM_UNDO</span>. It suffices to record the <em>sum</em> of all of the semaphore adjustments performed using <span class="literal">SEM_UNDO</span> in a per-semaphore, per-process integer total called the <em>semadj</em> (semaphore adjustment) value. When the process terminates, all that is necessary is to subtract this total from the semaphore&#8217;s current value.</p>
<div class="block">
<p class="noindent">Since Linux 2.6, processes (threads) created using <em>clone()</em> share <em>semadj</em> values if the <span class="literal">CLONE_SYSVSEM</span> flag is employed. Such sharing is required for a conforming implementation of POSIX threads. The NPTL threading implementation employs <span class="literal">CLONE_SYSVSEM</span> for the implementation of <em>pthread_create()</em>.</p>
</div>
<p class="noindent">When a semaphore value is set using the <em>semctl()</em> <span class="literal">SETVAL</span> or <span class="literal">SETALL</span> operation, the corresponding <em>semadj</em> values are cleared (i.e., set to 0) in all processes using the semaphore. This makes sense, since absolutely setting the value of a semaphore destroys the value associated with the historical record maintained in the <em>semadj</em> total.</p>
<p class="indent">A child created via <em>fork()</em> doesn&#8217;t inherit its parent&#8217;s <em>semadj</em> values; it doesn&#8217;t make sense for a child to undo its parent&#8217;s semaphore operations. On the other hand, <em>semadj</em> values are preserved across an <em>exec()</em>. This permits us to adjust a semaphore value using <span class="literal">SEM_UNDO</span>, and then <em>exec()</em> a program that performs no operation on the semaphore, but does automatically adjust the semaphore on process termination. (This can be used as a technique that allows another process to discover when this process terminates.)</p>
<h5 class="h5" id="ch47lev3sec07"><strong>Example of the effect of</strong> <span class="literal"><span class="codestrong">SEM_UNDO</span></span></h5>
<p class="noindenta">The following shell session log shows the effect of performing operations on two semaphores: one operation with the <span class="literal">SEM_UNDO</span> flag and one without. We begin by creating a set containing two semaphores that we initialize to 0:</p>
<p class="programs">$ <span class="codestrong">./svsem_create -p 2</span><br/>131073<br/>$ <span class="codestrong">./svsem_setall 131073 0 0</span><br/>Semaphore values changed (PID=2220)</p>
<p class="noindent">Next, we execute a command that adds 1 to both semaphores and then terminates. The operation on semaphore 0 specifies the <span class="literal">SEM_UNDO</span> flag:</p>
<p class="programs">$ <span class="codestrong">./svsem_op 131073 0+1u 1+1</span><br/>&#160;2248, 06:41:56: about to semop()<br/>&#160;2248, 06:41:56: semop() completed</p>
<p class="noindent">Now, we use the program in <a href="ch47.xhtml#ch47ex3">Listing 47-3</a> to check the state of the semaphores:</p>
<p class="programs">$ <span class="codestrong">./svsem_mon 131073</span><br/>Semaphore changed: Sun Jul 25 06:41:34 2010<br/>Last semop():&#160;&#160;&#160;&#160;&#160;&#160;Sun Jul 25 06:41:56 2010<br/>Sem #&#160;&#160;Value&#160;&#160;SEMPID&#160;&#160;SEMNCNT&#160;&#160;SEMZCNT<br/>&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;2248&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0<br/>&#160;&#160;1&#160;&#160;&#160;&#160;&#160;&#160;&#160;1&#160;&#160;&#160;&#160;2248&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0</p>
<p class="noindent">Looking at the semaphore values in the last two lines of the above output, we can see that the operation on semaphore 0 was undone, but the operation on semaphore 1 was not undone.</p>
<h5 class="h5" id="ch47lev3sec08"><span epub:type="pagebreak" id="page_988"/><strong>Limitations of</strong> <span class="literal"><span class="codestrong">SEM_UNDO</span></span></h5>
<p class="noindenta">We conclude by noting that the <span class="literal">SEM_UNDO</span> flag is less useful than it first appears, for two reasons. One is that because modifying a semaphore typically corresponds to acquiring or releasing some shared resource, the use of <span class="literal">SEM_UNDO</span> on its own may be insufficient to allow a multiprocess application to recover in the event that a process unexpectedly terminates. Unless process termination also automatically returns the shared resource state to a consistent state (unlikely in many scenarios), undoing a semaphore operation is probably insufficient to allow the application to recover.</p>
<p class="indent">The second factor limiting the utility of <span class="literal">SEM_UNDO</span> is that, in some cases, it is not possible to perform semaphore adjustments when a process terminates. Consider the following scenario, applied to a semaphore whose initial value is 0:</p>
<ol>
<li class="order"><p class="orderp">Process A increases the value of a semaphore by 2, specifying the <span class="literal">SEM_UNDO</span> flag for the operation.</p></li>
<li class="order"><p class="orderp">Process B decreases the value of the semaphore by 1, so that it has the value 1.</p></li>
<li class="order"><p class="orderp">Process A terminates.</p></li>
</ol>
<p class="noindentb">At this point, it is impossible to completely undo the effect of process A&#8217;s operation in step 1, since the value of the semaphore is too low. There are three possible ways to resolve this situation:</p>
<p class="bull">&#8226; Force the process to block until the semaphore adjustment is possible.</p>
<p class="bull">&#8226; Decrease the semaphore value as far as possible (i.e., to 0) and exit.</p>
<p class="bull">&#8226; Exit without performing any semaphore adjustment.</p>
<p class="noindentt">The first solution is infeasible since it might force a terminating process to block forever. Linux adopts the second solution. Some other UNIX implementations adopt the third solution. SUSv3 is silent on what an implementation should do in this situation.</p>
<div class="block">
<p class="noindent">An undo operation that attempts to raise a semaphore&#8217;s value above its permitted maximum value of 32,767 (the <span class="literal">SEMVMX</span> limit, described <a href="ch47.xhtml#ch47lev1sec10">Section 47.10</a>) also causes anomalous behavior. In this case, the kernel always performs the adjustment, thus (illegitimately) raising the semaphore&#8217;s value above <span class="literal">SEMVMX</span>.</p>
</div>
<h3 class="h3" id="ch47lev1sec09"><strong>47.9 Implementing a Binary Semaphores Protocol</strong></h3>
<p class="noindenta">The API for System V semaphores is complex, both because semaphore values can be adjusted by arbitrary amounts, and because semaphores are allocated and operated upon in sets. Both of these features provide more functionality than is typically needed within applications, and so it is useful to implement some simpler protocols (APIs) on top of System V semaphores.</p>
<p class="indentb">One commonly used protocol is binary semaphores. A binary semaphore has two values: <em>available</em> (free) and <em>reserved</em> (in use). Two operations are defined for binary semaphores:</p>
<p class="bull">&#8226; <em>Reserve</em>: Attempt to reserve this semaphore for exclusive use. If the semaphore is already reserved by another process, then block until the semaphore is released.</p>
<p class="bull"><span epub:type="pagebreak" id="page_989"/>&#8226; <em>Release</em>: Free a currently reserved semaphore, so that it can be reserved by another process.</p>
<div class="block1">
<p class="noindent">In academic computer science, these two operations often go by the names <em>P</em> and <em>V</em>, the first letters of the Dutch terms for these operations. This nomenclature was coined by the late Dutch computer scientist Edsger Dijkstra, who produced much of the early theoretical work on semaphores. The terms <em>down</em> (decrement the semaphore) and <em>up</em> (increment the semaphore) are also used. POSIX terms the two operations <em>wait</em> and <em>post</em>.</p>
</div>
<p class="noindentb">A third operation is also sometimes defined:</p>
<p class="bull">&#8226; <em>Reserve conditionally</em>: Make a nonblocking attempt to reserve this semaphore for exclusive use. If the semaphore is already reserved, then immediately return a status indicating that the semaphore is unavailable.</p>
<p class="noindentt">In implementing binary semaphores, we must choose how to represent the <em>available</em> and <em>reserved</em> states, and how to implement the above operations. A moment&#8217;s reflection leads us to realize that the best way to represent the states is to use the value 1 for <em>free</em> and the value 0 for <em>reserved</em>, with the <em>reserve</em> and <em>release</em> operations decrementing and incrementing the semaphore value by one.</p>
<p class="indent"><a href="ch47.xhtml#ch47ex9">Listing 47-9</a> and <a href="ch47.xhtml#ch47ex10">Listing 47-10</a> provide an implementation of binary semaphores using System V semaphores. As well as providing the prototypes of the functions in the implementation, the header file in <a href="ch47.xhtml#ch47ex9">Listing 47-9</a> declares two global Boolean variables exposed by the implementation. The <em>bsUseSemUndo</em> variable controls whether the implementation uses the <span class="literal">SEM_UNDO</span> flag in <em>semop()</em> calls. The <em>bsRetryOnEintr</em> variable controls whether the implementation restarts <em>semop()</em> calls that are interrupted by signals.</p>
<p class="examplet"><a id="ch47ex9"/><strong>Listing 47-9:</strong> Header file for <span class="literal">binary_sems.c</span></p>
<p class="programsli">______________________________________________________ <span class="codestrong">svsem/binary_sems.h</span><br/><br/>#ifndef BINARY_SEMS_H&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Prevent accidental double inclusion */<br/>#define BINARY_SEMS_H<br/><br/>#include "tlpi_hdr.h"<br/><br/>/* Variables controlling operation of functions below */<br/><br/>extern Boolean bsUseSemUndo;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Use SEM_UNDO during semop()? */<br/>extern Boolean bsRetryOnEintr;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Retry if semop() interrupted by<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;signal handler? */<br/><br/>int initSemAvailable(int semId, int semNum);<br/><br/>int initSemInUse(int semId, int semNum);<br/><br/>int reserveSem(int semId, int semNum);<br/><br/>int releaseSem(int semId, int semNum);<br/><br/>#endif<br/>______________________________________________________ <span class="codestrong">svsem/binary_sems.h</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_990"/><a href="ch47.xhtml#ch47ex10">Listing 47-10</a> shows the implementation of the binary semaphore functions. Each function in this implementation takes two arguments, which identify a semaphore set and the number of a semaphore within that set. (These functions don&#8217;t deal with the creation and deletion of semaphore sets; nor do they handle the race condition described in <a href="ch47.xhtml#ch47lev1sec05">Section 47.5</a>.) We employ these functions in the example programs shown in <a href="ch48.xhtml#ch48lev1sec04">Section 48.4</a>.</p>
<p class="examplet"><a id="ch47ex10"/><strong>Listing 47-10:</strong> Implementing binary semaphores using System V semaphores</p>
<p class="programsli">______________________________________________________ <span class="codestrong">svsem/binary_sems.c</span><br/><br/>#include &lt;sys/types.h&gt;<br/>#include &lt;sys/sem.h&gt;<br/>#include "semun.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Definition of semun union */<br/>#include "binary_sems.h"<br/><br/>Boolean bsUseSemUndo = FALSE;<br/>Boolean bsRetryOnEintr = TRUE;<br/><br/>int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Initialize semaphore to 1 (i.e., "available") */<br/>initSemAvailable(int semId, int semNum)<br/>{<br/>&#160;&#160;&#160;&#160;union semun arg;<br/><br/>&#160;&#160;&#160;&#160;arg.val = 1;<br/>&#160;&#160;&#160;&#160;return semctl(semId, semNum, SETVAL, arg);<br/>}<br/><br/>int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Initialize semaphore to 0 (i.e., "in use") */<br/>initSemInUse(int semId, int semNum)<br/>{<br/>&#160;&#160;&#160;&#160;union semun arg;<br/><br/>&#160;&#160;&#160;&#160;arg.val = 0;<br/>&#160;&#160;&#160;&#160;return semctl(semId, semNum, SETVAL, arg);<br/>}<br/><br/>/* Reserve semaphore (blocking), return 0 on success, or -1 with 'errno'<br/>&#160;&#160;&#160;set to EINTR if operation was interrupted by a signal handler */<br/><br/>int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Reserve semaphore - decrement it by 1 */<br/>reserveSem(int semId, int semNum)<br/>{<br/>&#160;&#160;&#160;&#160;struct sembuf sops;<br/><br/>&#160;&#160;&#160;&#160;sops.sem_num = semNum;<br/>&#160;&#160;&#160;&#160;sops.sem_op = -1;<br/>&#160;&#160;&#160;&#160;sops.sem_flg = bsUseSemUndo ? SEM_UNDO : 0;<br/><br/>&#160;&#160;&#160;&#160;while (semop(semId, &#38;sops, 1) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno != EINTR || !bsRetryOnEintr)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Release semaphore - increment it by 1 */<br/>releaseSem(int semId, int semNum)<br/>{<br/>&#160;&#160;&#160;&#160;struct sembuf sops;<br/><br/>&#160;&#160;&#160;&#160;sops.sem_num = semNum;<br/>&#160;&#160;&#160;&#160;sops.sem_op = 1;<br/>&#160;&#160;&#160;&#160;sops.sem_flg = bsUseSemUndo ? SEM_UNDO : 0;<br/><br/>&#160;&#160;&#160;&#160;return semop(semId, &#38;sops, 1);<br/>}<br/>______________________________________________________ <span class="codestrong">svsem/binary_sems.c</span></p>
<h3 class="h3" id="ch47lev1sec10"><span epub:type="pagebreak" id="page_991"/><strong>47.10 Semaphore Limits</strong></h3>
<p class="noindentab">Most UNIX implementations impose various limits on the operation of System V semaphores. The following is a list of the Linux semaphore limits. The system call affected by the limit and the error that results if the limit is reached are noted in parentheses.</p>
<p class="term"><span class="literal">SEMAEM</span></p>
<p class="termlist">This is the maximum value that can be recorded in a <em>semadj</em> total. <span class="literal">SEMAEM</span> is defined to have the same value as <span class="literal">SEMVMX</span> (described below). (<em>semop()</em>, <span class="literal">ERANGE</span>)</p>
<p class="term"><span class="literal">SEMMNI</span></p>
<p class="termlist">This is a system-wide limit on the number of semaphore identifiers (in other words, semaphore sets) that can be created. (<em>semget()</em>, <span class="literal">ENOSPC</span>)</p>
<p class="term"><span class="literal">SEMMSL</span></p>
<p class="termlist">This is the maximum number of semaphores that can be allocated in a semaphore set. (<em>semget()</em>, <span class="literal">EINVAL</span>)</p>
<p class="term"><span class="literal">SEMMNS</span></p>
<p class="termlist">This is a system-wide limit on the number of semaphores in all semaphore sets. The number of semaphores on the system is also limited by <span class="literal">SEMMNI</span> and <span class="literal">SEMMSL</span>; in fact, the default value for <span class="literal">SEMMNS</span> is the product of the defaults for these two limits. (<em>semget()</em>, <span class="literal">ENOSPC</span>)</p>
<p class="term"><span class="literal">SEMOPM</span></p>
<p class="termlist">This is the maximum number of operations per <em>semop()</em> call. (<em>semop()</em>, <span class="literal">E2BIG</span>)</p>
<p class="term"><span class="literal">SEMVMX</span></p>
<p class="termlist">This is the maximum value for a semaphore. (<em>semop()</em>, <span class="literal">ERANGE</span>)</p>
<p class="noindenttb">The limits above appear on most UNIX implementations. Some UNIX implementations (but not Linux) impose the following additional limits relating to semaphore undo operations (<a href="ch47.xhtml#ch47lev1sec08">Section 47.8</a>):</p>
<p class="term"><span class="literal">SEMMNU</span></p>
<p class="termlist">This is a system-wide limit on the total number of semaphore undo structures. Undo structures are allocated to store <em>semadj</em> values.</p>
<p class="term"><span class="literal">SEMUME</span></p>
<p class="termlist">This is the maximum number of undo entries per semaphore undo structure.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_992"/>At system startup, the semaphore limits are set to default values. These defaults may vary across kernel versions. (Some distributors&#8217; kernels set different defaults from those provided by vanilla kernels.) Some of these limits can be modified by changing the values stored in the Linux-specific <span class="literal">/proc/sys/kernel/sem</span> file. This file contains four space-delimited numbers defining, in order, the limits <span class="literal">SEMMSL</span>, <span class="literal">SEMMNS</span>, <span class="literal">SEMOPM</span>, and <span class="literal">SEMMNI</span>. (The <span class="literal">SEMVMX</span> and <span class="literal">SEMAEM</span> limits can&#8217;t be changed; both are fixed at 32,767.) As an example, here are the default limits that we see for Linux 2.6.31 on one x86-32 system:</p>
<p class="programs">$ <span class="codestrong">cd /proc/sys/kernel</span><br/>$ <span class="codestrong">cat sem</span><br/>250&#160;&#160;&#160;&#160;&#160;32000&#160;&#160;&#160;32&#160;&#160;&#160;&#160;&#160;&#160;128</p>
<div class="block">
<p class="noindent">The formats employed in the Linux <span class="literal">/proc</span> file system are inconsistent for the three System V IPC mechanisms. For message queues and shared memory, each configurable limit is controlled by a separate file. For semaphores, one file holds all configurable limits. This is a historical accident that occurred during the development of these APIs and is difficult to rectify for compatibility reasons.</p>
</div>
<p class="noindentb"><a href="ch47.xhtml#ch47table1">Table 47-1</a> shows the maximum value to which each limit can be raised on the x86-32 architecture. Note the following supplementary information to this table:</p>
<p class="bull">&#8226; It is possible to raise <span class="literal">SEMMSL</span> to values larger than 65,536, and create semaphore sets up to that larger size. However, it isn&#8217;t possible to use <em>semop()</em> to adjust semaphores in the set beyond the 65,536th element.</p>
<div class="block1">
<p class="noindent">Because of certain limitations in the current implementation, the practical recommended upper limit on the size of a semaphore set is around 8000.</p>
</div>
<p class="bull">&#8226; The practical ceiling for the <span class="literal">SEMMNS</span> limit is governed by the amount of RAM available on the system.</p>
<p class="bull">&#8226; The ceiling value for the <span class="literal">SEMOPM</span> limit is determined by memory allocation primitives used within the kernel. The recommended maximum is 1000. In practical usage, it is rarely useful to perform more than a few operations in a single <em>semop()</em> call.</p>
<p class="tablecap"><a id="ch47table1"/><strong>Table 47-1:</strong> System V semaphore limits</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Limit</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Ceiling value (x86-32)</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SEMMNI</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">32768 (IPCMNI)</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SEMMSL</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">65536</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SEMMNS</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">2147483647 (INT_MAX)</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">SEMOPM</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">See text</p></td>
</tr>
</tbody>
</table>
<p class="noindent">The Linux-specific <em>semctl()</em> <span class="literal">IPC_INFO</span> operation retrieves a structure of type <em>seminfo</em>, which contains the values of the various semaphore limits:</p>
<p class="programs">union semun arg;<br/>struct seminfo buf;<br/><br/>arg.__buf = &#38;buf;<br/>semctl(0, 0, IPC_INFO, arg);</p>
<p class="noindent"><span epub:type="pagebreak" id="page_993"/>A related Linux-specific operation, <span class="literal">SEM_INFO</span>, retrieves a <em>seminfo</em> structure that contains information about actual resources used for semaphore objects. An example of the use of <span class="literal">SEM_INFO</span> is provided in the file <span class="literal">svsem/svsem_info.c</span> in the source code distribution for this book.</p>
<p class="indent">Details about <span class="literal">IPC_INFO</span>, <span class="literal">SEM_INFO</span>, and the <em>seminfo</em> structure can be found in the <em>semctl(2)</em> manual page.</p>
<h3 class="h3" id="ch47lev1sec11"><strong>47.11 Disadvantages of System V Semaphores</strong></h3>
<p class="noindentab">System V semaphores have many of the same disadvantages as message queues (<a href="ch46.xhtml#ch46lev1sec09">Section 46.9</a>), including the following:</p>
<p class="bull">&#8226; Semaphores are referred to by identifiers, rather than the file descriptors used by most other UNIX I/O and IPC mechanisms. This makes it difficult to perform operations such as simultaneously waiting both on a semaphore and on input from a file descriptor. (It is possible to resolve this difficulty by creating a child process or thread that operates on the semaphore and writes messages to a pipe monitored, along with other file descriptors, using one of the methods described in <a href="ch63.xhtml#ch63">Chapter 63</a>.)</p>
<p class="bull">&#8226; The use of keys, rather than filenames, to identify semaphores results in additional programming complexity.</p>
<p class="bull">&#8226; The use of separate system calls for creating and initializing semaphores means that, in some cases, we must do extra programming work to avoid race conditions when initializing a semaphore.</p>
<p class="bull">&#8226; The kernel doesn&#8217;t maintain a count of the number of processes referring to a semaphore set. This complicates the decision about when it is appropriate to delete a semaphore set and makes it difficult to ensure that an unused set is deleted.</p>
<p class="bull">&#8226; The programming interface provided by System V semaphores is overly complex. In the common case, a program operates on a single semaphore. The ability to simultaneously operate on multiple semaphores in a set is unnecessary.</p>
<p class="bull">&#8226; There are various limits on the operation of semaphores. These limits are configurable, but if an application operates outside the range of the default limits, this nevertheless requires extra work when installing the application.</p>
<p class="noindentt">However, unlike the situation with message queues, there are fewer alternatives to System V semaphores, and consequently there are more situations in which we may choose to employ them. One alternative to the use of semaphores is record locking, which we describe in <a href="ch55.xhtml#ch55">Chapter 55</a>. Also, from kernel 2.6 onward, Linux supports the use of POSIX semaphores for process synchronization. We describe POSIX semaphores in <a href="ch53.xhtml#ch53">Chapter 53</a>.</p>
<h3 class="h3" id="ch47lev1sec12"><span epub:type="pagebreak" id="page_994"/><strong>47.12 Summary</strong></h3>
<p class="noindenta">System V semaphores allow processes to synchronize their actions. This is useful when a process must gain exclusive access to some shared resource, such as a region of shared memory.</p>
<p class="indent">Semaphores are created and operated upon in sets containing one or more semaphores. Each semaphore within a set is an integer whose value is always greater than or equal to 0. The <em>semop()</em> system call allows the caller to add an integer to a semaphore, subtract an integer from a semaphore, or wait for a semaphore to equal 0. The last two of these operations may cause the caller to block.</p>
<p class="indent">A semaphore implementation is not required to initialize the members of a new semaphore set, so an application must initialize the set after creating it. When any of a number of peer processes may try to create and initialize the semaphore, special care must be taken to avoid the race condition that results from the fact that these two steps are performed via separate system calls.</p>
<p class="indent">Where multiple processes are trying to decrease a semaphore by the same amount, it is indeterminate which process will actually be permitted to perform the operation first. However, where different processes are trying to decrease a semaphore by different amounts, the operations complete in the order in which they become possible, and we may need to take care to avoid scenarios where a process is starved because the semaphore value never reaches a level that would allow the process&#8217;s operation to proceed.</p>
<p class="indent">The <span class="literal">SEM_UNDO</span> flag allows a process&#8217;s semaphore operations to be automatically undone on process termination. This can be useful to avoid scenarios where a process accidentally terminates, leaving a semaphore in a state that causes other processes to block indefinitely waiting for the semaphore&#8217;s value to be changed by the terminated process.</p>
<p class="indent">System V semaphores are allocated and operated upon in sets, and can be increased and decreased by arbitrary amounts. This provides more functionality than is needed by most applications. A common requirement is for individual binary semaphores, which take on only the values 0 and 1. We showed how to implement binary semaphores on top of System V semaphores.</p>
<h5 class="h5" id="ch47lev3sec09"><strong>Further information</strong></h5>
<p class="noindenta">[<a href="bib.xhtml#bib09">Bovet &#38; Cesati, 2005</a>] and [<a href="bib.xhtml#bib63">Maxwell, 1999</a>] provide some background on the implementation of semaphores on Linux. [<a href="bib.xhtml#bib19">Dijkstra, 1968</a>] is a classic early paper on semaphore theory.</p>
<h3 class="h3" id="ch47lev1sec13"><strong>47.13 Exercises</strong></h3>
<p class="exer"><a id="ch47exe1"/><strong>47-1.</strong>&#160;&#160;&#160;Experiment with the program in <a href="ch47.xhtml#ch47ex8">Listing 47-8</a> (<span class="literal">svsem_op.c</span>) to confirm your understanding of the <em>semop()</em> system call.</p>
<p class="exer"><a id="ch47exe2"/><strong>47-2.</strong>&#160;&#160;&#160;Modify the program in <a href="ch24.xhtml#ch24ex6">Listing 24-6</a> (<span class="literal">fork_sig_sync.c</span>, on <a href="ch24.xhtml#page_528">page 528</a>) to use semaphores instead of signals to synchronize the parent and child processes.</p>
<p class="exer"><span epub:type="pagebreak" id="page_995"/><a id="ch47exe3"/><strong>47-3.</strong>&#160;&#160;&#160;Experiment with the program in <a href="ch47.xhtml#ch47ex8">Listing 47-8</a> (<span class="literal">svsem_op.c</span>) and the other semaphore programs provided in this chapter to see what happens to the <em>sempid</em> value if an exiting process performs a <span class="literal">SEM_UNDO</span> adjustment to a semaphore.</p>
<p class="exer"><a id="ch47exe4"/><strong>47-4.</strong>&#160;&#160;&#160;Add a <em>reserveSemNB()</em> function to the code in <a href="ch47.xhtml#ch47ex10">Listing 47-10</a> (<span class="literal">binary_sems.c</span>) to implement the <em>reserve conditionally</em> operation, using the <span class="literal">IPC_NOWAIT</span> flag.</p>
<p class="exer"><a id="ch47exe5"/><strong>47-5.</strong>&#160;&#160;&#160;For the VMS operating system, Digital provided a synchronization method similar to a binary semaphore, called an <em>event flag</em>. An event flag has two possible values, <em>clear</em> and <em>set</em>, and the following four operations can be performed: <em>setEventFlag</em>, to set the flag; <em>clearEventFlag</em>, to clear the flag; <em>waitForEventFlag</em>, to block until the flag is set; and <em>getFlagState</em>, to obtain the current state of the flag. Devise an implementation of event flags using System V semaphores. This implementation will require two arguments for each of the functions above: a semaphore identifier and a semaphore number. (Consideration of the <em>waitForEventFlag</em> operation will lead you to realize that the values chosen for <em>clear</em> and <em>set</em> are not the obvious choices.)</p>
<p class="exer"><a id="ch47exe6"/><strong>47-6.</strong>&#160;&#160;&#160;Implement a binary semaphores protocol using named pipes. Provide functions to reserve, release, and conditionally reserve the semaphore.</p>
<p class="exer"><a id="ch47exe7"/><strong>47-7.</strong>&#160;&#160;&#160;Write a program, analogous to the program in <a href="ch46.xhtml#ch46ex6">Listing 46-6</a> (<span class="literal">svmsg_ls.c</span>, on <a href="ch46.xhtml#page_953">page 953</a>), that uses the <em>semctl()</em> <span class="literal">SEM_INFO</span> and <span class="literal">SEM_STAT</span> operations to obtain and display a list of all semaphore sets on the system.<span epub:type="pagebreak" id="page_996"/></p>
</body>
</html>
