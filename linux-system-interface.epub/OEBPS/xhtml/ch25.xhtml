<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch25"><span epub:type="pagebreak" id="page_531"/><strong><span class="big">25</span></strong><br/><strong>PROCESS TERMINATION</strong></h2>
<p class="noindenta">This chapter describes what happens when a process terminates. We begin by describing the use of <em>exit()</em> and <em>_exit()</em> to terminate a process. We then discuss the use of exit handlers to automatically perform cleanups when a process calls <em>exit()</em>. We conclude by considering some interactions between <em>fork()</em>, <em>stdio</em> buffers, and <em>exit()</em>.</p>
<h3 class="h3" id="ch25lev1sec01"><strong>25.1 Terminating a Process: <em>_exit()</em> and <em>exit()</em></strong></h3>
<p class="noindenta">A process may terminate in two general ways. One of these is <em>abnormal</em> termination, caused by the delivery of a signal whose default action is to terminate the process (with or without a core dump), as described in <a href="ch20.xhtml#ch20lev1sec01">Section 20.1</a>. Alternatively, a process can terminate <em>normally</em>, using the <em>_exit()</em> system call.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>void _<span class="codestrong">exit</span>(int <span class="font1">status</span>);</p>
</div>
<p class="noindent">The <em>status</em> argument given to <em>_exit()</em> defines the <em>termination status</em> of the process, which is available to the parent of this process when it calls <em>wait()</em>. Although defined as an <em>int</em>, only the bottom 8 bits of <em>status</em> are actually made available to the parent. By convention, a termination status of 0 indicates that a process completed <span epub:type="pagebreak" id="page_532"/>successfully, and a nonzero status value indicates that the process terminated unsuccessfully. There are no fixed rules about how nonzero status values are to be interpreted; different applications follow their own conventions, which should be described in their documentation. SUSv3 specifies two constants, <span class="literal">EXIT_SUCCESS</span> (0) and <span class="literal">EXIT_FAILURE</span> (1), that are used in most programs in this book.</p>
<p class="indent">A process is always successfully terminated by <em>_exit()</em> (i.e., <em>_exit()</em> never returns).</p>
<div class="block">
<p class="noindent">Although any value in the range 0 to 255 can be passed to the parent via the <em>status</em> argument to <em>_exit()</em>, specifying values greater than 128 can cause confusion in shell scripts. The reason is that, when a command is terminated by a signal, the shell indicates this fact by setting the value of the variable <em>$?</em> to 128 plus the signal number, and this value is indistinguishable from that yielded when a process calls <em>_exit()</em> with the same <em>status</em> value.</p>
</div>
<p class="noindent">Programs generally don&#8217;t call <em>_exit()</em> directly, but instead call the <em>exit()</em> library function, which performs various actions before calling <em>_exit()</em>.</p>
<div class="box">
<p class="programsa">#include &lt;stdlib.h&gt;<br/><br/>void <span class="codestrong">exit</span>(int <span class="font1">status</span>);</p>
</div>
<p class="noindentb">The following actions are performed by <em>exit()</em>:</p>
<p class="bull">&#8226; Exit handlers (functions registered with <em>atexit()</em> and <em>on_exit()</em>) are called, in reverse order of their registration (<a href="ch25.xhtml#ch25lev1sec03">Section 25.3</a>).</p>
<p class="bull">&#8226; The <em>stdio</em> stream buffers are flushed.</p>
<p class="bull">&#8226; The <em>_exit()</em> system call is invoked, using the value supplied in <em>status</em>.</p>
<div class="block">
<p class="noindent">Unlike <em>_exit()</em>, which is UNIX-specific, <em>exit()</em> is defined as part of the standard C library; that is, it is available with every C implementation.</p>
</div>
<p class="noindent">One other way in which a process may terminate is to return from <em>main()</em>, either explicitly, or implicitly, by falling off the end of the <em>main()</em> function. Performing an explicit <em>return n</em> is generally equivalent to calling <em>exit(n)</em>, since the run-time function that invokes <em>main()</em> uses the return value from <em>main()</em> in a call to <em>exit()</em>.</p>
<div class="block">
<p class="noindent">There is one circumstance in which calling <em>exit()</em> and returning from <em>main()</em> are not equivalent. If any steps performed during exit processing access variables local to <em>main()</em>, then doing a <span class="literal">return</span> from <em>main()</em> results in undefined behavior. For example, this could occur if a variable that is local to <em>main()</em> is specified in a call to <em>setvbuf()</em> or <em>setbuf()</em> (<a href="ch13.xhtml#ch13lev1sec02">Section 13.2</a>).</p>
</div>
<p class="noindentb">Performing a return without specifying a value, or falling off the end of the <em>main()</em> function, also results in the caller of <em>main()</em> invoking <em>exit()</em>, but with results that vary depending on the version of the C standard supported and the compilation options employed:</p>
<p class="bull"><span epub:type="pagebreak" id="page_533"/>&#8226; In C89, the behavior in these circumstances is undefined; the program can terminate with an arbitrary <em>status</em> value. This is the behavior that occurs by default with <em>gcc</em> on Linux, where the exit status of the program is taken from some random value lying on the stack or in a particular CPU register. Terminating a program in this way should be avoided.</p>
<p class="bull">&#8226; The C99 standard requires that falling off the end of the main program should be equivalent to calling <em>exit(0)</em>. This is the behavior we obtain on Linux if we compile a program using <em>gcc &#8211;std=c99</em>.</p>
<h3 class="h3" id="ch25lev1sec02"><strong>25.2 Details of Process Termination</strong></h3>
<p class="noindentab">During both normal and abnormal termination of a process, the following actions occur:</p>
<p class="bull">&#8226; Open file descriptors, directory streams (<a href="ch18.xhtml#ch18lev1sec08">Section 18.8</a>), message catalog descriptors (see the <em>catopen(3)</em> and <em>catgets(3)</em> manual pages), and conversion descriptors (see the <em>iconv_open(3)</em> manual page) are closed.</p>
<p class="bull">&#8226; As a consequence of closing file descriptors, any file locks (<a href="ch55.xhtml#ch55">Chapter 55</a>) held by this process are released.</p>
<p class="bull">&#8226; Any attached System V shared memory segments are detached, and the <em>shm_nattch</em> counter corresponding to each segment is decremented by one. (Refer to <a href="ch48.xhtml#ch48lev1sec08">Section 48.8</a>.)</p>
<p class="bull">&#8226; For each System V semaphore for which a <em>semadj</em> value has been set by the process, that <em>semadj</em> value is added to the semaphore value. (Refer to <a href="ch47.xhtml#ch47lev1sec08">Section 47.8</a>.)</p>
<p class="bull">&#8226; If this is the controlling process for a controlling terminal, then the <span class="literal">SIGHUP</span> signal is sent to each process in the controlling terminal&#8217;s foreground process group, and the terminal is disassociated from the session. We consider this point further in <a href="ch34.xhtml#ch34lev1sec06">Section 34.6</a>.</p>
<p class="bull">&#8226; Any POSIX named semaphores that are open in the calling process are closed as though <em>sem_close()</em> were called.</p>
<p class="bull">&#8226; Any POSIX message queues that are open in the calling process are closed as though <em>mq_close()</em> were called.</p>
<p class="bull">&#8226; If, as a consequence of this process exiting, a process group becomes orphaned and there are any stopped processes in that group, then all processes in the group are sent a <span class="literal">SIGHUP</span> signal followed by a <span class="literal">SIGCONT</span> signal. We consider this point further in <a href="ch34.xhtml#ch34lev2sec06">Section 34.7.4</a>.</p>
<p class="bull">&#8226; Any memory locks established by this process using <em>mlock()</em> or <em>mlockall()</em> (<a href="ch50.xhtml#ch50lev1sec02">Section 50.2</a>) are removed.</p>
<p class="bull">&#8226; Any memory mappings established by this process using <em>mmap()</em> are unmapped.</p>
<h3 class="h3" id="ch25lev1sec03"><strong>25.3 Exit Handlers</strong></h3>
<p class="noindenta">Sometimes, an application needs to automatically perform some operations on process termination. Consider the example of an application library that, if used during the life of the process, needs to have some cleanup actions performed automatically <span epub:type="pagebreak" id="page_534"/>when the process exits. Since the library doesn&#8217;t have control of when and how the process exits, and can&#8217;t mandate that the main program call a library-specific cleanup function before exiting, cleanup is not guaranteed to occur. One approach in such situations is to use an <em>exit handler</em> (older System V manuals used the term <em>program termination routine</em>).</p>
<p class="indent">An exit handler is a programmer-supplied function that is registered at some point during the life of the process and is then automatically called during <em>normal</em> process termination via <em>exit()</em>. Exit handlers are not called if a program calls <em>_exit()</em> directly or if the process is terminated abnormally by a signal.</p>
<div class="block">
<p class="noindent">To some extent, the fact that exit handlers are not called when a process is terminated by a signal limits their utility. The best we can do is to establish handlers for the signals that might be sent to the process, and have these handlers set a flag that causes the main program to call <em>exit()</em>. (Because <em>exit()</em> is not one of the async-signal-safe functions listed in <a href="ch21.xhtml#ch21table1">Table 21-1</a>, on <a href="ch21.xhtml#page_426">page 426</a>, we generally can&#8217;t call it from a signal handler.) Even then, this doesn&#8217;t handle the case of <span class="literal">SIGKILL</span>, whose default action can&#8217;t be changed. This is one more reason we should avoid using <span class="literal">SIGKILL</span> to terminate a process (as noted in <a href="ch20.xhtml#ch20lev1sec02">Section 20.2</a>), and instead use <span class="literal">SIGTERM</span>, which is the default signal sent by the <em>kill</em> command.</p>
</div>
<h5 class="h5" id="ch25lev3sec01"><strong>Registering exit handlers</strong></h5>
<p class="noindenta">The GNU C library provides two ways of registering exit handlers. The first method, specified in SUSv3, is to use the <em>atexit()</em> function.</p>
<div class="box">
<p class="programsa">#include &lt;stdlib.h&gt;<br/><br/>int <span class="codestrong">atexit</span>(void (*<span class="font1">func</span>)(void));</p>
<p class="right">Returns 0 on success, or nonzero on error</p>
</div>
<p class="noindent">The <em>atexit()</em> function adds <em>func</em> to a list of functions that are called when the process terminates. The function <em>func</em> should be defined to take no arguments and return no value, thus having the following general form:</p>
<p class="programs">void<br/>func(void)<br/>{<br/>&#160;&#160;&#160;&#160;/* Perform some actions */<br/>}</p>
<p class="noindent">Note that <em>atexit()</em> returns a nonzero value (not necessarily &#8211;1) on error.</p>
<p class="indent">It is possible to register multiple exit handlers (and even the same exit handler multiple times). When the program invokes <em>exit()</em>, these functions are called <em>in reverse order</em> of registration. This ordering is logical because, typically, functions that are registered earlier are those that carry out more fundamental types of cleanups that may need to be performed after later-registered functions.</p>
<p class="indent">Essentially, any desired action can be performed inside an exit handler, including registering additional exit handlers, which are placed at the head of the list of exit handlers that remain to be called. However, if one of the exit handlers fails to return&#8212;either because it called <em>_exit()</em> or because the process was terminated by a <span epub:type="pagebreak" id="page_535"/>signal (e.g., the exit handler called <em>raise()</em>)&#8212;then the remaining exit handlers are not called. In addition, the remaining actions that would normally be performed by <em>exit()</em> (i.e., flushing <em>stdio</em> buffers) are not performed.</p>
<div class="block">
<p class="noindent">SUSv3 states that if an exit handler itself calls <em>exit()</em>, the results are undefined. On Linux, the remaining exit handlers are invoked as normal. However, on some systems, this causes all of the exit handlers to once more be invoked, which can result in an infinite recursion (until a stack overflow kills the process). Portable applications should avoid calling <em>exit()</em> inside an exit handler.</p>
</div>
<p class="noindent">SUSv3 requires that an implementation allow a process to be able to register at least 32 exit handlers. Using the call <em>sysconf(_SC_ATEXIT_MAX)</em>, a program can determine the implementation-defined upper limit on the number of exit handlers that can be registered. (However, there is no way to find out how many exit handlers have already been registered.) By chaining the registered exit handlers in a dynamically allocated linked list, <em>glibc</em> allows a virtually unlimited number of exit handlers to be registered. On Linux, <em>sysconf(_SC_ATEXIT_MAX)</em> returns 2,147,483,647 (i.e., the maximum signed 32-bit integer). In other words, something else will break (e.g., lack of memory) before we reach the limit on the number of functions that can be registered.</p>
<p class="indent">A child process created via <em>fork()</em> inherits a copy of its parent&#8217;s exit handler registrations. When a process performs an <em>exec()</em>, all exit handler registrations are removed. (This is necessarily so, since an <em>exec()</em> replaces the code of the exit handlers along with the rest of the existing program code.)</p>
<div class="block">
<p class="noindent">We can&#8217;t deregister an exit handler that has been registered with <em>atexit()</em> (or <em>on_exit()</em>, described below). However, we can have the exit handler check whether a global flag is set before it performs its actions, and disable the exit handler by clearing the flag.</p>
</div>
<p class="noindent">Exit handlers registered with <em>atexit()</em> suffer a couple of limitations. The first is that when called, an exit handler doesn&#8217;t know what status was passed to <em>exit()</em>. Occasionally, knowing the status could be useful; for example, we may like to perform different actions depending on whether the process is exiting successfully or unsuccessfully. The second limitation is that we can&#8217;t specify an argument to the exit handler when it is called. Such a facility could be useful to define an exit handler that performs different actions depending on its argument, or to register a function multiple times, each time with a different argument.</p>
<p class="indent">To address these limitations, <em>glibc</em> provides a (nonstandard) alternative method of registering exit handlers: <em>on_exit()</em>.</p>
<div class="box">
<p class="programsa">#define _BSD_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Or: #define _SVID_SOURCE */<br/>#include &lt;stdlib.h&gt;<br/><br/>int <span class="codestrong">on_exit</span>(void (*<span class="font1">func</span>)(int, void *), void *<span class="font1">arg</span>);</p>
<p class="right">Returns 0 on success, or nonzero on error</p>
</div>
<p class="noindent">The <em>func</em> argument of <em>on_exit()</em> is a pointer to a function of the following type:</p>
<p class="programs">void<br/>func(int status, void *arg)<br/>{<br/>&#160;&#160;&#160;&#160;/* Perform cleanup actions */<br/>}</p>
<p class="noindent"><span epub:type="pagebreak" id="page_536"/>When called, <em>func()</em> is passed two arguments: the <em>status</em> argument supplied to <em>exit()</em>, and a copy of the <em>arg</em> argument supplied to <em>on_exit()</em> at the time the function was registered. Although defined as a pointer type, <em>arg</em> is open to programmer-defined interpretation. It could be used as a pointer to some structure; equally, through judicious use of casting, it could be treated as an integer or other scalar type.</p>
<p class="indent">Like <em>atexit()</em>, <em>on_exit()</em> returns a nonzero value (not necessarily &#8211;1) on error.</p>
<p class="indent">As with <em>atexit()</em>, multiple exit handlers can be registered with <em>on_exit()</em>. Functions registered using <em>atexit()</em> and <em>on_exit()</em> are placed on the same list. If both methods are used in the same program, then the exit handlers are called in reverse order of their registration using the two methods.</p>
<p class="indent">Although more flexible than <em>atexit()</em>, <em>on_exit()</em> should be avoided in programs intended to be portable, since it is not covered by any standards and is available on few other UNIX implementations.</p>
<h5 class="h5" id="ch25lev3sec02"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch25.xhtml#ch25ex1">Listing 25-1</a> demonstrates the use of <em>atexit()</em> and <em>on_exit()</em> to register exit handlers. When we run this program, we see the following output:</p>
<p class="programs">$ <span class="codestrong">./exit_handlers</span><br/>on_exit function called: status=2, arg=20<br/>atexit function 2 called<br/>atexit function 1 called<br/>on_exit function called: status=2, arg=10</p>
<p class="examplet"><a id="ch25ex1"/><strong>Listing 25-1:</strong> Using exit handlers</p>
<p class="programsli">__________________________________________________ <span class="codestrong">procexec/exit_handlers.c</span><br/><br/>#define _BSD_SOURCE&#160;&#160;&#160;&#160;&#160;/* Get on_exit() declaration from &lt;stdlib.h&gt; */<br/>#include &lt;stdlib.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static void<br/>atexitFunc1(void)<br/>{<br/>&#160;&#160;&#160;&#160;printf("atexit function 1 called\n");<br/>}<br/><br/>static void<br/>atexitFunc2(void)<br/>{<br/>&#160;&#160;&#160;&#160;printf("atexit function 2 called\n");<br/>}<br/><br/>static void<br/>onexitFunc(int exitStatus, void *arg)<br/>{<br/>&#160;&#160;&#160;&#160;printf("on_exit function called: status=%d, arg=%ld\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exitStatus, (long) arg);<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;if (on_exit(onexitFunc, (void *) 10) != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("on_exit 1");<br/>&#160;&#160;&#160;&#160;if (atexit(atexitFunc1) != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("atexit 1");<br/>&#160;&#160;&#160;&#160;if (atexit(atexitFunc2) != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("atexit 2");<br/>&#160;&#160;&#160;&#160;if (on_exit(onexitFunc, (void *) 20) != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("on_exit 2");<br/><br/>&#160;&#160;&#160;&#160;exit(2);<br/>}<br/>__________________________________________________ <span class="codestrong">procexec/exit_handlers.c</span></p>
<h3 class="h3" id="ch25lev1sec04"><span epub:type="pagebreak" id="page_537"/><strong>25.4 Interactions Between <em>fork()</em>, <em>stdio</em> Buffers, and <em>_exit()</em></strong></h3>
<p class="noindenta">The output yielded by the program in <a href="ch25.xhtml#ch25ex2">Listing 25-2</a> demonstrates a phenomenon that is at first puzzling. When we run this program with standard output directed to the terminal, we see the expected result:</p>
<p class="programs">$ <span class="codestrong">./fork_stdio_buf</span><br/>Hello world<br/>Ciao</p>
<p class="noindent">However, when we redirect standard output to a file, we see the following:</p>
<p class="programs">$ <span class="codestrong">./fork_stdio_buf &gt; a</span><br/>$ <span class="codestrong">cat a</span><br/>Ciao<br/>Hello world<br/>Hello world</p>
<p class="noindent">In the above output, we see two strange things: the line written by <em>printf()</em> appears twice, and the output of <em>write()</em> precedes that of <em>printf()</em>.</p>
<p class="examplet"><a id="ch25ex2"/><strong>Listing 25-2:</strong> Interaction of <em>fork()</em> and <em>stdio</em> buffering</p>
<p class="programsli">_________________________________________________ <span class="codestrong">procexec/fork_stdio_buf.c</span><br/><br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;printf("Hello world\n");<br/>&#160;&#160;&#160;&#160;write(STDOUT_FILENO, "Ciao\n", 5);<br/><br/>&#160;&#160;&#160;&#160;if (fork() == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;/* Both child and parent continue execution here */<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________ <span class="codestrong">procexec/fork_stdio_buf.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_538"/>To understand why the message written with <em>printf()</em> appears twice, recall that the <em>stdio</em> buffers are maintained in a process&#8217;s user-space memory (refer to <a href="ch13.xhtml#ch13lev1sec02">Section 13.2</a>). Therefore, these buffers are duplicated in the child by <em>fork()</em>. When standard output is directed to a terminal, it is line-buffered by default, with the result that the newline-terminated string written by <em>printf()</em> appears immediately. However, when standard output is directed to a file, it is block-buffered by default. Thus, in our example, the string written by <em>printf()</em> is still in the parent&#8217;s <em>stdio</em> buffer at the time of the <em>fork()</em>, and this string is duplicated in the child. When the parent and the child later call <em>exit()</em>, they both flush their copies of the <em>stdio</em> buffers, resulting in duplicate output.</p>
<p class="indentb">We can prevent this duplicated output from occurring in one of the following ways:</p>
<p class="bull">&#8226; As a specific solution to the <em>stdio</em> buffering issue, we can use <em>fflush()</em> to flush the <em>stdio</em> buffer prior to a <em>fork()</em> call. Alternatively, we could use <em>setvbuf()</em> or <em>setbuf()</em> to disable buffering on the <em>stdio</em> stream.</p>
<p class="bull">&#8226; Instead of calling <em>exit()</em>, the child can call <em>_exit()</em>, so that it doesn&#8217;t flush <em>stdio</em> buffers. This technique exemplifies a more general principle: in an application that creates child processes that don&#8217;t exec new programs, typically only one of the processes (most often the parent) should terminate via <em>exit()</em>, while the other processes should terminate via <em>_exit()</em>. This ensures that only one process calls exit handlers and flushes <em>stdio</em> buffers, which is usually desirable.</p>
<div class="block">
<p class="noindent">Other approaches that allow both the parent and child to call <em>exit()</em> are possible (and sometimes necessary). For example, it may be possible to design exit handlers so that they operate correctly even if called from multiple processes, or to have the application install exit handlers only after the call to <em>fork()</em>. Furthermore, sometimes we may actually want all processes to flush their <em>stdio</em> buffers after a <em>fork()</em>. In this case, we may choose to terminate the processes using <em>exit()</em>, or use explicit calls to <em>fflush()</em> in each process, as appropriate.</p>
</div>
<p class="noindent">The output of the <em>write()</em> in the program in <a href="ch25.xhtml#ch25ex2">Listing 25-2</a> doesn&#8217;t appear twice, because <em>write()</em> transfers data directly to a kernel buffer, and this buffer is not duplicated during a <em>fork()</em>.</p>
<p class="indent">By now, the reason for the second strange aspect of the program&#8217;s output when redirected to a file should be clear. The output of <em>write()</em> appears before that from <em>printf()</em> because the output of <em>write()</em> is immediately transferred to the kernel buffer cache, while the output from <em>printf()</em> is transferred only when the <em>stdio</em> buffers are flushed by the call to <em>exit()</em>. (In general, care is required when mixing <em>stdio</em> functions and system calls to perform I/O on the same file, as described in <a href="ch13.xhtml#ch13lev1sec07">Section 13.7</a>.)</p>
<h3 class="h3" id="ch25lev1sec05"><span epub:type="pagebreak" id="page_539"/><strong>25.5 Summary</strong></h3>
<p class="noindenta">A process can terminate either abnormally or normally. Abnormal termination occurs on delivery of certain signals, some of which also cause the process to produce a core dump file.</p>
<p class="indent">Normal termination is accomplished by calling <em>_exit()</em> or, more usually, <em>exit()</em>, which is layered on top of <em>_exit()</em>. Both <em>_exit()</em> and <em>exit()</em> take an integer argument whose least significant 8 bits define the termination status of the process. By convention, a status of 0 is used to indicate successful termination, and a nonzero status indicates unsuccessful termination.</p>
<p class="indent">As part of both normal and abnormal process termination, the kernel performs various cleanup steps. Terminating a process normally by calling <em>exit()</em> additionally causes exit handlers registered using <em>atexit()</em> and <em>on_exit()</em> to be called (in reverse order of registration), and causes <em>stdio</em> buffers to be flushed.</p>
<h5 class="h5" id="ch25lev3sec03"><strong>Further information</strong></h5>
<p class="noindenta">Refer to the sources of further information listed in <a href="ch24.xhtml#ch24lev1sec06">Section 24.6</a>.</p>
<h3 class="h3" id="ch25lev1sec06"><strong>25.6 Exercise</strong></h3>
<p class="exer"><a id="ch25exe1"/><strong>25-1.</strong>&#160;&#160;&#160;If a child process makes the call <em>exit(&#8211;1)</em>, what exit status will be seen by the parent?<span epub:type="pagebreak" id="page_540"/></p>
</body>
</html>
