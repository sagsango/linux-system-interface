<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch19"><span epub:type="pagebreak" id="page_375"/><strong><span class="big">19</span></strong><br/><strong>MONITORING FILE EVENTS</strong></h2>
<p class="noindenta">Some applications need to be able to monitor files or directories in order to determine whether events have occurred for the monitored objects. For example, a graphical file manager needs to be able to determine when files are added or removed from the directory that is currently being displayed, or a daemon may want to monitor its configuration file in order to know if the file has been changed.</p>
<p class="indent">Starting with kernel 2.6.13, Linux provides the <em>inotify</em> mechanism, which allows an application to monitor file events. This chapter describes the use of <em>inotify</em>.</p>
<p class="indent">The <em>inotify</em> mechanism replaces an older mechanism, <em>dnotify</em>, which provided a subset of the functionality of <em>inotify</em>. We describe <em>dnotify</em> briefly at the end of this chapter, focusing on why <em>inotify</em> is better.</p>
<p class="indent">The <em>inotify</em> and <em>dnotify</em> mechanisms are Linux-specific. (A few other systems provide similar mechanisms. For example, the BSDs provide the <em>kqueue</em> API.)</p>
<div class="block">
<p class="noindent">A few libraries provide an API that is more abstract and portable than <em>inotify</em> and <em>dnotify</em>. The use of these libraries may be preferable for some applications. Some of these libraries employ <em>inotify</em> or <em>dnotify</em>, on systems where they are available. Two such libraries are FAM (File Alteration Monitor, <em><a href="http://oss.sgi.com/projects/fam/">http://oss.sgi.com/projects/fam/</a></em>) and Gamin (<em><a href="http://www.gnome.org/~veillard/gamin/">http://www.gnome.org/~veillard/gamin/</a></em>).</p>
</div>
<h3 class="h3" id="ch19lev1sec01"><span epub:type="pagebreak" id="page_376"/><strong>19.1 Overview</strong></h3>
<p class="noindenta">The key steps in the use of the <em>inotify</em> API are as follows:</p>
<ol>
<li class="order"><p class="orderp">The application uses <em>inotify_init()</em> to create an <em>inotify instance</em>. This system call returns a file descriptor that is used to refer to the <em>inotify</em> instance in later operations.</p></li>
<li class="order"><p class="orderp">The application informs the kernel about which files are of interest by using <em>inotify_add_watch()</em> to add items to the watch list of the <em>inotify</em> instance created in the previous step. Each watch item consists of a pathname and an associated bit mask. The bit mask specifies the set of events to be monitored for the pathname. As its function result, <em>inotify_add_watch()</em> returns a <em>watch descriptor</em>, which is used to refer to the watch in later operations. (The <em>inotify_rm_watch()</em> system call performs the converse task, removing a watch that was previously added to an <em>inotify</em> instance.)</p></li>
<li class="order"><p class="orderp">In order to obtain event notifications, the application performs <em>read()</em> operations on the <em>inotify</em> file descriptor. Each successful <em>read()</em> returns one or more <em>inotify_event</em> structures, each containing information about an event that occurred on one of the pathnames being watched via this <em>inotify</em> instance.</p></li>
<li class="order"><p class="orderp">When the application has finished monitoring, it closes the <em>inotify</em> file descriptor. This automatically removes all watch items associated with the <em>inotify</em> instance.</p></li>
</ol>
<p class="noindent">The <em>inotify</em> mechanism can be used to monitor files or directories. When monitoring a directory, the application will be informed about events for the directory itself and for files inside the directory.</p>
<p class="indent">The <em>inotify</em> monitoring mechanism is not recursive. If an application wants to monitor events within an entire directory subtree, it must issue <em>inotify_add_watch()</em> calls for each directory in the tree.</p>
<p class="indent">An <em>inotify</em> file descriptor can be monitored using <em>select()</em>, <em>poll()</em>, <em>epoll</em>, and, since Linux 2.6.25, signal-driven I/O. If events are available to be read, then these interfaces indicate the <em>inotify</em> file descriptor as being readable. See <a href="ch63.xhtml#ch63">Chapter 63</a> for further details of these interfaces.</p>
<div class="block">
<p class="noindent">The <em>inotify</em> mechanism is an optional Linux kernel component that is configured via the options <span class="literal">CONFIG_INOTIFY</span> and <span class="literal">CONFIG_INOTIFY_USER</span>.</p>
</div>
<h3 class="h3" id="ch19lev1sec02"><strong>19.2 The <em>inotify</em> API</strong></h3>
<p class="noindenta">The <em>inotify_init()</em> system call creates a new <em>inotify</em> instance.</p>
<div class="box">
<p class="programsa">#include &lt;sys/inotify.h&gt;<br/><br/>int <span class="codestrong">inotify_init</span>(void);</p>
<p class="right">Returns file descriptor on success, or &#8211;1 on error</p>
</div>
<p class="noindent">As its function result, <em>inotify_init()</em> returns a file descriptor. This file descriptor is the handle that is used to refer to the <em>inotify</em> instance in subsequent operations.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_377"/>Starting with kernel 2.6.27, Linux supports a new, nonstandard system call, <em>inotify_init1()</em>. This system call performs the same task as <em>inotify_init()</em>, but provides an additional argument, <em>flags</em>, that can be used to modify the behavior of the system call. Two flags are supported. The <span class="literal">IN_CLOEXEC</span> flag causes the kernel to enable the close-on-exec flag (<span class="literal">FD_CLOEXEC</span>) for the new file descriptor. This flag is useful for the same reasons as the <em>open()</em> <span class="literal">O_CLOEXEC</span> flag described in <a href="ch04.xhtml#ch04lev2sec01">Section 4.3.1</a>. The <span class="literal">IN_NONBLOCK</span> flag causes the kernel to enable the <span class="literal">O_NONBLOCK</span> flag on the underlying open file description, so that future reads will be nonblocking. This saves additional calls to <em>fcntl()</em> to achieve the same result.</p>
</div>
<p class="noindent">The <em>inotify_add_watch()</em> system call either adds a new watch item to or modifies an existing watch item in the watch list for the <em>inotify</em> instance referred to by the file descriptor <em>fd</em>. (Refer to <a href="ch19.xhtml#ch19fig1">Figure 19-1</a>.)</p>
<div class="box">
<p class="programsa">#include &lt;sys/inotify.h&gt;<br/><br/>int <span class="codestrong">inotify_add_watch</span>(int <span class="font1">fd</span>, const char *<span class="font1">pathname</span>, uint32_t <span class="font1">mask</span>);</p>
<p class="right">Returns watch descriptor on success, or &#8211;1 on error</p>
</div>
<div class="image"><img src="../images/f19-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch19fig1"/><strong>Figure 19-1:</strong> An <em>inotify</em> instance and associated kernel data structures</p>
<p class="noindent">The <em>pathname</em> argument identifies the file for which a watch item is to be created or modified. The caller must have read permission for this file. (The file permission check is performed once, at the time of the <em>inotify_add_watch()</em> call. As long as the watch item continues to exist, the caller will continue to receive file notifications even if the file permissions are later changed so that the caller no longer has read permission on the file.)</p>
<p class="indent">The <em>mask</em> argument is a bit mask that specifies the events to be monitored for <em>pathname</em>. We say more about the bit values that can be specified in <em>mask</em> shortly.</p>
<p class="indent">If <em>pathname</em> has not previously been added to the watch list for <em>fd</em>, then <em>inotify_add_watch()</em> creates a new watch item in the list and returns a new, nonnegative watch descriptor, which is used to refer to the watch item in later operations. This watch descriptor is unique for this <em>inotify</em> instance.</p>
<p class="indent">If <em>pathname</em> has previously been added to the watch list for <em>fd</em>, then <em>inotify_add_watch()</em> modifies the mask of the existing watch item for <em>pathname</em> and returns the watch descriptor for that item. (This watch descriptor will be the same as that returned by the <em>inotify_add_watch()</em> call that initially added <em>pathname</em> to this watch list.) We say more about how the mask may be modified when we describe the <span class="literal">IN_MASK_ADD</span> flag in the next section.</p>
<p class="indent"><span epub:type="pagebreak" id="page_378"/>The <em>inotify_rm_watch()</em> system call removes the watch item specified by <em>wd</em> from the <em>inotify</em> instance referred to by the file descriptor <em>fd</em>.</p>
<div class="box">
<p class="programsa">#include &lt;sys/inotify.h&gt;<br/><br/>int <span class="codestrong">inotify_rm_watch</span>(int <span class="font1">fd</span>, int <span class="font1">wd</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>wd</em> argument is a watch descriptor returned by a previous call to <em>inotify_add_watch()</em>.</p>
<p class="indent">Removing a watch causes an <span class="literal">IN_IGNORED</span> event to be generated for this watch descriptor. We say more about this event shortly.</p>
<h3 class="h3" id="ch19lev1sec03"><strong>19.3 <em>inotify</em> Events</strong></h3>
<p class="noindenta">When we create or modify a watch using <em>inotify_add_watch()</em>, the <em>mask</em> bit-mask argument identifies the events to be monitored for the given <em>pathname</em>. The event bits that may be specified in <em>mask</em> are indicated by the <em>In</em> column of <a href="ch19.xhtml#ch19table1">Table 19-1</a>.</p>
<p class="tablecap"><a id="ch19table1"/><strong>Table 19-1:</strong> <em>inotify</em> events</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Bit value</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong>In</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong>Out</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_ACCESS</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">File was accessed (<em>read()</em>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_ATTRIB</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">File metadata changed</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_CLOSE_WRITE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">File opened for writing was closed</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_CLOSE_NOWRITE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">File opened read-only was closed</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_CREATE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">File/directory created inside watched directory</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_DELETE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">File/directory deleted from within watched directory</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_DELETE_SELF</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Watched file/directory was itself deleted</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_MODIFY</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">File was modified</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_MOVE_SELF</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Watched file/directory was itself moved</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_MOVED_FROM</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">File moved out of watched directory</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_MOVED_TO</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">File moved into watched directory</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">IN_OPEN</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">File was opened</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_ALL_EVENTS</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Shorthand for all of the above input events</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_MOVE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Shorthand for <span class="literal">IN_MOVED_FROM | IN_MOVED_TO</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">IN_CLOSE</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Shorthand for <span class="literal">IN_CLOSE_WRITE | IN_CLOSE_NOWRITE</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_DONT_FOLLOW</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Don&#8217;t dereference symbolic link (since Linux 2.6.15)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_MASK_ADD</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Add events to current watch mask for <em>pathname</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_ONESHOT</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Monitor <em>pathname</em> for just one event</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">IN_ONLYDIR</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Fail if <em>pathname</em> is not a directory (since Linux 2.6.15)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_IGNORED</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Watch was removed by application or by kernel</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_ISDIR</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Filename returned in <em>name</em> is a directory</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">IN_Q_OVERFLOW</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Overflow on event queue</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">IN_UNMOUNT</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">File system containing object was unmounted</p></td>
</tr>
</tbody>
</table>
<p class="noindentb"><span epub:type="pagebreak" id="page_379"/>The meanings of most of the bits in <a href="ch19.xhtml#ch19table1">Table 19-1</a> are evident from their names. The following list clarifies a few details:</p>
<p class="bull">&#8226; The <span class="literal">IN_ATTRIB</span> event occurs when file metadata such as permissions, ownership, link count, extended attributes, user ID, or group ID, is changed.</p>
<p class="bull">&#8226; The <span class="literal">IN_DELETE_SELF</span> event occurs when an object (i.e., a file or a directory) that is being monitored is deleted. The <span class="literal">IN_DELETE</span> event occurs when the monitored object is a directory and one of the files that it contains is deleted.</p>
<p class="bull">&#8226; The <span class="literal">IN_MOVE_SELF</span> event occurs when an object that is being monitored is renamed. The <span class="literal">IN_MOVED_FROM</span> and <span class="literal">IN_MOVED_TO</span> events occur when an object is renamed within monitored directories. The former event occurs for the directory containing the old name, and the latter event occurs for the directory containing the new name.</p>
<p class="bull">&#8226; The <span class="literal">IN_DONT_FOLLOW</span>, <span class="literal">IN_MASK_ADD</span>, <span class="literal">IN_ONESHOT</span>, and <span class="literal">IN_ONLYDIR</span> bits don&#8217;t specify events to be monitored. Instead, they control the operation of the <em>inotify_add_watch()</em> call.</p>
<p class="bull">&#8226; <span class="literal">IN_DONT_FOLLOW</span> specifies that <em>pathname</em> should not be dereferenced if it is a symbolic link. This permits an application to monitor a symbolic link, rather than the file to which it refers.</p>
<p class="bull">&#8226; If we perform an <em>inotify_add_watch()</em> call that specifies a pathname that is already being watched via this <em>inotify</em> file descriptor, then, by default, the given <em>mask</em> is used to replace the current mask for this watch item. If <span class="literal">IN_MASK_ADD</span> is specified, then the current mask is instead modified by ORing it with the value given in <em>mask</em>.</p>
<p class="bull">&#8226; <span class="literal">IN_ONESHOT</span> permits an application to monitor <em>pathname</em> for a single event. After that event, the watch item is automatically removed from the watch list.</p>
<p class="bull">&#8226; <span class="literal">IN_ONLYDIR</span> permits an application to monitor a pathname only if it is a directory. If <em>pathname</em> is not a directory, then <em>inotify_add_watch()</em> fails with the error <span class="literal">ENOTDIR</span>. Using this flag prevents race conditions that could otherwise occur if we wanted to ensure that we are monitoring a directory.</p>
<h3 class="h3" id="ch19lev1sec04"><strong>19.4 Reading <em>inotify</em> Events</strong></h3>
<p class="noindenta">Having registered items in the watch list, an application can determine which events have occurred by using <em>read()</em> to read events from the <em>inotify</em> file descriptor. If no events have occurred so far, then <em>read()</em> blocks until an event occurs (unless the <span class="literal">O_NONBLOCK</span> status flag has been set for the file descriptor, in which case the <em>read()</em> fails immediately with the error <span class="literal">EAGAIN</span> if no events are available).</p>
<p class="indent">After events have occurred, each <em>read()</em> returns a buffer (see <a href="ch19.xhtml#ch19fig2">Figure 19-2</a>) containing one or more structures of the following type:</p>
<p class="programs">struct inotify_event {<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;&#160;wd;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Watch descriptor on which event occurred */<br/>&#160;&#160;&#160;&#160;uint32_t mask;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Bits describing event that occurred */<br/>&#160;&#160;&#160;&#160;uint32_t cookie;&#160;&#160;&#160;&#160;&#160;/* Cookie for related events (for rename()) */<br/>&#160;&#160;&#160;&#160;uint32_t len;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Size of 'name' field */<br/>&#160;&#160;&#160;&#160;char&#160;&#160;&#160;&#160;&#160;name[];&#160;&#160;&#160;&#160;&#160;/* Optional null-terminated filename */<br/>};</p>
<div class="image"><span epub:type="pagebreak" id="page_380"/><img src="../images/f19-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch19fig2"/><strong>Figure 19-2:</strong> An input buffer containing three <em>inotify_event</em> structures</p>
<p class="noindent">The <em>wd</em> field tells us the watch descriptor for which this event occurred. This field contains one of the values returned by a previous call to <em>inotify_add_watch()</em>. The <em>wd</em> field is useful when an application is monitoring multiple files or directories via the same <em>inotify</em> file descriptor. It provides the link that allows the application to determine the particular file or directory for which the event occurred. (To do this, the application must maintain a bookkeeping data structure that relates watch descriptors to pathnames.)</p>
<p class="indentb">The <em>mask</em> field returns a bit mask that describes the event. The range of bits that can appear in <em>mask</em> is indicated via the <em>Out</em> column of <a href="ch19.xhtml#ch19table1">Table 19-1</a>. Note the following additional details about specific bits:</p>
<p class="bull">&#8226; An <span class="literal">IN_IGNORED</span> event is generated when a watch is removed. This can occur for two reasons: the application used an <em>inotify_rm_watch()</em> call to explicitly remove the watch, or the watch was implicitly removed by the kernel because the monitored object was deleted or the file system where it resides was unmounted. An <span class="literal">IN_IGNORED</span> event is not generated when a watch that was established with <span class="literal">IN_ONESHOT</span> is automatically removed because an event was triggered.</p>
<p class="bull">&#8226; If the subject of the event is a directory, then, in addition to some other bit, the <span class="literal">IN_ISDIR</span> bit will be set in <em>mask</em>.</p>
<p class="bull"><span epub:type="pagebreak" id="page_381"/>&#8226; The <span class="literal">IN_UNMOUNT</span> event informs the application that the file system containing the monitored object has been unmounted. After this event, a further event containing the <span class="literal">IN_IGNORED</span> bit will be delivered.</p>
<p class="bull">&#8226; We describe the <span class="literal">IN_Q_OVERFLOW</span> in <a href="ch19.xhtml#ch19lev1sec05">Section 19.5</a>, which discusses limits on queued <em>inotify</em> events.</p>
<p class="noindentt">The <em>cookie</em> field is used to tie related events together. Currently, this field is used only when a file is renamed. When this happens, an <span class="literal">IN_MOVED_FROM</span> event is generated for the directory from which the file is renamed, and then an <span class="literal">IN_MOVED_TO</span> event is generated for the directory to which the file is renamed. (If a file is given a new name within the same directory, then both events occur for the same directory.) These two events will have the same unique value in their <em>cookie</em> field, thus allowing the application to associate them. For all other types of event, the <em>cookie</em> field is set to 0.</p>
<p class="indent">When an event occurs for a file within a monitored directory, the <em>name</em> field is used to return a null-terminated string that identifies the file. If the event occurs for the monitored object itself, then the <em>name</em> field is unused, and the <em>len</em> field will contain 0.</p>
<p class="indent">The <em>len</em> field indicates how many bytes are actually allocated for the <em>name</em> field. This field is necessary because there may be additional padding bytes between the end of the string stored in <em>name</em> and the start of the next <em>inotify_event</em> structure contained in the buffer returned by <em>read()</em> (see <a href="ch19.xhtml#ch19fig2">Figure 19-2</a>). The length of an individual <em>inotify</em> event is thus <em>sizeof(struct inotify_event) + len</em>.</p>
<p class="indent">If the buffer passed to <em>read()</em> is too small to hold the next <em>inotify_event</em> structure, then <em>read()</em> fails with the error <span class="literal">EINVAL</span> to warn the application of this fact. (In kernels before 2.6.21, <em>read()</em> returned 0 for this case. The change to the use of an <span class="literal">EINVAL</span> error provides a clearer indication that a programming error has been made.) The application could respond by performing another <em>read()</em> with a larger buffer. However, the problem can be avoided altogether by ensuring that the buffer is always large enough to hold at least one event: the buffer given to <em>read()</em> should be at least <em>(sizeof(struct inotify_event) + NAME_MAX + 1)</em> bytes, where <span class="literal">NAME_MAX</span> is the maximum length of a filename, plus one for the terminating null byte.</p>
<p class="indent">Using a larger buffer size than the minimum allows an application to efficiently retrieve multiple events with a single <em>read()</em>. A <em>read()</em> from an <em>inotify</em> file descriptor reads the minimum of the number of events that are available and the number of events that will fit in the supplied buffer.</p>
<div class="block">
<p class="noindent">The call <em>ioctl(fd, FIONREAD, &#38;numbytes)</em> returns the number of bytes that are currently available to read from the <em>inotify</em> instance referred to by the file descriptor <em>fd</em>.</p>
</div>
<p class="noindent">The events read from an <em>inotify</em> file descriptor form an ordered queue. Thus, for example, it is guaranteed that when a file is renamed, the <span class="literal">IN_MOVED_FROM</span> event will be read before the <span class="literal">IN_MOVED_TO</span> event.</p>
<p class="indent"><span epub:type="pagebreak" id="page_382"/>When appending a new event to the end of the event queue, the kernel will coalesce that event with the event at the tail of the queue (so that the new event is not in fact queued), if the two events have the same values for <em>wd</em>, <em>mask</em>, <em>cookie</em>, and <em>name</em>. This is done because many applications don&#8217;t need to know about repeated instances of the same event, and dropping the excess events reduces the amount of (kernel) memory required for the event queue. However, this means we can&#8217;t use <em>inotify</em> to reliably determine how many times or how often a recurrent event occurs.</p>
<h5 class="h5" id="ch19lev3sec01"><strong>Example program</strong></h5>
<p class="noindenta">Although there is a lot of detail in the preceding description, the <em>inotify</em> API is actually quite simple to use. <a href="ch19.xhtml#ch19ex1">Listing 19-1</a> demonstrates the use of <em>inotify</em>.</p>
<p class="examplet"><a id="ch19ex1"/><strong>Listing 19-1:</strong> Using the <em>inotify</em> API</p>
<p class="programsli">____________________________________________________ <span class="codestrong">inotify/demo_inotify.c</span><br/><br/>&#160;&#160;&#160;#include &lt;sys/inotify.h&gt;<br/>&#160;&#160;&#160;#include &lt;limits.h&gt;<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Display information from inotify_event structure */<br/>&#160;&#160;&#160;displayInotifyEvent(struct inotify_event *i)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;&#160;wd =%2d; ", i-&gt;wd);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i-&gt;cookie &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("cookie =%4d; ", i-&gt;cookie);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("mask = ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i-&gt;mask &#38; IN_ACCESS)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("IN_ACCESS ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i-&gt;mask &#38; IN_ATTRIB)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("IN_ATTRIB ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i-&gt;mask &#38; IN_CLOSE_NOWRITE) printf("IN_CLOSE_NOWRITE ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i-&gt;mask &#38; IN_CLOSE_WRITE)&#160;&#160;&#160;printf("IN_CLOSE_WRITE ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i-&gt;mask &#38; IN_CREATE)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("IN_CREATE ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i-&gt;mask &#38; IN_DELETE)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("IN_DELETE ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i-&gt;mask &#38; IN_DELETE_SELF)&#160;&#160;&#160;printf("IN_DELETE_SELF ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i-&gt;mask &#38; IN_IGNORED)&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("IN_IGNORED ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i-&gt;mask &#38; IN_ISDIR)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("IN_ISDIR ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i-&gt;mask &#38; IN_MODIFY)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("IN_MODIFY ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i-&gt;mask &#38; IN_MOVE_SELF)&#160;&#160;&#160;&#160;&#160;printf("IN_MOVE_SELF ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i-&gt;mask &#38; IN_MOVED_FROM)&#160;&#160;&#160;&#160;printf("IN_MOVED_FROM ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i-&gt;mask &#38; IN_MOVED_TO)&#160;&#160;&#160;&#160;&#160;&#160;printf("IN_MOVED_TO ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i-&gt;mask &#38; IN_OPEN)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("IN_OPEN ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i-&gt;mask &#38; IN_Q_OVERFLOW)&#160;&#160;&#160;&#160;printf("IN_Q_OVERFLOW ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i-&gt;mask &#38; IN_UNMOUNT)&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("IN_UNMOUNT ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("\n");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i-&gt;len &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;name = %s\n", i-&gt;name);<br/>&#160;&#160;&#160;}<br/><span epub:type="pagebreak" id="page_383"/><br/>&#160;&#160;&#160;#define BUF_LEN (10 * (sizeof(struct inotify_event) + NAME_MAX + 1))<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int inotifyFd, wd, j;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char buf[BUF_LEN] __attribute__((aligned(8)));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;ssize_t numRead;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char *p;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct inotify_event *event;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s pathname... \n", argv[0]);<br/><br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;&#160;inotifyFd = inotify_init();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create inotify instance */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (inotifyFd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("inotify_init");<br/><br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;&#160;for (j = 1; j &lt; argc; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;wd = inotify_add_watch(inotifyFd, argv[j], IN_ALL_EVENTS);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (wd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("inotify_add_watch");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Watching %s using wd %d\n", argv[j], wd);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (;;) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Read events forever */<br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numRead = read(inotifyFd, buf, BUF_LEN);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("read() from inotify fd returned 0!");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("read");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Read %ld bytes from inotify fd\n", (long) numRead);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Process all of the events in buffer returned by read() */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (p = buf; p &lt; buf + numRead; ) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;event = (struct inotify_event *) p;<br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;displayInotifyEvent(event);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p += sizeof(struct inotify_event) + event-&gt;len;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;}<br/>____________________________________________________ <span class="codestrong">inotify/demo_inotify.c</span></p>
<p class="noindentb"><span epub:type="pagebreak" id="page_384"/>The program in <a href="ch19.xhtml#ch19ex1">Listing 19-1</a> performs the following steps:</p>
<p class="bull">&#8226; Use <em>inotify_init()</em> to create an <em>inotify</em> file descriptor <span class="ent">&#x2460;</span>.</p>
<p class="bull">&#8226; Use <em>inotify_add_watch()</em> to add a watch item for each of the files named in the command-line argument of the program <span class="ent">&#x2461;</span>. Each watch item watches for all possible events.</p>
<p class="bull">&#8226; Execute an infinite loop that:</p>
<p class="dash1">&#8211; Reads a buffer of events from the <em>inotify</em> file descriptor <span class="ent">&#x2462;</span>.</p>
<p class="dash1">&#8211; Calls the <em>displayInotifyEvent()</em> function to display the contents of each of the <em>inotify_event</em> structures within that buffer <span class="ent">&#x2463;</span>.</p>
<p class="noindentt">The following shell session demonstrates the use of the program in <a href="ch19.xhtml#ch19ex1">Listing 19-1</a>. We start an instance of the program that runs in the background monitoring two directories:</p>
<p class="programs">$ <span class="codestrong">./demo_inotify dir1 dir2 &#38;</span><br/>[1] 5386<br/>Watching dir1 using wd 1<br/>Watching dir2 using wd 2</p>
<p class="noindent">Then we execute commands that generate events in the two directories. We begin by creating a file using <em>cat(1)</em>:</p>
<p class="programs">$ <span class="codestrong">cat &gt; dir1/aaa</span><br/>Read 64 bytes from inotify fd<br/>&#160;&#160;&#160;&#160;wd = 1; mask = IN_CREATE<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;name = aaa<br/>&#160;&#160;&#160;&#160;wd = 1; mask = IN_OPEN<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;name = aaa</p>
<p class="noindent">The above output produced by the background program shows that <em>read()</em> fetched a buffer containing two events. We continue by typing some input for the file and then the terminal <em>end-of-file</em> character:</p>
<p class="programs"><span class="codestrong">Hello world</span><br/>Read 32 bytes from inotify fd<br/>&#160;&#160;&#160;&#160;wd = 1; mask = IN_MODIFY<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;name = aaa<br/><span class="font1">Type Control-D</span><br/>Read 32 bytes from inotify fd<br/>&#160;&#160;&#160;&#160;wd = 1; mask = IN_CLOSE_WRITE<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;name = aaa</p>
<p class="noindent">We then rename the file into the other monitored directory. This results in two events, one for the directory from which the file moves (watch descriptor 1), and the other for the destination directory (watch descriptor 2):</p>
<p class="programs">$ <span class="codestrong">mv dir1/aaa dir2/bbb</span><br/>Read 64 bytes from inotify fd<br/>&#160;&#160;&#160;&#160;wd = 1; cookie = 548; mask = IN_MOVED_FROM<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;name = aaa<br/>&#160;&#160;&#160;&#160;wd = 2; cookie = 548; mask = IN_MOVED_TO<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;name = bbb</p>
<p class="noindent"><span epub:type="pagebreak" id="page_385"/>These two events share the same <em>cookie</em> value, allowing the application to link them.</p>
<p class="indent">When we create a subdirectory under one of the monitored directories, the mask in the resulting event includes the <span class="literal">IN_ISDIR</span> bit, indicating that the subject of the event is a directory:</p>
<p class="programs">$ <span class="codestrong">mkdir dir2/ddd</span><br/>Read 32 bytes from inotify fd<br/>&#160;&#160;&#160;&#160;wd = 2; mask = IN_CREATE IN_ISDIR<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;name = ddd</p>
<p class="noindent">At this point, it is worth repeating that <em>inotify</em> monitoring is not recursive. If the application wanted to monitor events in the newly created subdirectory, then it would need to issue a further <em>inotify_add_watch()</em> call specifying the pathname of the subdirectory.</p>
<p class="indent">Finally, we remove one of the monitored directories:</p>
<p class="programs">$ <span class="codestrong">rmdir dir1</span><br/>Read 32 bytes from inotify fd<br/>&#160;&#160;&#160;&#160;wd = 1; mask = IN_DELETE_SELF<br/>&#160;&#160;&#160;&#160;wd = 1; mask = IN_IGNORED</p>
<p class="noindent">The last event, <span class="literal">IN_IGNORED</span>, was generated to inform the application that the kernel has removed this watch item from the watch list.</p>
<h3 class="h3" id="ch19lev1sec05"><strong>19.5 Queue Limits and</strong> <span class="literal"><span class="codestrong">/proc</span></span> <strong>Files</strong></h3>
<p class="noindentab">Queuing <em>inotify</em> events requires kernel memory. For this reason, the kernel places various limits on the operation of the <em>inotify</em> mechanism. The superuser can configure these limits via three files in the directory <span class="literal">/proc/sys/fs/inotify</span>:</p>
<p class="term"><span class="literal">max_queued_events</span></p>
<p class="termlist">When <em>inotify_init()</em> is called, this value is used to set an upper limit on the number of events that can be queued on the new <em>inotify</em> instance. If this limit is reached, then an <span class="literal">IN_Q_OVERFLOW</span> event is generated and excess events are discarded. The <em>wd</em> field for the overflow event will have the value &#8211;1.</p>
<p class="term"><span class="literal">max_user_instances</span></p>
<p class="termlist">This is a limit on the number of <em>inotify</em> instances that can be created per real user ID.</p>
<p class="term"><span class="literal">max_user_watches</span></p>
<p class="termlist">This is a limit on the number of watch items that can be created per real user ID.</p>
<p class="noindentt">Typical default values for these three files are 16,384, 128, and 8192, respectively.</p>
<h3 class="h3" id="ch19lev1sec06"><span epub:type="pagebreak" id="page_386"/><strong>19.6 An Older System for Monitoring File Events: <em>dnotify</em></strong></h3>
<p class="noindentab">Linux provides another mechanism for monitoring file events. This mechanism, known as <em>dnotify</em>, has been available since kernel 2.4, but has been made obsolete by <em>inotify</em>. The <em>dnotify</em> mechanism suffers a number of limitations compared with <em>inotify</em>:</p>
<p class="bull">&#8226; The <em>dnotify</em> mechanism provides notification of events by sending signals to the application. Using signals as a notification mechanism complicates application design (<a href="ch22.xhtml#ch22lev1sec12">Section 22.12</a>). It also makes the use of <em>dnotify</em> within a library difficult, since the calling program might change the disposition of the notification signal(s). The <em>inotify</em> mechanism doesn&#8217;t use signals.</p>
<p class="bull">&#8226; The monitoring unit of <em>dnotify</em> is a directory. The application is informed when an operation is performed on any file in that directory. By contrast, <em>inotify</em> can be used to monitor directories or individual files.</p>
<p class="bull">&#8226; In order to monitor a directory, <em>dnotify</em> requires the application to open a file descriptor for that directory. The use of file descriptors causes two problems. First, because it is busy, the file system containing the directory can&#8217;t be unmounted. Second, because one file descriptor is required for each directory, an application can end up consuming a large number of file descriptors. Because <em>inotify</em> doesn&#8217;t use file descriptors, it avoids these problems.</p>
<p class="bull">&#8226; The information provided by <em>dnotify</em> about file events is less precise than that provided by <em>inotify</em>. When a file is changed inside a monitored directory, <em>dnotify</em> tells us that an event has occurred, but doesn&#8217;t tell us which file was involved in the event. The application must determine this by caching information about the directory contents. Furthermore, <em>inotify</em> provides more detailed information than <em>dnotify</em> about the type of event that has occurred.</p>
<p class="bull">&#8226; In some circumstances, <em>dnotify</em> doesn&#8217;t provide reliable notification of file events.</p>
<p class="noindentt">Further information about <em>dnotify</em> can be found under the description of the <span class="literal">F_NOTIFY</span> operation in the <em>fcntl(2)</em> manual page, and in the kernel source file <span class="literal">Documentation/dnotify.txt</span>.</p>
<h3 class="h3" id="ch19lev1sec07"><strong>19.7 Summary</strong></h3>
<p class="noindenta">The Linux-specific <em>inotify</em> mechanism allows an application to obtain notifications when events (files are opened, closed, created, deleted, modified, renamed, and so on) occur for a set of monitored files and directories. The <em>inotify</em> mechanism supersedes the older <em>dnotify</em> mechanism.</p>
<h3 class="h3" id="ch19lev1sec08"><strong>19.8 Exercise</strong></h3>
<p class="exer"><a id="ch19exe1"/><strong>19-1.</strong>&#160;&#160;&#160;Write a program that logs all file creations, deletions, and renames under the directory named in its command-line argument. The program should monitor events in all of the subdirectories under the specified directory. To obtain a list of all of these subdirectories, you will need to make use of <em>nftw()</em> (<a href="ch18.xhtml#ch18lev1sec09">Section 18.9</a>). When a new subdirectory is added under the tree or a directory is deleted, the set of monitored subdirectories should be updated accordingly.</p>
</body>
</html>
