<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="app02"><span epub:type="pagebreak" id="page_1405"/><strong><span class="big">B</span></strong><br/><strong>PARSING COMMAND-LINE OPTIONS</strong></h2>
<p class="noindenta">A typical UNIX command line has the following form:</p>
<div class="box2">
<p class="noindenta"><em>command</em> <span class="literal">[</span> <em>options</em> <span class="literal">]</span> <em>arguments</em></p>
</div>
<p class="noindent">An option takes the form of a hyphen (<span class="literal">-</span>) followed by a unique character identifying the option and a possible argument for the option. An option that takes an argument may optionally be separated from that argument by white space. Multiple options can be grouped after a single hyphen, and the last option in the group may be one that takes an argument. According to these rules, the following commands are all equivalent:</p>
<p class="programs">$ <span class="codestrong">grep -l -i -f patterns *.c</span><br/>$ <span class="codestrong">grep -lif patterns *.c</span><br/>$ <span class="codestrong">grep -lifpatterns *.c</span></p>
<p class="noindent">In the above commands, the <em>&#8211;l</em> and <em>&#8211;i</em> options don&#8217;t have an argument, while the <em>&#8211;f</em> option takes the string <em>patterns</em> as its argument.</p>
<p class="indent">Since many programs (including some of the example programs in this book) need to parse options in the above format, the facility to do so is encapsulated in a standard library function, <em>getopt()</em>.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_1406"/>#include &lt;unistd.h&gt;<br/><br/>extern int <span class="codestrong">optind</span>, <span class="codestrong">opterr</span>, <span class="codestrong">optopt</span>;<br/>extern char *<span class="codestrong">optarg</span>;<br/><br/>int <span class="codestrong">getopt</span>(int <span class="font1">argc</span>, char *const <span class="font1">argv</span>[], const char *<span class="font1">optstring</span>);</p>
<p class="right">See main text for description of return value</p>
</div>
<p class="noindent">The <em>getopt()</em> function parses the set of command-line arguments given in <em>argc</em> and <em>argv</em>, which would normally be taken from the arguments of the same name to <em>main()</em>. The <em>optstring</em> argument specifies the set of options that <em>getopt()</em> should look for in <em>argv</em>. This argument consists of a sequence of characters, each of which identifies an option. SUSv3 specifies that <em>getopt()</em> should permit at least the characters in the 62-character set <span class="literal">[a-zA-Z0-9]</span> as options. Most implementations allow other characters as well, with the exception of <span class="literal">:</span>, <span class="literal">?</span>, and <span class="literal">-</span>, which have special meaning to <em>getopt()</em>. Each option character may be followed by a colon (<span class="literal">:</span>), indicating that this option expects an argument.</p>
<p class="indent">We parse a command line by calling <em>getopt()</em> repeatedly. Each call returns information about the next unprocessed option. If an option was found, the option character is returned as the function result. If the end of the option list was reached, <em>getopt()</em> returns &#8211;1. If an option has an argument, <em>getopt()</em> sets the global variable <em>optarg</em> to point to that argument.</p>
<p class="indent">Note that the function result of <em>getopt()</em> is <em>int</em>. We must not assign the result of <em>getopt()</em> to a variable of type <em>char</em>, because the comparison of the <em>char</em> variable with &#8211;1 won&#8217;t work on systems where <em>char</em> is unsigned.</p>
<div class="block">
<p class="noindent">If an option doesn&#8217;t have an argument, then the <em>glibc getopt()</em> implementation (like most other implementations) sets <em>optarg</em> to <span class="literal">NULL</span>. However, SUSv3 doesn&#8217;t specify this behavior, so applications can&#8217;t portably rely on it (nor is it usually needed).</p>
<p class="indent">SUSv3 specifies (and <em>glibc</em> implements) a related function, <em>getsubopt()</em>, that parses option arguments that consist of one or more comma-separated strings of the form <em>name[=value]</em>. See the <em>getsubopt(3)</em> manual page for details.</p>
</div>
<p class="noindentb">On each call to <em>getopt()</em>, the global variable <em>optind</em> is updated to contain the index of the next unprocessed element of <em>argv</em>. (When multiple options are grouped in a single word, <em>getopt()</em> does some internal bookkeeping to keep track of which part of the word is next to be processed.) The <em>optind</em> variable is automatically set to 1 before the first call to <em>getopt()</em>. There are two circumstances where we may make use of this variable:</p>
<p class="bull">&#8226; If <em>getopt()</em> returns &#8211;1, indicating that no more options are present and <em>optind</em> is less than <em>argc</em>, then <em>argv[optind]</em> is the location of the next nonoption word from the command line.</p>
<p class="bull">&#8226; If we are processing multiple command-line vectors or rescanning the same command line, then we must explicitly reset <em>optind</em> to 1.</p>
<p class="noindenttb"><span epub:type="pagebreak" id="page_1407"/>The <em>getopt()</em> function returns &#8211;1, indicating the end of the option list, in the following circumstances:</p>
<p class="bull">&#8226; The end of the list described by <em>argc</em> plus <em>argv</em> was reached (i.e., <em>argv[optind]</em> is <span class="literal">NULL</span>).</p>
<p class="bull">&#8226; The next unprocessed word in <em>argv</em> does not start with an option delimiter (i.e., <em>argv[optind][0]</em> is not a hyphen).</p>
<p class="bull">&#8226; The next unprocessed word in <em>argv</em> consists of a single hyphen (i.e., <em>argv[optind]</em> is <span class="literal">-</span>). Some commands understand such a word as an argument with a special meaning, as described in <a href="ch05.xhtml#ch05lev1sec11">Section 5.11</a>.</p>
<p class="bull">&#8226; The next unprocessed word in <em>argv</em> consists of two hyphens (<span class="literal">--</span>). In this case, <em>getopt()</em> silently consumes the two hyphens and <em>optind</em> is adjusted to point to the next word after the double hyphen. This syntax enables a user to indicate the end of the options of a command, even when the next word on the command line (after the double hyphen) looks like an option (i.e., starts with a hyphen). For example, if we want to use <em>grep</em> to search for the string <em>&#8211;k</em> inside a file, then we would write <em>grep &#8211;&#8211; &#8211;k myfile</em>.</p>
<p class="noindenttb">Two kinds of errors may occur as <em>getopt()</em> processes an option list. One error arises when an option that is not specified in <em>optstring</em> is encountered. The other error occurs when an argument is not supplied to an option that expects one (i.e., the option appears at the end of the command line). The rules about how <em>getopt()</em> handles and reports these errors are as follows:</p>
<p class="bull">&#8226; By default, <em>getopt()</em> prints an appropriate error message on standard error and returns the character <span class="literal">?</span> as its function result. In this case, the global variable <em>optopt</em> returns the erroneous option character (i.e., the one that is unrecognized or whose argument is missing).</p>
<p class="bull">&#8226; The global variable <em>opterr</em> can be used to suppress the error messages printed by <em>getopt()</em>. By default, this variable is set to 1. If we set it to 0, then <em>getopt()</em> doesn&#8217;t print error messages, but otherwise behaves as described in the preceding point. The program can detect the error via the <span class="literal">?</span> function result and display a customized error message.</p>
<p class="bull">&#8226; Alternatively, we may suppress error messages by specifying a colon (<span class="literal">:</span>) as the first character in <em>optstring</em> (doing so overrides the effect of setting <em>opterr</em> to 0). In this case, an error is reported as with setting <em>opterr</em> to 0, except that an option with a missing argument is reported by returning <span class="literal">:</span> as the function result. This difference in return values allows us to distinguish the two types of errors (unrecognized option and missing option argument), if we need to do so.</p>
<p class="noindentt">The above error-reporting alternatives are summarized in <a href="app02.xhtml#app02table1">Table B-1</a>.</p>
<p class="tablecap"><a id="app02table1"/><strong>Table B-1:</strong> <em>getopt()</em> error-reporting behavior</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Error-reporting method</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><em>getopt()</em> displays error message?</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Return for unrecognized option</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Return for missing argument</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">default (<em>opterr == 1</em>)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">Y</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">?</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec"><span class="literal">?</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>opterr == 0</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">N</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">?</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec"><span class="literal">?</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">:</span> at start of <em>optstring</em></p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec">N</p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec"><span class="literal">?</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="tablec"><span class="literal">:</span></p></td>
</tr>
</tbody>
</table>
<h3 class="h3a" id="app02lev1sec01"><span epub:type="pagebreak" id="page_1408"/><strong>Example program</strong></h3>
<p class="noindenta"><a href="app02.xhtml#app02ex1">Listing B-1</a> demonstrates the use of <em>getopt()</em> to parse the command line for two options: the <em>&#8211;x</em> option, which doesn&#8217;t expect an argument, and the <em>&#8211;p</em> option which does expect an argument. This program suppresses error messages from <em>getopt()</em> by specifying a colon (<span class="literal">:</span>) as the first character in <em>optstring</em>.</p>
<p class="indent">To allow us to observe the operation of <em>getopt()</em>, we include some <em>printf()</em> calls to display the information returned by each <em>getopt()</em> call. On completion, the program prints some summary information about the specified options and also displays the next nonoption word on the command line, if there is one. The following shell session log shows the results when we run this program with different command-line arguments:</p>
<p class="programs">$ <span class="codestrong">./t_getopt -x -p hello world</span><br/>opt =120 (x); optind = 2<br/>opt =112 (p); optind = 4<br/>-x was specified (count=1)<br/>-p was specified with the value "hello"<br/>First nonoption argument is "world" at argv[4]<br/>$ <span class="codestrong">./t_getopt -p</span><br/>opt = 58 (:); optind = 2; optopt =112 (p)<br/>Missing argument (-p)<br/>Usage: ./t_getopt [-p arg] [-x]<br/>$ <span class="codestrong">./t_getopt -a</span><br/>opt = 63 (?); optind = 2; optopt = 97 (a)<br/>Unrecognized option (-a)<br/>Usage: ./t_getopt [-p arg] [-x]<br/>$ <span class="codestrong">./t_getopt -p str -- -x</span><br/>opt =112 (p); optind = 3<br/>-p was specified with the value "str"<br/>First nonoption argument is "-x" at argv[4]<br/>$ <span class="codestrong">./t_getopt -p -x</span><br/>opt =112 (p); optind = 3<br/>-p was specified with the value "-x"</p>
<p class="noindent">Note that in the last example above, the string <em>&#8211;x</em> was interpreted as an argument to the <em>&#8211;p</em> option, rather than as an option.</p>
<p class="examplet"><a id="app02ex1"/><strong>Listing B-1:</strong> Using <em>getopt()</em></p>
<p class="programsli">________________________________________________________ <span class="codestrong">getopt/t_getopt.c</span><br/><br/>#include &lt;ctype.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>#define printable(ch) (isprint((unsigned char) ch) ? ch : '#')<br/><br/>static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Print "usage" message and exit */<br/>usageError(char *progName, char *msg, int opt)<br/>{<br/>&#160;&#160;&#160;&#160;if (msg != NULL &#38;&#38; opt != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(stderr, "%s (-%c)\n", msg, printable(opt));<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "Usage: %s [-p arg] [-x]\n", progName);<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}<br/><br/><span epub:type="pagebreak" id="page_1409"/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int opt, xfnd;<br/>&#160;&#160;&#160;&#160;char *pstr;<br/><br/>&#160;&#160;&#160;&#160;xfnd = 0;<br/>&#160;&#160;&#160;&#160;pstr = NULL;<br/><br/>&#160;&#160;&#160;&#160;while ((opt = getopt(argc, argv, ":p:x")) != -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("opt =%3d (%c); optind = %d", opt, printable(opt), optind);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (opt == '?' || opt == ':')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("; optopt =%3d (%c)", optopt, printable(optopt));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("\n");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (opt) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'p': pstr = optarg;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'x': xfnd++;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case ':': usageError(argv[0], "Missing argument", optopt);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case '?': usageError(argv[0], "Unrecognized option", optopt);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default: fatal("Unexpected case in switch()");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (xfnd != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("-x was specified (count=%d)\n", xfnd);<br/>&#160;&#160;&#160;&#160;if (pstr != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("-p was specified with the value \"%s\"\n", pstr);<br/>&#160;&#160;&#160;&#160;if (optind &lt; argc)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("First nonoption argument is \"%s\" at argv[%d]\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;argv[optind], optind);<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>________________________________________________________ <span class="codestrong">getopt/t_getopt.c</span></p>
<h3 class="h3a" id="app02lev1sec02"><strong>GNU-specific behavior</strong></h3>
<p class="noindenta">By default, the <em>glibc</em> implementation of <em>getopt()</em> implements a nonstandard feature: it allows options and nonoptions to be intermingled. Thus, for example, the following are equivalent:</p>
<p class="programs">$ <span class="codestrong">ls -l file</span><br/>$ <span class="codestrong">ls file -l</span></p>
<p class="noindent">In processing command lines of the second form, <em>getopt()</em> permutes the contents of <em>argv</em> so that all options are moved to the beginning of the array and all nonoptions are moved to the end of the array. (If <em>argv</em> contains an element pointing to the word <span class="literal">--</span>, then only the elements preceding that element are subject to permutation and interpretation as options.) In other words, the <span class="literal">const</span> declaration of <em>argv</em> in the <em>getopt()</em> prototype shown earlier is not actually true for <em>glibc</em>.</p>
<p class="indentb">Permuting the contents of <em>argv</em> is not permitted by SUSv3 (or SUSv4). We can force <em>getopt()</em> to provide standards-conformant behavior (i.e., to follow the rules <span epub:type="pagebreak" id="page_1410"/>listed earlier for determining the end of the option list) by setting the environment variable <span class="literal">POSIXLY_CORRECT</span> to any value. This can be done in two ways:</p>
<p class="bull">&#8226; From within the program, we can call <em>putenv()</em> or <em>setenv()</em>. This has the advantage that the user is not required to do anything. It has the disadvantages that it requires modifications of the program source code and that it changes the behavior of only that program.</p>
<p class="bull">&#8226; We can define the variable from the shell before we execute the program:</p>
<p class="programsbl">$ <span class="codestrong">export POSIXLY_CORRECT=y</span></p>
<p class="bullp">This method has the advantage that it affects all programs that use <em>getopt()</em>. However, it also has some disadvantages. <span class="literal">POSIXLY_CORRECT</span> causes other changes in the behavior of various Linux tools. Furthermore, setting this variable requires explicit user intervention (most likely by setting the variable in a shell startup file).</p>
<p class="noindentt">An alternative method of preventing <em>getopt()</em> from permuting command-line arguments is to make the first character of <em>optstring</em> a plus sign (<span class="literal">+</span>). (If we want to also suppress <em>getopt()</em> error messages as described above, then the first two characters of <em>optstring</em> should be <span class="literal">+:</span>, in that order.) As with the use of <em>putenv()</em> or <em>setenv()</em>, this approach has the disadvantage that it requires changes to the program code. See the <em>getopt(3)</em> manual page for further details.</p>
<div class="block">
<p class="noindent">A future technical corrigendum of SUSv4 is likely to add a specification for the use of the plus sign in <em>optstring</em> to prevent permutation of command-line arguments.</p>
</div>
<p class="noindent">Note that the <em>glibc getopt()</em> permuting behavior affects how we write shell scripts. (This affects developers porting shell scripts from other systems to Linux.) Suppose we have a shell script that performs the following command on all of the files in a directory:</p>
<p class="programs">chmod 644 *</p>
<p class="noindent">If one of these filenames starts with a hyphen, then the <em>glibc getopt()</em> permuting behavior would cause that filename to be interpreted as an option to <em>chmod</em>. This would not happen on other UNIX implementations, where the occurrence of the first nonoption (<span class="literal">644</span>) ensures that <em>getopt()</em> ceases looking for options in the remainder of the command line. For most commands, (if we don&#8217;t set <span class="literal">POSIXLY_CORRECT</span>, then) the way of dealing with this possibility in shell scripts that must run on Linux is to place the string <span class="literal">--</span> before the first nonoption argument. Thus, we would rewrite the above line as follows:</p>
<p class="programs">chmod -- 644 *</p>
<p class="noindent">In this particular example, which employs filename generation, we could alternatively write this:</p>
<p class="programs">chmod 644 ./*</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1411"/>Although we have used the example of filename pattern matching (globbing) above, similar scenarios can also occur as a result of other shell processing (e.g., command substitution and parameter expansion), and they can be dealt with similarly, by using a <span class="literal">--</span> string to separate options from arguments.</p>
<h3 class="h3a" id="app02lev1sec03"><strong>GNU extensions</strong></h3>
<p class="noindentab">The GNU C library provides a number of extensions to <em>getopt()</em>. We briefly note the following:</p>
<p class="bull">&#8226; The SUSv3 specification permits options to have only mandatory arguments. In the GNU version of <em>getopt()</em>, we can place two colons after an option character in <em>optstring</em> to indicate that its argument is optional. The argument to such an option must appear in the same word as the option itself (i.e., no spaces may appear between the option and its argument). If the argument is not present, then, on return from <em>getopt()</em>, <em>optarg</em> is set to <span class="literal">NULL</span>.</p>
<p class="bull">&#8226; Many GNU commands allow a form of long option syntax. A long option begins with two hyphens, and the option itself is identified using a word, rather than a single character, as in the following example:</p>
<p class="programsbl">$ <span class="codestrong">gcc --version</span></p>
<p class="bullp">The <em>glibc</em> function <em>getopt_long()</em> can be used to parse such options.</p>
<p class="bull">&#8226; The GNU C library provides an even more sophisticated (but nonportable) API for parsing the command-line, called <em>argp</em>. This API is described in the <em>glibc</em> manual.<span epub:type="pagebreak" id="page_1412"/></p>
</body>
</html>
