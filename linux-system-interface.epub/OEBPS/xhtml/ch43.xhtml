<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch43"><span epub:type="pagebreak" id="page_877"/><strong><span class="big">43</span></strong><br/><strong>INTERPROCESS COMMUNICATION OVERVIEW</strong></h2>
<p class="noindenta">This chapter presents a brief overview of the facilities that processes and threads can use to communicate with one another and to synchronize their actions. The following chapters provide more details about these facilities.</p>
<h3 class="h3" id="ch43lev1sec01"><strong>43.1 A Taxonomy of IPC Facilities</strong></h3>
<p class="noindentab"><a href="ch43.xhtml#ch43fig1">Figure 43-1</a> summarizes the rich variety of UNIX communication and synchronization facilities, dividing them into three broad functional categories:</p>
<p class="bull">&#8226; <em>Communication</em>: These facilities are concerned with exchanging data between processes.</p>
<p class="bull">&#8226; <em>Synchronization</em>: These facilities are concerned with synchronizing the actions of processes or threads.</p>
<p class="bull">&#8226; <em>Signals</em>: Although signals are intended primarily for other purposes, they can be used as a synchronization technique in certain circumstances. More rarely, signals can be used as a communication technique: the signal number itself is a form of information, and realtime signals can be accompanied by associated data (an integer or a pointer). Signals are described in detail in <a href="ch20.xhtml#ch20">Chapters 20</a> to <a href="ch22.xhtml#ch22">22</a>.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_878"/>Although some of these facilities are concerned with synchronization, the general term <em>interprocess communication</em> (IPC) is often used to describe them all.</p>
<div class="image"><img src="../images/f43-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch43fig1"/><strong>Figure 43-1:</strong> A taxonomy of UNIX IPC facilities</p>
<p class="noindentb">As <a href="ch43.xhtml#ch43fig1">Figure 43-1</a> illustrates, often several facilities provide similar IPC functionality. There are a couple of reasons for this:</p>
<p class="bull">&#8226; Similar facilities evolved on different UNIX variants, and later came to be ported to other UNIX systems. For example, FIFOs were developed on System V, while (stream) sockets were developed on BSD.</p>
<p class="bull">&#8226; New facilities have been developed to address design deficiencies in similar earlier facilities. For example, the POSIX IPC facilities (message queues, semaphores, and shared memory) were designed as an improvement on the older System V IPC facilities.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_879"/>In some cases, facilities that are grouped together in <a href="ch43.xhtml#ch43fig1">Figure 43-1</a> actually provide significantly different functionality. For example, stream sockets can be used to communicate over a network, while FIFOs can be used only for communication between processes on the same machine.</p>
<h3 class="h3" id="ch43lev1sec02"><strong>43.2 Communication Facilities</strong></h3>
<p class="noindenta">The various communication facilities shown in <a href="ch43.xhtml#ch43fig1">Figure 43-1</a> allow processes to exchange data with one another. (These facilities can also be used to exchange data between the threads of a single process, but this is seldom necessary, since threads can exchange information via shared global variables.)</p>
<p class="indentb">We can break the communication facilities into two categories:</p>
<p class="bull">&#8226; <em>Data-transfer facilities</em>: The key factor distinguishing these facilities is the notion of writing and reading. In order to communicate, one process writes data to the IPC facility, and another process reads the data. These facilities require two data transfers between user memory and kernel memory: one transfer from user memory to kernel memory during writing, and another transfer from kernel memory to user memory during reading. (<a href="ch43.xhtml#ch43fig2">Figure 43-2</a> shows this situation for a pipe.)</p>
<p class="bull">&#8226; <em>Shared memory</em>: Shared memory allows processes to exchange information by placing it in a region of memory that is shared between the processes. (The kernel accomplishes this by making page-table entries in each process point to the same pages of RAM, as shown in <a href="ch49.xhtml#ch49fig2">Figure 49-2</a>, on <a href="ch49.xhtml#page_1026">page 1026</a>.) A process can make data available to other processes by placing it in the shared memory region. Because communication doesn&#8217;t require system calls or data transfer between user memory and kernel memory, shared memory can provide very fast communication.</p>
<div class="image"><img src="../images/f43-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch43fig2"/><strong>Figure 43-2:</strong> Exchanging data between two processes using a pipe</p>
<h5 class="h5" id="ch43lev3sec01"><strong>Data transfer</strong></h5>
<p class="noindentab">We can further break data-transfer facilities into the following subcategories:</p>
<p class="bull">&#8226; <em>Byte stream</em>: The data exchanged via pipes, FIFOs, and stream sockets is an undelimited byte stream. Each read operation may read an arbitrary number of bytes from the IPC facility, regardless of the size of blocks written by the writer. This model mirrors the traditional UNIX &#8220;file as a sequence of bytes&#8221; model.</p>
<p class="bull"><span epub:type="pagebreak" id="page_880"/>&#8226; <em>Message</em>: The data exchanged via System V message queues, POSIX message queues, and datagram sockets takes the form of delimited messages. Each read operation reads a whole message, as written by the writer process. It is not possible to read part of a message, leaving the remainder on the IPC facility; nor is it possible to read multiple messages in a single read operation.</p>
<p class="bull">&#8226; <em>Pseudoterminals</em>: A pseudoterminal is a communication facility intended for use in specialized situations. We provide details in <a href="ch64.xhtml#ch64">Chapter 64</a>.</p>
<p class="noindenttb">A few general features distinguish data-transfer facilities from shared memory:</p>
<p class="bull">&#8226; Although a data-transfer facility may have multiple readers, reads are destructive. A read operation consumes data, and that data is not available to any other process.</p>
<div class="block1">
<p class="noindent">The <span class="literal">MSG_PEEK</span> flag can be used to perform a nondestructive read from a socket (<a href="ch61.xhtml#ch61lev1sec03">Section 61.3</a>). UDP (Internet domain datagram) sockets allow a single message to be broadcast or multicast to multiple recipients (<a href="ch61.xhtml#ch61lev1sec12">Section 61.12</a>).</p>
</div>
<p class="bull">&#8226; Synchronization between the reader and writer processes is automatic. If a reader attempts to fetch data from a data-transfer facility that currently has no data, then (by default) the read operation will block until some process writes data to the facility.</p>
<h5 class="h5" id="ch43lev3sec02"><strong>Shared memory</strong></h5>
<p class="noindenta">Most modern UNIX systems provide three flavors of shared memory: System V shared memory, POSIX shared memory, and memory mappings. We consider the differences between them when describing the facilities in later chapters (see <a href="ch54.xhtml#ch54lev1sec05">Section 54.5</a> in particular).</p>
<p class="indentb">Note the following general points about shared memory:</p>
<p class="bull">&#8226; Although shared memory provides fast communication, this speed advantage is offset by the need to synchronize operations on the shared memory. For example, one process should not attempt to access a data structure in the shared memory while another process is updating it. A semaphore is the usual synchronization method used with shared memory.</p>
<p class="bull">&#8226; Data placed in shared memory is visible to all of the processes that share that memory. (This contrasts with the destructive read semantics described above for data-transfer facilities.)</p>
<h3 class="h3" id="ch43lev1sec03"><strong>43.3 Synchronization Facilities</strong></h3>
<p class="noindenta">The synchronization facilities shown in <a href="ch43.xhtml#ch43fig1">Figure 43-1</a> allow processes to coordinate their actions. Synchronization allows processes to avoid doing things such as simultaneously updating a shared memory region or the same part of a file. Without synchronization, such simultaneous updates could cause an application to produce incorrect results.</p>
<p class="noindentb"><span epub:type="pagebreak" id="page_881"/>UNIX systems provide the following synchronization facilities:</p>
<p class="bull">&#8226; <em>Semaphores</em>: A semaphore is a kernel-maintained integer whose value is never permitted to fall below 0. A process can decrease or increase the value of a semaphore. If an attempt is made to decrease the value of the semaphore below 0, then the kernel blocks the operation until the semaphore&#8217;s value increases to a level that permits the operation to be performed. (Alternatively, the process can request a nonblocking operation; then, instead of blocking, the kernel causes the operation to return immediately with an error indicating that the operation can&#8217;t be performed immediately.) The meaning of a semaphore is determined by the application. A process decrements a semaphore (from, say, 1 to 0) in order to reserve exclusive access to some shared resource, and after completing work on the resource, increments the semaphore so that the shared resource is released for use by some other process. The use of a binary semaphore&#8212;a semaphore whose value is limited to 0 or 1&#8212;is common. However, an application that deals with multiple instances of a shared resource would employ a semaphore whose maximum value equals the number of shared resources. Linux provides both System V semaphores and POSIX semaphores, which have essentially similar functionality.</p>
<p class="bull">&#8226; <em>File locks</em>: File locks are a synchronization method explicitly designed to coordinate the actions of multiple processes operating on the same file. They can also be used to coordinate access to other shared resources. File locks come in two flavors: read (shared) locks and write (exclusive) locks. Any number of processes can hold a read lock on the same file (or region of a file). However, when one process holds a write lock on a file (or file region), other processes are prevented from holding either read or write locks on that file (or file region). Linux provides file-locking facilities via the <em>flock()</em> and <em>fcntl()</em> system calls. The <em>flock()</em> system call provides a simple locking mechanism, allowing processes to place a shared or an exclusive lock on an entire file. Because of its limited functionality, <em>flock()</em> locking facility is rarely used nowadays. The <em>fcntl()</em> system call provides record locking, allowing processes to place multiple read and write locks on different regions of the same file.</p>
<p class="bull">&#8226; <em>Mutexes and condition variables</em>: These synchronization facilities are normally used with POSIX threads, as described in <a href="ch30.xhtml#ch30">Chapter 30</a>.</p>
<div class="block">
<p class="noindent">Some UNIX implementations, including Linux systems with a <em>glibc</em> that provides the NPTL threading implementation, also allow mutexes and condition variables to be shared between processes. SUSv3 permits, but doesn&#8217;t require, an implementation to support process-shared mutexes and condition variables. They are not available on all UNIX systems, and so are not commonly employed for process synchronization.</p>
</div>
<p class="noindent">When performing interprocess synchronization, our choice of facility is typically determined by the functional requirements. When coordinating access to a file, file record locking is usually the best choice. Semaphores are often the better choice for coordinating access to other types of shared resource.</p>
<p class="indent">Communication facilities can also be used for synchronization. For example, in <a href="ch44.xhtml#ch44lev1sec03">Section 44.3</a>, we show how a pipe can be used to synchronize the actions of a parent process with its children. More generally, any of the data-transfer facilities can be <span epub:type="pagebreak" id="page_882"/>used for synchronization, with the synchronization operation taking the form of exchanging messages via the facility.</p>
<div class="block">
<p class="noindent">Since kernel 2.6.22, Linux provides an additional, nonstandard synchronization mechanism via the <em>eventfd()</em> system call. This system call creates an <em>eventfd</em> object that has an associated 8-byte unsigned integer maintained by the kernel. The system call returns a file descriptor that refers to the object. Writing an integer to this file descriptor adds that integer to the object&#8217;s value. A <em>read()</em> from the file descriptor blocks if the object&#8217;s value is 0. If the object has a nonzero value, a <em>read()</em> returns that value and resets it to 0. In addition, <em>poll()</em>, <em>select()</em>, or <em>epoll</em> can be used to test if the object has a nonzero value; if it does, the file descriptor indicates as being readable. An application that wishes to use an <em>eventfd</em> object for synchronization must first create the object using <em>eventfd()</em>, and then call <em>fork()</em> to create related processes that inherit file descriptors referring to the object. For further details, see the <em>eventfd(2)</em> manual page.</p>
</div>
<h3 class="h3" id="ch43lev1sec04"><strong>43.4 Comparing IPC Facilities</strong></h3>
<p class="noindenta">When it comes to IPC, we face a range of choices that can at first seem bewildering. In later chapters that describe each IPC facility, we include sections that compare each facility against other similar facilities. In the following pages, we consider a number of general points that may determine the choice of IPC facility.</p>
<h5 class="h5" id="ch43lev3sec03"><strong>IPC object identification and handles for open objects</strong></h5>
<p class="noindenta">In order to access an IPC object, a process must have some means of identifying the object, and once the object has been &#8220;opened,&#8221; the process must use some type of handle to refer to the open object. <a href="ch43.xhtml#ch43table1">Table 43-1</a> summarizes these properties for the various types of IPC facilities.</p>
<p class="tablecap"><a id="ch43table1"/><strong>Table 43-1:</strong> Identifiers and handles for various types of IPC facilities</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Facility type</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Name used to identify object</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Handle used to refer to object in programs</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Pipe</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">no name</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">file descriptor</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">FIFO</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">pathname</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">file descriptor</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">UNIX domain socket</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">pathname</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">file descriptor</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">Internet domain socket</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">IP address + port number</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">file descriptor</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">System V message queue</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">System V IPC key</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">System V IPC identifier</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">System V semaphore</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">System V IPC key</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">System V IPC identifier</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">System V shared memory</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">System V IPC key</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">System V IPC identifier</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">POSIX message queue</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">POSIX IPC pathname</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>mqd_t</em> (message queue descriptor)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">POSIX named semaphore</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">POSIX IPC pathname</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>sem_t *</em> (semaphore pointer)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">POSIX unnamed semaphore</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">no name</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>sem_t *</em> (semaphore pointer)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">POSIX shared memory</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">POSIX IPC pathname</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">file descriptor</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Anonymous mapping</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">no name</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">none</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">Memory-mapped file</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">pathname</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">file descriptor</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>flock()</em> lock</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">pathname</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">file descriptor</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><em>fcntl()</em> lock</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">pathname</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">file descriptor</p></td>
</tr>
</tbody>
</table>
<h5 class="h5" id="ch43lev3sec04"><span epub:type="pagebreak" id="page_883"/><strong>Functionality</strong></h5>
<p class="noindentab">There are functional differences between the various IPC facilities that can be relevant in determining which facility to use. We begin by summarizing the differences between data-transfer facilities and shared memory:</p>
<p class="bull">&#8226; Data-transfer facilities involve read and write operations, with transferred data being consumable by just one reader process. Flow control between writer and reader, as well as synchronization (so that a reader is blocked when trying to read data from a facility that is currently empty) is automatically handled by the kernel. This model fits well with many application designs.</p>
<p class="bull">&#8226; Other application designs more naturally suit a shared-memory model. Shared memory allows one process to make data visible to any number of other processes sharing the same memory region. Communication &#8220;operations&#8221; are simple&#8212;a process can access data in shared memory in the same manner as it accesses any other memory in its virtual address space. On the other hand, the need to handle synchronization (and perhaps flow control) can add to the complexity of a shared-memory design. This model fits well with application designs that need to maintain shared state (e.g., a shared data structure).</p>
<p class="noindenttb">With respect to the various data-transfer facilities, the following points are worth noting:</p>
<p class="bull">&#8226; Some data-transfer facilities transfer data as a byte stream (pipes, FIFOs, and stream sockets); others are message-oriented (message queues and datagram sockets). Which approach is preferable depends on the application. (An application can also impose a message-oriented model on a byte-stream facility, by using delimiter characters, fixed-length messages, or message headers that encode the length of the total message; see <a href="ch44.xhtml#ch44lev1sec08">Section 44.8</a>.)</p>
<p class="bull">&#8226; A distinctive feature of System V and POSIX message queues, compared with other data-transfer facilities, is the ability to assign a numeric type or priority to a message, so that messages can be delivered in a different order from that in which they were sent.</p>
<p class="bull">&#8226; Pipes, FIFOs, and sockets are implemented using file descriptors. These IPC facilities all support a range of alternative I/O models that we describe in <a href="ch63.xhtml#ch63">Chapter 63</a>: I/O multiplexing (the <em>select()</em> and <em>poll()</em> system calls), signal-driven I/O, and the Linux-specific <em>epoll</em> API. The primary benefit of these techniques is that they allow an application to simultaneously monitor multiple file descriptors to see whether I/O is possible on any of them. By contrast, System V message queues don&#8217;t employ file descriptors and don&#8217;t support these techniques.</p>
<div class="block1">
<p class="noindent">On Linux, POSIX message queues are also implemented using file descriptors and support the alternative I/O techniques described above. However, this behavior is not specified in SUSv3, and is not supported on most other implementations.</p>
</div>
<p class="bull">&#8226; POSIX message queues provide a notification facility that can send a signal to a process, or instantiate a new thread, when a message arrives on a previously empty queue.</p>
<p class="bull"><span epub:type="pagebreak" id="page_884"/>&#8226; UNIX domain sockets provide a feature that allows a file descriptor to be passed from one process to another. This allows one process to open a file and make it available to another process that otherwise might not be able to access the file. We briefly describe this feature in <a href="ch61.xhtml#ch61lev2sec10">Section 61.13.3</a>.</p>
<p class="bull">&#8226; UDP (Internet domain datagram) sockets allow a sender to broadcast or multicast a message to multiple recipients. We briefly describe this feature in <a href="ch61.xhtml#ch61lev1sec12">Section 61.12</a>.</p>
<p class="noindenttb">With respect to process-synchronization facilities, the following points are worth noting:</p>
<p class="bull">&#8226; Record locks placed using <em>fcntl()</em> are considered to be owned by the process placing the lock. The kernel uses this ownership property to detect deadlocks (situations where two or more processes are holding locks that block each other&#8217;s further lock requests). If a deadlock situation occurs, the kernel denies the lock request of one of the processes, returning an error from the <em>fcntl()</em> call to indicate that a deadlock occurred. System V and POSIX semaphores don&#8217;t have an ownership property; no deadlock detection occurs for semaphores.</p>
<p class="bull">&#8226; Record locks placed using <em>fcntl()</em> are automatically released when the process that owns the locks terminates. System V semaphores provide a similar feature in the form of an &#8220;undo&#8221; feature, but this feature is not reliable in all circumstances (<a href="ch47.xhtml#ch47lev1sec08">Section 47.8</a>). POSIX semaphores don&#8217;t provide an analog of this feature.</p>
<h5 class="h5" id="ch43lev3sec05"><strong>Network communication</strong></h5>
<p class="noindenta">Of all of the IPC methods shown in <a href="ch43.xhtml#ch43fig1">Figure 43-1</a>, only sockets permit processes to communicate over a network. Sockets are generally used in one of two domains: the UNIX domain, which allows communication between processes on the same system, and the <em>Internet</em> domain, which allows communication between processes on different hosts connected via a TCP/IP network. Often, only minor changes are required to convert a program that uses UNIX domain sockets into one that uses Internet domain sockets, so an application that is built using UNIX domain sockets can be made network-capable with relatively little effort.</p>
<h5 class="h5" id="ch43lev3sec06"><strong>Portability</strong></h5>
<p class="noindenta">Modern UNIX implementations support most of the IPC facilities shown in <a href="ch43.xhtml#ch43fig1">Figure 43-1</a>. However, the POSIX IPC facilities (message queues, semaphores, and shared memory) are not quite as widely available as their System V IPC counterparts, especially on older UNIX systems. (An implementation of POSIX message queues and full support for POSIX semaphores have appeared on Linux only in the 2.6.<em>x</em> kernel series.) Therefore, from a portability point of view, System V IPC may be preferable to POSIX IPC.</p>
<h5 class="h5" id="ch43lev3sec07"><strong>System V IPC design issues</strong></h5>
<p class="noindentab">The System V IPC facilities were designed independently of the traditional UNIX I/O model, and consequently suffer a few peculiarities that make their programming <span epub:type="pagebreak" id="page_885"/>interfaces more complicated to use. The corresponding POSIX IPC facilities were designed to address these problems. The following points are of particular note:</p>
<p class="bull">&#8226; The System V IPC facilities are connectionless. These facilities provide no notion of a handle (like a file descriptor) referring to an open IPC object. In later chapters, we&#8217;ll sometimes talk of &#8220;opening&#8221; a System V IPC object, but this is really just shorthand to describe the process of obtaining an identifer that refers to the object. The kernel does not record the process as having &#8220;opened&#8221; the object (unlike other types of IPC objects). This means that the kernel can&#8217;t maintain a reference count of the number of processes that are currently using an object. Consequently, it can require additional programming effort for an application to be able to know when an object can safely be deleted.</p>
<p class="bull">&#8226; The programming interfaces for the System V IPC facilities are inconsistent with the traditional UNIX I/O model (they use integer key values and IPC identifiers instead of pathnames and file descriptors). The programming interfaces are also overly complex. This last point applies particularly to System V semaphores (refer to <a href="ch47.xhtml#ch47lev1sec11">Sections 47.11</a> and <a href="ch53.xhtml#ch53lev1sec05">53.5</a>).</p>
<p class="noindentt">By contrast, the kernel counts open references for POSIX IPC objects. This simplifies decisions about when an object can be deleted. Furthermore, the POSIX IPC facilities provide an interface that is simpler and more consistent with the traditional UNIX model.</p>
<h5 class="h5" id="ch43lev3sec08"><strong>Accessibility</strong></h5>
<p class="noindentab">The second column of <a href="ch43.xhtml#ch43table2">Table 43-2</a> summarizes an important characteristic of each type of IPC object: the permissions scheme that governs which processes can access the object. The following list adds some details on the various schemes:</p>
<p class="bull">&#8226; For some IPC facilities (e.g., FIFOs and sockets), object names live in the file system, and accessibility is determined according to the associated file permissions mask, which specifies permissions for owner, group, and other (<a href="ch15.xhtml#ch15lev1sec04">Section 15.4</a>). Although System V IPC objects don&#8217;t reside in the file system, each object has an associated permissions mask whose semantics are similar to those for files.</p>
<p class="bull">&#8226; A few IPC facilities (pipes, anonymous memory mappings) are marked as being accessible only by related processes. Here, <em>related</em> means related via <em>fork()</em>. In order for two processes to access the object, one of them must create the object and then call <em>fork()</em>. As a consequence of the <em>fork()</em>, the child process inherits a handle referring to the object, allowing both processes to share the object.</p>
<p class="bull">&#8226; The accessibility of a POSIX unnamed semaphore is determined by the accessibility of the shared memory region containing the semaphore.</p>
<p class="bull">&#8226; In order to place a lock on a file, a process must have a file descriptor referring to the file (i.e., in practice, it must have permission to open the file).</p>
<p class="bull">&#8226; There are no restrictions on accessing (i.e., connecting or sending a datagram to) an Internet domain socket. If necessary, access control must be implemented within the application.</p>
<p class="tablecap"><span epub:type="pagebreak" id="page_886"/><a id="ch43table2"/><strong>Table 43-2:</strong> Accessibility and persistence for various types of IPC facilities</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Facility type</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Accessibility</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Persistence</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Pipe</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">only by related processes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">process</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">FIFO</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">permissions mask</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">process</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">UNIX domain socket</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">permissions mask</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">process</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">Internet domain socket</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">by any process</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">process</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">System V message queue</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">permissions mask</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">kernel</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">System V semaphore</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">permissions mask</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">kernel</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">System V shared memory</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">permissions mask</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">kernel</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">POSIX message queue</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">permissions mask</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">kernel</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">POSIX named semaphore</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">permissions mask</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">kernel</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">POSIX unnamed semaphore</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">permissions of underlying memory</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">depends</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">POSIX shared memory</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">permissions mask</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">kernel</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Anonymous mapping</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">only by related processes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">process</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">Memory-mapped file</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">permissions mask</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">file system</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>flock()</em> file lock</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>open()</em> of file</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">process</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><em>fcntl()</em> file lock</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><em>open()</em> of file</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">process</p></td>
</tr>
</tbody>
</table>
<h5 class="h5" id="ch43lev3sec09"><strong>Persistence</strong></h5>
<p class="noindentab">The term <em>persistence</em> refers to the lifetime of an IPC object. (Refer to the third column of <a href="ch43.xhtml#ch43table2">Table 43-2</a>.) We can distinguish three types of persistence:</p>
<p class="bull">&#8226; <em>Process persistence</em>: A process-persistent IPC object remains in existence only as long as it is held open by at least one process. If the object is closed by all processes, then all kernel resources associated with the object are freed, and any unread data is destroyed. Pipes, FIFOs, and sockets are examples of IPC facilities with process persistence.</p>
<div class="block1">
<p class="noindent">The persistence of a FIFO&#8217;s data is not the same as the persistence of its name. A FIFO has a name in the file system that persists even after all file descriptors referring to the FIFO have been closed.</p>
</div>
<p class="bull">&#8226; <em>Kernel persistence</em>: A kernel-persistent IPC object exists until either it is explicitly deleted or the system is shut down. The lifetime of the object is independent of whether any process holds the object open. This means that, for example, one process can create an object, write data to it, and then close it (or terminate). At a later point, another process can open the object and read the data. Examples of facilities with kernel persistence are System V IPC and POSIX IPC. We exploit this property in the example programs that we present when describing these facilities in later chapters: for each facility, we implement separate programs that create an object, delete an object, and perform communication or synchronization.</p>
<p class="bull">&#8226; <em>File-system persistence</em>: An IPC object with file-system persistence retains its information even when the system is rebooted. The object exists until it is explicitly deleted. The only type of IPC object that demonstrates file-system persistence is shared memory based on a memory-mapped file.</p>
<h5 class="h5" id="ch43lev3sec10"><span epub:type="pagebreak" id="page_887"/><strong>Performance</strong></h5>
<p class="noindentab">In some circumstances, different IPC facilities may show notable differences in performance. However, in later chapters, we generally refrain from making performance comparisons, for the following reasons:</p>
<p class="bull">&#8226; The performance of an IPC facility may not be a significant factor in the overall performance of an application, and it may not be the only factor in determining the choice of an IPC facility.</p>
<p class="bull">&#8226; The relative performance of the various IPC facilities may vary across UNIX implementations or between different versions of the Linux kernel.</p>
<p class="bull">&#8226; Most importantly, the performance of an IPC facility will vary depending on the precise manner and environment in which it is used. Relevant factors include the size of the data units exchanged in each IPC operation, the amount of unread data that may be outstanding on the IPC facility, whether or not a process context switch is required for each unit of data exchanged, and other load on the system.</p>
<p class="noindentt">If IPC performance is crucial, there is no substitute for application-specific benchmarks run under an environment that matches the target system. To this end, it may be worth writing an abstract software layer that hides details of the IPC facility from the application and then testing performance when different IPC facilities are substituted underneath the abstract layer.</p>
<h3 class="h3" id="ch43lev1sec05"><strong>43.5 Summary</strong></h3>
<p class="noindenta">In this chapter, we provided an overview of various facilities that processes (and threads) can use to communicate with one another and to synchronize their actions.</p>
<p class="indent">Among the communication facilities provided on Linux are pipes, FIFOs, sockets, message queues, and shared memory. Synchronization facilities provided on Linux include semaphores and file locks.</p>
<p class="indent">In many cases, we have a choice of several possible techniques for communication and synchronization when performing a given task. In the course of this chapter, we compared the different techniques in various ways, with the aim of highlighting some differences that may influence the choice of one technique over another.</p>
<p class="indent">In the following chapters, we go into each of the communication and synchronization facilities in much more detail.</p>
<h3 class="h3" id="ch43lev1sec06"><strong>43.6 Exercises</strong></h3>
<p class="exer"><a id="ch43exe1"/><strong>43-1.</strong>&#160;&#160;&#160;Write a program that measures the bandwidth provided by pipes. As command-line arguments, the program should accept the number of data blocks to be sent and the size of each data block. After creating a pipe, the program splits into two process: a child that writes the data blocks to the pipe as fast as possible, and a parent that reads the data blocks. After all data has been read, the parent should print the elapsed time required and the bandwidth (bytes transferred per second). Measure the bandwidth for different data block sizes.</p>
<p class="exer"><span epub:type="pagebreak" id="page_888"/><a id="ch43exe2"/><strong>43-2.</strong>&#160;&#160;&#160;Repeat the preceding exercise for System V message queues, POSIX message queues, UNIX domain stream sockets, and UNIX domain datagram sockets. Use these programs to compare the relative performance of the various IPC facilities on Linux. If you have access to other UNIX implementations, perform the same comparisons on those systems.</p>
</body>
</html>
