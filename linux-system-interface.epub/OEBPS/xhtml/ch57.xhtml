<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch57"><span epub:type="pagebreak" id="page_1165"/><strong><span class="big">57</span></strong><br/><strong>SOCKETS: UNIX DOMAIN</strong></h2>
<p class="noindenta">This chapter looks at the use of UNIX domain sockets, which allow communication between processes on the same host system. We discuss the use of both stream and datagram sockets in the UNIX domain. We also describe the use of file permissions to control access to UNIX domain sockets, the use of <em>socketpair()</em> to create a pair of connected UNIX domain sockets, and the Linux abstract socket namespace.</p>
<h3 class="h3" id="ch57lev1sec01"><strong>57.1 UNIX Domain Socket Addresses: <em>struct sockaddr_un</em></strong></h3>
<p class="noindenta">In the UNIX domain, a socket address takes the form of a pathname, and the domain-specific socket address structure is defined as follows:</p>
<p class="programs">struct sockaddr_un {<br/>&#160;&#160;&#160;&#160;sa_family_t sun_family;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Always AF_UNIX */<br/>&#160;&#160;&#160;&#160;char sun_path[108];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Null-terminated socket pathname */<br/>};</p>
<div class="block">
<p class="noindent">The prefix <em>sun_</em> in the fields of the <em>sockaddr_un</em> structure has nothing to do with Sun Microsystems; rather, it derives from <em>socket unix</em>.</p>
</div>
<p class="noindent">SUSv3 doesn&#8217;t specify the size of the <em>sun_path</em> field. Early BSD implementations used 108 and 104 bytes, and one contemporary implementation (HP-UX 11) uses 92 bytes. Portable applications should code to this lower value, and use <em>snprintf()</em> or <em>strncpy()</em> to avoid buffer overruns when writing into this field.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1166"/>In order to bind a UNIX domain socket to an address, we initialize a <em>sockaddr_un</em> structure, and then pass a (cast) pointer to this structure as the <em>addr</em> argument to <em>bind()</em>, and specify <em>addrlen</em> as the size of the structure, as shown in <a href="ch57.xhtml#ch57ex1">Listing 57-1</a>.</p>
<p class="examplet"><a id="ch57ex1"/><strong>Listing 57-1:</strong> Binding a UNIX domain socket</p>
<p class="programsli">______________________________________________________________________<br/><br/>&#160;&#160;&#160;&#160;const char *SOCKNAME = "/tmp/mysock";<br/>&#160;&#160;&#160;&#160;int sfd;<br/>&#160;&#160;&#160;&#160;struct sockaddr_un addr;<br/><br/>&#160;&#160;&#160;&#160;sfd = socket(AF_UNIX, SOCK_STREAM, 0);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create socket */<br/>&#160;&#160;&#160;&#160;if (sfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("socket");<br/><br/>&#160;&#160;&#160;&#160;memset(&#38;addr, 0, sizeof(struct sockaddr_un));&#160;&#160;&#160;&#160;&#160;/* Clear structure */<br/>&#160;&#160;&#160;&#160;addr.sun_family = AF_UNIX;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* UNIX domain address */<br/>&#160;&#160;&#160;&#160;strncpy(addr.sun_path, SOCKNAME, sizeof(addr.sun_path) - 1);<br/><br/>&#160;&#160;&#160;&#160;if (bind(sfd, (struct sockaddr *) &#38;addr, sizeof(struct sockaddr_un)) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("bind");<br/>______________________________________________________________________</p>
<p class="noindent">The use of the <em>memset()</em> call in <a href="ch57.xhtml#ch57ex1">Listing 57-1</a> ensures that all of the structure fields have the value 0. (The subsequent <em>strncpy()</em> call takes advantage of this by specifying its final argument as one less than the size of the <em>sun_path</em> field, to ensure that this field always has a terminating null byte.) Using <em>memset()</em> to zero out the entire structure, rather than initializing individual fields, ensures that any nonstandard fields that are provided by some implementations are also initialized to 0.</p>
<div class="block">
<p class="noindent">The BSD-derived function <em>bzero()</em> is an alternative to <em>memset()</em> for zeroing the contents of a structure. SUSv3 specifies <em>bzero()</em> and the related <em>bcopy()</em> (which is similar to <em>memmove()</em>), but marks both functions LEGACY, noting that <em>memset()</em> and <em>memmove()</em> are preferred. SUSv4 removes the specifications of <em>bzero()</em> and <em>bcopy()</em>.</p>
</div>
<p class="noindent">When used to bind a UNIX domain socket, <em>bind()</em> creates an entry in the file system. (Thus, a directory specified as part of the socket pathname needs to be accessible and writable.) The ownership of the file is determined according to the usual rules for file creation (<a href="ch15.xhtml#ch15lev2sec03">Section 15.3.1</a>). The file is marked as a socket. When <em>stat()</em> is applied to this pathname, it returns the value <span class="literal">S_IFSOCK</span> in the file-type component of the <em>st_mode</em> field of the <em>stat</em> structure (<a href="ch15.xhtml#ch15lev1sec01">Section 15.1</a>). When listed with <em>ls &#8211;l</em>, a UNIX domain socket is shown with the type <em>s</em> in the first column, and <em>ls &#8211;F</em> appends an equal sign (<span class="literal">=</span>) to the socket pathname.</p>
<div class="block">
<p class="noindent">Although UNIX domain sockets are identified by pathnames, I/O on these sockets doesn&#8217;t involve operations on the underlying device.</p>
</div>
<p class="noindentb">The following points are worth noting about binding a UNIX domain socket:</p>
<p class="bull">&#8226; We can&#8217;t bind a socket to an existing pathname (<em>bind()</em> fails with the error <span class="literal">EADDRINUSE</span>).</p>
<p class="bull"><span epub:type="pagebreak" id="page_1167"/>&#8226; It is usual to bind a socket to an absolute pathname, so that the socket resides at a fixed address in the file system. Using a relative pathname is possible, but unusual, because it requires an application that wants to <em>connect()</em> to this socket to know the current working directory of the application that performs the <em>bind()</em>.</p>
<p class="bull">&#8226; A socket may be bound to only one pathname; conversely, a pathname can be bound to only one socket.</p>
<p class="bull">&#8226; We can&#8217;t use <em>open()</em> to open a socket.</p>
<p class="bull">&#8226; When the socket is no longer required, its pathname entry can (and generally should) be removed using <em>unlink()</em> (or <em>remove()</em>).</p>
<p class="noindentt">In most of our example programs, we bind UNIX domain sockets to pathnames in the <span class="literal">/tmp</span> directory, because this directory is normally present and writable on every system. This makes it easy for the reader to run these programs without needing to first edit the socket pathnames. Be aware, however, that this is generally not a good design technique. As pointed out in <a href="ch38.xhtml#ch38lev1sec07">Section 38.7</a>, creating files in publicly writable directories such as <span class="literal">/tmp</span> can lead to various security vulnerabilities. For example, by creating a pathname in <span class="literal">/tmp</span> with the same name as that used by the application socket, we can create a simple denial-of-service attack. Real-world applications should <em>bind()</em> UNIX domain sockets to absolute pathnames in suitably secured directories.</p>
<h3 class="h3" id="ch57lev1sec02"><strong>57.2 Stream Sockets in the UNIX Domain</strong></h3>
<p class="noindenta">We now present a simple client-server application that uses stream sockets in the UNIX domain. The client program (<a href="ch57.xhtml#ch57ex4">Listing 57-4</a>) connects to the server, and uses the connection to transfer data from its standard input to the server. The server program (<a href="ch57.xhtml#ch57ex3">Listing 57-3</a>) accepts client connections, and transfers all data sent on the connection by the client to standard output. The server is a simple example of an <em>iterative</em> server&#8212;a server that handles one client at a time before proceeding to the next client. (We consider server design in more detail in <a href="ch60.xhtml#ch60">Chapter 60</a>.)</p>
<p class="indent"><a href="ch57.xhtml#ch57ex2">Listing 57-2</a> is the header file used by both of these programs.</p>
<p class="examplet"><a id="ch57ex2"/><strong>Listing 57-2:</strong> Header file for <span class="literal">us_xfr_sv.c</span> and <span class="literal">us_xfr_cl.c</span></p>
<p class="programsli">_________________________________________________________ <span class="codestrong">sockets/us_xfr.h</span><br/><br/>#include &lt;sys/un.h&gt;<br/>#include &lt;sys/socket.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>#define SV_SOCK_PATH "/tmp/us_xfr"<br/><br/>#define BUF_SIZE 100<br/>_________________________________________________________ <span class="codestrong">sockets/us_xfr.h</span></p>
<p class="noindent">In the following pages, we first present the source code of the server and client, and then discuss the details of these programs and show an example of their use.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1168"/><a id="ch57ex3"/><strong>Listing 57-3:</strong> A simple UNIX domain stream socket server</p>
<p class="programsli">______________________________________________________ <span class="codestrong">sockets/us_xfr_sv.c</span><br/><br/>#include "us_xfr.h"<br/>#define BACKLOG 5<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct sockaddr_un addr;<br/>&#160;&#160;&#160;&#160;int sfd, cfd;<br/>&#160;&#160;&#160;&#160;ssize_t numRead;<br/>&#160;&#160;&#160;&#160;char buf[BUF_SIZE];<br/><br/>&#160;&#160;&#160;&#160;sfd = socket(AF_UNIX, SOCK_STREAM, 0);<br/>&#160;&#160;&#160;&#160;if (sfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("socket");<br/><br/>&#160;&#160;&#160;&#160;/* Construct server socket address, bind socket to it,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;and make this a listening socket */<br/><br/>&#160;&#160;&#160;&#160;if (strlen(SV_SOCK_PATH) &gt; sizeof(addr.sun_path) - 1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("Server socket path too long: %s", SV_SOCK_PATH);<br/><br/>&#160;&#160;&#160;&#160;if (remove(SV_SOCK_PATH) == -1 &#38;&#38; errno != ENOENT)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("remove-%s", SV_SOCK_PATH);<br/><br/>&#160;&#160;&#160;&#160;memset(&#38;addr, 0, sizeof(struct sockaddr_un));<br/>&#160;&#160;&#160;&#160;addr.sun_family = AF_UNIX;<br/>&#160;&#160;&#160;&#160;strncpy(addr.sun_path, SV_SOCK_PATH, sizeof(addr.sun_path) - 1);<br/><br/>&#160;&#160;&#160;&#160;if (bind(sfd, (struct sockaddr *) &#38;addr, sizeof(struct sockaddr_un)) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("bind");<br/><br/>&#160;&#160;&#160;&#160;if (listen(sfd, BACKLOG) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("listen");<br/><br/>&#160;&#160;&#160;&#160;for (;;) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Handle client connections iteratively */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Accept a connection. The connection is returned on a new<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;socket, 'cfd'; the listening socket ('sfd') remains open<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;and can be used to accept further connections. */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cfd = accept(sfd, NULL, NULL);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (cfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("accept");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Transfer data from connected socket to stdout until EOF */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while ((numRead = read(cfd, buf, BUF_SIZE)) &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (write(STDOUT_FILENO, buf, numRead) != numRead)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("partial/failed write");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("read");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (close(cfd) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("close");<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>______________________________________________________ <span class="codestrong">sockets/us_xfr_sv.c</span></p>
<p class="examplet"><span epub:type="pagebreak" id="page_1169"/><a id="ch57ex4"/><strong>Listing 57-4:</strong> A simple UNIX domain stream socket client</p>
<p class="programsli">______________________________________________________ <span class="codestrong">sockets/us_xfr_cl.c</span><br/><br/>#include "us_xfr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct sockaddr_un addr;<br/>&#160;&#160;&#160;&#160;int sfd;<br/>&#160;&#160;&#160;&#160;ssize_t numRead;<br/>&#160;&#160;&#160;&#160;char buf[BUF_SIZE];<br/><br/>&#160;&#160;&#160;&#160;sfd = socket(AF_UNIX, SOCK_STREAM, 0);&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create client socket */<br/>&#160;&#160;&#160;&#160;if (sfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("socket");<br/><br/>&#160;&#160;&#160;&#160;/* Construct server address, and make the connection */<br/><br/>&#160;&#160;&#160;&#160;memset(&#38;addr, 0, sizeof(struct sockaddr_un));<br/>&#160;&#160;&#160;&#160;addr.sun_family = AF_UNIX;<br/>&#160;&#160;&#160;&#160;strncpy(addr.sun_path, SV_SOCK_PATH, sizeof(addr.sun_path) - 1);<br/><br/>&#160;&#160;&#160;&#160;if (connect(sfd, (struct sockaddr *) &#38;addr,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sizeof(struct sockaddr_un)) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("connect");<br/><br/>&#160;&#160;&#160;&#160;/* Copy stdin to socket */<br/><br/>&#160;&#160;&#160;&#160;while ((numRead = read(STDIN_FILENO, buf, BUF_SIZE)) &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (write(sfd, buf, numRead) != numRead)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("partial/failed write");<br/><br/>&#160;&#160;&#160;&#160;if (numRead == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("read");<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Closes our socket; server sees EOF */<br/>}<br/>______________________________________________________ <span class="codestrong">sockets/us_xfr_cl.c</span></p>
<p class="noindentb">The server program is shown in <a href="ch57.xhtml#ch57ex3">Listing 57-3</a>. The server performs the following steps:</p>
<p class="bull">&#8226; Create a socket.</p>
<p class="bull">&#8226; Remove any existing file with the same pathname as that to which we want to bind the socket.</p>
<p class="bull"><span epub:type="pagebreak" id="page_1170"/>&#8226; Construct an address structure for the server&#8217;s socket, bind the socket to that address, and mark the socket as a listening socket.</p>
<p class="bull">&#8226; Execute an infinite loop to handle incoming client requests. Each loop iteration performs the following steps:</p>
<p class="dash1">&#8211; Accept a connection, obtaining a new socket, <em>cfd</em>, for the connection.</p>
<p class="dash1">&#8211; Read all of the data from the connected socket and write it to standard output.</p>
<p class="dash1">&#8211; Close the connected socket <em>cfd</em>.</p>
<p class="noindentt">The server must be terminated manually (e.g., by sending it a signal).</p>
<p class="indentb">The client program (<a href="ch57.xhtml#ch57ex4">Listing 57-4</a>) performs the following steps:</p>
<p class="bull">&#8226; Create a socket.</p>
<p class="bull">&#8226; Construct the address structure for the server&#8217;s socket and connect to the socket at that address.</p>
<p class="bull">&#8226; Execute a loop that copies its standard input to the socket connection. Upon encountering end-of-file in its standard input, the client terminates, with the result that its socket is closed and the server sees end-of-file when reading from the socket on the other end of the connection.</p>
<p class="noindentt">The following shell session log demonstrates the use of these programs. We begin by running the server in the background:</p>
<p class="programs">$ <span class="codestrong">./us_xfr_sv &gt; b &#38;</span><br/>[1] 9866<br/>$ <span class="codestrong">ls -lF /tmp/us_xfr</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Examine socket file with ls</span><br/>srwxr-xr-x&#160;&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0 Jul 18 10:48 /tmp/us_xfr=</p>
<p class="noindent">We then create a test file to be used as input for the client, and run the client:</p>
<p class="programs">$ <span class="codestrong">cat *.c &gt; a</span><br/>$ <span class="codestrong">./us_xfr_cl &lt; a</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Client takes input from test file</span></p>
<p class="noindent">At this point, the client has completed. Now we terminate the server as well, and check that the server&#8217;s output matches the client&#8217;s input:</p>
<p class="programs">$ <span class="codestrong">kill %1</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Terminate server</span><br/>&#160;[1]+&#160;&#160;Terminated&#160;&#160;&#160;./us_xfr_sv &gt;b&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Shell sees server's termination</span><br/>$ <span class="codestrong">diff a b</span><br/>$</p>
<p class="noindent">The <em>diff</em> command produces no output, indicating that the input and output files are identical.</p>
<p class="indent">Note that after the server terminates, the socket pathname continues to exist. This is why the server uses <em>remove()</em> to remove any existing instance of the socket pathname before calling <em>bind()</em>. (Assuming we have appropriate permissions, this <em>remove()</em> call would remove any type of file with this pathname, even if it wasn&#8217;t a socket.) If we did not do this, then the <em>bind()</em> call would fail if a previous invocation of the server had already created this socket pathname.</p>
<h3 class="h3" id="ch57lev1sec03"><span epub:type="pagebreak" id="page_1171"/><strong>57.3 Datagram Sockets in the UNIX Domain</strong></h3>
<p class="noindenta">In the generic description of datagram sockets that we provided in <a href="ch56.xhtml#ch56lev1sec06">Section 56.6</a>, we stated that communication using datagram sockets is unreliable. This is the case for datagrams transferred over a network. However, for UNIX domain sockets, datagram transmission is carried out within the kernel, and is reliable. All messages are delivered in order and unduplicated.</p>
<h5 class="h5" id="ch57lev3sec01"><strong>Maximum datagram size for UNIX domain datagram sockets</strong></h5>
<p class="noindenta">SUSv3 doesn&#8217;t specify a maximum size for datagrams sent via a UNIX domain socket. On Linux, we can send quite large datagrams. The limits are controlled via the <span class="literal">SO_SNDBUF</span> socket option and various <span class="literal">/proc</span> files, as described in the <em>socket(7)</em> manual page. However, some other UNIX implementations impose lower limits, such as 2048 bytes. Portable applications employing UNIX domain datagram sockets should consider imposing a low upper limit on the size of datagrams used.</p>
<h5 class="h5" id="ch57lev3sec02"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch57.xhtml#ch57ex6">Listing 57-6</a> and <a href="ch57.xhtml#ch57ex7">Listing 57-7</a> show a simple client-server application using UNIX domain datagram sockets. Both of these programs make use of the header file shown in <a href="ch57.xhtml#ch57ex5">Listing 57-5</a>.</p>
<p class="examplet"><a id="ch57ex5"/><strong>Listing 57-5:</strong> Header file used by <span class="literal">ud_ucase_sv.c</span> and <span class="literal">ud_ucase_cl.c</span></p>
<p class="programsli">_______________________________________________________ <span class="codestrong">sockets/ud_ucase.h</span><br/><br/>#include &lt;sys/un.h&gt;<br/>#include &lt;sys/socket.h&gt;<br/>#include &lt;ctype.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>#define BUF_SIZE 10&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Maximum size of messages exchanged<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;between client and server */<br/><br/>#define SV_SOCK_PATH "/tmp/ud_ucase"<br/>_______________________________________________________ <span class="codestrong">sockets/ud_ucase.h</span></p>
<p class="noindent">The server program (<a href="ch57.xhtml#ch57ex6">Listing 57-6</a>) first creates a socket and binds it to a well-known address. (Beforehand, the server unlinks the pathname matching that address, in case the pathname already exists.) The server then enters an infinite loop, using <em>recvfrom()</em> to receive datagrams from clients, converting the received text to uppercase, and returning the converted text to the client using the address obtained via <em>recvfrom()</em>.</p>
<p class="indent">The client program (<a href="ch57.xhtml#ch57ex7">Listing 57-7</a>) creates a socket and binds the socket to an address, so that the server can send its reply. The client address is made unique by including the client&#8217;s process ID in the pathname. The client then loops, sending each of its command-line arguments as a separate message to the server. After sending each message, the client reads the server response and displays it on standard output.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1172"/><a id="ch57ex6"/><strong>Listing 57-6:</strong> A simple UNIX domain datagram server</p>
<p class="programsli">_____________________________________________________ <span class="codestrong">sockets/ud_ucase_sv.c</span><br/><br/>#include "ud_ucase.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct sockaddr_un svaddr, claddr;<br/>&#160;&#160;&#160;&#160;int sfd, j;<br/>&#160;&#160;&#160;&#160;ssize_t numBytes;<br/>&#160;&#160;&#160;&#160;socklen_t len;<br/>&#160;&#160;&#160;&#160;char buf[BUF_SIZE];<br/><br/>&#160;&#160;&#160;&#160;sfd = socket(AF_UNIX, SOCK_DGRAM, 0);&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create server socket */<br/>&#160;&#160;&#160;&#160;if (sfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("socket");<br/><br/>&#160;&#160;&#160;&#160;/* Construct well-known address and bind server socket to it */<br/><br/>&#160;&#160;&#160;&#160;if (strlen(SV_SOCK_PATH) &gt; sizeof(svaddr.sun_path) - 1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("Server socket path too long: %s", SV_SOCK_PATH);<br/><br/>&#160;&#160;&#160;&#160;if (remove(SV_SOCK_PATH) == -1 &#38;&#38; errno != ENOENT)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("remove-%s", SV_SOCK_PATH);<br/><br/>&#160;&#160;&#160;&#160;memset(&#38;svaddr, 0, sizeof(struct sockaddr_un));<br/>&#160;&#160;&#160;&#160;svaddr.sun_family = AF_UNIX;<br/>&#160;&#160;&#160;&#160;strncpy(svaddr.sun_path, SV_SOCK_PATH, sizeof(svaddr.sun_path) - 1);<br/><br/>&#160;&#160;&#160;&#160;if (bind(sfd, (struct sockaddr *) &#38;svaddr, sizeof(struct sockaddr_un)) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("bind");<br/><br/>&#160;&#160;&#160;&#160;/* Receive messages, convert to uppercase, and return to client */<br/><br/>&#160;&#160;&#160;&#160;for (;;) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;len = sizeof(struct sockaddr_un);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numBytes = recvfrom(sfd, buf, BUF_SIZE, 0,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(struct sockaddr *) &#38;claddr, &#38;len);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numBytes == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("recvfrom");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Server received %ld bytes from %s\n", (long) numBytes,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;claddr.sun_path);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (j = 0; j &lt; numBytes; j++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;buf[j] = toupper((unsigned char) buf[j]);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sendto(sfd, buf, numBytes, 0, (struct sockaddr *) &#38;claddr, len) !=<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numBytes)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("sendto");<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>_____________________________________________________ <span class="codestrong">sockets/ud_ucase_sv.c</span></p>
<p class="examplet"><span epub:type="pagebreak" id="page_1173"/><a id="ch57ex7"/><strong>Listing 57-7:</strong> A simple UNIX domain datagram client</p>
<p class="programsli">_____________________________________________________ <span class="codestrong">sockets/ud_ucase_cl.c</span><br/><br/>#include "ud_ucase.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct sockaddr_un svaddr, claddr;<br/>&#160;&#160;&#160;&#160;int sfd, j;<br/>&#160;&#160;&#160;&#160;size_t msgLen;<br/>&#160;&#160;&#160;&#160;ssize_t numBytes;<br/>&#160;&#160;&#160;&#160;char resp[BUF_SIZE];<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s msg...\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;/* Create client socket; bind to unique pathname (based on PID) */<br/><br/>&#160;&#160;&#160;&#160;sfd = socket(AF_UNIX, SOCK_DGRAM, 0);<br/>&#160;&#160;&#160;&#160;if (sfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("socket");<br/><br/>&#160;&#160;&#160;&#160;memset(&#38;claddr, 0, sizeof(struct sockaddr_un));<br/>&#160;&#160;&#160;&#160;claddr.sun_family = AF_UNIX;<br/>&#160;&#160;&#160;&#160;snprintf(claddr.sun_path, sizeof(claddr.sun_path),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"/tmp/ud_ucase_cl.%ld", (long) getpid());<br/><br/>&#160;&#160;&#160;&#160;if (bind(sfd, (struct sockaddr *) &#38;claddr, sizeof(struct sockaddr_un)) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("bind");<br/><br/>&#160;&#160;&#160;&#160;/* Construct address of server */<br/><br/>&#160;&#160;&#160;&#160;memset(&#38;svaddr, 0, sizeof(struct sockaddr_un));<br/>&#160;&#160;&#160;&#160;svaddr.sun_family = AF_UNIX;<br/>&#160;&#160;&#160;&#160;strncpy(svaddr.sun_path, SV_SOCK_PATH, sizeof(svaddr.sun_path) - 1);<br/><br/>&#160;&#160;&#160;&#160;/* Send messages to server; echo responses on stdout */<br/><br/>&#160;&#160;&#160;&#160;for (j = 1; j &lt; argc; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msgLen = strlen(argv[j]);&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* May be longer than BUF_SIZE */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sendto(sfd, argv[j], msgLen, 0, (struct sockaddr *) &#38;svaddr,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sizeof(struct sockaddr_un)) != msgLen)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("sendto");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numBytes = recvfrom(sfd, resp, BUF_SIZE, 0, NULL, NULL);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numBytes == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("recvfrom");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Response %d: %.*s\n", j, (int) numBytes, resp);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;remove(claddr.sun_path);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Remove client socket pathname */<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_____________________________________________________ <span class="codestrong">sockets/ud_ucase_cl.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_1174"/>The following shell session log demonstrates the use of the server and client programs:</p>
<p class="programs">$ <span class="codestrong">./ud_ucase_sv &#38;</span><br/>[1] 20113<br/>$ <span class="codestrong">./ud_ucase_cl hello world</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Send 2 messages to server</span><br/>Server received 5 bytes from /tmp/ud_ucase_cl.20150<br/>Response 1: HELLO<br/>Server received 5 bytes from /tmp/ud_ucase_cl.20150<br/>Response 2: WORLD<br/>$ <span class="codestrong">./ud_ucase_cl 'long message'</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Send 1 longer message to server</span><br/>Server received 10 bytes from /tmp/ud_ucase_cl.20151<br/>Response 1: LONG MESSA<br/>$ <span class="codestrong">kill %1</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Terminate server</span></p>
<p class="noindent">The second invocation of the client program was designed to show that when a <em>recvfrom()</em> call specifies a <em>length</em> (<span class="literal">BUF_SIZE</span>, defined in <a href="ch57.xhtml#ch57ex5">Listing 57-5</a> with the value 10) that is shorter than the message size, the message is silently truncated. We can see that this truncation occurred, because the server prints a message saying it received just 10 bytes, while the message sent by the client consisted of 12 bytes.</p>
<h3 class="h3" id="ch57lev1sec04"><strong>57.4 UNIX Domain Socket Permissions</strong></h3>
<p class="noindentab">The ownership and permissions of the socket file determine which processes are able to communicate with that socket:</p>
<p class="bull">&#8226; To connect to a UNIX domain stream socket, write permission is required on the socket file.</p>
<p class="bull">&#8226; To send a datagram to a UNIX domain datagram socket, write permission is required on the socket file.</p>
<p class="noindentt">In addition, execute (search) permission is required on each of the directories in the socket pathname.</p>
<p class="indent">By default, a socket is created (by <em>bind()</em>) with all permissions granted to owner (user), group, and other. To change this, we can precede the call to <em>bind()</em> with a call to <em>umask()</em> to disable the permissions that we do not wish to grant.</p>
<p class="indent">Some systems ignore the permissions on the socket file (SUSv3 allows this). Thus, we can&#8217;t portably use socket file permissions to control access to the socket, although we can portably use permissions on the hosting directory for this purpose.</p>
<h3 class="h3" id="ch57lev1sec05"><strong>57.5 Creating a Connected Socket Pair: <em>socketpair()</em></strong></h3>
<p class="noindenta">Sometimes, it is useful for a single process to create a pair of sockets and connect them together. This could be done using two calls to <em>socket()</em>, a call to <em>bind()</em>, and then either calls to <em>listen()</em>, <em>connect()</em>, and <em>accept()</em> (for stream sockets), or a call to <em>connect()</em> (for datagram sockets). The <em>socketpair()</em> system call provides a shorthand for this operation.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_1175"/>#include &lt;sys/socket.h&gt;<br/><br/>int <span class="codestrong">socketpair</span>(int <span class="font1">domain</span>, int <span class="font1">type</span>, int <span class="font1">protocol</span>, int <span class="font1">sockfd</span>[2]);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">This <em>socketpair()</em> system call can be used only in the UNIX domain; that is, <em>domain</em> must be specified as <span class="literal">AF_UNIX</span>. (This restriction applies on most implementations, and is logical, since the socket pair is created on a single host system.) The socket <em>type</em> may be specified as either <span class="literal">SOCK_DGRAM</span> or <span class="literal">SOCK_STREAM</span>. The <em>protocol</em> argument must be specified as 0. The <em>sockfd</em> array returns the file descriptors referring to the two connected sockets.</p>
<p class="indent">Specifying <em>type</em> as <span class="literal">SOCK_STREAM</span> creates the equivalent of a bidirectional pipe (also known as a <em>stream pipe</em>). Each socket can be used for both reading and writing, and separate data channels flow in each direction between the two sockets. (On BSD-derived implementations, <em>pipe()</em> is implemented as a call to <em>socketpair()</em>.)</p>
<p class="indent">Typically, a socket pair is used in a similar fashion to a pipe. After the <em>socketpair()</em> call, the process then creates a child via <em>fork()</em>. The child inherits copies of the parent&#8217;s file descriptors, including the descriptors referring to the socket pair. Thus, the parent and child can use the socket pair for IPC.</p>
<p class="indent">One way in which the use of <em>socketpair()</em> differs from creating a pair of connected sockets manually is that the sockets are not bound to any address. This can help us avoid a whole class of security vulnerabilities, since the sockets are not visible to any other process.</p>
<div class="block">
<p class="noindent">Starting with kernel 2.6.27, Linux provides a second use for the <em>type</em> argument, by allowing two nonstandard flags to be ORed with the socket type. The <span class="literal">SOCK_CLOEXEC</span> flag causes the kernel to enable the close-on-exec flag (<span class="literal">FD_CLOEXEC</span>) for the two new file descriptors. This flag is useful for the same reasons as the <em>open()</em> <span class="literal">O_CLOEXEC</span> flag described in <a href="ch04.xhtml#ch04lev2sec01">Section 4.3.1</a>. The <span class="literal">SOCK_NONBLOCK</span> flag causes the kernel to set the <span class="literal">O_NONBLOCK</span> flag on both underlying open file descriptions, so that future I/O operations on the socket will be nonblocking. This saves additional calls to <em>fcntl()</em> to achieve the same result.</p>
</div>
<h3 class="h3" id="ch57lev1sec06"><strong>57.6 The Linux Abstract Socket Namespace</strong></h3>
<p class="noindentab">The so-called <em>abstract namespace</em> is a Linux-specific feature that allows us to bind a UNIX domain socket to a name without that name being created in the file system. This provides a few potential advantages:</p>
<p class="bull">&#8226; We don&#8217;t need to worry about possible collisions with existing names in the file system.</p>
<p class="bull">&#8226; It is not necessary to unlink the socket pathname when we have finished using the socket. The abstract name is automatically removed when the socket is closed.</p>
<p class="bull">&#8226; We don&#8217;t need to create a file-system pathname for the socket. This may be useful in a <em>chroot</em> environment, or if we don&#8217;t have write access to a file system.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_1176"/>To create an abstract binding, we specify the first byte of the <em>sun_path</em> field as a null byte (<span class="literal">\0</span>). This distinguishes abstract socket names from conventional UNIX domain socket pathnames, which consist of a string of one or more nonnull bytes terminated by a null byte. The name of the abstract socket is then defined by the remaining bytes (including any null bytes) in <em>sun_path</em> up to the length defined for the size of the address structure (i.e., <em>addrlen &#8211; sizeof(sa_family_t)</em>).</p>
<p class="indent"><a href="ch57.xhtml#ch57ex8">Listing 57-8</a> demonstrates the creation of an abstract socket binding.</p>
<p class="examplet"><a id="ch57ex8"/><strong>Listing 57-8:</strong> Creating an abstract socket binding</p>
<p class="programsli">_____________________________________________ <span class="font1">from</span> <span class="codestrong">sockets/us_abstract_bind.c</span><br/><br/>&#160;&#160;&#160;struct sockaddr_un addr;<br/><br/>&#160;&#160;&#160;memset(&#38;addr, 0, sizeof(struct sockaddr_un));&#160;&#160;/* Clear address structure */<br/>&#160;&#160;&#160;addr.sun_family = AF_UNIX;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* UNIX domain address */<br/><br/>&#160;&#160;&#160;/* addr.sun_path[0] has already been set to 0 by memset() */<br/><br/>&#160;&#160;&#160;str = "xyz";&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Abstract name is "\0xyz" */<br/>&#160;&#160;&#160;strncpy(&#38;addr.sun_path[1], str, strlen(str));<br/><br/>&#160;&#160;&#160;sockfd = socket(AF_UNIX, SOCK_STREAM, 0);<br/>&#160;&#160;&#160;if (sockfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("socket");<br/><br/>&#160;&#160;&#160;if (bind(sockfd, (struct sockaddr *) &#38;addr,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sizeof(sa_family_t) + strlen(str) + 1) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("bind");<br/>_____________________________________________ <span class="font1">from</span> <span class="codestrong">sockets/us_abstract_bind.c</span></p>
<p class="noindent">The fact that an initial null byte is used to distinguish an abstract socket name from a conventional socket name can have an unusual consequence. Suppose that the variable <em>name</em> happens to point to a zero-length string and that we attempt to bind a UNIX domain socket to a <em>sun_path</em> initialized as follows:</p>
<p class="programs">strncpy(addr.sun_path, name, sizeof(addr.sun_path) - 1);</p>
<p class="noindent">On Linux, we&#8217;ll inadvertently create an abstract socket binding. However, such a code sequence is probably unintentional (i.e., a bug). On other UNIX implementations, the subsequent <em>bind()</em> would fail.</p>
<h3 class="h3" id="ch57lev1sec07"><strong>57.7 Summary</strong></h3>
<p class="noindenta">UNIX domain sockets allow communication between applications on the same host. The UNIX domain supports both stream and datagram sockets.</p>
<p class="indent">A UNIX domain socket is identified by a pathname in the file system. File permissions can be used to control access to a UNIX domain socket.</p>
<p class="indent">The <em>socketpair()</em> system call creates a pair of connected UNIX domain sockets. This avoids the need for multiple system calls to create, bind, and connect the sockets. A socket pair is normally used in a similar fashion to a pipe: one process creates <span epub:type="pagebreak" id="page_1177"/>the socket pair and then forks to create a child that inherits descriptors referring to the sockets. The two processes can then communicate via the socket pair.</p>
<p class="indent">The Linux-specific abstract socket namespace allows us to bind a UNIX domain socket to a name that doesn&#8217;t appear in the file system.</p>
<h5 class="h5" id="ch57lev3sec03"><strong>Further information</strong></h5>
<p class="noindenta">Refer to the sources of further information listed in <a href="ch59.xhtml#ch59lev1sec15">Section 59.15</a>.</p>
<h3 class="h3" id="ch57lev1sec08"><strong>57.8 Exercises</strong></h3>
<p class="exer"><a id="ch57exe1"/><strong>57-1.</strong>&#160;&#160;&#160;In <a href="ch57.xhtml#ch57lev1sec03">Section 57.3</a>, we noted that UNIX domain datagram sockets are reliable. Write programs to show that if a sender transmits datagrams to a UNIX domain datagram socket faster than the receiver reads them, then the sender is eventually blocked, and remains blocked until the receiver reads some of the pending datagrams.</p>
<p class="exer"><a id="ch57exe2"/><strong>57-2.</strong>&#160;&#160;&#160;Rewrite the programs in <a href="ch57.xhtml#ch57ex3">Listing 57-3</a> (<span class="literal">us_xfr_sv.c</span>) and <a href="ch57.xhtml#ch57ex4">Listing 57-4</a> (<span class="literal">us_xfr_cl.c</span>) to use the Linux-specific abstract socket namespace (<a href="ch57.xhtml#ch57lev1sec06">Section 57.6</a>).</p>
<p class="exer"><a id="ch57exe3"/><strong>57-3.</strong>&#160;&#160;&#160;Reimplement the sequence-number server and client of <a href="ch44.xhtml#ch44lev1sec08">Section 44.8</a> using UNIX domain stream sockets.</p>
<p class="exer"><a id="ch57exe4"/><strong>57-4.</strong>&#160;&#160;&#160;Suppose that we create two UNIX domain datagram sockets bound to the paths <span class="literal">/somepath/a</span> and <span class="literal">/somepath/b</span>, and that we connect the socket <span class="literal">/somepath/a</span> to <span class="literal">/somepath/b</span>. What happens if we create a third datagram socket and try to send (<em>sendto()</em>) a datagram via that socket to <span class="literal">/somepath/a</span>? Write a program to determine the answer. If you have access to other UNIX systems, test the program on those systems to see if the answer differs.<span epub:type="pagebreak" id="page_1178"/></p>
</body>
</html>
