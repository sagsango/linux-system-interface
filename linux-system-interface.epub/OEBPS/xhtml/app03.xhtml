<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="app03"><span epub:type="pagebreak" id="page_1413"/><strong><span class="big">C</span></strong><br/><strong>CASTING THE</strong> <span class="literal"><span class="codestrong">NULL</span></span> <strong>POINTER</strong></h2>
<p class="noindenta">Consider the following call to the variadic function <em>execl()</em>:</p>
<p class="programs">execl("ls", "ls", "-l", (char *) NULL);</p>
<div class="block">
<p class="noindent">A <em>variadic function</em> is one that takes a variable number of arguments or arguments of varying types.</p>
</div>
<p class="noindent">Whether the cast is required before the <span class="literal">NULL</span> in cases like this is the source of some confusion. While we can often get away without the cast, the C standards require it; failure to include it may lead an application to break on some systems.</p>
<p class="indent"><span class="literal">NULL</span> is typically defined as either 0 or as <em>(void *) 0</em>. (The C standards allow other definitions, but they are essentially equivalent to one of these two possibilities.) The main reason casts are needed is that <span class="literal">NULL</span> is allowed to be defined as 0, so this is the case we examine first.</p>
<p class="indent">The C preprocessor translates <span class="literal">NULL</span> to 0 before the source code is passed to the compiler. The C standards specify that the integer constant 0 may be used in any context where a pointer may be used, and the compiler will ensure that this value is treated as a null pointer. In most cases, everything is fine, and we don&#8217;t need to worry about casts. We can, for example, write code such as the following:</p>
<p class="programs">int *p;<br/><br/>p = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Assign null pointer to 'p' */<br/>p = NULL;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Same as 'p = 0' */</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1414"/>The above assignments work because the compiler can determine that a pointer value is required on the right-hand side of the assignment, and it will convert the value 0 to a null pointer.</p>
<p class="indent">Similarly, for functions with prototypes specifying a fixed argument list, we can specify either 0 or <span class="literal">NULL</span> for a pointer argument, to indicate that a null pointer should be passed to the function:</p>
<p class="programs">sigaction(SIGINT, &#38;sa, 0);<br/>sigaction(SIGINT, &#38;sa, NULL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Equivalent to the preceding */</p>
<div class="block">
<p class="noindent">If we are passing a null pointer to an old-style, nonprototyped C function, then all of the arguments given here about the need to appropriately cast 0 or <span class="literal">NULL</span> also apply, regardless of whether the argument is part of a variadic argument list.</p>
</div>
<p class="noindentb">Because casting is not required in any of the above examples, one might conclude that it is never required. But this is wrong. The need for casting arises when specifying a null pointer as one of the varying arguments in a call to a variadic function such as <em>execl()</em>. To realize why this is necessary, we need to be aware of the following:</p>
<p class="bull">&#8226; The compiler can&#8217;t determine the expected types of the varying arguments of a variadic function.</p>
<p class="bull">&#8226; The C standards don&#8217;t require that a null pointer is actually represented in the same way as the integer constant 0. (In theory, a null pointer could be represented by any bit pattern that wasn&#8217;t the same as a valid pointer.) Nor do the standards even require that a null pointer is the same size as the integer constant 0. All that the standards require is that when the integer constant 0 is found in a context where a pointer is expected, the 0 should be interpreted as a null pointer.</p>
<p class="noindentt">Consequently, it is wrong to write either of the following:</p>
<p class="programs">execl(prog, arg, 0);<br/>execl(prog, arg, NULL);</p>
<p class="noindent">This is an error because the compiler will pass the integer constant 0 to <em>execl()</em>, and there is no guarantee that this is equivalent to a null pointer.</p>
<p class="indent">In practice, we can often get away without the cast, since, on many C implementations (e.g., Linux/x86-32), the representations of the integer (<em>int</em>) constant 0 and the null pointer are the same. However, there are implementations where they are not&#8212;for example, where the size of a null pointer is larger than the size of the integer constant 0&#8212;so that in the above examples, <em>execl()</em> is likely to receive some random bits adjacent to the integer 0, and the resulting value will be interpreted as a random (nonnull) pointer. Omitting the cast leads to programs breaking when ported to such implementations. (On some of the aforementioned implementations, <span class="literal">NULL</span> is defined as the <em>long</em> integer constant <em>0L</em>, and <em>long</em> and <em>void *</em> have the same size, which may save wrongly constructed programs that use the second of the <em>execl()</em> calls above.) Therefore, we should rewrite the above <em>execl()</em> calls in the following ways:</p>
<p class="programs">execl(prog, arg, (char *) 0);<br/>execl(prog, arg, (char *) NULL);</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1415"/>Casting <span class="literal">NULL</span> in the manner of the last call above is generally required, even on implementations where <span class="literal">NULL</span> is defined as <em>(void *) 0</em>. This is because, although the C standards require that null pointers of different types should test true for comparisons on equality, they don&#8217;t require that pointers of different types have the same internal representation (although on most implementations they do). And, as before, in a variadic function, the compiler can&#8217;t cast <em>(void *) 0</em> to a null pointer of the appropriate type.</p>
<div class="block">
<p class="noindent">The C standards make one exception to the rule that pointers of different types need not have the same representation: pointers of the types <em>char *</em> and <em>void *</em> are required to have the same internal representation. This means that passing <em>(void *) 0</em> instead of <em>(char *) 0</em> would not be a problem in the example case of <em>execl()</em>, but, in the general case, a cast is needed.<span epub:type="pagebreak" id="page_1416"/></p>
</div>
</body>
</html>
