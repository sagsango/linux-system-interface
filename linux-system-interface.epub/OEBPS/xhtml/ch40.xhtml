<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch40"><span epub:type="pagebreak" id="page_817"/><strong><span class="big">40</span></strong><br/><strong>LOGIN ACCOUNTING</strong></h2>
<p class="noindenta">Login accounting is concerned with recording which users are currently logged in to the system, and recording past logins and logouts. This chapter looks at the login accounting files and the library functions used to retrieve and update the information they contain. We also describe the steps that an application providing a login service should perform in order to update these files when a user logs in and out.</p>
<h3 class="h3" id="ch40lev1sec01"><strong>40.1 Overview of the</strong> <span class="literal"><span class="codestrong">utmp</span></span> <strong>and</strong> <span class="literal"><span class="codestrong">wtmp</span></span> <strong>Files</strong></h3>
<p class="noindentab">UNIX systems maintain two data files containing information about users logging in and out of the system:</p>
<p class="bull">&#8226; The <span class="literal">utmp</span> file maintains a record of users currently logged in to the system (as well as certain other information that we describe later). As each user logs in, a record is written to the <span class="literal">utmp</span> file. One of the fields in this record, <em>ut_user</em>, records the login name of the user. This record is later erased on logout. Programs such as <em>who(1)</em> use the information in the <span class="literal">utmp</span> file to display a list of currently logged-in users.</p>
<p class="bull">&#8226; The <span class="literal">wtmp</span> file is an audit trail of all user logins and logouts (as well as certain other information that we describe later). On each login, a record containing the same information as is written to the <span class="literal">utmp</span> file is appended to the <span class="literal">wtmp</span> file. On logout, a further record is appended to the file. This record contains the same information, except that the <em>ut_user</em> field is zeroed out. The <em>last(1)</em> command can be used to display and filter the contents of the <span class="literal">wtmp</span> file.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_818"/>On Linux, the <span class="literal">utmp</span> file resides at <span class="literal">/var/run/utmp</span>, and the <span class="literal">wtmp</span> file resides at <span class="literal">/var/log/wtmp</span>. In general, applications don&#8217;t need to know about these pathnames, since they are compiled into <em>glibc</em>. Programs that do need to refer to the locations of these files should use the <span class="literal">_PATH_UTMP</span> and <span class="literal">_PATH_WTMP</span> pathname constants, defined in <span class="literal">&lt;paths.h&gt;</span> (and <span class="literal">&lt;utmpx.h&gt;</span>), rather than explicitly coding pathnames into the program.</p>
<div class="block">
<p class="noindent">SUSv3 doesn&#8217;t standardize any symbolic names for the pathnames of the <span class="literal">utmp</span> and <span class="literal">wtmp</span> files. The names <span class="literal">_PATH_UTMP</span> and <span class="literal">_PATH_WTMP</span> are used on Linux and the BSDs. Many other UNIX implementations instead define the constants <span class="literal">UTMP_FILE</span> and <span class="literal">WTMP_FILE</span> for these pathnames. Linux also defines these names in <span class="literal">&lt;utmp.h&gt;</span>, but doesn&#8217;t define them in <span class="literal">&lt;utmpx.h&gt;</span> or <span class="literal">&lt;paths.h&gt;</span>.</p>
</div>
<h3 class="h3" id="ch40lev1sec02"><strong>40.2 The <em>utmpx</em> API</strong></h3>
<p class="noindenta">The <span class="literal">utmp</span> and <span class="literal">wtmp</span> files have been present in the UNIX system since early times, but underwent steady evolution and divergence across various UNIX implementations, especially BSD versus System V. System V Release 4 greatly extended the API, in the process creating a new (parallel) <em>utmpx</em> structure and associated <span class="literal">utmpx</span> and <span class="literal">wtmpx</span> files. The letter <em>x</em> was likewise included in the names of header files and additional functions for processing these new files. Many other UNIX implementations also added their own extensions to the API.</p>
<p class="indent">In this chapter, we describe the Linux <em>utmpx</em> API, which is a hybrid of the BSD and System V implementations. Linux doesn&#8217;t follow System V in creating parallel <span class="literal">utmpx</span> and <span class="literal">wtmpx</span> files; instead, the <span class="literal">utmp</span> and <span class="literal">wtmp</span> files contain all of the required information. However, for compatibility with other UNIX implementations, Linux provides both the traditional <em>utmp</em> and the System V&#8211;derived <em>utmpx</em> APIs for accessing the contents of these files. On Linux, these two APIs return exactly the same information. (One of the few differences between the two APIs is that the <em>utmp</em> API contains reentrant versions of a few functions, while the <em>utmpx</em> API does not.) However, we confine our discussion to the <em>utmpx</em> interface, since that is the API specified in SUSv3 and is thus preferred for portability to other UNIX implementations.</p>
<p class="indent">The SUSv3 specification doesn&#8217;t cover all aspects of the <em>utmpx</em> API (e.g., the locations of the <span class="literal">utmp</span> and <span class="literal">wtmp</span> files are not specified). The precise contents of the login accounting files differ somewhat across implementations, and various implementations provide additional login accounting functions that are not specified in SUSv3.</p>
<div class="block">
<p class="noindent"><a href="ch17.xhtml#ch17">Chapter 17</a> of [<a href="bib.xhtml#bib27">Frisch, 2002</a>] summarizes some of the variations in the location and use of the <span class="literal">wtmp</span> and <span class="literal">utmp</span> files across different UNIX implementations. It also describes the use of the <em>ac(1)</em> command, which can be used to summarize login information from the <span class="literal">wtmp</span> file.</p>
</div>
<h3 class="h3" id="ch40lev1sec03"><strong>40.3 The <em>utmpx</em> Structure</strong></h3>
<p class="noindenta">The <span class="literal">utmp</span> and <span class="literal">wtmp</span> files consist of <em>utmpx</em> records. The <em>utmpx</em> structure is defined in <span class="literal">&lt;utmpx.h&gt;</span>, as shown in <a href="ch40.xhtml#ch40ex1">Listing 40-1</a>.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_819"/>The SUSv3 specification of the <em>utmpx</em> structure doesn&#8217;t include the <em>ut_host</em>, <em>ut_exit</em>, <em>ut_session</em>, or <em>ut_addr_v6</em> fields. The <em>ut_host</em> and <em>ut_exit</em> fields are present on most other implementations; <em>ut_session</em> is present on a few other implementations; and <em>ut_addr_v6</em> is Linux-specific. SUSv3 specifies the <em>ut_line</em> and <em>ut_user</em> fields, but leaves their lengths unspecified.</p>
<p class="indent">The <em>int32_t</em> data type used to define the <em>ut_addr_v6</em> field of the <em>utmpx</em> structure is a 32-bit integer.</p>
</div>
<p class="examplet"><a id="ch40ex1"/><strong>Listing 40-1:</strong> Definition of the <em>utmpx</em> structure</p>
<p class="programsli">______________________________________________________________________<br/><br/>#define _GNU_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Without _GNU_SOURCE the two field<br/>struct exit_status {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;names below are prepended by "__" */<br/>&#160;&#160;&#160;&#160;short e_termination;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Process termination status (signal) */<br/>&#160;&#160;&#160;&#160;short e_exit;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Process exit status */<br/>};<br/><br/>#define __UT_LINESIZE&#160;&#160;&#160;&#160;32<br/>#define __UT_NAMESIZE&#160;&#160;&#160;&#160;32<br/>#define __UT_HOSTSIZE&#160;&#160;&#160;256<br/><br/>struct utmpx {<br/>&#160;&#160;&#160;&#160;short ut_type;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Type of record */<br/>&#160;&#160;&#160;&#160;pid_t ut_pid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* PID of login process */<br/>&#160;&#160;&#160;&#160;char&#160;&#160;ut_line[__UT_LINESIZE];&#160;&#160;&#160;&#160;&#160;&#160;/* Terminal device name */<br/>&#160;&#160;&#160;&#160;char&#160;&#160;ut_id[4];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Suffix from terminal name, or<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ID field from inittab(5) */<br/>&#160;&#160;&#160;&#160;char&#160;&#160;ut_user[__UT_NAMESIZE];&#160;&#160;&#160;&#160;&#160;&#160;/* Username */<br/>&#160;&#160;&#160;&#160;char&#160;&#160;ut_host[__UT_HOSTSIZE];&#160;&#160;&#160;&#160;&#160;&#160;/* Hostname for remote login, or kernel<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;version for run-level messages */<br/>&#160;&#160;&#160;&#160;struct exit_status ut_exit;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Exit status of process marked<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;as DEAD_PROCESS (not filled<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;in by init(8) on Linux) */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;ut_session;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Session ID */<br/>&#160;&#160;&#160;&#160;struct timeval ut_tv;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Time when entry was made */<br/>&#160;&#160;&#160;&#160;int32_t ut_addr_v6[4];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* IP address of remote host (IPv4<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;address uses just ut_addr_v6[0],<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;with other elements set to 0) */<br/>&#160;&#160;&#160;&#160;char __unused[20];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Reserved for future use */<br/>};<br/>______________________________________________________________________</p>
<p class="noindent">Each of the string fields in the <em>utmpx</em> structure is null-terminated unless it completely fills the corresponding array.</p>
<p class="indent">For login processes, the information stored in the <em>ut_line</em> and <em>ut_id</em> fields is derived from the name of the terminal device. The <em>ut_line</em> field contains the complete filename of the terminal device. The <em>ut_id</em> field contains the suffix part of the filename&#8212;that is, the string following <em>tty</em>, <em>pts</em>, or <em>pty</em> (the last two are for System V&#8211;style and BSD-style pseudoterminals, respectively). Thus, for the terminal <span class="literal">/dev/tty2</span>, <em>ut_line</em> would be <em>tty2</em> and <em>ut_id</em> would be <em>2</em>.</p>
<p class="indent">In a windowing environment, some terminal emulators use the <em>ut_session</em> field to record the session ID for the terminal window. (Refer to <a href="ch34.xhtml#ch34lev1sec03">Section 34.3</a> for an explanation of session IDs.)</p>
<p class="indentb"><span epub:type="pagebreak" id="page_820"/>The <em>ut_type</em> field is an integer defining the type of record being written to the file. The following set of constants (with their corresponding numeric values shown in parentheses) can be used as values for this field:</p>
<p class="term"><span class="literal">EMPTY</span> (0)</p>
<p class="termlist">This record doesn&#8217;t contain valid accounting information.</p>
<p class="term"><span class="literal">RUN_LVL</span> (1)</p>
<p class="termlist">This record indicates a change in the system&#8217;s run-level during system startup or shutdown. (Information about run-levels can be found in the <em>init(8)</em> manual page.) The <span class="literal">_GNU_SOURCE</span> feature test macro must be defined in order to obtain the definition of this constant from <span class="literal">&lt;utmpx.h&gt;</span>.</p>
<p class="term"><span class="literal">BOOT_TIME</span> (2)</p>
<p class="termlist">This record contains the time of system boot in the <em>ut_tv</em> field. The usual author of <span class="literal">RUN_LVL</span> and <span class="literal">BOOT_TIME</span> records is <em>init</em>. These records are written to both the <span class="literal">utmp</span> file and the <span class="literal">wtmp</span> file.</p>
<p class="term"><span class="literal">NEW_TIME</span> (3)</p>
<p class="termlist">This record contains the new time after a system clock change, recorded in the <em>ut_tv</em> field.</p>
<p class="term"><span class="literal">OLD_TIME</span> (4)</p>
<p class="termlist">This record contains the old time before a system clock change, recorded in the <em>ut_tv</em> field. Records of type <span class="literal">OLD_TIME</span> and <span class="literal">NEW_TIME</span> are written to the <span class="literal">utmp</span> and <span class="literal">wtmp</span> files by the NTP (or a similar) daemon when it makes changes to the system clock.</p>
<p class="term"><span class="literal">INIT_PROCESS</span> (5)</p>
<p class="termlist">This is a record for a process spawned by <em>init</em>, such as a <em>getty</em> process. Refer to the <em>inittab(5)</em> manual page for details.</p>
<p class="term"><span class="literal">LOGIN_PROCESS</span> (6)</p>
<p class="termlist">This is a record for a session leader process for a user login, such as a <em>login(1)</em> process.</p>
<p class="term"><span class="literal">USER_PROCESS</span> (7)</p>
<p class="termlist">This is a record for a user process, usually a login session, with the username appearing in the <em>ut_user</em> field. The login session may have been started by <em>login(1)</em> or by some application offering a remote login facility, such as <em>ftp</em> or <em>ssh</em>.</p>
<p class="term"><span class="literal">DEAD_PROCESS</span> (8)</p>
<p class="termlist">This record identifies a process that has exited.</p>
<p class="noindentt">We show the numeric values of these constants because various applications depend on the constants having the above numerical order. For example, in the source code of the <em>agetty</em> program, we find checks such as the following:</p>
<p class="programs">utp-&gt;ut_type &gt;= INIT_PROCESS &#38;&#38; utp-&gt;ut_type &lt;= DEAD_PROCESS</p>
<p class="noindentb">Records of the type <span class="literal">INIT_PROCESS</span> usually correspond to invocations of <em>getty(8)</em> (or a similar program, such as <em>agetty(8)</em> or <em>mingetty(8)</em>). On system boot, the <em>init</em> process <span epub:type="pagebreak" id="page_821"/>creates a child for each terminal line and virtual console, and each child execs the <em>getty</em> program. The <em>getty</em> program opens the terminal, prompts the user for a login name, and then execs <em>login(1)</em>. After successfully validating the user and performing various other steps, <em>login</em> forks a child that execs the user&#8217;s login shell. The complete life of such a login session is represented by four records written to the <span class="literal">wtmp</span> file in the following order:</p>
<p class="bull">&#8226; an <span class="literal">INIT_PROCESS</span> record, written by <em>init</em>;</p>
<p class="bull">&#8226; a <span class="literal">LOGIN_PROCESS</span> record, written by <em>getty</em>;</p>
<p class="bull">&#8226; a <span class="literal">USER_PROCESS</span> record, written by <em>login</em>; and</p>
<p class="bull">&#8226; a <span class="literal">DEAD_PROCESS</span> record, written by <em>init</em> when it detects the death of the child <em>login</em> process (which occurs on user logout).</p>
<p class="noindentt">Further details on the operation of <em>getty</em> and <em>login</em> during user login can be found in <a href="ch09.xhtml#ch09">Chapter 9</a> of [<a href="bib.xhtml#bib94">Stevens &#38; Rago, 2005</a>].</p>
<div class="block">
<p class="noindent">Some versions of <em>init</em> spawn the <em>getty</em> process before updating the <span class="literal">wtmp</span> file. Consequently, <em>init</em> and <em>getty</em> race with each other to update the <span class="literal">wtmp</span> file, with the result that the <span class="literal">INIT_PROCESS</span> and <span class="literal">LOGIN_PROCESS</span> records may be written in the opposite order from that described in the main text.</p>
</div>
<h3 class="h3" id="ch40lev1sec04"><strong>40.4 Retrieving Information from the</strong> <span class="literal"><span class="codestrong">utmp</span></span> <strong>and</strong> <span class="literal"><span class="codestrong">wtmp</span></span> <strong>Files</strong></h3>
<p class="noindenta">The functions described in this section retrieve records from files containing <em>utmpx</em>-format records. By default, these functions use the standard <span class="literal">utmp</span> file, but this can be changed using the <em>utmpxname()</em> function (described below).</p>
<p class="indent">These functions employ the notion of a <em>current location</em> within the file from which they are retrieving records. This location is updated by each function.</p>
<p class="indent">The <em>setutxent()</em> function rewinds the <span class="literal">utmp</span> file to the beginning.</p>
<div class="box">
<p class="programsa">#include &lt;utmpx.h&gt;<br/><br/>void <span class="codestrong">setutxent</span>(void);</p>
</div>
<p class="noindent">Normally, we should call <em>setutxent()</em> before employing any of the <em>getutx*()</em> functions (described below). This prevents possible confusion that might result if some third-party function that we have called has previously made use of these functions. Depending on the task being performed, it may also be necessary to call <em>setutxent()</em> again at appropriate points later in a program.</p>
<p class="indent">The <em>setutxent()</em> function and the <em>getutx*()</em> functions open the <span class="literal">utmp</span> file if it is not already open. When we have finished using the file, we can close it with the <em>endutxent()</em> function.</p>
<div class="box">
<p class="programsa">#include &lt;utmpx.h&gt;<br/><br/>void <span class="codestrong">endutxent</span>(void);</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_822"/>The <em>getutxent()</em>, <em>getutxid()</em>, and <em>getutxline()</em> functions read a record from the <span class="literal">utmp</span> file and return a pointer to a (statically allocated) <em>utmpx</em> structure.</p>
<div class="box">
<p class="programsa">#include &lt;utmpx.h&gt;<br/><br/>struct utmpx *<span class="codestrong">getutxent</span>(void);<br/>struct utmpx *<span class="codestrong">getutxid</span>(const struct utmpx *<span class="font1">ut</span>);<br/>struct utmpx *<span class="codestrong">getutxline</span>(const struct utmpx *<span class="font1">ut</span>);</p>
<p class="right">All return a pointer to a statically allocated <em>utmpx</em> structure, or <span class="literal">NULL</span> if no matching record or EOF was encountered</p>
</div>
<p class="noindent">The <em>getutxent()</em> function retrieves the next sequential record from the <span class="literal">utmp</span> file. The <em>getutxid()</em> and <em>getutxline()</em> functions perform searches, starting from the current file location, for a record matching the criteria specified in the <em>utmpx</em> structure pointed to by the <em>ut</em> argument.</p>
<p class="indentb">The <em>getutxid()</em> function searches the <span class="literal">utmp</span> file for a record based on the values specified in the <em>ut_type</em> and <em>ut_id</em> fields of the <em>ut</em> argument:</p>
<p class="bull">&#8226; If the <em>ut_type</em> field is <span class="literal">RUN_LVL</span>, <span class="literal">BOOT_TIME</span>, <span class="literal">NEW_TIME</span>, or <span class="literal">OLD_TIME</span>, then <em>getutxid()</em> finds the next record whose <em>ut_type</em> field matches the specified value. (Records of these types don&#8217;t correspond to user logins.) This permits searches for records of changes to the system time and run-level.</p>
<p class="bull">&#8226; If the <em>ut_type</em> field is one of the remaining valid values (<span class="literal">INIT_PROCESS</span>, <span class="literal">LOGIN_PROCESS</span>, <span class="literal">USER_PROCESS</span>, or <span class="literal">DEAD_PROCESS</span>), then <em>getutxid()</em> finds the next record whose <em>ut_type</em> field matches <em>any</em> of these values and whose <em>ut_id</em> field matches that specified in its <em>ut</em> argument. This permits scanning the file for records corresponding to a particular terminal.</p>
<p class="noindentt">The <em>getutxline()</em> function searches forward for a record whose <em>ut_type</em> field is either <span class="literal">LOGIN_PROCESS</span> or <span class="literal">USER_PROCESS</span>, and whose <em>ut_line</em> field matches that specified in the <em>ut</em> argument. This is useful for finding records corresponding to user logins.</p>
<p class="indent">Both <em>getutxid()</em> and <em>getutxline()</em> return <span class="literal">NULL</span> if the search fails (i.e., end-of-file is encountered without finding a matching record).</p>
<p class="indent">On some UNIX implementations, <em>getutxline()</em> and <em>getutxid()</em> treat the static area used for returning the <em>utmpx</em> structure as a kind of cache. If they determine that the record placed in this cache by a previous <em>getutx*()</em> call matches the criteria specified in <em>ut</em>, then no file read is performed; the call simply returns the same record once more (SUSv3 permits this behavior). Therefore, to prevent the same record from being repeatedly returned when calling <em>getutxline()</em> and <em>getutxid()</em> within a loop, we must zero out this static data structure, using code such as the following:</p>
<p class="programs">struct utmpx *res = NULL;<br/><br/>/* Other code omitted */<br/><br/>if (res != NULL)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If 'res' was set via a previous call */<br/>&#160;&#160;&#160;&#160;memset(res, 0, sizeof(struct utmpx));<br/>res = getutxline(&#38;ut);</p>
<p class="noindent"><span epub:type="pagebreak" id="page_823"/>The <em>glibc</em> implementation doesn&#8217;t perform this type of caching, but we should nevertheless employ this technique for the sake of portability.</p>
<div class="block">
<p class="noindent">Because the <em>getutx*()</em> functions return a pointer to a statically allocated structure, they are not reentrant. The GNU C library provides reentrant versions of the traditional <em>utmp</em> functions (<em>getutent_r()</em>, <em>getutid_r()</em>, and <em>getutline_r()</em>), but doesn&#8217;t provide reentrant versions of their <em>utmpx</em> counterparts. (SUSv3 doesn&#8217;t specify the reentrant versions.)</p>
</div>
<p class="noindent">By default, all of the <em>getutx*()</em> functions work on the standard <span class="literal">utmp</span> file. If we want to use another file, such as the <span class="literal">wtmp</span> file, then we must first call <em>utmpxname()</em>, specifying the desired pathname.</p>
<div class="box">
<p class="programsa">#define _GNU_SOURCE<br/>#include &lt;utmpx.h&gt;<br/><br/>int <span class="codestrong">utmpxname</span>(const char *<span class="font1">file</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>utmpxname()</em> function merely records a copy of the pathname given to it. It doesn&#8217;t open the file, but does close any file previously opened by one of the other calls. This means that <em>utmpxname()</em> doesn&#8217;t return an error if an invalid pathname is specified. Instead, when one of the <em>getutx*()</em> functions is later called, it will return an error (i.e., <span class="literal">NULL</span>, with <em>errno</em> set to <span class="literal">ENOENT</span>) when it fails to open the file.</p>
<div class="block">
<p class="noindent">Although not specified in SUSv3, most UNIX implementations provide <em>utmpxname()</em> or the analogous <em>utmpname()</em> function.</p>
</div>
<h5 class="h5" id="ch40lev3sec01"><strong>Example program</strong></h5>
<p class="noindenta">The program in <a href="ch40.xhtml#ch40ex2">Listing 40-2</a> uses some of the functions described in this section to dump the contents of a <em>utmpx</em>-format file. The following shell session log demonstrates the results when we use this program to dump the contents of <span class="literal">/var/run/utmp</span> (the default used by these functions if <em>utmpxname()</em> is not called):</p>
<p class="programs">$ <span class="codestrong">./dump_utmpx</span><br/>user&#160;&#160;&#160;&#160;&#160;type&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PID line&#160;&#160;&#160;id&#160;&#160;host&#160;&#160;&#160;&#160;&#160;&#160;date/time<br/>LOGIN&#160;&#160;&#160;&#160;LOGIN_PR&#160;&#160;&#160;1761 tty1&#160;&#160;&#160;1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Sat Oct 23 09:29:37 2010<br/>LOGIN&#160;&#160;&#160;&#160;LOGIN_PR&#160;&#160;&#160;1762 tty2&#160;&#160;&#160;2&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Sat Oct 23 09:29:37 2010<br/>lynley&#160;&#160;&#160;USER_PR&#160;&#160;&#160;10482 tty3&#160;&#160;&#160;3&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Sat Oct 23 10:19:43 2010<br/>david&#160;&#160;&#160;&#160;USER_PR&#160;&#160;&#160;&#160;9664 tty4&#160;&#160;&#160;4&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Sat Oct 23 10:07:50 2010<br/>liz&#160;&#160;&#160;&#160;&#160;&#160;USER_PR&#160;&#160;&#160;&#160;1985 tty5&#160;&#160;&#160;5&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Sat Oct 23 10:50:12 2010<br/>mtk&#160;&#160;&#160;&#160;&#160;&#160;USER_PR&#160;&#160;&#160;10111 pts/0&#160;&#160;/0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Sat Oct 23 09:30:57 2010</p>
<p class="noindent">For brevity, we edited out much of the output produced by the program. The lines matching <span class="literal">tty1</span> to <span class="literal">tty5</span> are for logins on virtual consoles (<span class="literal">/dev/tty[1-6]</span>). The last line of output is for an <em>xterm</em> session on a pseudoterminal.</p>
<p class="indent">The following output produced by dumping <span class="literal">/var/log/wtmp</span> shows that when a user logs in and out, two records are written to the <span class="literal">wtmp</span> file. (We edited out all of <span epub:type="pagebreak" id="page_824"/>the other output produced by the program.) By searching sequentially through the <span class="literal">wtmp</span> file (using <em>getutxline()</em>), these records can be matched via the <em>ut_line</em> field.</p>
<p class="programs">$ <span class="codestrong">./dump_utmpx /var/log/wtmp</span><br/>user&#160;&#160;&#160;&#160;&#160;type&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PID line&#160;&#160;&#160;id&#160;&#160;host&#160;&#160;&#160;&#160;&#160;&#160;date/time<br/>lynley&#160;&#160;&#160;USER_PR&#160;&#160;&#160;&#160;10482 tty3&#160;&#160;&#160;3&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Sat Oct 23 10:19:43 2010<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;DEAD_PR&#160;&#160;&#160;&#160;10482 tty3&#160;&#160;&#160;3&#160;&#160;&#160;2.4.20-4G Sat Oct 23 10:32:54 2010</p>
<p class="examplet"><a id="ch40ex2"/><strong>Listing 40-2:</strong> Displaying the contents of a <em>utmpx</em>-format file</p>
<p class="programsli">____________________________________________________ <span class="codestrong">loginacct/dump_utmpx.c</span><br/><br/>#define _GNU_SOURCE<br/>#include &lt;time.h&gt;<br/>#include &lt;utmpx.h&gt;<br/>#include &lt;paths.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct utmpx *ut;<br/><br/>&#160;&#160;&#160;&#160;if (argc &gt; 1 &#38;&#38; strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s [utmp-pathname]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;if (argc &gt; 1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Use alternate file if supplied */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (utmpxname(argv[1]) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("utmpxname");<br/><br/>&#160;&#160;&#160;&#160;setutxent();<br/><br/>&#160;&#160;&#160;&#160;printf("user&#160;&#160;&#160;&#160;&#160;type&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PID line&#160;&#160;&#160;id&#160;&#160;host&#160;&#160;&#160;&#160;&#160;&#160;date/time\n");<br/><br/>&#160;&#160;&#160;&#160;while ((ut = getutxent()) != NULL) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Sequential scan to EOF */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%-8s ", ut-&gt;ut_user);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%-9.9s ",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(ut-&gt;ut_type == EMPTY) ?&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"EMPTY" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(ut-&gt;ut_type == RUN_LVL) ?&#160;&#160;&#160;&#160;&#160;&#160;&#160;"RUN_LVL" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(ut-&gt;ut_type == BOOT_TIME) ?&#160;&#160;&#160;&#160;&#160;"BOOT_TIME" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(ut-&gt;ut_type == NEW_TIME) ?&#160;&#160;&#160;&#160;&#160;&#160;"NEW_TIME" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(ut-&gt;ut_type == OLD_TIME) ?&#160;&#160;&#160;&#160;&#160;&#160;"OLD_TIME" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(ut-&gt;ut_type == INIT_PROCESS) ?&#160;&#160;"INIT_PR" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(ut-&gt;ut_type == LOGIN_PROCESS) ? "LOGIN_PR" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(ut-&gt;ut_type == USER_PROCESS) ?&#160;&#160;"USER_PR" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(ut-&gt;ut_type == DEAD_PROCESS) ?&#160;&#160;"DEAD_PR" : "???");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%5ld %-6.6s %-3.5s %-9.9s ", (long) ut-&gt;ut_pid,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ut-&gt;ut_line, ut-&gt;ut_id, ut-&gt;ut_host);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s", ctime((time_t *) &#38;(ut-&gt;ut_tv.tv_sec)));<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;endutxent();<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>____________________________________________________ <span class="codestrong">loginacct/dump_utmpx.c</span></p>
<h3 class="h3" id="ch40lev1sec05"><span epub:type="pagebreak" id="page_825"/><strong>40.5 Retrieving the Login Name: <em>getlogin()</em></strong></h3>
<p class="noindenta">The <em>getlogin()</em> function returns the name of the user logged in on the controlling terminal of the calling process. This function uses the information maintained in the <span class="literal">utmp</span> file.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>char *<span class="codestrong">getlogin</span>(void);</p>
<p class="right">Returns pointer to username string, or <span class="literal">NULL</span> on error</p>
</div>
<p class="noindent">The <em>getlogin()</em> function calls <em>ttyname()</em> (<a href="ch62.xhtml#ch62lev1sec10">Section 62.10</a>) to find the name of the terminal associated with the calling process&#8217;s standard input. It then searches the <span class="literal">utmp</span> file for a record whose <em>ut_line</em> value matches this terminal name. If a matching record is found, then <em>getlogin()</em> returns the <em>ut_user</em> string from that record.</p>
<p class="indent">If a match is not found or an error occurs, then <em>getlogin()</em> returns <span class="literal">NULL</span> and sets <em>errno</em> to indicate the error. One reason <em>getlogin()</em> may fail is that the process doesn&#8217;t have a terminal associated with its standard input (<span class="literal">ENOTTY</span>), perhaps because it is daemon. Another possibility is that this terminal session is not recorded in <span class="literal">utmp</span>; for example, some software terminal emulators don&#8217;t create entries in the <span class="literal">utmp</span> file.</p>
<p class="indent">Even in the (unusual) case where a user ID has multiple login names in <span class="literal">/etc/passwd</span>, <em>getlogin()</em> is able to return the actual username that was used to log in on this terminal because it relies on the <span class="literal">utmp</span> file. By contrast, using <em>getpwuid(getuid())</em> always retrieves the first matching record from <span class="literal">/etc/passwd</span>, regardless of the name that was used to log in.</p>
<div class="block">
<p class="noindent">A reentrant version of <em>getlogin()</em> is specified by SUSv3, in the form of <em>getlogin_r()</em>, and this function is provided by <em>glibc</em>.</p>
<p class="indent">The <span class="literal">LOGNAME</span> environment variable can also be used to find a user&#8217;s login name. However, the value of this variable can be changed by the user, which means that it can&#8217;t be used to securely identify a user.</p>
</div>
<h3 class="h3" id="ch40lev1sec06"><strong>40.6 Updating the</strong> <span class="literal"><span class="codestrong">utmp</span></span> <strong>and</strong> <span class="literal"><span class="codestrong">wtmp</span></span> <strong>Files for a Login Session</strong></h3>
<p class="noindentab">When writing an application that creates a login session (in the manner of, say, <em>login</em> or <em>sshd</em>), we should update the <span class="literal">utmp</span> and <span class="literal">wtmp</span> files as follows:</p>
<p class="bull">&#8226; On login, a record should be written to the <span class="literal">utmp</span> file to indicate that this user logged in. The application must check whether a record for this terminal already exists in the <span class="literal">utmp</span> file. If a previous record exists, it is overwritten; otherwise, a new record is appended to the file. Often, calling <em>pututxline()</em> (described shortly) is enough to ensure that these steps are correctly performed (see <a href="ch40.xhtml#ch40ex3">Listing 40-3</a> for an example). The output <em>utmpx</em> record should have at least the <em>ut_type</em>, <em>ut_user</em>, <em>ut_tv</em>, <em>ut_pid</em>, <em>ut_id</em>, and <em>ut_line</em> fields filled in. The <em>ut_type</em> field should be set to <span class="literal">USER_PROCESS</span>. The <em>ut_id</em> field should contain the suffix of the name of the device (i.e., the terminal or pseudoterminal) on which the user is logging in, and the <em>ut_line</em> field should contain the name of the login device, with the leading <span class="literal">/dev/</span> string removed. (Examples of the contents of these two fields are shown in the <span epub:type="pagebreak" id="page_826"/>sample runs of the program in <a href="ch40.xhtml#ch40ex2">Listing 40-2</a>.) A record containing exactly the same information is appended to the <span class="literal">wtmp</span> file.</p>
<div class="block">
<p class="noindent">The terminal name acts (via the <em>ut_line</em> and <em>ut_id</em> fields) as a unique key for records in the <span class="literal">utmp</span> file.</p>
</div>
<p class="bull">&#8226; On logout, the record previously written to the <span class="literal">utmp</span> file should be erased. This is done by creating a record with <em>ut_type</em> set to <span class="literal">DEAD_PROCESS</span>, and with the same <em>ut_id</em> and <em>ut_line</em> values as the record written during login, but with the <em>ut_user</em> field zeroed out. This record is written over the earlier record. A copy of the same record is appended to the <span class="literal">wtmp</span> file.</p>
<div class="block">
<p class="noindent">If we fail to clean up the <em>utmp</em> record on logout, perhaps because of a program crash, then, on the next reboot, <em>init</em> automatically cleans up the record, setting its <em>ut_type</em> to <span class="literal">DEAD_PROCESS</span> and zeroing out various other fields of the record.</p>
</div>
<p class="noindent">The <span class="literal">utmp</span> and <span class="literal">wtmp</span> files are normally protected so that only privileged users can perform updates on these files. The accuracy of <em>getlogin()</em> depends on the integrity of the <span class="literal">utmp</span> file. For this, as well as other reasons, the permissions on the <span class="literal">utmp</span> and <span class="literal">wtmp</span> files should never be set to allow writing by unprivileged users.</p>
<p class="indent">What qualifies as a login session? As we might expect, logins via <em>login</em>, <em>telnet</em>, and <em>ssh</em> are recorded in the login accounting files. Most <em>ftp</em> implementations also create login accounting records. However, are login accounting records created for each terminal window started on the system or for invocations of <em>su</em>, for example? The answer to that question varies across UNIX implementations.</p>
<div class="block">
<p class="noindent">Under some terminal emulator programs (e.g., <em>xterm</em>), command-line options or other mechanisms can be used to determine whether the program updates the login accounting files.</p>
</div>
<p class="noindent">The <em>pututxline()</em> function writes the <em>utmpx</em> structure pointed to by <em>ut</em> into the <span class="literal">/var/run/utmp</span> file (or an alternative file if <em>utmpxname()</em> was previously called).</p>
<div class="box">
<p class="programsa">#include &lt;utmpx.h&gt;<br/><br/>struct utmpx *<span class="codestrong">pututxline</span>(const struct utmpx *<span class="font1">ut</span>);</p>
<p class="right">Returns pointer to copy of successfully updated record on success, or <span class="literal">NULL</span> on error</p>
</div>
<p class="noindent">Before writing the record, <em>pututxline()</em> first uses <em>getutxid()</em> to search forward for a record that may be overwritten. If such a record is found, it is overwritten; otherwise, a new record is appended to the end of the file. In many cases, an application precedes a call to <em>pututxline()</em> by a call to one of the <em>getutx*()</em> functions, which sets the current file location to the correct record&#8212;that is, one matching the <em>getutxid()</em>-style criteria in the <em>utmpx</em> structure pointed to by <em>ut</em>. If <em>pututxline()</em> determines that this has occurred, it doesn&#8217;t call <em>getutxid()</em>.</p>
<div class="block">
<p class="noindent">If <em>pututxline()</em> makes an internal call to <em>getutxid()</em>, this call doesn&#8217;t change the static area used by the <em>getutx*()</em> functions to return the <em>utmpx</em> structure. SUSv3 requires this behavior from an implementation.</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_827"/>When updating the <span class="literal">wtmp</span> file, we simply open the file and append a record to it. Because this is a standard operation, <em>glibc</em> encapsulates it in the <em>updwtmpx()</em> function.</p>
<div class="box">
<p class="programsa">#define _GNU_SOURCE<br/>#include &lt;utmpx.h&gt;<br/><br/>void <span class="codestrong">updwtmpx</span>(const char *<span class="font1">wtmpx_file</span>, const struct utmpx *<span class="font1">ut</span>);</p>
</div>
<p class="noindent">The <em>updwtmpx()</em> function appends the <em>utmpx</em> record pointed to by <em>ut</em> to the file specified in <em>wtmpx_file</em>.</p>
<p class="indent">SUSv3 doesn&#8217;t specify <em>updwtmpx()</em>, and it appears on only a few other UNIX implementations. Other implementations provide related functions&#8212;<em>login(3)</em>, <em>logout(3)</em>, and <em>logwtmp(3)</em>&#8212;which are also in <em>glibc</em> and described in the manual pages. If such functions are not present, we need to write our own equivalents. (The implementation of these functions is not complex.)</p>
<h5 class="h5" id="ch40lev3sec02"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch40.xhtml#ch40ex3">Listing 40-3</a> uses the functions described in this section to update the <span class="literal">utmp</span> and <span class="literal">wtmp</span> files. This program performs the required updates to <span class="literal">utmp</span> and <span class="literal">wtmp</span> in order to log in the user named on the command line, and then, after sleeping a few seconds, log them out again. Normally, such actions would be associated with the creation and termination of a login session for a user. This program uses <em>ttyname()</em> to retrieve the name of the terminal device associated with a file descriptor. We describe <em>ttyname()</em> in <a href="ch62.xhtml#ch62lev1sec10">Section 62.10</a>.</p>
<p class="indent">The following shell session log demonstrates the operation of the program in <a href="ch40.xhtml#ch40ex3">Listing 40-3</a>. We assume privilege in order to be able to update the login accounting files, and then use the program to create a record for the user <em>mtk</em>:</p>
<p class="programs">$ <span class="codestrong">su</span><br/>Password:<br/># <span class="codestrong">./utmpx_login mtk</span><br/>Creating login entries in utmp and wtmp<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;using pid 1471, line pts/7, id /7<br/><span class="font1">Type Control-Z to suspend program</span><br/>[1]+&#160;&#160;Stopped&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;./utmpx_login mtk</p>
<p class="noindent">While the <em>utmpx_login</em> program was sleeping, we typed <em>Control-Z</em> to suspend the program and push it into the background. Next, we use the program in <a href="ch40.xhtml#ch40ex2">Listing 40-2</a> to examine the contents of the <span class="literal">utmp</span> file:</p>
<p class="programs"># <span class="codestrong">./dump_utmpx /var/run/utmp</span><br/>user&#160;&#160;&#160;&#160;&#160;type&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PID line&#160;&#160;&#160;id&#160;&#160;host&#160;&#160;&#160;&#160;&#160;&#160;date/time<br/>cecilia&#160;&#160;USER_PR&#160;&#160;&#160;&#160;&#160;249 tty1&#160;&#160;&#160;1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Fri Feb&#160;&#160;1 21:39:07 2008<br/>mtk&#160;&#160;&#160;&#160;&#160;&#160;USER_PR&#160;&#160;&#160;&#160;1471 pts/7&#160;&#160;/7&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Fri Feb&#160;&#160;1 22:08:06 2008<br/># <span class="codestrong">who</span><br/>cecilia&#160;&#160;tty1&#160;&#160;&#160;&#160;&#160;Feb&#160;&#160;1 21:39<br/>mtk&#160;&#160;&#160;&#160;&#160;&#160;pts/7&#160;&#160;&#160;&#160;Feb&#160;&#160;1 22:08</p>
<p class="noindent">Above, we used the <em>who(1)</em> command to show that the output of <em>who</em> derives from <span class="literal">utmp</span>.</p>
<p class="noindent"><span epub:type="pagebreak" id="page_828"/>Next we use our program to examine the contents of the <span class="literal">wtmp</span> file:</p>
<p class="programs"># <span class="codestrong">./dump_utmpx /var/log/wtmp</span><br/>user&#160;&#160;&#160;&#160;&#160;type&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PID line&#160;&#160;&#160;id&#160;&#160;host&#160;&#160;&#160;&#160;&#160;&#160;&#160;date/time<br/>cecilia&#160;&#160;USER_PR&#160;&#160;&#160;&#160;&#160;249 tty1&#160;&#160;&#160;1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Fri Feb&#160;&#160;1 21:39:07 2008<br/>mtk&#160;&#160;&#160;&#160;&#160;&#160;USER_PR&#160;&#160;&#160;&#160;1471 pts/7&#160;&#160;/7&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Fri Feb&#160;&#160;1 22:08:06 2008<br/># <span class="codestrong">last mtk</span><br/>mtk&#160;&#160;&#160;&#160;&#160;&#160;pts/7&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Fri Feb&#160;&#160;&#160;1 22:08&#160;&#160;&#160;still logged in</p>
<p class="noindent">Above, we used the <em>last(1)</em> command to show that the output of <em>last</em> derives from <span class="literal">wtmp</span>. (For brevity, we have edited the output of the <em>dump_utmpx</em> and <em>last</em> commands in this shell session log to remove lines of output that are irrelevant to our discussion.)</p>
<p class="indent">Next, we use the <em>fg</em> command to resume the <em>utmpx_login</em> program in the foreground. It subsequently writes logout records to the <span class="literal">utmp</span> and <span class="literal">wtmp</span> files.</p>
<p class="programs"># <span class="codestrong">fg</span><br/>./utmpx_login mtk<br/>Creating logout entries in utmp and wtmp</p>
<p class="noindent">We then once more examine the contents of the <span class="literal">utmp</span> file. We see that the <span class="literal">utmp</span> record was overwritten:</p>
<p class="programs"># <span class="codestrong">./dump_utmpx /var/run/utmp</span><br/>user&#160;&#160;&#160;&#160;&#160;type&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PID line&#160;&#160;&#160;id&#160;&#160;host&#160;&#160;&#160;&#160;&#160;&#160;&#160;date/time<br/>cecilia&#160;&#160;USER_PR&#160;&#160;&#160;&#160;&#160;249 tty1&#160;&#160;&#160;1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Fri Feb&#160;&#160;1 21:39:07 2008<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;DEAD_PR&#160;&#160;&#160;&#160;1471 pts/7&#160;&#160;/7&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Fri Feb&#160;&#160;1 22:09:09 2008<br/># <span class="codestrong">who</span><br/>cecilia&#160;&#160;tty1&#160;&#160;&#160;&#160;&#160;Feb&#160;&#160;1 21:39</p>
<p class="noindent">The final line of output shows that <em>who</em> ignored the <span class="literal">DEAD_PROCESS</span> record.</p>
<p class="indent">When we examine the <span class="literal">wtmp</span> file, we see that the <span class="literal">wtmp</span> record was superseded:</p>
<p class="programs"># <span class="codestrong">./dump_utmpx /var/log/wtmp</span><br/>user&#160;&#160;&#160;&#160;&#160;type&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PID line&#160;&#160;&#160;id&#160;&#160;host&#160;&#160;&#160;&#160;&#160;&#160;date/time<br/>cecilia&#160;&#160;USER_PR&#160;&#160;&#160;&#160;&#160;249 tty1&#160;&#160;&#160;1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Fri Feb&#160;&#160;1 21:39:07 2008<br/>mtk&#160;&#160;&#160;&#160;&#160;&#160;USER_PR&#160;&#160;&#160;&#160;1471 pts/7&#160;&#160;/7&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Fri Feb&#160;&#160;1 22:08:06 2008<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;DEAD_PR&#160;&#160;&#160;&#160;1471 pts/7&#160;&#160;/7&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Fri Feb&#160;&#160;1 22:09:09 2008<br/># <span class="codestrong">last mtk</span><br/>mtk&#160;&#160;&#160;&#160;&#160;&#160;pts/7&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Fri Feb&#160;&#160;1 22:08 - 22:09&#160;&#160;(00:01)</p>
<p class="noindent">The final line of output above demonstrates that <em>last</em> matches the login and logout records in <span class="literal">wtmp</span> to show the starting and ending times of the completed login session.</p>
<p class="examplet"><a id="ch40ex3"/><strong>Listing 40-3:</strong> Updating the <span class="literal">utmp</span> and <span class="literal">wtmp</span> files</p>
<p class="programsli">___________________________________________________ <span class="codestrong">loginacct/utmpx_login.c</span><br/><br/>#define _GNU_SOURCE<br/>#include &lt;time.h&gt;<br/>#include &lt;utmpx.h&gt;<br/>#include &lt;paths.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Definitions of _PATH_UTMP and _PATH_WTMP */<br/>#include "tlpi_hdr.h"<br/><br/><span epub:type="pagebreak" id="page_829"/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct utmpx ut;<br/>&#160;&#160;&#160;&#160;char *devName;<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s username [sleep-time]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;/* Initialize login record for utmp and wtmp files */<br/><br/>&#160;&#160;&#160;&#160;memset(&#38;ut, 0, sizeof(struct utmpx));<br/>&#160;&#160;&#160;&#160;ut.ut_type = USER_PROCESS;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* This is a user login */<br/>&#160;&#160;&#160;&#160;strncpy(ut.ut_user, argv[1], sizeof(ut.ut_user));<br/>&#160;&#160;&#160;&#160;if (time((time_t *) &#38;ut.ut_tv.tv_sec) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("time");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Stamp with current time */<br/>&#160;&#160;&#160;&#160;ut.ut_pid = getpid();<br/><br/>&#160;&#160;&#160;&#160;/* Set ut_line and ut_id based on the terminal associated with<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;'stdin'. This code assumes terminals named "/dev/[pt]t[sy]*".<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;The "/dev/" dirname is 5 characters; the "[pt]t[sy]" filename<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;prefix is 3 characters (making 8 characters in all). */<br/><br/>&#160;&#160;&#160;&#160;devName = ttyname(STDIN_FILENO);<br/>&#160;&#160;&#160;&#160;if (devName == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("ttyname");<br/>&#160;&#160;&#160;&#160;if (strlen(devName) &lt;= 8)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Should never happen */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("Terminal name is too short: %s", devName);<br/><br/>&#160;&#160;&#160;&#160;strncpy(ut.ut_line, devName + 5, sizeof(ut.ut_line));<br/>&#160;&#160;&#160;&#160;strncpy(ut.ut_id, devName + 8, sizeof(ut.ut_id));<br/><br/>&#160;&#160;&#160;&#160;printf("Creating login entries in utmp and wtmp\n");<br/>&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;using pid %ld, line %.*s, id %.*s\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) ut.ut_pid, (int) sizeof(ut.ut_line), ut.ut_line,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(int) sizeof(ut.ut_id), ut.ut_id);<br/><br/>&#160;&#160;&#160;&#160;setutxent();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Rewind to start of utmp file */<br/>&#160;&#160;&#160;&#160;if (pututxline(&#38;ut) == NULL)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Write login record to utmp */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("pututxline");<br/>&#160;&#160;&#160;&#160;updwtmpx(_PATH_WTMP, &#38;ut);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Append login record to wtmp */<br/><br/>&#160;&#160;&#160;&#160;/* Sleep a while, so we can examine utmp and wtmp files */<br/><br/>&#160;&#160;&#160;&#160;sleep((argc &gt; 2) ? getInt(argv[2], GN_NONNEG, "sleep-time") : 15);<br/><br/>&#160;&#160;&#160;&#160;/* Now do a "logout"; use values from previously initialized 'ut',<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;except for changes below */<br/><br/>&#160;&#160;&#160;&#160;ut.ut_type = DEAD_PROCESS;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Required for logout record */<br/>&#160;&#160;&#160;&#160;time((time_t *) &#38;ut.ut_tv.tv_sec);&#160;&#160;/* Stamp with logout time */<br/>&#160;&#160;&#160;&#160;memset(&#38;ut.ut_user, 0, sizeof(ut.ut_user));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Logout record has null username */<br/><br/>&#160;&#160;&#160;&#160;printf("Creating logout entries in utmp and wtmp\n");<br/>&#160;&#160;&#160;&#160;setutxent();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Rewind to start of utmp file */<br/>&#160;&#160;&#160;&#160;if (pututxline(&#38;ut) == NULL)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Overwrite previous utmp record */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("pututxline");<br/>&#160;&#160;&#160;&#160;updwtmpx(_PATH_WTMP, &#38;ut);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Append logout record to wtmp */<br/><br/>&#160;&#160;&#160;&#160;endutxent();<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>___________________________________________________ <span class="codestrong">loginacct/utmpx_login.c</span></p>
<h3 class="h3" id="ch40lev1sec07"><span epub:type="pagebreak" id="page_830"/><strong>40.7 The</strong> <span class="literal"><span class="codestrong">lastlog</span></span> <strong>File</strong></h3>
<p class="noindenta">The <span class="literal">lastlog</span> file records the time each user last logged in to the system. (This is different from the <span class="literal">wtmp</span> file, which records all logins and logouts by all users.) Among other things, the <span class="literal">lastlog</span> file allows the <em>login</em> program to inform users (at the start of a new login session) when they last logged in. In addition to updating <span class="literal">utmp</span> and <span class="literal">wtmp</span>, applications providing login services should also update <span class="literal">lastlog</span>.</p>
<p class="indent">As with the <span class="literal">utmp</span> and <span class="literal">wtmp</span> files, there is variation in the location and format of the <span class="literal">lastlog</span> file. (A few UNIX implementations don&#8217;t provide this file.) On Linux, this file resides at <span class="literal">/var/log/lastlog</span>, and a constant, <span class="literal">_PATH_LASTLOG</span>, is defined in <span class="literal">&lt;paths.h&gt;</span> to point to this location. Like the <span class="literal">utmp</span> and <span class="literal">wtmp</span> files, the <span class="literal">lastlog</span> file is normally protected so that it can be read by all users but can be updated only by privileged processes.</p>
<p class="indent">The records in the <span class="literal">lastlog</span> file have the following format (defined in <span class="literal">&lt;lastlog.h&gt;</span>):</p>
<p class="programs">#define UT_NAMESIZE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;32<br/>#define UT_HOSTSIZE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;256<br/><br/>struct lastlog {<br/>&#160;&#160;&#160;&#160;time_t ll_time;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Time of last login */<br/>&#160;&#160;&#160;&#160;char&#160;&#160;&#160;ll_line[UT_NAMESIZE];&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Terminal for remote login */<br/>&#160;&#160;&#160;&#160;char&#160;&#160;&#160;ll_host[UT_HOSTSIZE];&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Hostname for remote login */<br/>};</p>
<p class="noindent">Note that these records don&#8217;t include a username or user ID. Instead, the <span class="literal">lastlog</span> file consists of a series of records that are indexed by user ID. Thus, to find the <span class="literal">lastlog</span> record for user ID 1000, we would seek to byte <em>(1000 * sizeof(struct lastlog))</em> of the file. This is demonstrated in <a href="ch40.xhtml#ch40ex4">Listing 40-4</a>, a program that allows us to view the <span class="literal">lastlog</span> records for the user(s) listed on its command line. This is similar to the functionality offered by the <em>lastlog(1)</em> command. Here is an example of the output produced by running this program:</p>
<p class="programs">$ <span class="codestrong">./view_lastlog annie paulh</span><br/>annie&#160;&#160;&#160;&#160;tty2&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Mon Jan 17 11:00:12 2011<br/>paulh&#160;&#160;&#160;&#160;pts/11&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Sat Aug 14 09:22:14 2010</p>
<p class="noindent">Performing updates on <span class="literal">lastlog</span> is similarly a matter of opening the file, seeking to the correct location, and performing a write.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_831"/>Since the <span class="literal">lastlog</span> file is indexed by user ID, it is not possible to distinguish logins under different usernames that have the same user ID. (In <a href="ch08.xhtml#ch08lev1sec01">Section 8.1</a>, we noted that it is possible, though unusual, to have multiple login names with the same user ID.)</p>
</div>
<p class="examplet"><a id="ch40ex4"/><strong>Listing 40-4:</strong> Displaying information from the <span class="literal">lastlog</span> file</p>
<p class="programsli">__________________________________________________ <span class="codestrong">loginacct/view_lastlog.c</span><br/><br/>#include &lt;time.h&gt;<br/>#include &lt;lastlog.h&gt;<br/>#include &lt;paths.h&lt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Definition of _PATH_LASTLOG */<br/>#include &lt;fcntl.h&gt;<br/>#include "ugid_functions.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declaration of userIdFromName() */<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct lastlog llog;<br/>&#160;&#160;&#160;&#160;int fd, j;<br/>&#160;&#160;&#160;&#160;uid_t uid;<br/><br/>&#160;&#160;&#160;&#160;if (argc &gt; 1 &#38;&#38; strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s [username...]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;fd = open(_PATH_LASTLOG, O_RDONLY);<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open");<br/><br/>&#160;&#160;&#160;&#160;for (j = 1; j &lt; argc; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;uid = userIdFromName(argv[j]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (uid == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("No such user: %s\n", argv[j]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (lseek(fd, uid * sizeof(struct lastlog), SEEK_SET) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("lseek");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (read(fd, &#38;llog, sizeof(struct lastlog)) &lt;= 0) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("read failed for %s\n", argv[j]);&#160;&#160;&#160;&#160;/* EOF or error */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%-8.8s %-6.6s %-20.20s %s", argv[j], llog.ll_line,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;llog.ll_host, ctime((time_t *) &#38;llog.ll_time));<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;close(fd);<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>__________________________________________________ <span class="codestrong">loginacct/view_lastlog.c</span></p>
<h3 class="h3" id="ch40lev1sec08"><span epub:type="pagebreak" id="page_832"/><strong>40.8 Summary</strong></h3>
<p class="noindenta">Login accounting records the users currently logged in, as well as all past logins. This information is maintained in three files: the <span class="literal">utmp</span> file, which maintains a record of all currently logged-in users; the <span class="literal">wtmp</span> file, which is an audit trail of all logins and logouts; and the <span class="literal">lastlog</span> file, which records the time of last login for each user. Various commands, such as <em>who</em> and <em>last</em>, use the information in these files.</p>
<p class="indent">The C library provides functions to retrieve and update the information in the login accounting files. Applications providing login services should use these functions to update the login accounting files, so that commands depending on this information operate correctly.</p>
<h5 class="h5" id="ch40lev3sec03"><strong>Further information</strong></h5>
<p class="noindenta">Aside from the <em>utmp(5)</em> manual page, the most useful place to find further information about the login accounting functions is in the source code of the various applications that use these functions. See, for example, the sources of <em>mingetty</em> (or <em>agetty</em>), <em>login</em>, <em>init</em>, <em>telnet</em>, <em>ssh</em>, and <em>ftp</em>.</p>
<h3 class="h3" id="ch40lev1sec09"><strong>40.9 Exercises</strong></h3>
<p class="exer"><a id="ch40exe1"/><strong>40-1.</strong>&#160;&#160;&#160;Implement <em>getlogin()</em>. As noted in <a href="ch40.xhtml#ch40lev1sec05">Section 40.5</a>, <em>getlogin()</em> may not work correctly for processes running under some software terminal emulators; in that case, test from a virtual console instead.</p>
<p class="exer"><a id="ch40exe2"/><strong>40-2.</strong>&#160;&#160;&#160;Modify the program in <a href="ch40.xhtml#ch40ex3">Listing 40-3</a> (<span class="literal">utmpx_login.c</span>) so that it updates the <span class="literal">lastlog</span> file in addition to the <span class="literal">utmp</span> and <span class="literal">wtmp</span> files.</p>
<p class="exer"><a id="ch40exe3"/><strong>40-3.</strong>&#160;&#160;&#160;Read the manual pages for <em>login(3)</em>, <em>logout(3)</em>, and <em>logwtmp(3)</em>. Implement these functions.</p>
<p class="exer"><a id="ch40exe4"/><strong>40-4.</strong>&#160;&#160;&#160;Implement a simple version of <em>who(1)</em>.</p>
</body>
</html>
