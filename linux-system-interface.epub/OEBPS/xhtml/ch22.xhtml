<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch22"><span epub:type="pagebreak" id="page_447"/><strong><span class="big">22</span></strong><br/><strong>SIGNALS: ADVANCED FEATURES</strong></h2>
<p class="noindentab">This chapter completes the discussion of signals that we began in <a href="ch20.xhtml#ch20">Chapter 20</a>, covering a number of more advanced topics, including the following:</p>
<p class="bull">&#8226; core dump files;</p>
<p class="bull">&#8226; special cases regarding signal delivery, disposition, and handling;</p>
<p class="bull">&#8226; synchronous and asynchronous generation of signals;</p>
<p class="bull">&#8226; when and in what order signals are delivered;</p>
<p class="bull">&#8226; realtime signals;</p>
<p class="bull">&#8226; the use of <em>sigsuspend(</em>) to set the process signal mask and wait for a signal to arrive;</p>
<p class="bull">&#8226; the use of <em>sigwaitinfo()</em> (and <em>sigtimedwait()</em>) to synchronously wait for a signal to arrive;</p>
<p class="bull">&#8226; the use of <em>signalfd()</em> to receive a signal via a file descriptor; and</p>
<p class="bull">&#8226; the older BSD and System V signal APIs.</p>
<h3 class="h3" id="ch22lev1sec01"><span epub:type="pagebreak" id="page_448"/><strong>22.1 Core Dump Files</strong></h3>
<p class="noindenta">Certain signals cause a process to create a core dump and terminate (<a href="ch20.xhtml#ch20table1">Table 20-1</a>, <a href="ch20.xhtml#page_396">page 396</a>). A core dump is a file containing a memory image of the process at the time it terminated. (The term <em>core</em> derives from an old memory technology.) This memory image can be loaded into a debugger in order to examine the state of a program&#8217;s code and data at the moment when the signal arrived.</p>
<p class="indent">One way of causing a program to produce a core dump is to type the <em>quit</em> character (usually <em>Control-\</em>), which causes the <span class="literal">SIGQUIT</span> signal to be generated:</p>
<p class="programs">$ <span class="codestrong">ulimit -c unlimited</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Explained in main text</span><br/>$ <span class="codestrong">sleep 30</span><br/><span class="font1">Type Control-\</span><br/>Quit (core dumped)<br/>$ <span class="codestrong">ls -l core</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Shows core dump file for sleep(1)</span><br/>-rw-------&#160;&#160;&#160;1 mtk&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;57344 Nov 30 13:39 core</p>
<p class="noindent">In this example, the message <em>Quit (core dumped)</em> is printed by the shell, which detects that its child (the process running <em>sleep</em>) was killed by <span class="literal">SIGQUIT</span> and did a core dump.</p>
<p class="indent">The core dump file was created in the working directory of the process, with the name <span class="literal">core</span>. This is the default location and name for a core dump file; shortly, we explain how these defaults can be changed.</p>
<div class="block">
<p class="noindent">Many implementations provide a tool (e.g., <em>gcore</em> on FreeBSD and Solaris) to obtain a core dump of a running process. Similar functionality is available on Linux by attaching to a running process using <em>gdb</em> and then using the <em>gcore</em> command.</p>
</div>
<h5 class="h5" id="ch22lev3sec01"><strong>Circumstances in which core dump files are not produced</strong></h5>
<p class="noindentab">A core dump is not produced in the following circumstances:</p>
<p class="bull">&#8226; The process doesn&#8217;t have permission to write the core dump file. This could happen because the process doesn&#8217;t have write permission for the directory in which the core dump file is to be created, or because a file with the same name already exists and either is not writable or is not a regular file (e.g., it is a directory or a symbolic link).</p>
<p class="bull">&#8226; A regular file with the same name already exists, and is writable, but there is more than one (hard) link to the file.</p>
<p class="bull">&#8226; The directory in which the core dump file is to be created doesn&#8217;t exist.</p>
<p class="bull">&#8226; The process resource limit on the size of a core dump file is set to 0. This limit, <span class="literal">RLIMIT_CORE</span>, is discussed in more detail in <a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a>. In the example above, we used the <em>ulimit</em> command (<em>limit</em> in the C shell) to ensure that there is no limit on the size of <span class="literal">core</span> files.</p>
<p class="bull">&#8226; The process resource limit on the size of a file that may be produced by the process is set to 0. We describe this limit, <span class="literal">RLIMIT_FSIZE</span>, in <a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a>.</p>
<p class="bull">&#8226; The binary executable file that the process is executing doesn&#8217;t have read permission enabled. This prevents users from using a core dump to obtain a copy of the code of a program that they would otherwise be unable to read.</p>
<p class="bull"><span epub:type="pagebreak" id="page_449"/>&#8226; The file system on which the current working directory resides is mounted read-only, is full, or has run out of i-nodes. Alternatively, the user has reached their quota limit on the file system.</p>
<p class="bull">&#8226; Set-user-ID (set-group-ID) programs executed by a user other than the file owner (group owner) don&#8217;t generate core dumps. This prevents malicious users from dumping the memory of a secure program and examining it for sensitive information such as passwords.</p>
<div class="block">
<p class="noindent">Using the <span class="literal">PR_SET_DUMPABLE</span> operation of the Linux-specific <em>prctl()</em> system call, we can set the <em>dumpable</em> flag for a process, so that when a set-user-ID (set-group-ID) program is run by a user other than the owner (group owner), a core dump can be produced. The <span class="literal">PR_SET_DUMPABLE</span> operation is available from Linux 2.4 onward. See the <em>prctl(2)</em> manual page for further details. In addition, since kernel 2.6.13, the <span class="literal">/proc/sys/fs/suid_dumpable</span> file provides system-wide control over whether or not set-user-ID and set-group-ID processes produce core dumps. For details, see the <em>proc(5)</em> manual page.</p>
</div>
<p class="noindent">Since kernel 2.6.23, the Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/coredump_filter</span> can be used on a per-process basis to determine which types of memory mappings are written to a core dump file. (We explain memory mappings in <a href="ch49.xhtml#ch49">Chapter 49</a>.) The value in this file is a mask of four bits corresponding to the four types of memory mappings: private anonymous mappings, private file mappings, shared anonymous mappings, and shared file mappings. The default value of the file provides traditional Linux behavior: only private anonymous and shared anonymous mappings are dumped. See the <em>core(5)</em> manual page for further details.</p>
<h5 class="h5" id="ch22lev3sec02"><strong>Naming the core dump file:</strong> <span class="literal"><span class="codestrong">/proc/sys/kernel/core_pattern</span></span></h5>
<p class="noindenta">Starting with Linux 2.6, the format string contained in the Linux-specific <span class="literal">/proc/sys/kernel/core_pattern</span> file controls the naming of all core dump files produced on the system. By default, this file contains the string <em>core</em>. A privileged user can define this file to include any of the format specifiers shown in <a href="ch22.xhtml#ch22table1">Table 22-1</a>. These format specifiers are replaced by the value indicated in the right column of the table. Additionally, the string may include slashes (<span class="literal">/</span>). In other words, we can control not just the name of the core file, but also the (absolute or relative) directory in which it is created. After all format specifiers have been replaced, the resulting pathname string is truncated to a maximum of 128 characters (64 characters before Linux 2.6.19).</p>
<p class="indent">Since kernel 2.6.19, Linux supports an additional syntax in the <span class="literal">core_pattern</span> file. If this file contains a string starting with the pipe symbol (<span class="literal">|</span>), then the remaining characters in the file are interpreted as a program&#8212;with optional arguments that may include the <span class="literal">%</span> specifiers shown in <a href="ch22.xhtml#ch22table1">Table 22-1</a>&#8212;that is to be executed when a process dumps core. The core dump is written to the standard input of that program instead of to a file. See the <em>core(5)</em> manual page for further details.</p>
<div class="block">
<p class="noindent">Some other UNIX implementations provide facilities similar to <span class="literal">core_pattern</span>. For example, in BSD derivatives, the program name is appended to the filename, thus <span class="literal">core.</span><em>progname</em>. Solaris provides a tool (<em>coreadm</em>) that allows the user to choose the filename and directory where core dump files are placed.</p>
</div>
<p class="tablecap"><span epub:type="pagebreak" id="page_450"/><a id="ch22table1"/><strong>Table 22-1:</strong> Format specifiers for <span class="literal">/proc/sys/kernel/core_pattern</span></p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Specifier</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Replaced by</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">%c</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Core file size soft resource limit (bytes; since Linux 2.6.24)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">%e</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Executable filename (without path prefix)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">%g</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Real group ID of dumped process</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">%h</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Name of host system</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">%p</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Process ID of dumped process</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">%s</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Number of signal that terminated process</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">%t</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Time of dump, in seconds since the Epoch</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">%u</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Real user ID of dumped process</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="tablec"><span class="literal">%%</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">A single <span class="literal">%</span> character</p></td>
</tr>
</tbody>
</table>
<h3 class="h3" id="ch22lev1sec02"><strong>22.2 Special Cases for Delivery, Disposition, and Handling</strong></h3>
<p class="noindenta">For certain signals, special rules apply regarding delivery, disposition, and handling, as described in this section.</p>
<h5 class="h5" id="ch22lev3sec03"><span class="literal"><span class="codestrong">SIGKILL</span></span> <strong>and</strong> <span class="literal"><span class="codestrong">SIGSTOP</span></span></h5>
<p class="noindenta">It is not possible to change the default action for <span class="literal">SIGKILL</span>, which always terminates a process, and <span class="literal">SIGSTOP</span>, which always stops a process. Both <em>signal()</em> and <em>sigaction()</em> return an error on attempts to change the disposition of these signals. These two signals also can&#8217;t be blocked. This is a deliberate design decision. Disallowing changes to the default actions of these signals means that they can always be used to kill or stop a runaway process.</p>
<h5 class="h5" id="ch22lev3sec04"><span class="literal"><span class="codestrong">SIGCONT</span></span> <strong>and stop signals</strong></h5>
<p class="noindenta">As noted earlier, the <span class="literal">SIGCONT</span> signal is used to continue a process previously stopped by one of the stop signals (<span class="literal">SIGSTOP</span>, <span class="literal">SIGTSTP</span>, <span class="literal">SIGTTIN</span>, and <span class="literal">SIGTTOU</span>). Because of their unique purpose, in certain situations the kernel deals with these signals differently from other signals.</p>
<p class="indent">If a process is currently stopped, the arrival of a <span class="literal">SIGCONT</span> signal always causes the process to resume, even if the process is currently blocking or ignoring <span class="literal">SIGCONT</span>. This feature is necessary because it would otherwise be impossible to resume such stopped processes. (If the stopped process was blocking <span class="literal">SIGCONT</span>, and had established a handler for <span class="literal">SIGCONT</span>, then, after the process is resumed, the handler is invoked only when <span class="literal">SIGCONT</span> is later unblocked.)</p>
<div class="block">
<p class="noindent">If any other signal is sent to a stopped process, the signal is not actually delivered to the process until it is resumed via receipt of a <span class="literal">SIGCONT</span> signal. The one exception is <span class="literal">SIGKILL</span>, which always kills a process&#8212;even one that is currently stopped.</p>
</div>
<p class="noindent">Whenever <span class="literal">SIGCONT</span> is delivered to a process, any pending stop signals for the process are discarded (i.e., the process never sees them). Conversely, if any of the stop signals is delivered to a process, then any pending <span class="literal">SIGCONT</span> signal is automatically discarded. These steps are taken in order to prevent the action of a <span class="literal">SIGCONT</span> signal from being subsequently undone by a stop signal that was actually sent beforehand, and vice versa.</p>
<h5 class="h5" id="ch22lev3sec05"><span epub:type="pagebreak" id="page_451"/><strong>Don&#8217;t change the disposition of ignored terminal-generated signals</strong></h5>
<p class="noindenta">If, at the time it was execed, a program finds that the disposition of a terminal-generated signal has been set to <span class="literal">SIG_IGN</span> (ignore), then generally the program should not attempt to change the disposition of the signal. This is not a rule enforced by the system, but rather a convention that should be followed when writing applications. We explain the reasons for this in <a href="ch34.xhtml#ch34lev2sec05">Section 34.7.3</a>. The signals for which this convention is relevant are <span class="literal">SIGHUP</span>, <span class="literal">SIGINT</span>, <span class="literal">SIGQUIT</span>, <span class="literal">SIGTTIN</span>, <span class="literal">SIGTTOU</span>, and <span class="literal">SIGTSTP</span>.</p>
<h3 class="h3" id="ch22lev1sec03"><strong>22.3 Interruptible and Uninterruptible Process Sleep States</strong></h3>
<p class="noindentab">We need to add a proviso to our earlier statement that <span class="literal">SIGKILL</span> and <span class="literal">SIGSTOP</span> always act immediately on a process. At various times, the kernel may put a process to sleep, and two sleep states are distinguished:</p>
<p class="bull">&#8226; <span class="literal">TASK_INTERRUPTIBLE</span>: The process is waiting for some event. For example, it is waiting for terminal input, for data to be written to a currently empty pipe, or for the value of a System V semaphore to be increased. A process may spend an arbitrary length of time in this state. If a signal is generated for a process in this state, then the operation is interrupted and the process is woken up by the delivery of a signal. When listed by <em>ps(1)</em>, processes in the <span class="literal">TASK_INTERRUPTIBLE</span> state are marked by the letter <em>S</em> in the STAT (process state) field.</p>
<p class="bull">&#8226; <span class="literal">TASK_UNINTERRUPTIBLE</span>: The process is waiting on certain special classes of event, such as the completion of a disk I/O. If a signal is generated for a process in this state, then the signal is not delivered until the process emerges from this state. Processes in the <span class="literal">TASK_UNINTERRUPTIBLE</span> state are listed by <em>ps(1)</em> with a <em>D</em> in the STAT field.</p>
<p class="noindentt">Because a process normally spends only very brief periods in the <span class="literal">TASK_UNINTERRUPTIBLE</span> state, the fact that a signal is delivered only when the process leaves this state is invisible. However, in rare circumstances, a process may remain hung in this state, perhaps as the result of a hardware failure, an NFS problem, or a kernel bug. In such cases, <span class="literal">SIGKILL</span> won&#8217;t terminate the hung process. If the underlying problem can&#8217;t otherwise be resolved, then we must restart the system in order to eliminate the process.</p>
<p class="indentb">The <span class="literal">TASK_INTERRUPTIBLE</span> and <span class="literal">TASK_UNINTERRUPTIBLE</span> states are present on most UNIX implementations. Starting with kernel 2.6.25, Linux adds a third state to address the hanging process problem just described:</p>
<p class="bull">&#8226; <span class="literal">TASK_KILLABLE</span>: This state is like <span class="literal">TASK_UNINTERRUPTIBLE</span>, but wakes the process if a fatal signal (i.e., one that would kill the process) is received. By converting relevant parts of the kernel code to use this state, various scenarios where a hung process requires a system restart can be avoided. Instead, the process can be killed by sending it a fatal signal. The first piece of kernel code to be converted to use <span class="literal">TASK_KILLABLE</span> was NFS.</p>
<h3 class="h3" id="ch22lev1sec04"><span epub:type="pagebreak" id="page_452"/><strong>22.4 Hardware-Generated Signals</strong></h3>
<p class="noindentab"><span class="literal">SIGBUS</span>, <span class="literal">SIGFPE</span>, <span class="literal">SIGILL</span>, and <span class="literal">SIGSEGV</span> can be generated as a consequence of a hardware exception or, less usually, by being sent by <em>kill()</em>. In the case of a hardware exception, SUSv3 specifies that the behavior of a process is undefined if it returns from a handler for the signal, or if it ignores or blocks the signal. The reasons for this are as follows:</p>
<p class="bull">&#8226; <em>Returning from the signal handler</em>: Suppose that a machine-language instruction generates one of these signals, and a signal handler is consequently invoked. On normal return from the handler, the program attempts to resume execution at the point where it was interrupted. But this is the very instruction that generated the signal in the first place, so the signal is generated once more. The consequence is usually that the program goes into an infinite loop, repeatedly calling the signal handler.</p>
<p class="bull">&#8226; <em>Ignoring the signal</em>: It makes little sense to ignore a hardware-generated signal, as it is unclear how a program should continue execution after, say, an arithmetic exception. When one of these signals is generated as a consequence of a hardware exception, Linux forces its delivery, even if the program has requested that the signal be ignored.</p>
<p class="bull">&#8226; <em>Blocking the signal</em>: As with the previous case, it makes little sense to block a hardware-generated signal, as it is unclear how a program should then continue execution. On Linux 2.4 and earlier, the kernel simply ignores attempts to block a hardware-generated signal; the signal is delivered to the process anyway, and then either terminates the process or is caught by a signal handler, if one has been established. Starting with Linux 2.6, if the signal is blocked, then the process is always immediately killed by that signal, even if the process has installed a handler for the signal. (The rationale for the Linux 2.6 change in the treatment of blocked hardware-generated signals was that the Linux 2.4 behavior hid bugs and could cause deadlocks in threaded programs.)</p>
<div class="block">
<p class="noindent">The <span class="literal">signals/demo_SIGFPE.c</span> program in the source code distribution for this book can be used to demonstrate the results of ignoring or blocking <span class="literal">SIGFPE</span> or catching the signal with a handler that performs a normal return.</p>
</div>
<p class="noindent">The correct way to deal with hardware-generated signals is either to accept their default action (process termination) or to write handlers that don&#8217;t perform a normal return. Other than returning normally, a handler can complete execution by calling <em>_exit()</em> to terminate the process or by calling <em>siglongjmp()</em> (<a href="ch21.xhtml#ch21lev2sec04">Section 21.2.1</a>) to ensure that control passes to some point in the program other than the instruction that generated the signal.</p>
<h3 class="h3" id="ch22lev1sec05"><strong>22.5 Synchronous and Asynchronous Signal Generation</strong></h3>
<p class="noindenta">We have already seen that a process generally can&#8217;t predict when it will receive a signal. We now need to qualify this observation by distinguishing between <em>synchronous</em> and <em>asynchronous</em> signal generation.</p>
<p class="indent"><span epub:type="pagebreak" id="page_453"/>The model we have implicitly considered so far is <em>asynchronous</em> signal generation, in which the signal is sent either by another process or generated by the kernel for an event that occurs independently of the execution of the process (e.g., the user types the <em>interrupt</em> character or a child of this process terminates). For asynchronously generated signals, the earlier statement that a process can&#8217;t predict when the signal will be delivered holds true.</p>
<p class="indentb">However, in some cases, a signal is generated while the process itself is executing. We have already seen two examples of this:</p>
<p class="bull">&#8226; The hardware-generated signals (<span class="literal">SIGBUS</span>, <span class="literal">SIGFPE</span>, <span class="literal">SIGILL</span>, <span class="literal">SIGSEGV</span>, and <span class="literal">SIGEMT</span>) described in <a href="ch22.xhtml#ch22lev1sec04">Section 22.4</a> are generated as a consequence of executing a specific machine-language instruction that results in a hardware exception.</p>
<p class="bull">&#8226; A process can use <em>raise()</em>, <em>kill()</em>, or <em>killpg()</em> to send a signal to itself.</p>
<p class="noindentt">In these cases, the generation of the signal is <em>synchronous</em>&#8212;the signal is delivered immediately (unless it is blocked, but see <a href="ch22.xhtml#ch22lev1sec04">Section 22.4</a> for a discussion of what happens when blocking hardware-generated signals). In other words, the earlier statement about the unpredictability of the delivery of a signal doesn&#8217;t apply. For synchronously generated signals, delivery is predictable and reproducible.</p>
<p class="indent">Note that synchronicity is an attribute of how a signal is generated, rather than of the signal itself. All signals may be generated synchronously (e.g., when a process sends itself a signal using <em>kill()</em>) or asynchronously (e.g., when the signal is sent by another process using <em>kill()</em>).</p>
<h3 class="h3" id="ch22lev1sec06"><strong>22.6 Timing and Order of Signal Delivery</strong></h3>
<p class="noindenta">As the first topic of this section, we consider exactly when a pending signal is delivered. We then consider what happens if multiple pending blocked signals are simultaneously unblocked.</p>
<h5 class="h5" id="ch22lev3sec06"><strong>When is a signal delivered?</strong></h5>
<p class="noindenta">As noted in <a href="ch22.xhtml#ch22lev1sec05">Section 22.5</a>, synchronously generated signals are delivered immediately. For example, a hardware exception triggers an immediate signal, and when a process sends itself a signal using <em>raise()</em>, the signal is delivered before the <em>raise()</em> call returns.</p>
<p class="indentb">When a signal is generated asynchronously, there may be a (small) delay while the signal is pending between the time when it was generated and the time it is actually delivered, even if we have not blocked the signal. The reason for this is that the kernel delivers a pending signal to a process only at the next switch from kernel mode to user mode while executing that process. In practice, this means the signal is delivered at one of the following times:</p>
<p class="bull">&#8226; when the process is rescheduled after it earlier timed out (i.e., at the start of a time slice); or</p>
<p class="bull">&#8226; at completion of a system call (delivery of the signal may cause a blocking system call to complete prematurely).</p>
<h5 class="h5" id="ch22lev3sec07"><span epub:type="pagebreak" id="page_454"/><strong>Order of delivery of multiple unblocked signals</strong></h5>
<p class="noindenta">If a process has multiple pending signals that are unblocked using <em>sigprocmask()</em>, then all of these signals are immediately delivered to the process.</p>
<p class="indent">As currently implemented, the Linux kernel delivers the signals in ascending order. For example, if pending <span class="literal">SIGINT</span> (signal 2) and <span class="literal">SIGQUIT</span> (signal 3) signals were both simultaneously unblocked, then the <span class="literal">SIGINT</span> signal would be delivered before <span class="literal">SIGQUIT</span>, regardless of the order in which the two signals were generated.</p>
<p class="indent">We can&#8217;t, however, rely on (standard) signals being delivered in any particular order, since SUSv3 says that the delivery order of multiple signals is implementation-defined. (This statement applies only to standard signals. As we&#8217;ll see in <a href="ch22.xhtml#ch22lev1sec08">Section 22.8</a>, the standards governing realtime signals do provide guarantees about the order in which multiple unblocked realtime signals are delivered.)</p>
<p class="indent">When multiple unblocked signals are awaiting delivery, if a switch between kernel mode and user mode occurs during the execution of a signal handler, then the execution of that handler will be interrupted by the invocation of a second signal handler (and so on), as shown in <a href="ch22.xhtml#ch22fig1">Figure 22-1</a>.</p>
<div class="image"><img src="../images/f22-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch22fig1"/><strong>Figure 22-1:</strong> Delivery of multiple unblocked signals</p>
<h3 class="h3" id="ch22lev1sec07"><strong>22.7 Implementation and Portability of <em>signal()</em></strong></h3>
<p class="noindentab">In this section, we show how to implement <em>signal()</em> using <em>sigaction()</em>. The implementation is straightforward, but needs to account for the fact that, historically and across different UNIX implementations, <em>signal()</em> has had different semantics. In particular, early implementations of signals were unreliable, meaning that:</p>
<p class="bull">&#8226; On entry to a signal handler, the disposition of the signal was reset to its default. (This corresponds to the <span class="literal">SA_RESETHAND</span> flag described in <a href="ch20.xhtml#ch20lev1sec13">Section 20.13</a>.) In order to have the signal handler invoked again for a subsequent delivery of the same signal, the programmer needed to make a call to <em>signal()</em> from within the handler to explicitly reestablish the handler. The problem in this scenario is that there is a small window of time between entering the signal handler and reestablishment of the handler, during which, if the signal arrives a second time, it would be processed according to its default disposition.</p>
<p class="bull"><span epub:type="pagebreak" id="page_455"/>&#8226; Delivery of further occurrences of a signal was not blocked during execution of a signal handler. (This corresponds to the <span class="literal">SA_NODEFER</span> flag described in <a href="ch20.xhtml#ch20lev1sec13">Section 20.13</a>.) This meant that if the signal was delivered again while the handler was still executing, then the handler would be recursively invoked. Given a sufficiently rapid stream of signals, the resulting recursive invocations of the handler could overflow the stack.</p>
<p class="noindentt">As well as being unreliable, early UNIX implementations did not provide automatic restarting of system calls (i.e., the behavior described for the <span class="literal">SA_RESTART</span> flag in <a href="ch21.xhtml#ch21lev1sec05">Section 21.5</a>).</p>
<p class="indent">The 4.2BSD reliable signals implementation rectified these limitations, and several other UNIX implementations followed suit. However, the older semantics live on today in the System V implementation of <em>signal()</em>, and even contemporary standards such as SUSv3 and C99 leave these aspects of <em>signal()</em> deliberately unspecified.</p>
<p class="indent">Tying the above information together, we implement <em>signal()</em> as shown in <a href="ch22.xhtml#ch22ex1">Listing 22-1</a>. By default, this implementation provides the modern signal semantics. If compiled with <em>&#8211;DOLD_SIGNAL</em>, then it provides the earlier unreliable signal semantics and doesn&#8217;t enable automatic restarting of system calls.</p>
<p class="examplet"><a id="ch22ex1"/><strong>Listing 22-1:</strong> An implementation of <em>signal()</em></p>
<p class="programsli">_________________________________________________________ <span class="codestrong">signals/signal.c</span><br/><br/>#include &lt;signal.h&gt;<br/><br/>typedef void (*sighandler_t)(int);<br/><br/>sighandler_t<br/>signal(int sig, sighandler_t handler)<br/>{<br/>&#160;&#160;&#160;&#160;struct sigaction newDisp, prevDisp;<br/><br/>&#160;&#160;&#160;&#160;newDisp.sa_handler = handler;<br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;newDisp.sa_mask);<br/>#ifdef OLD_SIGNAL<br/>&#160;&#160;&#160;&#160;newDisp.sa_flags = SA_RESETHAND | SA_NODEFER;<br/>#else<br/>&#160;&#160;&#160;&#160;newDisp.sa_flags = SA_RESTART;<br/>#endif<br/><br/>&#160;&#160;&#160;&#160;if (sigaction(sig, &#38;newDisp, &#38;prevDisp) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return SIG_ERR;<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return prevDisp.sa_handler;<br/>}<br/>_________________________________________________________ <span class="codestrong">signals/signal.c</span></p>
<h5 class="h5" id="ch22lev3sec08"><strong>Some <em>glibc</em> details</strong></h5>
<p class="noindenta">The <em>glibc</em> implementation of the <em>signal()</em> library function has changed over time. In newer versions of the library (<em>glibc 2</em> and later), the modern semantics are provided <span epub:type="pagebreak" id="page_456"/>by default. In older versions of the library, the earlier unreliable (System V-compatible) semantics are provided.</p>
<div class="block">
<p class="noindent">The Linux kernel contains an implementation of <em>signal()</em> as a system call. This implementation provides the older, unreliable semantics. However, <em>glibc</em> bypasses this system call by providing a <em>signal()</em> library function that calls <em>sigaction()</em>.</p>
</div>
<p class="noindent">If we want to obtain unreliable signal semantics with modern versions of <em>glibc</em>, we can explicitly replace our calls to <em>signal()</em> with calls to the (nonstandard) <em>sysv_signal()</em> function.</p>
<div class="box">
<p class="programsa">#define _GNU_SOURCE<br/>#include &lt;signal.h&gt;<br/><br/>void ( *<span class="codestrong">sysv_signal</span>(int <span class="font1">sig</span>, void (*<span class="font1">handler</span>)(int)) ) (int);</p>
<p class="right">Returns previous signal disposition on success, or <span class="literal">SIG_ERR</span> on error</p>
</div>
<p class="noindent">The <em>sysv_signal()</em> function takes the same arguments as <em>signal()</em>.</p>
<p class="indent">If the <span class="literal">_BSD_SOURCE</span> feature test macro is not defined when compiling a program, <em>glibc</em> implicitly redefines all calls to <em>signal()</em> to be calls to <em>sysv_signal()</em>, meaning that <em>signal()</em> has unreliable semantics. By default, <span class="literal">_BSD_SOURCE</span> <em>is</em> defined, but it is disabled (unless also explicitly defined) if other feature test macros such as <span class="literal">_SVID_SOURCE</span> or <span class="literal">_XOPEN_SOURCE</span> are defined when compiling a program.</p>
<h5 class="h5" id="ch22lev3sec09"><strong><em>sigaction()</em> is the preferred API for establishing a signal handler</strong></h5>
<p class="noindenta">Because of the System V versus BSD (and old versus recent <em>glibc</em>) portability issues described above, it is good practice always to use <em>sigaction()</em>, rather than <em>signal()</em>, to establish signal handlers. We follow this practice throughout the remainder of this book. (An alternative is to write our own version of <em>signal()</em>, probably similar to <a href="ch22.xhtml#ch22ex1">Listing 22-1</a>, specifying exactly the flags that we require, and employ that version with our applications.) Note, however, that it is portable (and shorter) to use <em>signal()</em> to set the disposition of a signal to <span class="literal">SIG_IGN</span> or <span class="literal">SIG_DFL</span>, and we&#8217;ll often use <em>signal()</em> for that purpose.</p>
<h3 class="h3" id="ch22lev1sec08"><strong>22.8 Realtime Signals</strong></h3>
<p class="noindentab">Realtime signals were defined in POSIX.1b to remedy a number of limitations of standard signals. They have the following advantages over standard signals:</p>
<p class="bull">&#8226; Realtime signals provide an increased range of signals that can be used for application-defined purposes. Only two standard signals are freely available for application-defined purposes: <span class="literal">SIGUSR1</span> and <span class="literal">SIGUSR2</span>.</p>
<p class="bull">&#8226; Realtime signals are queued. If multiple instances of a realtime signal are sent to a process, then the signal is delivered multiple times. By contrast, if we send further instances of a standard signal that is already pending for a process, that signal is delivered only once.</p>
<p class="bull"><span epub:type="pagebreak" id="page_457"/>&#8226; When sending a realtime signal, it is possible to specify data (an integer or pointer value) that accompanies the signal. The signal handler in the receiving process can retrieve this data.</p>
<p class="bull">&#8226; The order of delivery of different realtime signals is guaranteed. If multiple different realtime signals are pending, then the lowest-numbered signal is delivered first. In other words, signals are prioritized, with lower-numbered signals having higher priority. When multiple signals of the same type are queued, they are delivered&#8212;along with their accompanying data&#8212;in the order in which they were sent.</p>
<p class="noindentt">SUSv3 requires that an implementation provide a minimum of <span class="literal">_POSIX_RTSIG_MAX</span> (defined as 8) different realtime signals. The Linux kernel defines 33 different real-time signals, numbered from 32 to 64. The <span class="literal">&lt;limits.h&gt;</span> header file defines the constant <span class="literal">RTSIG_MAX</span> to indicate the number of available realtime signals, and the constants <span class="literal">SIGRTMIN</span> and <span class="literal">SIGRTMAX</span> to indicate the lowest and highest available realtime signal numbers.</p>
<div class="block">
<p class="noindent">On systems employing the LinuxThreads threading implementation, <span class="literal">SIGRTMIN</span> is defined as 35 (rather than 32) to allow for the fact that LinuxThreads makes internal use of the first three realtime signals. On systems employing the NPTL threading implementation, <span class="literal">SIGRTMIN</span> is defined as 34 to allow for the fact that NPTL makes internal use of the first two realtime signals.</p>
</div>
<p class="noindent">Realtime signals are not individually identified by different constants in the manner of standard signals. However, an application should not hard-code integer values for them, since the range used for realtime signals varies across UNIX implementations. Instead, a realtime signal number can be referred to by adding a value to <span class="literal">SIGRTMIN</span>; for example, the expression <em>(SIGRTMIN + 1)</em> refers to the second realtime signal.</p>
<p class="indent">Be aware that SUSv3 doesn&#8217;t require <span class="literal">SIGRTMAX</span> and <span class="literal">SIGRTMIN</span> to be simple integer values. They may be defined as functions (as they are on Linux). This means that we can&#8217;t write code for the preprocessor such as the following:</p>
<p class="programs">#if SIGRTMIN+100 &gt; SIGRTMAX&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* WRONG! */<br/>#error "Not enough realtime signals"<br/>#endif</p>
<p class="noindent">Instead, we must perform equivalent checks at run time.</p>
<h5 class="h5" id="ch22lev3sec10"><strong>Limits on the number of queued realtime signals</strong></h5>
<p class="noindenta">Queuing realtime signals (with associated data) requires that the kernel maintain data structures listing the signals queued to each process. Since these data structures consume kernel memory, the kernel places limits on the number of realtime signals that may be queued.</p>
<p class="indent">SUSv3 allows an implementation to place an upper limit on the number of real-time signals (of all types) that may be queued by a process, and requires that this limit be at least <span class="literal">_POSIX_SIGQUEUE_MAX</span> (defined as 32). An implementation can define the constant <span class="literal">SIGQUEUE_MAX</span> to indicate the number of realtime signals it allows to be queued. It can also make this information available through the following call:</p>
<p class="programs">lim = sysconf(_SC_SIGQUEUE_MAX);</p>
<p class="noindent"><span epub:type="pagebreak" id="page_458"/>In systems with <em>glibc</em> versions before 2.4, this call returns &#8211;1. Since <em>glibc</em> 2.4, the return value depends on the kernel version. Before Linux 2.6.8, the call returns the value in the Linux-specific <span class="literal">/proc/sys/kernel/rtsig-max</span> file. This file defines a systemwide limit on the number of realtime signals that may be queued to all processes. The default value is 1024, but a privileged process can change it. The Linux-specific <span class="literal">/proc/sys/kernel/rtsig-nr</span> file shows the number of currently queued realtime signals.</p>
<p class="indent">Starting with Linux 2.6.8, these <span class="literal">/proc</span> files disappear. In their place, the <span class="literal">RLIMIT_SIGPENDING</span> resource limit (<a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a>) limits the number of signals that can be queued to all processes owned by a particular real user ID. Since <em>glibc</em> 2.10, the <em>sysconf()</em> call returns the <span class="literal">RLIMIT_SIGPENDING</span> limit. (The <span class="literal">SigQ</span> field of the Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/status</span> file displays the number of realtime signals pending for a process.)</p>
<h5 class="h5" id="ch22lev3sec11"><strong>Using realtime signals</strong></h5>
<p class="noindentab">In order for a pair of processes to send and receive realtime signals, SUSv3 requires the following:</p>
<p class="bull">&#8226; The sending process sends the signal plus its accompanying data using the <em>sigqueue()</em> system call.</p>
<div class="block1">
<p class="noindent">A realtime signal can also be sent using <em>kill()</em>, <em>killpg()</em>, and <em>raise()</em>. However, SUSv3 leaves it as implementation-dependent whether realtime signals sent using these interfaces are queued. On Linux, these interfaces do queue real-time signals, but on many other UNIX implementations, they do not.</p>
</div>
<p class="bull">&#8226; The receiving process establishes a handler for the signal using a call to <em>sigaction()</em> that specifies the <span class="literal">SA_SIGINFO</span> flag. This causes the signal handler to be invoked with additional arguments, one of which includes the data accompanying the realtime signal.</p>
<div class="block1">
<p class="noindent">On Linux, it is possible to queue realtime signals even if the receiving process doesn&#8217;t specify the <span class="literal">SA_SIGINFO</span> flag when establishing the signal handler (although it is not then possible to obtain the data associated with the signal in this case). However, SUSv3 doesn&#8217;t require implementations to guarantee this behavior, so we can&#8217;t portably rely on it.</p>
</div>
<h4 class="h4" id="ch22lev2sec01"><strong>22.8.1 Sending Realtime Signals</strong></h4>
<p class="noindenta">The <em>sigqueue()</em> system call sends the realtime signal specified by <em>sig</em> to the process specified by <em>pid</em>.</p>
<div class="box">
<p class="programsa">#define _POSIX_C_SOURCE 199309<br/>#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">sigqueue</span>(pid_t <span class="font1">pid</span>, int <span class="font1">sig</span>, const union sigval <span class="font1">value</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The same permissions are required to send a signal using <em>sigqueue()</em> as are required with <em>kill()</em> (see <a href="ch20.xhtml#ch20lev1sec05">Section 20.5</a>). A null signal (i.e., signal 0) can be sent, with the same meaning as for <em>kill()</em>. (Unlike <em>kill()</em>, we can&#8217;t use <em>sigqueue()</em> to send a signal to an entire process group by specifying a negative value in <em>pid</em>.)</p>
<p class="examplet"><span epub:type="pagebreak" id="page_459"/><a id="ch22ex2"/><strong>Listing 22-2:</strong> Using <em>sigqueue()</em> to send realtime signals</p>
<p class="programsli">______________________________________________________ <span class="codestrong">signals/t_sigqueue.c</span><br/><br/>#define _POSIX_C_SOURCE 199309<br/>#include &lt;signal.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int sig, numSigs, j, sigData;<br/>&#160;&#160;&#160;&#160;union sigval sv;<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 4 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s pid sig-num data [num-sigs]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;/* Display our PID and UID, so that they can be compared with the<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;corresponding fields of the siginfo_t argument supplied to the<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;handler in the receiving process */<br/><br/>&#160;&#160;&#160;&#160;printf("%s: PID is %ld, UID is %ld\n", argv[0],<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) getpid(), (long) getuid());<br/><br/>&#160;&#160;&#160;&#160;sig = getInt(argv[2], 0, "sig-num");<br/>&#160;&#160;&#160;&#160;sigData = getInt(argv[3], GN_ANY_BASE, "data");<br/>&#160;&#160;&#160;&#160;numSigs = (argc &gt; 4) ? getInt(argv[4], GN_GT_0, "num-sigs") : 1;<br/><br/>&#160;&#160;&#160;&#160;for (j = 0; j &lt; numSigs; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sv.sival_int = sigData + j;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigqueue(getLong(argv[1], 0, "pid"), sig, sv) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigqueue %d", j);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>______________________________________________________ <span class="codestrong">signals/t_sigqueue.c</span></p>
<p class="noindent">The <em>value</em> argument specifies the data to accompany the signal. This argument has the following form:</p>
<p class="programs">union sigval {<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;sival_int;&#160;&#160;&#160;&#160;&#160;/* Integer value for accompanying data */<br/>&#160;&#160;&#160;&#160;void *sival_ptr;&#160;&#160;&#160;&#160;&#160;/* Pointer value for accompanying data */<br/>};</p>
<p class="noindent">The interpretation of this argument is application-dependent, as is the choice of whether to set the <em>sival_int</em> or the <em>sival_ptr</em> field of the union. The <em>sival_ptr</em> field is seldom useful with <em>sigqueue()</em>, since a pointer value that is useful in one process is rarely meaningful in another process. However, this field is useful in other functions that employ <em>sigval</em> unions, as we&#8217;ll see when we consider POSIX timers in <a href="ch23.xhtml#ch23lev1sec06">Section 23.6</a> and POSIX message queue notification in <a href="ch52.xhtml#ch52lev1sec06">Section 52.6</a>.</p>
<div class="block">
<p class="noindent">Several UNIX implementations, including Linux, define a <em>sigval_t</em> data type as a synonym for <em>union sigval</em>. However, this type is not specified in SUSv3 and is not available on some implementations. Portable applications should avoid using it.</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_460"/>A call to <em>sigqueue()</em> may fail if the limit on the number of queued signals has been reached. In this case, <em>errno</em> is set to <span class="literal">EAGAIN</span>, indicating that we need to send the signal again (at some later time when some of the currently queued signals have been delivered).</p>
<p class="indent">An example of the use of <em>sigqueue()</em> is provided in <a href="ch22.xhtml#ch22ex2">Listing 22-2</a> (<a href="ch22.xhtml#page_459">page 459</a>). This program takes up to four arguments, of which the first three are mandatory: a target process ID, a signal number, and an integer value to accompany the realtime signal. If more than one instance of the specified signal is to be sent, the optional fourth argument specifies the number of instances; in this case, the accompanying integer data value is incremented by one for each successive signal. We demonstrate the use of this program in <a href="ch22.xhtml#ch22lev2sec02">Section 22.8.2</a>.</p>
<h4 class="h4" id="ch22lev2sec02"><strong>22.8.2 Handling Realtime Signals</strong></h4>
<p class="noindenta">We can handle realtime signals just like standard signals, using a normal (single-argument) signal handler. Alternatively, we can handle a realtime signal using a three-argument signal handler established using the <span class="literal">SA_SIGINFO</span> flag (<a href="ch21.xhtml#ch21lev1sec04">Section 21.4</a>). Here is an example of using <span class="literal">SA_SIGINFO</span> to establish a handler for the sixth realtime signal:</p>
<p class="programs">struct sigaction act;<br/><br/>sigemptyset(&#38;act.sa_mask);<br/>act.sa_sigaction = handler;<br/>act.sa_flags = SA_RESTART | SA_SIGINFO;<br/><br/>if (sigaction(SIGRTMIN + 5, &#38;act, NULL) == -1)<br/>&#160;&#160;&#160;&#160;errExit("sigaction");</p>
<p class="noindentb">When we employ the <span class="literal">SA_SIGINFO</span> flag, the second argument passed to the signal handler is a <em>siginfo_t</em> structure that contains additional information about the realtime signal. We described this structure in detail in <a href="ch21.xhtml#ch21lev1sec04">Section 21.4</a>. For a realtime signal, the following fields are set in the <em>siginfo_t</em> structure:</p>
<p class="bull">&#8226; The <em>si_signo</em> field is the same value as is passed in the first argument of the signal handler.</p>
<p class="bull">&#8226; The <em>si_code</em> field indicates the source of the signal, and contains one of the values shown in <a href="ch21.xhtml#ch21table2">Table 21-2</a> (<a href="ch21.xhtml#page_441">page 441</a>). For a realtime signal sent via <em>sigqueue()</em>, this field always has the value <span class="literal">SI_QUEUE</span>.</p>
<p class="bull">&#8226; The <em>si_value</em> field contains the data specified in the <em>value</em> argument (the <em>sigval</em> union) by the process that sent the signal using <em>sigqueue()</em>. As noted already, the interpretation of this data is application-defined. (The <em>si_value</em> field doesn&#8217;t contain valid information if the signal was sent using <em>kill()</em>.)</p>
<p class="bull">&#8226; The <em>si_pid</em> and <em>si_uid</em> fields contain, respectively, the process ID and real user ID of the process sending the signal.</p>
<p class="noindentt"><a href="ch22.xhtml#ch22ex3">Listing 22-3</a> provides an example of handling realtime signals. This program catches signals and displays various fields from the <em>siginfo_t</em> structure passed to the signal handler. The program takes two optional integer command-line arguments. <span epub:type="pagebreak" id="page_461"/>If the first argument is supplied, the main program blocks all signals, and then sleeps for the number of seconds specified by this argument. During this time, we can queue multiple realtime signals to the process and observe what happens when the signals are unblocked. The second argument specifies the number of seconds that the signal handler should sleep before returning. Specifying a nonzero value (the default is 1 second) is useful for slowing down the program so that we can more easily see what is happening when multiple signals are handled.</p>
<p class="indent">We can use the program in <a href="ch22.xhtml#ch22ex3">Listing 22-3</a>, along with the program in <a href="ch22.xhtml#ch22ex2">Listing 22-2</a> (<span class="literal">t_sigqueue.c</span>) to explore the behavior of realtime signals, as shown in the following shell session log:</p>
<p class="programs">$ <span class="codestrong">./catch_rtsigs 60 &#38;</span><br/>[1] 12842<br/>$ ./catch_rtsigs: PID is 12842&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Shell prompt mixed with program output</span><br/>./catch_rtsigs: signals blocked - sleeping 60 seconds<br/><span class="font1">Press Enter to see next shell prompt</span><br/>$ <span class="codestrong">./t_sigqueue 12842 54 100 3</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Send signal three times</span><br/>./t_sigqueue: PID is 12843, UID is 1000<br/>$ <span class="codestrong">./t_sigqueue 12842 43 200</span><br/>./t_sigqueue: PID is 12844, UID is 1000<br/>$ <span class="codestrong">./t_sigqueue 12842 40 300</span><br/>./t_sigqueue: PID is 12845, UID is 1000</p>
<p class="noindent">Eventually, the <em>catch_rtsigs</em> program completes sleeping, and displays messages as the signal handler catches various signals. (We see a shell prompt mixed with the next line of the program&#8217;s output because the <em>catch_rtsigs</em> program is writing output from the background.) We first observe that realtime signals are delivered lowest-numbered signal first, and that the <em>siginfo_t</em> structure passed to the handler includes the process ID and user ID of the process that sent the signal:</p>
<p class="programs">$ ./catch_rtsigs: sleep complete<br/>caught signal 40<br/>&#160;&#160;&#160;&#160;si_signo=40, si_code=-1 (SI_QUEUE), si_value=300<br/>&#160;&#160;&#160;&#160;si_pid=12845, si_uid=1000<br/>caught signal 43<br/>&#160;&#160;&#160;&#160;si_signo=43, si_code=-1 (SI_QUEUE), si_value=200<br/>&#160;&#160;&#160;&#160;si_pid=12844, si_uid=1000</p>
<p class="noindent">The remaining output is produced by the three instances of the same realtime signal. Looking at the <em>si_value</em> values, we can see that these signals were delivered in the order they were sent:</p>
<p class="programs">caught signal 54<br/>&#160;&#160;&#160;&#160;si_signo=54, si_code=-1 (SI_QUEUE), si_value=100<br/>&#160;&#160;&#160;&#160;si_pid=12843, si_uid=1000<br/>caught signal 54<br/>&#160;&#160;&#160;&#160;si_signo=54, si_code=-1 (SI_QUEUE), si_value=101<br/>&#160;&#160;&#160;&#160;si_pid=12843, si_uid=1000<br/>caught signal 54<br/>&#160;&#160;&#160;&#160;si_signo=54, si_code=-1 (SI_QUEUE), si_value=102<br/>&#160;&#160;&#160;&#160;si_pid=12843, si_uid=1000</p>
<p class="noindent"><span epub:type="pagebreak" id="page_462"/>We continue by using the shell <em>kill</em> command to send a signal to the <em>catch_rtsigs</em> program. As before, we see that the <em>siginfo_t</em> structure received by the handler includes the process ID and user ID of the sending process, but in this case, the <em>si_code</em> value is <span class="literal">SI_USER</span>:</p>
<p class="programs"><span class="font1">Press Enter to see next shell prompt</span><br/>$ <span class="codestrong">echo $$</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Display PID of shell</span><br/>12780<br/>$ <span class="codestrong">kill -40 12842</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Uses kill(2) to send a signal</span><br/>$ caught signal 40<br/>&#160;&#160;&#160;&#160;si_signo=40, si_code=0 (SI_USER), si_value=0<br/>&#160;&#160;&#160;&#160;si_pid=12780, si_uid=1000&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">PID is that of the shell</span><br/><span class="font1">Press Enter to see next shell prompt</span><br/>$ <span class="codestrong">kill 12842</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Kill catch_rtsigs by sending</span> SIGTERM<br/>Caught 6 signals<br/><span class="font1">Press Enter to see notification from shell about terminated background job</span><br/>[1]+&#160;&#160;Done&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;./catch_rtsigs 60</p>
<p class="examplet"><a id="ch22ex3"/><strong>Listing 22-3:</strong> Handling realtime signals</p>
<p class="programsli">____________________________________________________ <span class="codestrong">signals/catch_rtsigs.c</span><br/><br/>#define _GNU_SOURCE<br/>#include &lt;string.h&gt;<br/>#include &lt;signal.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static volatile int handlerSleepTime;<br/>static volatile int sigCnt = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of signals received */<br/>static volatile int allDone = 0;<br/><br/>static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Handler for signals established using SA_SIGINFO */<br/>siginfoHandler(int sig, siginfo_t *si, void *ucontext)<br/>{<br/>&#160;&#160;&#160;&#160;/* UNSAFE: This handler uses non-async-signal-safe functions<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;(printf()); see <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>) */<br/><br/>&#160;&#160;&#160;&#160;/* SIGINT or SIGTERM can be used to terminate program */<br/><br/>&#160;&#160;&#160;&#160;if (sig == SIGINT || sig == SIGTERM) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;allDone = 1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;sigCnt++;<br/>&#160;&#160;&#160;&#160;printf("caught signal %d\n", sig);<br/><br/>&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;si_signo=%d, si_code=%d (%s), ", si-&gt;si_signo, si-&gt;si_code,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(si-&gt;si_code == SI_USER) ? "SI_USER" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(si-&gt;si_code == SI_QUEUE) ? "SI_QUEUE" : "other");<br/>&#160;&#160;&#160;&#160;printf("si_value=%d\n", si-&gt;si_value.sival_int);<br/>&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;si_pid=%ld, si_uid=%ld\n", (long) si-&gt;si_pid, (long) si-&gt;si_uid);<br/><br/>&#160;&#160;&#160;&#160;sleep(handlerSleepTime);<br/>}<br/><br/><span epub:type="pagebreak" id="page_463"/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct sigaction sa;<br/>&#160;&#160;&#160;&#160;int sig;<br/>&#160;&#160;&#160;&#160;sigset_t prevMask, blockMask;<br/><br/>&#160;&#160;&#160;&#160;if (argc &gt; 1 &#38;&#38; strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s [block-time [handler-sleep-time]]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;printf("%s: PID is %ld\n", argv[0], (long) getpid());<br/><br/>&#160;&#160;&#160;&#160;handlerSleepTime = (argc &gt; 2) ?<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;getInt(argv[2], GN_NONNEG, "handler-sleep-time") : 1;<br/><br/>&#160;&#160;&#160;&#160;/* Establish handler for most signals. During execution of the handler,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;mask all other signals to prevent handlers recursively interrupting<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;each other (which would make the output hard to read). */<br/><br/>&#160;&#160;&#160;&#160;sa.sa_sigaction = siginfoHandler;<br/>&#160;&#160;&#160;&#160;sa.sa_flags = SA_SIGINFO;<br/>&#160;&#160;&#160;&#160;sigfillset(&#38;sa.sa_mask);<br/><br/>&#160;&#160;&#160;&#160;for (sig = 1; sig &lt; NSIG; sig++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sig != SIGTSTP &#38;&#38; sig != SIGQUIT)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigaction(sig, &#38;sa, NULL);<br/><br/>&#160;&#160;&#160;&#160;/* Optionally block signals and sleep, allowing signals to be<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sent to us before they are unblocked and handled */<br/><br/>&#160;&#160;&#160;&#160;if (argc &gt; 1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigfillset(&#38;blockMask);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigdelset(&#38;blockMask, SIGINT);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigdelset(&#38;blockMask, SIGTERM);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigprocmask(SIG_SETMASK, &#38;blockMask, &#38;prevMask) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s: signals blocked - sleeping %s seconds\n", argv[0], argv[1]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep(getInt(argv[1], GN_GT_0, "block-time"));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s: sleep complete\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigprocmask(SIG_SETMASK, &#38;prevMask, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask");<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;while (!allDone)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for incoming signals */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pause();<br/><br/>&#160;&#160;&#160;&#160;printf("Caught %d signals\n", sigCnt);<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>____________________________________________________ <span class="codestrong">signals/catch_rtsigs.c</span></p>
<h3 class="h3" id="ch22lev1sec09"><span epub:type="pagebreak" id="page_464"/><strong>22.9 Waiting for a Signal Using a Mask: <em>sigsuspend()</em></strong></h3>
<p class="noindenta">Before we explain what <em>sigsuspend()</em> does, we first describe a situation where we need to use it. Consider the following scenario that is sometimes encountered when programming with signals:</p>
<ol>
<li class="order"><p class="orderp">We temporarily block a signal so that the handler for the signal doesn&#8217;t interrupt the execution of some critical section of code.</p></li>
<li class="order"><p class="orderp">We unblock the signal, and then suspend execution until the signal is delivered.</p></li>
</ol>
<p class="noindent">In order to do this, we might try using code such as that shown in <a href="ch22.xhtml#ch22ex4">Listing 22-4</a>.</p>
<p class="examplet"><a id="ch22ex4"/><strong>Listing 22-4:</strong> Incorrectly unblocking and waiting for a signal</p>
<p class="programsli">______________________________________________________________________<br/><br/>&#160;&#160;&#160;&#160;sigset_t prevMask, intMask;<br/>&#160;&#160;&#160;&#160;struct sigaction sa;<br/><br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;intMask);<br/>&#160;&#160;&#160;&#160;sigaddset(&#38;intMask, SIGINT);<br/><br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;sa.sa_flags = 0;<br/>&#160;&#160;&#160;&#160;sa.sa_handler = handler;<br/><br/>&#160;&#160;&#160;&#160;if (sigaction(SIGINT, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;/* Block SIGINT prior to executing critical section. (At this<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;point we assume that SIGINT is not already blocked.) */<br/><br/>&#160;&#160;&#160;&#160;if (sigprocmask(SIG_BLOCK, &#38;intMask, &#38;prevMask) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask - SIG_BLOCK");<br/><br/>&#160;&#160;&#160;&#160;/* Critical section: do some work here that must not be<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;interrupted by the SIGINT handler */<br/><br/>&#160;&#160;&#160;&#160;/* End of critical section - restore old mask to unblock SIGINT */<br/><br/>&#160;&#160;&#160;&#160;if (sigprocmask(SIG_SETMASK, &#38;prevMask, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask - SIG_SETMASK");<br/><br/>&#160;&#160;&#160;&#160;/* BUG: what if SIGINT arrives now... */<br/><br/>&#160;&#160;&#160;&#160;pause();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for SIGINT */<br/>______________________________________________________________________</p>
<p class="noindent">There is a problem with the code in <a href="ch22.xhtml#ch22ex4">Listing 22-4</a>. Suppose that the <span class="literal">SIGINT</span> signal is delivered after execution of the second <em>sigprocmask()</em>, but before the <em>pause()</em> call. (The signal might actually have been generated at any time during the execution of the critical section, and then be delivered only when it is unblocked.) Delivery of the <span class="literal">SIGINT</span> signal will cause the handler to be invoked, and after the handler returns <span epub:type="pagebreak" id="page_465"/>and the main program resumes, the <em>pause()</em> call will block until a <em>second</em> instance of <span class="literal">SIGINT</span> is delivered. This defeats the purpose of the code, which was to unblock <span class="literal">SIGINT</span> and then wait for its <em>first</em> occurrence.</p>
<p class="indent">Even if the likelihood of <span class="literal">SIGINT</span> being generated between the start of the critical section (i.e., the first <em>sigprocmask()</em> call) and the <em>pause()</em> call is small, this nevertheless constitutes a bug in the above code. This time-dependent bug is an example of a race condition (<a href="ch05.xhtml#ch05lev1sec01">Section 5.1</a>). Normally, race conditions occur where two processes or threads share common resources. However, in this case, the main program is racing against its own signal handler.</p>
<p class="indent">To avoid this problem, we require a means of <em>atomically</em> unblocking a signal and suspending the process. That is the purpose of the <em>sigsuspend()</em> system call.</p>
<div class="box">
<p class="programsa">#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">sigsuspend</span>(const sigset_t *<span class="font1">mask</span>);</p>
<p class="right">(Normally) returns &#8211;1 with <em>errno</em> set to <span class="literal">EINTR</span></p>
</div>
<p class="noindent">The <em>sigsuspend()</em> system call replaces the process signal mask by the signal set pointed to by <em>mask</em>, and then suspends execution of the process until a signal is caught and its handler returns. Once the handler returns, <em>sigsuspend()</em> restores the process signal mask to the value it had prior to the call.</p>
<p class="indent">Calling <em>sigsuspend()</em> is equivalent to atomically performing these operations:</p>
<p class="programs">sigprocmask(SIG_SETMASK, &#38;mask, &#38;prevMask);&#160;&#160;&#160;&#160;&#160;/* Assign new mask */<br/>pause();<br/>sigprocmask(SIG_SETMASK, &#38;prevMask, NULL);&#160;&#160;&#160;&#160;&#160;&#160;/* Restore old mask */</p>
<p class="noindent">Although restoring the old signal mask (i.e., the last step in the above sequence) may at first appear inconvenient, it is essential to avoid race conditions in situations where we need to repeatedly wait for signals. In such situations, the signals must remain blocked except during the <em>sigsuspend()</em> calls. If we later need to unblock the signals that were blocked prior to the <em>sigsuspend()</em> call, we can employ a further call to <em>sigprocmask()</em>.</p>
<p class="indent">When <em>sigsuspend()</em> is interrupted by delivery of a signal, it returns &#8211;1, with <em>errno</em> set to <span class="literal">EINTR</span>. If <em>mask</em> doesn&#8217;t point to a valid address, <em>sigsuspend()</em> fails with the error <span class="literal">EFAULT</span>.</p>
<h5 class="h5" id="ch22lev3sec12"><strong>Example program</strong></h5>
<p class="noindentab"><a href="ch22.xhtml#ch22ex5">Listing 22-5</a> demonstrates the use of <em>sigsuspend()</em>. This program performs the following steps:</p>
<p class="bull">&#8226; Display the initial value of the process signal mask using the <em>printSigMask()</em> function (<a href="ch20.xhtml#ch20ex4">Listing 20-4</a>, on <a href="ch20.xhtml#page_408">page 408</a>) <span class="ent">&#x2460;</span>.</p>
<p class="bull">&#8226; Block <span class="literal">SIGINT</span> and <span class="literal">SIGQUIT</span>, and save the original process signal mask <span class="ent">&#x2461;</span>.</p>
<p class="bull">&#8226; Establish the same handler for both <span class="literal">SIGINT</span> and <span class="literal">SIGQUIT</span> <span class="ent">&#x2462;</span>. This handler displays a message, and, if it was invoked via delivery of <span class="literal">SIGQUIT</span>, sets the global variable <em>gotSigquit</em>.</p>
<p class="bull"><span epub:type="pagebreak" id="page_466"/>&#8226; Loop until <em>gotSigquit</em> is set <span class="ent">&#x2463;</span>. Each loop iteration performs the following steps:</p>
<p class="dash1">&#8211; Display the current value of the signal mask using our <em>printSigMask()</em> function.</p>
<p class="dash1">&#8211; Simulate a critical section by executing a CPU busy loop for a few seconds.</p>
<p class="dash1">&#8211; Display the mask of pending signals using our <em>printPendingSigs()</em> function (<a href="ch20.xhtml#ch20ex4">Listing 20-4</a>).</p>
<p class="dash1">&#8211; Uses <em>sigsuspend()</em> to unblock <span class="literal">SIGINT</span> and <span class="literal">SIGQUIT</span> and wait for a signal (if one is not already pending).</p>
<p class="bull">&#8226; Use <em>sigprocmask()</em> to restore the process signal mask to its original state <span class="ent">&#x2464;</span>, and then display the signal mask using <em>printSigMask()</em> <span class="ent">&#x2465;</span>.</p>
<p class="examplet"><a id="ch22ex5"/><strong>Listing 22-5:</strong> Using <em>sigsuspend()</em></p>
<p class="programsli">____________________________________________________ <span class="codestrong">signals/t_sigsuspend.c</span><br/><br/>&#160;&#160;&#160;#define _GNU_SOURCE&#160;&#160;&#160;&#160;&#160;/* Get strsignal() declaration from &lt;string.h&gt; */<br/>&#160;&#160;&#160;#include &lt;string.h&gt;<br/>&#160;&#160;&#160;#include &lt;signal.h&gt;<br/>&#160;&#160;&#160;#include &lt;time.h&gt;<br/>&#160;&#160;&#160;#include "signal_functions.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declarations of printSigMask()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;and printPendingSigs() */<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;static volatile sig_atomic_t gotSigquit = 0;<br/><br/>&#160;&#160;&#160;static void<br/>&#160;&#160;&#160;handler(int sig)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Caught signal %d (%s)\n", sig, strsignal(sig));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* UNSAFE (see <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>) */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sig == SIGQUIT)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;gotSigquit = 1;<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int loopNum;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;time_t startTime;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigset_t origMask, blockMask;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sigaction sa;<br/><br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;printSigMask(stdout, "Initial signal mask is:\n");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;blockMask);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigaddset(&#38;blockMask, SIGINT);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigaddset(&#38;blockMask, SIGQUIT);<br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;if (sigprocmask(SIG_BLOCK, &#38;blockMask, &#38;origMask) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask - SIG_BLOCK");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_flags = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_handler = handler;<br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGINT, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGQUIT, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;for (loopNum = 1; !gotSigquit; loopNum++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("=== LOOP %d\n", loopNum);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Simulate a critical section by delaying a few seconds */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printSigMask(stdout, "Starting critical section, signal mask is:\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (startTime = time(NULL); time(NULL) &lt; startTime + 4; )<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Run for a few seconds elapsed time */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printPendingSigs(stdout,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Before sigsuspend() - pending signals:\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigsuspend(&#38;origMask) == -1 &#38;&#38; errno != EINTR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigsuspend");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;if (sigprocmask(SIG_SETMASK, &#38;origMask, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask - SIG_SETMASK");<br/><br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;printSigMask(stdout, "=== Exited loop\nRestored signal mask to:\n");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Do other processing... */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;}<br/>____________________________________________________ <span class="codestrong">signals/t_sigsuspend.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_467"/>The following shell session log shows an example of what we see when running the program in <a href="ch22.xhtml#ch22ex5">Listing 22-5</a>:</p>
<p class="programs">$ <span class="codestrong">./t_sigsuspend</span><br/>Initial signal mask is:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;empty signal set&gt;<br/>=== LOOP 1<br/>Starting critical section, signal mask is:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2 (Interrupt)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3 (Quit)<br/><span class="font1">Type Control-C;</span> SIGINT <span class="font1">is generated, but remains pending because it is blocked</span><br/>Before sigsuspend() - pending signals:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2 (Interrupt)<br/>Caught signal 2 (Interrupt)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">sigsuspend() is called, signals are unblocked</span></p>
<p class="noindent">The last line of output appeared when the program called <em>sigsuspend()</em>, which caused <span class="literal">SIGINT</span> to be unblocked. At that point, the signal handler was called and displayed that line of output.</p>
<p class="noindent"><span epub:type="pagebreak" id="page_468"/>The main program continues its loop:</p>
<p class="programs">=== LOOP 2<br/>Starting critical section, signal mask is:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2 (Interrupt)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3 (Quit)<br/><span class="font1">Type Control-\ to generate</span> SIGQUIT<br/>Before sigsuspend() - pending signals:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3 (Quit)<br/>Caught signal 3 (Quit)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">sigsuspend() is called, signals are unblocked</span><br/>=== Exited loop&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Signal handler set gotSigquit</span><br/>Restored signal mask to:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;empty signal set&gt;</p>
<p class="noindent">This time, we typed <em>Control-\</em>, which caused the signal handler to set the <em>gotSigquit</em> flag, which in turn caused the main program to terminate its loop.</p>
<h3 class="h3" id="ch22lev1sec10"><strong>22.10 Synchronously Waiting for a Signal</strong></h3>
<p class="noindenta">In <a href="ch22.xhtml#ch22lev1sec09">Section 22.9</a>, we saw how to use a signal handler plus <em>sigsuspend()</em> to suspend execution of a process until a signal is delivered. However, the need to write a signal handler and to handle the complexities of asynchronous delivery makes this approach cumbersome for some applications. Instead, we can use the <em>sigwaitinfo()</em> system call to synchronously <em>accept</em> a signal.</p>
<div class="box">
<p class="programsa">#define _POSIX_C_SOURCE 199309<br/>#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">sigwaitinfo</span>(const sigset_t *<span class="font1">set</span>, siginfo_t *<span class="font1">info</span>);</p>
<p class="right">Returns signal number on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>sigwaitinfo()</em> system call suspends execution of the process until one of the signals in the signal set pointed to by <em>set</em> becomes pending. If one of the signals in <em>set</em> is already pending at the time of the call, <em>sigwaitinfo()</em> returns immediately. One of the signals is removed from the process&#8217;s list of pending signals, and the signal number is returned as the function result. If the <em>info</em> argument is not <span class="literal">NULL</span>, then it points to a <em>siginfo_t</em> structure that is initialized to contain the same information provided to a signal handler taking a <em>siginfo_t</em> argument (<a href="ch21.xhtml#ch21lev1sec04">Section 21.4</a>).</p>
<p class="indent">The delivery order and queuing characteristics of signals accepted by <em>sigwaitinfo()</em> are the same as for signals caught by a signal handler; that is, standard signals are not queued, and realtime signals are queued and delivered lowest signal number first.</p>
<p class="indent">As well as saving us the extra baggage of writing a signal handler, waiting for signals using <em>sigwaitinfo()</em> is somewhat faster than the combination of a signal handler plus <em>sigsuspend()</em> (see <a href="ch22.xhtml#ch22exe3">Exercise 22-3</a>).</p>
<p class="indent">It usually makes sense to use <em>sigwaitinfo()</em> only in conjunction with blocking the set of signals for which we were interested in waiting. (We can fetch a pending signal with <em>sigwaitinfo()</em> even while that signal is blocked.) If we fail to do this and a signal arrives before the first, or between successive calls to <em>sigwaitinfo()</em>, then the signal will be handled according to its current disposition.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_469"/>According to SUSv3, calling <em>sigwaitinfo()</em> without blocking the signals in <em>set</em> results in undefined behavior.</p>
</div>
<p class="noindent">An example of the use of <em>sigwaitinfo()</em> is shown in <a href="ch22.xhtml#ch22ex6">Listing 22-6</a>. This program first blocks all signals, then delays for the number of seconds specified in its optional command-line argument. This allows signals to be sent to the program before <em>sigwaitinfo()</em>. The program then loops continuously using <em>sigwaitinfo()</em> to accept incoming signals, until <span class="literal">SIGINT</span> or <span class="literal">SIGTERM</span> is received.</p>
<p class="indent">The following shell session log demonstrates the use of the program in <a href="ch22.xhtml#ch22ex6">Listing 22-6</a>. We run the program in the background, specifying that it should delay 60 seconds before calling <em>sigwaitinfo()</em>, and then send it two signals:</p>
<p class="programs">$ <span class="codestrong">./t_sigwaitinfo 60 &#38;</span><br/>./t_sigwaitinfo: PID is 3837<br/>./t_sigwaitinfo: signals blocked<br/>./t_sigwaitinfo: about to delay 60 seconds<br/>[1] 3837<br/>$ <span class="codestrong">./t_sigqueue 3837 43 100</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Send signal 43</span><br/>./t_sigqueue: PID is 3839, UID is 1000<br/>$ <span class="codestrong">./t_sigqueue 3837 42 200</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Send signal 42</span><br/>./t_sigqueue: PID is 3840, UID is 1000</p>
<p class="noindent">Eventually, the program completes its sleep interval, and the <em>sigwaitinfo()</em> loop accepts the queued signals. (We see a shell prompt mixed with the next line of the program&#8217;s output because the <em>t_sigwaitinfo</em> program is writing output from the background.) As with realtime signals caught with a handler, we see that signals are delivered lowest number first, and that the <em>siginfo_t</em> structure passed to the signal handler allows us to obtain the process ID and user ID of the sending process:</p>
<p class="programs">$ ./t_sigwaitinfo: finished delay<br/>got signal: 42<br/>&#160;&#160;&#160;&#160;si_signo=42, si_code=-1 (SI_QUEUE), si_value=200<br/>&#160;&#160;&#160;&#160;si_pid=3840, si_uid=1000<br/>got signal: 43<br/>&#160;&#160;&#160;&#160;si_signo=43, si_code=-1 (SI_QUEUE), si_value=100<br/>&#160;&#160;&#160;&#160;si_pid=3839, si_uid=1000</p>
<p class="noindent">We continue, using the shell <em>kill</em> command to send a signal to the process. This time, we see that the <em>si_code</em> field is set to <span class="literal">SI_USER</span> (instead of <span class="literal">SI_QUEUE</span>):</p>
<p class="programs"><span class="font1">Press Enter to see next shell prompt</span><br/>$ <span class="codestrong">echo $$</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Display PID of shell</span><br/>3744<br/>$ <span class="codestrong">kill -USR1 3837</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Shell sends</span> SIGUSR1 <span class="font1">using kill()</span><br/>$ got signal: 10&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Delivery of</span> SIGUSR1<br/>&#160;&#160;&#160;&#160;si_signo=10, si_code=0 (SI_USER), si_value=100<br/>&#160;&#160;&#160;&#160;si_pid=3744, si_uid=1000&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">3744 is PID of shell</span><br/><span class="font1">Press Enter to see next shell prompt</span><br/>$ <span class="codestrong">kill %1</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Terminate program with</span> SIGTERM<br/>$<br/><span class="font1">Press Enter to see notification of background job termination</span><br/>[1]+&#160;&#160;Done&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;./t_sigwaitinfo 60</p>
<p class="noindent"><span epub:type="pagebreak" id="page_470"/>In the output for the accepted <span class="literal">SIGUSR1</span> signal, we see that the <em>si_value</em> field has the value 100. This is the value to which the field was initialized by the preceding signal that was sent using <em>sigqueue()</em>. We noted earlier that the <em>si_value</em> field contains valid information only for signals sent using <em>sigqueue()</em>.</p>
<p class="examplet"><a id="ch22ex6"/><strong>Listing 22-6:</strong> Synchronously waiting for a signal with <em>sigwaitinfo()</em></p>
<p class="programsli">___________________________________________________ <span class="codestrong">signals/t_sigwaitinfo.c</span><br/><br/>#define _GNU_SOURCE<br/>#include &lt;string.h&gt;<br/>#include &lt;signal.h&gt;<br/>#include &lt;time.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int sig;<br/>&#160;&#160;&#160;&#160;siginfo_t si;<br/>&#160;&#160;&#160;&#160;sigset_t allSigs;<br/><br/>&#160;&#160;&#160;&#160;if (argc &gt; 1 &#38;&#38; strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s [delay-secs]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;printf("%s: PID is %ld\n", argv[0], (long) getpid());<br/><br/>&#160;&#160;&#160;&#160;/* Block all signals (except SIGKILL and SIGSTOP) */<br/><br/>&#160;&#160;&#160;&#160;sigfillset(&#38;allSigs);<br/>&#160;&#160;&#160;&#160;if (sigprocmask(SIG_SETMASK, &#38;allSigs, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask");<br/>&#160;&#160;&#160;&#160;printf("%s: signals blocked\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;if (argc &gt; 1) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Delay so that signals can be sent to us */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s: about to delay %s seconds\n", argv[0], argv[1]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep(getInt(argv[1], GN_GT_0, "delay-secs"));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s: finished delay\n", argv[0]);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;for (;;) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Fetch signals until SIGINT (^C) or SIGTERM */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sig = sigwaitinfo(&#38;allSigs, &#38;si);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sig == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigwaitinfo");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sig == SIGINT || sig == SIGTERM)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("got signal: %d (%s)\n", sig, strsignal(sig));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;si_signo=%d, si_code=%d (%s), si_value=%d\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;si.si_signo, si.si_code,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(si.si_code == SI_USER) ? "SI_USER" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(si.si_code == SI_QUEUE) ? "SI_QUEUE" : "other",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;si.si_value.sival_int);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;si_pid=%ld, si_uid=%ld\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) si.si_pid, (long) si.si_uid);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>___________________________________________________ <span class="codestrong">signals/t_sigwaitinfo.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_471"/>The <em>sigtimedwait()</em> system call is a variation on <em>sigwaitinfo()</em>. The only difference is that <em>sigtimedwait()</em> allows us to specify a time limit for waiting.</p>
<div class="box">
<p class="programsa">#define _POSIX_C_SOURCE 199309<br/>#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">sigtimedwait</span>(const sigset_t *<span class="font1">set</span>, siginfo_t *<span class="font1">info</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const struct timespec *<span class="font1">timeout</span>);</p>
<p class="right">Returns signal number on success, or &#8211;1 on error or timeout (<span class="literal">EAGAIN</span>)</p>
</div>
<p class="noindent">The <em>timeout</em> argument specifies the maximum time that <em>sigtimedwait()</em> should wait for a signal. It is a pointer to a structure of the following type:</p>
<p class="programs">struct timespec {<br/>&#160;&#160;&#160;&#160;time_t tv_sec;&#160;&#160;&#160;&#160;&#160;&#160;/* Seconds ('time_t' is an integer type) */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;tv_nsec;&#160;&#160;&#160;&#160;&#160;/* Nanoseconds */<br/>};</p>
<p class="noindent">The fields of the <em>timespec</em> structure are filled in to specify the maximum number of seconds and nanoseconds that <em>sigtimedwait()</em> should wait. Specifying both fields of the structure as 0 causes an immediate timeout&#8212;that is, a poll to check if any of the specified set of signals is pending. If the call times out without a signal being delivered, <em>sigtimedwait()</em> fails with the error <span class="literal">EAGAIN</span>.</p>
<p class="indent">If the <em>timeout</em> argument is specified as <span class="literal">NULL</span>, then <em>sigtimedwait()</em> is exactly equivalent to <em>sigwaitinfo()</em>. SUSv3 leaves the meaning of a <span class="literal">NULL</span> <em>timeout</em> unspecified, and some UNIX implementations instead interpret this as a poll request that returns immediately.</p>
<h3 class="h3" id="ch22lev1sec11"><strong>22.11 Fetching Signals via a File Descriptor</strong></h3>
<p class="noindenta">Starting with kernel 2.6.22, Linux provides the (nonstandard) <em>signalfd()</em> system call, which creates a special file descriptor from which signals directed to the caller can be read. The <em>signalfd</em> mechanism provides an alternative to the use of <em>sigwaitinfo()</em> for synchronously accepting signals.</p>
<div class="box">
<p class="programsa">#include &lt;sys/signalfd.h&gt;<br/><br/>int <span class="codestrong">signalfd</span>(int <span class="font1">fd</span>, const sigset_t *<span class="font1">mask</span>, int <span class="font1">flags</span>);</p>
<p class="right">Returns file descriptor on success, or &#8211;1 on error</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_472"/>The <em>mask</em> argument is a signal set that specifies the signals that we want to be able to read via the <em>signalfd</em> file descriptor. As with <em>sigwaitinfo()</em>, we should normally also block all of the signals in <em>mask</em> using <em>sigprocmask()</em>, so that the signals don&#8217;t get handled according to their default dispositions before we have a chance to read them.</p>
<p class="indent">If <em>fd</em> is specified as &#8211;1, then <em>signalfd()</em> creates a new file descriptor that can be used to read the signals in <em>mask</em>; otherwise, it modifies the mask associated with <em>fd</em>, which must be a file descriptor created by a previous call to <em>signalfd()</em>.</p>
<p class="indentb">In the initial implementation, the <em>flags</em> argument was reserved for future use and had to be specified as 0. However, since Linux 2.6.27, two flags are supported:</p>
<p class="term"><span class="literal">SFD_CLOEXEC</span></p>
<p class="termlist">Set the close-on-exec flag (<span class="literal">FD_CLOEXEC</span>) for the new file descriptor. This flag is useful for the same reasons as the <em>open()</em> <span class="literal">O_CLOEXEC</span> flag described in <a href="ch04.xhtml#ch04lev2sec01">Section 4.3.1</a>.</p>
<p class="term"><span class="literal">SFD_NONBLOCK</span></p>
<p class="termlist">Set the <span class="literal">O_NONBLOCK</span> flag on the underlying open file description, so that future reads will be nonblocking. This saves additional calls to <em>fcntl()</em> to achieve the same result.</p>
<p class="noindentt">Having created the file descriptor, we can then read signals from it using <em>read()</em>. The buffer given to <em>read()</em> must be large enough to hold at least one <em>signalfd_siginfo</em> structure, defined as follows in <span class="literal">&lt;sys/signalfd.h&gt;</span>:</p>
<p class="programs">struct signalfd_siginfo {<br/>&#160;&#160;&#160;&#160;uint32_t&#160;&#160;ssi_signo;&#160;&#160;&#160;&#160;/* Signal number */<br/>&#160;&#160;&#160;&#160;int32_t&#160;&#160;&#160;ssi_errno;&#160;&#160;&#160;&#160;/* Error number (generally unused) */<br/>&#160;&#160;&#160;&#160;int32_t&#160;&#160;&#160;ssi_code;&#160;&#160;&#160;&#160;&#160;/* Signal code */<br/>&#160;&#160;&#160;&#160;uint32_t&#160;&#160;ssi_pid;&#160;&#160;&#160;&#160;&#160;&#160;/* Process ID of sending process */<br/>&#160;&#160;&#160;&#160;uint32_t&#160;&#160;ssi_uid;&#160;&#160;&#160;&#160;&#160;&#160;/* Real user ID of sender */<br/>&#160;&#160;&#160;&#160;int32_t&#160;&#160;&#160;ssi_fd;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* File descriptor (SIGPOLL/SIGIO) */<br/>&#160;&#160;&#160;&#160;uint32_t&#160;&#160;ssi_tid;&#160;&#160;&#160;&#160;&#160;&#160;/* (Kernel-internal) timer ID (POSIX timers) */<br/>&#160;&#160;&#160;&#160;uint32_t&#160;&#160;ssi_band;&#160;&#160;&#160;&#160;&#160;/* Band event (SIGPOLL/SIGIO) */<br/>&#160;&#160;&#160;&#160;uint32_t&#160;&#160;ssi_overrun;&#160;&#160;/* Overrun count (POSIX timers) */<br/>&#160;&#160;&#160;&#160;uint32_t&#160;&#160;ssi_trapno;&#160;&#160;&#160;/* Trap number */<br/>&#160;&#160;&#160;&#160;int32_t&#160;&#160;&#160;ssi_status;&#160;&#160;&#160;/* Exit status or signal (SIGCHLD) */<br/>&#160;&#160;&#160;&#160;int32_t&#160;&#160;&#160;ssi_int;&#160;&#160;&#160;&#160;&#160;&#160;/* Integer sent by sigqueue() */<br/>&#160;&#160;&#160;&#160;uint64_t&#160;&#160;ssi_ptr;&#160;&#160;&#160;&#160;&#160;&#160;/* Pointer sent by sigqueue() */<br/>&#160;&#160;&#160;&#160;uint64_t&#160;&#160;ssi_utime;&#160;&#160;&#160;&#160;/* User CPU time (SIGCHLD) */<br/>&#160;&#160;&#160;&#160;uint64_t&#160;&#160;ssi_stime;&#160;&#160;&#160;&#160;/* System CPU time (SIGCHLD) */<br/>&#160;&#160;&#160;&#160;uint64_t&#160;&#160;ssi_addr;&#160;&#160;&#160;&#160;&#160;/* Address that generated signal<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(hardware-generated signals only) */<br/>};</p>
<p class="noindent">The fields in this structure return the same information as the similarly named fields in the traditional <em>siginfo_t</em> structure (<a href="ch21.xhtml#ch21lev1sec04">Section 21.4</a>).</p>
<p class="indent">Each call to <em>read()</em> returns as many <em>signalfd_siginfo</em> structures as there are signals pending and will fit in the supplied buffer. If no signals are pending at the time of the call, then <em>read()</em> blocks until a signal arrives. We can also use the <em>fcntl()</em> <span class="literal">F_SETFL</span> <span epub:type="pagebreak" id="page_473"/>operation (<a href="ch05.xhtml#ch05lev1sec03">Section 5.3</a>) to set the <span class="literal">O_NONBLOCK</span> flag for the file descriptor, so that reads are nonblocking and will fail with the error <span class="literal">EAGAIN</span> if no signals are pending.</p>
<p class="indent">When a signal is read from a <em>signalfd</em> file descriptor, it is consumed and ceases to be pending for the process.</p>
<p class="examplet"><a id="ch22ex7"/><strong>Listing 22-7:</strong> Using <em>signalfd()</em> to read signals</p>
<p class="programsli">__________________________________________________<span class="codestrong">signals/signalfd_sigval.c</span><br/><br/>#include &lt;sys/signalfd.h&gt;<br/>#include &lt;signal.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;sigset_t mask;<br/>&#160;&#160;&#160;&#160;int sfd, j;<br/>&#160;&#160;&#160;&#160;struct signalfd_siginfo fdsi;<br/>&#160;&#160;&#160;&#160;ssize_t s;<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s sig-num...\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;printf("%s: PID = %ld\n", argv[0], (long) getpid());<br/><br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;mask);<br/>&#160;&#160;&#160;&#160;for (j = 1; j &lt; argc; j++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigaddset(&#38;mask, atoi(argv[j]));<br/><br/>&#160;&#160;&#160;&#160;if (sigprocmask(SIG_BLOCK, &#38;mask, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask");<br/><br/>&#160;&#160;&#160;&#160;sfd = signalfd(-1, &#38;mask, 0);<br/>&#160;&#160;&#160;&#160;if (sfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("signalfd");<br/><br/>&#160;&#160;&#160;&#160;for (;;) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = read(sfd, &#38;fdsi, sizeof(struct signalfd_siginfo));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != sizeof(struct signalfd_siginfo))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("read");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s: got signal %d", argv[0], fdsi.ssi_signo);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (fdsi.ssi_code == SI_QUEUE) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("; ssi_pid = %d; ", fdsi.ssi_pid);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("ssi_int = %d", fdsi.ssi_int);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("\n");<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>__________________________________________________<span class="codestrong">signals/signalfd_sigval.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_474"/>A <em>signalfd</em> file descriptor can be monitored along with other descriptors using <em>select()</em>, <em>poll()</em>, and <em>epoll</em> (described in <a href="ch63.xhtml#ch63">Chapter 63</a>). Among other uses, this feature provides an alternative to the self-pipe trick described in <a href="ch63.xhtml#ch63lev2sec17">Section 63.5.2</a>. If signals are pending, then these techniques indicate the file descriptor as being readable.</p>
<p class="indent">When we no longer require a <em>signalfd</em> file descriptor, we should close it, in order to release the associated kernel resources.</p>
<p class="indent"><a href="ch22.xhtml#ch22ex7">Listing 22-7</a> (on <a href="ch22.xhtml#page_473">page 473</a>) demonstrates the use of <em>signalfd()</em>. This program creates a mask of the signal numbers specified in its command-line arguments, blocks those signals, and then creates a <em>signalfd</em> file descriptor to read those signals. It then loops, reading signals from the file descriptor and displaying some of the information from the returned <em>signalfd_siginfo</em> structure. In the following shell session, we run the program in <a href="ch22.xhtml#ch22ex7">Listing 22-7</a> in the background and send it a realtime signal with accompanying data using the program in <a href="ch22.xhtml#ch22ex2">Listing 22-2</a> (<span class="literal">t_sigqueue.c</span>):</p>
<p class="programs">$ <span class="codestrong">./signalfd_sigval 44 &#38;</span><br/>./signalfd_sigval: PID = 6267<br/>[1] 6267<br/>$ <span class="codestrong">./t_sigqueue 6267 44 123</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Send signal 44 with data 123 to PID 6267</span><br/>./t_sigqueue: PID is 6269, UID is 1000<br/>./signalfd_sigval: got signal 44; ssi_pid=6269; ssi_int=123<br/>$ <span class="codestrong">kill %1</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Kill program running in background</span></p>
<h3 class="h3" id="ch22lev1sec12"><strong>22.12 Interprocess Communication with Signals</strong></h3>
<p class="noindentab">From one viewpoint, we can consider signals as a form of interprocess communication (IPC). However, signals suffer a number of limitations as an IPC mechanism. First, by comparison with other methods of IPC that we examine in later chapters, programming with signals is cumbersome and difficult. The reasons for this are as follows:</p>
<p class="bull">&#8226; The asynchronous nature of signals means that we face various problems, including reentrancy requirements, race conditions, and the correct handling of global variables from signal handlers. (Most of these problems do not occur if we are using <em>sigwaitinfo()</em> or <em>signalfd()</em> to synchronously fetch signals.)</p>
<p class="bull">&#8226; Standard signals are not queued. Even for realtime signals, there are upper limits on the number of signals that may be queued. This means that in order to avoid loss of information, the process receiving the signals must have a method of informing the sender that it is ready to receive another signal. The most obvious method of doing this is for the receiver to send a signal to the sender.</p>
<p class="noindentt">A further problem is that signals carry only a limited amount of information: the signal number, and in the case of realtime signals, a word (an integer or a pointer) of additional data. This low bandwidth makes signals slow by comparison with other methods of IPC such as pipes.</p>
<p class="indent">As a consequence of the above limitations, signals are rarely used for IPC.</p>
<h3 class="h3" id="ch22lev1sec13"><span epub:type="pagebreak" id="page_475"/><strong>22.13 Earlier Signal APIs (System V and BSD)</strong></h3>
<p class="noindenta">Our discussion of signals has focused on the POSIX signal API. We now briefly look at the historical APIs provided by System V and BSD. Although all new applications should use the POSIX API, we may encounter these obsolete APIs when porting (usually older) applications from other UNIX implementations. Because Linux (like many other UNIX implementations) provides System V and BSD compatibility APIs, often all that is required to port programs using these older APIs is to recompile them on Linux.</p>
<h5 class="h5" id="ch22lev3sec13"><strong>The System V signal API</strong></h5>
<p class="noindenta">As noted earlier, one important difference in the System V signal API is that when a handler is established with <em>signal()</em>, we get the older, unreliable signal semantics. This means that the signal is not added to the process signal mask, the disposition of the signal is reset to the default when the handler is called, and system calls are not automatically restarted.</p>
<p class="indent">Below, we briefly describe the functions in the System V signal API. The manual pages provide full details. SUSv3 specifies all of these functions, but notes that the modern POSIX equivalents are preferred. SUSv4 marks these functions obsolete.</p>
<div class="box">
<p class="programsa">#define _XOPEN_SOURCE 500<br/>#include &lt;signal.h&gt;<br/><br/>void (*<span class="codestrong">sigset</span>(int <span class="font1">sig</span>, void (*<span class="font1">handler</span>)(int)))(int);</p>
<p class="right">On success: returns the previous disposition of <em>sig</em>, or <span class="literal">SIG_HOLD</span> if <em>sig</em> was previously blocked; on error &#8211;1 is returned</p>
</div>
<p class="noindent">To establish a signal handler with reliable semantics, System V provided the <em>sigset()</em> call (with a prototype similar to that of <em>signal()</em>). As with <em>signal()</em>, the <em>handler</em> argument for <em>sigset()</em> can be specified as <span class="literal">SIG_IGN</span>, <span class="literal">SIG_DFL</span>, or the address of a signal handler. Alternatively, it can be specified as <span class="literal">SIG_HOLD</span>, to add the signal to the process signal mask while leaving the disposition of the signal unchanged.</p>
<p class="indent">If <em>handler</em> is specified as anything other than <span class="literal">SIG_HOLD</span>, <em>sig</em> is removed from the process signal mask (i.e., if <em>sig</em> was blocked, it is unblocked).</p>
<div class="box">
<p class="programsa">#define _XOPEN_SOURCE 500<br/>#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">sighold</span>(int <span class="font1">sig</span>);<br/>int <span class="codestrong">sigrelse</span>(int <span class="font1">sig</span>);<br/>int <span class="codestrong">sigignore</span>(int <span class="font1">sig</span>);</p>
<p class="right">All return 0 on success, or &#8211;1 on error</p>
<p class="programsat">int <span class="codestrong">sigpause</span>(int <span class="font1">sig</span>);</p>
<p class="right">Always returns &#8211;1 with <em>errno</em> set to <span class="literal">EINTR</span></p>
</div>
<p class="noindent">The <em>sighold()</em> function adds a signal to the process signal mask. The <em>sigrelse()</em> function removes a signal from the signal mask. The <em>sigignore()</em> function sets a signal&#8217;s <span epub:type="pagebreak" id="page_476"/>disposition to <em>ignore</em>. The <em>sigpause()</em> function is similar to <em>sigsuspend()</em>, but removes just one signal from the process signal mask before suspending the process until the arrival of a signal.</p>
<h5 class="h5" id="ch22lev3sec14"><strong>The BSD signal API</strong></h5>
<p class="noindenta">The POSIX signal API drew heavily on the 4.2BSD API, so the BSD functions are mainly direct analogs of those in POSIX.</p>
<p class="indent">As with the functions in the System V signal API described above, we present the prototypes of the functions in the BSD signal API, and briefly explain the operation of each function. Once again, the manual pages provide full details.</p>
<div class="box">
<p class="programsa">#define _BSD_SOURCE<br/>#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">sigvec</span>(int <span class="font1">sig</span>, const struct sigvec *<span class="font1">vec</span>, struct sigvec *<span class="font1">ovec</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>sigvec()</em> function is analogous to <em>sigaction()</em>. The <em>vec</em> and <em>ovec</em> arguments are pointers to structures of the following type:</p>
<p class="programs">struct sigvec {<br/>&#160;&#160;&#160;&#160;void (*sv_handler)(int);<br/>&#160;&#160;&#160;&#160;int&#160;&#160;sv_mask;<br/>&#160;&#160;&#160;&#160;int&#160;&#160;sv_flags;<br/>};</p>
<p class="noindent">The fields of the <em>sigvec</em> structure correspond closely with those of the <em>sigaction</em> structure. The first notable difference is that the <em>sv_mask</em> field (the analog of <em>sa_mask</em>) was an integer rather than a <em>sigset_t</em>, which meant that, on 32-bit architectures, there was a maximum of 31 different signals. The other difference is the use of the <span class="literal">SV_INTERRUPT</span> flag in the <em>sv_flags</em> field (the analog of <em>sa_flags</em>). Since system call restarting was the default on 4.2BSD, this flag was used to specify that slow system calls should be interrupted by signal handlers. (This contrasts with the POSIX API, where we must explicitly specify <span class="literal">SA_RESTART</span> in order to enable restarting of system calls when establishing a signal handler with <em>sigaction()</em>.)</p>
<div class="box">
<p class="programsa">#define _BSD_SOURCE<br/>#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">sigblock</span>(int <span class="font1">mask</span>);<br/>int <span class="codestrong">sigsetmask</span>(int <span class="font1">mask</span>);</p>
<p class="right">Both return previous signal mask</p>
<p class="programsat">int <span class="codestrong">sigpause</span>(int <span class="font1">sigmask</span>);</p>
<p class="right">Always returns &#8211;1 with <em>errno</em> set to <span class="literal">EINTR</span></p>
<p class="programsat">int <span class="codestrong">sigmask</span>(int <span class="font1">sig</span>);</p>
<p class="right">Returns signal mask value with bit <em>sig</em> set</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_477"/>The <em>sigblock()</em> function adds a set of signals to the process signal mask. It is analogous to the <em>sigprocmask()</em> <span class="literal">SIG_BLOCK</span> operation. The <em>sigsetmask()</em> call specifies an absolute value for the signal mask. It is analogous to the <em>sigprocmask()</em> <span class="literal">SIG_SETMASK</span> operation.</p>
<p class="indent">The <em>sigpause()</em> function is analogous to <em>sigsuspend()</em>. Note that this function is defined with different calling signatures in the System V and BSD APIs. The GNU C library provides the System V version by default, unless we specify the <span class="literal">_BSD_SOURCE</span> feature test macro when compiling a program.</p>
<p class="indent">The <em>sigmask()</em> macro turns a signal number into the corresponding 32-bit mask value. Such bit masks can then be ORed together to create a set of signals, as in the following:</p>
<p class="programs">sigblock(sigmask(SIGINT) | sigmask(SIGQUIT));</p>
<h3 class="h3" id="ch22lev1sec14"><strong>22.14 Summary</strong></h3>
<p class="noindenta">Certain signals cause a process to create a core dump and terminate. Core dumps contain information that can be used by a debugger to inspect the state of a process at the time that it terminated. By default, a core dump file is named <span class="literal">core</span>, but Linux provides the <span class="literal">/proc/sys/kernel/core_pattern</span> file to control the naming of core dump files.</p>
<p class="indent">A signal may be generated asynchronously or synchronously. Asynchronous generation occurs when a signal is sent to a process by the kernel or by another process. A process can&#8217;t predict precisely when an asynchronously generated signal will be delivered. (We noted that asynchronous signals are normally delivered the next time the receiving process switches from kernel mode to user mode.) Synchronous generation occurs when the process itself executes code that directly generates the signal&#8212;for example, by executing an instruction that causes a hardware exception or by calling <em>raise()</em>. The delivery of a synchronously generated signal is precisely predictable (it occurs immediately).</p>
<p class="indent">Realtime signals are a POSIX addition to the original signal model, and differ from standard signals in that they are queued, have a specified delivery order, and can be sent with an accompanying piece of data. Realtime signals are designed to be used for application-defined purposes. A realtime signal is sent using the <em>sigqueue()</em> system call, and an additional argument (the <em>siginfo_t</em> structure) is supplied to the signal handler so that it can obtain the data accompanying the signal, as well as the process ID and real user ID of the sending process.</p>
<p class="indent">The <em>sigsuspend()</em> system call allows a program to atomically modify the process signal mask and suspend execution until a signal arrives. The atomicity of <em>sigsuspend()</em> is essential to avoid race conditions when unblocking a signal and then suspending execution until that signal arrives.</p>
<p class="indent">We can use <em>sigwaitinfo()</em> and <em>sigtimedwait()</em> to synchronously wait for a signal. This saves us the work of designing and writing a signal handler, which may be unnecessary if our only aim is to wait for the delivery of a signal.</p>
<p class="indent">Like <em>sigwaitinfo()</em> and <em>sigtimedwait()</em>, the Linux-specific <em>signalfd()</em> system call can be used to synchronously wait for a signal. The distinctive feature of this interface is that signals can be read via a file descriptor. This file descriptor can also be monitored using <em>select()</em>, <em>poll()</em>, and <em>epoll</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_478"/>Although signals can be viewed as a method of IPC, many factors make them generally unsuitable for this purpose, including their asynchronous nature, the fact that they are not queued, and their low bandwidth. More usually, signals are used as a method of process synchronization and for a variety of other purposes (e.g., event notification, job control, and timer expiration).</p>
<p class="indent">Although the fundamental signal concepts are straightforward, our discussion has stretched over three chapters, since there were many details to cover. Signals play an important role in various parts of the system call API, and we&#8217;ll revisit their use in several later chapters. In addition, various signal-related functions are specific to threads (e.g., <em>pthread_kill()</em> and <em>pthread_sigmask()</em>), and we defer discussion of these functions until <a href="ch33.xhtml#ch33lev1sec02">Section 33.2</a>.</p>
<h5 class="h5" id="ch22lev3sec15"><strong>Further information</strong></h5>
<p class="noindenta">See the sources listed in <a href="ch20.xhtml#ch20lev1sec15">Section 20.15</a>.</p>
<h3 class="h3" id="ch22lev1sec15"><strong>22.15 Exercises</strong></h3>
<p class="exer"><a id="ch22exe1"/><strong>22-1.</strong>&#160;&#160;&#160;<a href="ch22.xhtml#ch22lev1sec02">Section 22.2</a> noted that if a stopped process that has established a handler for and blocked <span class="literal">SIGCONT</span> is later resumed as a consequence of receiving a <span class="literal">SIGCONT</span>, then the handler is invoked only when <span class="literal">SIGCONT</span> is unblocked. Write a program to verify this. Recall that a process can be stopped by typing the terminal <em>suspend</em> character (usually <em>Control-Z</em>) and can be sent a <span class="literal">SIGCONT</span> signal using the command <em>kill &#8211;CONT</em> (or implicitly, using the shell <em>fg</em> command).</p>
<p class="exer"><a id="ch22exe2"/><strong>22-2.</strong>&#160;&#160;&#160;If both a realtime and a standard signal are pending for a process, SUSv3 leaves it unspecified which is delivered first. Write a program that shows what Linux does in this case. (Have the program set up a handler for all signals, block signals for a period of time so that you can send various signals to it, and then unblock all signals.)</p>
<p class="exer"><a id="ch22exe3"/><strong>22-3.</strong>&#160;&#160;&#160;<a href="ch22.xhtml#ch22lev1sec10">Section 22.10</a> stated that accepting signals using <em>sigwaitinfo()</em> is faster than the use of a signal handler plus <em>sigsuspend()</em>. The program <span class="literal">signals/sig_speed_sigsuspend.c</span>, supplied in the source code distribution for this book, uses <em>sigsuspend()</em> to alternately send signals back and forward between a parent and a child process. Time the operation of this program to exchange one million signals between the two processes. (The number of signals to exchange is provided as a command-line argument to the program.) Create a modified version of the program that instead uses <em>sigwaitinfo()</em>, and time that version. What is the speed difference between the two programs?</p>
<p class="exer"><a id="ch22exe4"/><strong>22-4.</strong>&#160;&#160;&#160;Implement the System V functions <em>sigset()</em>, <em>sighold()</em>, <em>sigrelse()</em>, <em>sigignore()</em>, and <em>sigpause()</em> using the POSIX signal API.</p>
</body>
</html>
