<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_211"/><strong><span class="big">11</span></strong><br/><strong>SYSTEM LIMITS AND OPTIONS</strong></h2>
<p class="noindentab">Each UNIX implementation sets limits on various system features and resources, and provides&#8212;or chooses not to provide&#8212;options defined in various standards. Examples include the following:</p>
<p class="bull">&#8226; How many files can a process hold open at one time?</p>
<p class="bull">&#8226; Does the system support realtime signals?</p>
<p class="bull">&#8226; What is the largest value that can be stored in a variable of type <em>int</em>?</p>
<p class="bull">&#8226; How big an argument list can a program have?</p>
<p class="bull">&#8226; What is the maximum length of a pathname?</p>
<p class="noindenttb">While we could hard-code assumed limits and options into an application, this reduces portability, since limits and options may vary:</p>
<p class="bull">&#8226; <em>Across UNIX implementations</em>: Although limits and options may be fixed on an individual implementation, they can vary from one UNIX implementation to another. The maximum value that can be stored in an <em>int</em> is an example of such a limit.</p>
<p class="bull">&#8226; <em>At run time on a particular implementation</em>: The kernel may have been reconfigured to change a limit, for example. Alternatively, the application may have been compiled on one system, but run on another system with different limits and options.</p>
<p class="bull"><span epub:type="pagebreak" id="page_212"/>&#8226; <em>From one file system to another</em>: For example, traditional System V file systems allow a filename to be up to 14 bytes, while traditional BSD file systems and most native Linux file systems allow filenames of up to 255 bytes.</p>
<p class="noindenttb">Since system limits and options affect what an application may do, a portable application needs ways of determining limit values and whether options are supported. The C programming language standards and SUSv3 provide two principal avenues for an application to obtain such information:</p>
<p class="bull">&#8226; Some limits and options can be determined at compile time. For example, the maximum value of an <em>int</em> is determined by the hardware architecture and compiler design choices. Such limits can be recorded in header files.</p>
<p class="bull">&#8226; Other limits and options may vary at run time. For such cases, SUSv3 defines three functions&#8212;<em>sysconf()</em>, <em>pathconf()</em>, and <em>fpathconf()</em>&#8212;that an application can call to check these implementation limits and options.</p>
<p class="noindent">SUSv3 specifies a range of limits that a conforming implementation may enforce, as well as a set of options, each of which may or may not be provided by a particular system. We describe a few of these limits and options in this chapter, and describe others at relevant points in later chapters.</p>
<h3 class="h3" id="ch11lev1sec01"><strong>11.1 System Limits</strong></h3>
<p class="noindenta">For each limit that it specifies, SUSv3 requires that all implementations support a <em>minimum value</em> for the limit. In most cases, this minimum value is defined as a constant in <span class="literal">&lt;limits.h&gt;</span> with a name prefixed by the string <span class="literal">_POSIX_</span>, and (usually) containing the string <span class="literal">_MAX</span>; thus, the form of the name is <span class="literal">_POSIX_XXX_MAX</span>.</p>
<p class="indent">If an application restricts itself to the minimum values that SUSv3 requires for each limit, then it will be portable to all implementations of the standard. However, doing so prevents an application from taking advantage of implementations that provide higher limits. For this reason, it is usually preferable to determine the limit on a particular system using <span class="literal">&lt;limits.h&gt;</span>, <em>sysconf()</em>, or <em>pathconf()</em>.</p>
<div class="block">
<p class="noindent">The use of the string <span class="literal">_MAX</span> in the limit names defined by SUSv3 can appear confusing, given their description as <em>minimum</em> values. The rationale for the names becomes clear when we consider that each of these constants defines an upper limit on some resource or feature, and the standards are saying that this upper limit must have a certain minimum value.</p>
<p class="indent">In some cases, <em>maximum values</em> are provided for a limit, and these values have names containing the string <span class="literal">_MIN</span>. For these constants, the converse holds true: they represent a lower limit on some resource, and the standards are saying that, on a conforming implementation, this lower limit can be no greater than a certain value. For example, the <span class="literal">FLT_MIN</span> limit (<span class="literal">1E-37</span>) defines the largest value that an implementation may set for the smallest floating-point number that may be represented, and all conforming implementations will be able to represent floating-point numbers at least this small.</p>
</div>
<p class="noindent">Each limit has a <em>name</em>, which corresponds to the <em>minimum value name</em> described above, but lacks the <span class="literal">_POSIX_</span> prefix. An implementation <em>may</em> define a constant with this name in <span class="literal">&lt;limits.h&gt;</span> to indicate the corresponding limit for this implementation. <span epub:type="pagebreak" id="page_213"/>If defined, this limit will always be at least the size of the minimum value described above (i.e., <span class="literal">XXX_MAX &gt;= _POSIX_XXX_MAX</span>).</p>
<p class="indent">SUSv3 divides the limits that it specifies into three categories: <em>runtime invariant values</em>, <em>pathname variable values</em>, and <em>runtime increasable values</em>. In the following paragraphs, we describe these categories and provide some examples.</p>
<h5 class="h5" id="ch11lev3sec01"><strong>Runtime invariant values (possibly indeterminate)</strong></h5>
<p class="noindenta">A runtime invariant value is a limit whose value, if defined in <span class="literal">&lt;limits.h&gt;</span>, is fixed for the implementation. However, the value may be indeterminate (perhaps because it depends on available memory space), and hence omitted from <span class="literal">&lt;limits.h&gt;</span>. In this case (and even if the limit is also defined in <span class="literal">&lt;limits.h&gt;</span>), an application can use <em>sysconf()</em> to determine the value at run time.</p>
<p class="indent">The <span class="literal">MQ_PRIO_MAX</span> limit is an example of a runtime invariant value. As noted in <a href="ch52.xhtml#ch52lev2sec01">Section 52.5.1</a>, there is a limit on the priority for messages in POSIX message queues. SUSv3 defines the constant <span class="literal">_POSIX_MQ_PRIO_MAX</span>, with the value 32, as the minimum value that all conforming implementations must provide for this limit. This means that we can be sure that all conforming implementations will allow priorities from 0 up to at least 31 for message priorities. A UNIX implementation can set a higher limit than this, defining the constant <span class="literal">MQ_PRIO_MAX</span> in <span class="literal">&lt;limits.h&gt;</span> with the value of its limit. For example, on Linux, <span class="literal">MQ_PRIO_MAX</span> is defined with the value 32,768. This value can also be determined at run time using the following call:</p>
<p class="programs">lim = sysconf(_SC_MQ_PRIO_MAX);</p>
<h5 class="h5" id="ch11lev3sec02"><strong>Pathname variable values</strong></h5>
<p class="noindenta">Pathname variable values are limits that relate to pathnames (files, directories, terminals, and so on). Each limit may be constant for the implementation or may vary from one file system to another. In cases where a limit can vary depending on the pathname, an application can determine its value using <em>pathconf()</em> or <em>fpathconf()</em>.</p>
<p class="indent">The <span class="literal">NAME_MAX</span> limit is an example of a pathname variable value. This limit defines the maximum size for a filename on a particular file system. SUSv3 defines the constant <span class="literal">_POSIX_NAME_MAX</span>, with the value 14 (the old System V file-system limit), as the minimum value that an implementation must allow. An implementation may define <span class="literal">NAME_MAX</span> with a limit higher than this and/or make information about a specific file system available via a call of the following form:</p>
<p class="programs">lim = pathconf(directory_path, _PC_NAME_MAX)</p>
<p class="noindent">The <em>directory_path</em> is a pathname for a directory on the file system of interest.</p>
<h5 class="h5" id="ch11lev3sec03"><strong>Runtime increasable values</strong></h5>
<p class="noindenta">A runtime increasable value is a limit that has a fixed minimum value for a particular implementation, and all systems running the implementation will provide at least this minimum value. However, a specific system may increase this limit at run time, and an application can find the actual value supported on the system using <em>sysconf()</em>.</p>
<p class="indent">An example of a runtime increasable value is <span class="literal">NGROUPS_MAX</span>, which defines the maximum number of simultaneous supplementary group IDs for a process <span epub:type="pagebreak" id="page_214"/>(<a href="ch09.xhtml#ch09lev1sec06">Section 9.6</a>). SUSv3 defines the corresponding minimum value, <span class="literal">_POSIX_NGROUPS_MAX</span>, with the value 8. At run time, an application can retrieve the limit using the call <em>sysconf(_SC_NGROUPS_MAX)</em>.</p>
<h5 class="h5" id="ch11lev3sec04"><strong>Summary of selected SUSv3 limits</strong></h5>
<p class="noindenta"><a href="ch11.xhtml#ch11table1">Table 11-1</a> lists a few of the SUSv3-defined limits that are relevant to this book (other limits are introduced in later chapters).</p>
<p class="tablecap"><a id="ch11table1"/><strong>Table 11-1:</strong> Selected SUSv3 limits</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Name of limit (</strong><span class="literal"><span class="codestrong">&lt;limits.h&gt;</span></span><strong>)</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Min. value</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><em>sysconf() / pathconf()</em> name (</strong><span class="literal"><span class="codestrong">&lt;unistd.h&gt;</span></span><strong>)</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ARG_MAX</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">4096</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">_SC_ARG_MAX</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Maximum bytes for arguments (<em>argv</em>) plus environment (<em>environ</em>) that can be supplied to an <em>exec()</em> (<a href="ch06.xhtml#ch06lev1sec07">Sections 6.7</a> and <a href="ch27.xhtml#ch27lev2sec03">27.2.3</a>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">none</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">none</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">_SC_CLK_TCK</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Unit of measurement for <em>times()</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">LOGIN_NAME_MAX</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">9</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">_SC_LOGIN_NAME_MAX</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Maximum size of a login name (including terminating null byte)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">OPEN_MAX</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">20</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">_SC_OPEN_MAX</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Maximum number of file descriptors that a process can have open at one time, and one greater than maximum usable descriptor number (<a href="ch36.xhtml#ch36lev1sec02">Section 36.2</a>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">NGROUPS_MAX</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">8</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">_SC_NGROUPS_MAX</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Maximum number of supplementary groups of which a process can be a member (<a href="ch09.xhtml#ch09lev2sec03">Section 9.7.3</a>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">none</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">1</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">_SC_PAGESIZE</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Size of a virtual memory page (<span class="literal">_SC_PAGE_SIZE</span> is a synonym)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">RTSIG_MAX</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">8</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">_SC_RTSIG_MAX</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Maximum number of distinct realtime signals (<a href="ch22.xhtml#ch22lev1sec08">Section 22.8</a>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGQUEUE_MAX</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">32</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">_SC_SIGQUEUE_MAX</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Maximum number of queued realtime signals (<a href="ch22.xhtml#ch22lev1sec08">Section 22.8</a>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">STREAM_MAX</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">8</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">_SC_STREAM_MAX</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Maximum number of <em>stdio</em> streams that can be open at one time</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">NAME_MAX</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">14</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">_PC_NAME_MAX</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Maximum number of bytes in a filename, <em>excluding</em> terminating null byte</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">PATH_MAX</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">256</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">_PC_PATH_MAX</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Maximum number of bytes in a pathname, <em>including</em> terminating null byte</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">PIPE_BUF</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">512</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">_PC_PIPE_BUF</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Maximum number of bytes that can be written atomically to a pipe or FIFO (<a href="ch44.xhtml#ch44lev1sec01">Section 44.1</a>)</p></td>
</tr>
</tbody>
</table>
<p class="noindent">The first column of <a href="ch11.xhtml#ch11table1">Table 11-1</a> gives the name of the limit, which may be defined as a constant in <span class="literal">&lt;limits.h&gt;</span> to indicate the limit for a particular implementation. The second column is the SUSv3-defined minimum for the limit (also defined in <span class="literal">&lt;limits.h&gt;</span>). In most cases, each of the minimum values is defined as a constant prefixed with the string <span class="literal">_POSIX_</span>. For example, the constant <span class="literal">_POSIX_RTSIG_MAX</span> (defined <span epub:type="pagebreak" id="page_215"/>with the value 8) specifies the SUSv3-required minimum corresponding to the <span class="literal">RTSIG_MAX</span> implementation constant. The third column specifies the constant name that can be given at run time to <em>sysconf()</em> or <em>pathconf()</em> in order to retrieve the implementation limit. The constants beginning with <span class="literal">_SC_</span> are for use with <em>sysconf()</em>; those beginning with <span class="literal">_PC_</span> are for use with <em>pathconf()</em> and <em>fpathconf()</em>.</p>
<p class="indentb">Note the following information supplementary to that shown in <a href="ch11.xhtml#ch11table1">Table 11-1</a>:</p>
<p class="bull">&#8226; The <em>getdtablesize()</em> function is an obsolete alternative for determining the process file descriptor limit (<span class="literal">OPEN_MAX</span>). This function was specified in SUSv2 (marked LEGACY), but was removed in SUSv3.</p>
<p class="bull">&#8226; The <em>getpagesize()</em> function is an obsolete alternative for determining the system page size (<span class="literal">_SC_PAGESIZE</span>). This function was specified in SUSv2 (marked LEGACY), but was removed in SUSv3.</p>
<p class="bull">&#8226; The constant <span class="literal">FOPEN_MAX</span>, defined in <span class="literal">&lt;stdio.h&gt;</span>, is synonymous with <span class="literal">STREAM_MAX</span>.</p>
<p class="bull">&#8226; <span class="literal">NAME_MAX</span> excludes the terminating null byte, while <span class="literal">PATH_MAX</span> includes it. This inconsistency repairs an earlier inconsistency in the POSIX.1 standard that left it unclear whether <span class="literal">PATH_MAX</span> included the terminating null byte. Defining <span class="literal">PATH_MAX</span> to include the terminator means that applications that allocated just <span class="literal">PATH_MAX</span> bytes for a pathname will still conform to the standard.</p>
<h5 class="h5" id="ch11lev3sec05"><strong>Determining limits and options from the shell: <em>getconf</em></strong></h5>
<p class="noindenta">From the shell, we can use the <em>getconf</em> command to obtain the limits and options implemented by a particular UNIX implementation. The general form of this command is as follows:</p>
<p class="programs">$ <span class="codestrong">getconf <span class="codeitalic">variable-name</span></span> [ <span class="codestrong"><span class="codeitalic">pathname</span></span> ]</p>
<p class="noindent">The <em>variable-name</em> identifies the limit of interest and is one of the SUSV3 standard limit names, such as <span class="literal">ARG_MAX</span> or <span class="literal">NAME_MAX</span>. Where the limit relates to a pathname, we must specify a pathname as the second argument to the command, as in the second of the following examples.</p>
<p class="programs">$ <span class="codestrong">getconf ARG_MAX</span><br/>131072<br/>$ <span class="codestrong">getconf NAME_MAX /boot</span><br/>255</p>
<h3 class="h3" id="ch11lev1sec02"><strong>11.2 Retrieving System Limits (and Options) at Run Time</strong></h3>
<p class="noindenta">The <em>sysconf()</em> function allows an application to obtain the values of system limits at run time.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>long <span class="codestrong">sysconf</span>(int <span class="font1">name</span>);</p>
<p class="right">Returns value of limit specified by <em>name</em>, or &#8211;1 if limit is indeterminate or an error occurred</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_216"/>The <em>name</em> argument is one of the <span class="literal">_SC_*</span> constants defined in <span class="literal">&lt;unistd.h&gt;</span>, some of which are listed in <a href="ch11.xhtml#ch11table1">Table 11-1</a>. The value of the limit is returned as the function result.</p>
<p class="indent">If a limit can&#8217;t be determined, <em>sysconf()</em> returns &#8211;1. It may also return &#8211;1 if an error occurred. (The only specified error is <span class="literal">EINVAL</span>, indicating that <em>name</em> is not valid.) To distinguish the case of an indeterminate limit from an error, we must set <em>errno</em> to 0 before the call; if the call returns &#8211;1 and <em>errno</em> is set after the call, then an error occurred.</p>
<div class="block">
<p class="noindent">The limit values returned by <em>sysconf()</em> (as well as <em>pathconf()</em> and <em>fpathconf()</em>) are always (<em>long</em>) integers. In the rationale text for <em>sysconf()</em>, SUSv3 notes that strings were considered as possible return values, but were rejected because of the complexity of implementation and use.</p>
</div>
<p class="noindent"><a href="ch11.xhtml#ch11ex1">Listing 11-1</a> demonstrates the use of <em>sysconf()</em> to display various system limits. Running this program on one Linux 2.6.31/x86-32 system yields the following:</p>
<p class="programs">$ <span class="codestrong">./t_sysconf</span><br/>_SC_ARG_MAX:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2097152<br/>_SC_LOGIN_NAME_MAX:&#160;&#160;256<br/>_SC_OPEN_MAX:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1024<br/>_SC_NGROUPS_MAX:&#160;&#160;&#160;&#160;&#160;65536<br/>_SC_PAGESIZE:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4096<br/>_SC_RTSIG_MAX:&#160;&#160;&#160;&#160;&#160;&#160;&#160;32</p>
<p class="examplet"><a id="ch11ex1"/><strong>Listing 11-1:</strong> Using <em>sysconf()</em></p>
<p class="programsli">________________________________________________________<span class="codestrong">syslim/t_sysconf.c</span><br/><br/>#include "tlpi_hdr.h"<br/><br/>static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Print 'msg' plus sysconf() value for 'name' */<br/>sysconfPrint(const char *msg, int name)<br/>{<br/>&#160;&#160;&#160;&#160;long lim;<br/><br/>&#160;&#160;&#160;&#160;errno = 0;<br/>&#160;&#160;&#160;&#160;lim = sysconf(name);<br/>&#160;&#160;&#160;&#160;if (lim != -1) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Call succeeded, limit determinate */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s %ld\n", msg, lim);<br/>&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno == 0)&#160;&#160;&#160;&#160;&#160;/* Call succeeded, limit indeterminate */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s (indeterminate)\n", msg);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Call failed */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sysconf %s", msg);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;sysconfPrint("_SC_ARG_MAX:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;", _SC_ARG_MAX);<br/>&#160;&#160;&#160;&#160;sysconfPrint("_SC_LOGIN_NAME_MAX: ", _SC_LOGIN_NAME_MAX);<br/>&#160;&#160;&#160;&#160;sysconfPrint("_SC_OPEN_MAX:&#160;&#160;&#160;&#160;&#160;&#160;&#160;", _SC_OPEN_MAX);<br/>&#160;&#160;&#160;&#160;sysconfPrint("_SC_NGROUPS_MAX:&#160;&#160;&#160;&#160;", _SC_NGROUPS_MAX);<br/>&#160;&#160;&#160;&#160;sysconfPrint("_SC_PAGESIZE:&#160;&#160;&#160;&#160;&#160;&#160;&#160;", _SC_PAGESIZE);<br/>&#160;&#160;&#160;&#160;sysconfPrint("_SC_RTSIG_MAX:&#160;&#160;&#160;&#160;&#160;&#160;", _SC_RTSIG_MAX);<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>________________________________________________________<span class="codestrong">syslim/t_sysconf.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_217"/>SUSv3 requires that the value returned by <em>sysconf()</em> for a particular limit be constant for the lifetime of the calling process. For example, we can assume that the value returned for <span class="literal">_SC_PAGESIZE</span> won&#8217;t change while a process is running.</p>
<div class="block">
<p class="noindent">On Linux, there are some (sensible) exceptions to the statement that limit values are constant for the life of a process. A process can use <em>setrlimit()</em> (<a href="ch36.xhtml#ch36lev1sec02">Section 36.2</a>) to change various process resource limits that affect limit values reported by <em>sysconf()</em>: <span class="literal">RLIMIT_NOFILE</span>, which determines the number of files the process may open (<span class="literal">_SC_OPEN_MAX</span>); <span class="literal">RLIMIT_NPROC</span> (a resource limit not actually specified in SUSv3), which is the per-user limit on the number of processes that may be created by this process (<span class="literal">_SC_CHILD_MAX</span>); and <span class="literal">RLIMIT_STACK</span>, which, since Linux 2.6.23, determines the limit on the space allowed for the process&#8217;s command-line arguments and environment (<span class="literal">_SC_ARG_MAX</span>; see the <em>execve(2)</em> manual page for details).</p>
</div>
<h3 class="h3" id="ch11lev1sec03"><strong>11.3 Retrieving File-Related Limits (and Options) at Run Time</strong></h3>
<p class="noindenta">The <em>pathconf()</em> and <em>fpathconf()</em> functions allow an application to obtain the values of file-related limits at run time.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>long <span class="codestrong">pathconf</span>(const char *<span class="font1">pathname</span>, int <span class="font1">name</span>);<br/>long <span class="codestrong">fpathconf</span>(int <span class="font1">fd</span>, int <span class="font1">name</span>);</p>
<p class="right">Both return value of limit specified by <em>name</em>, or &#8211;1 if limit is indeterminate or an error occurred</p>
</div>
<p class="noindent">The only difference between <em>pathconf()</em> and <em>fpathconf()</em> is the manner in which a file or directory is specified. For <em>pathconf()</em>, specification is by pathname; for <em>fpathconf()</em>, specification is via a (previously opened) file descriptor.</p>
<p class="indent">The <em>name</em> argument is one of the <span class="literal">_PC_*</span> constants defined in <span class="literal">&lt;unistd.h&gt;</span>, some of which are listed in <a href="ch11.xhtml#ch11table1">Table 11-1</a>. <a href="ch11.xhtml#ch11table2">Table 11-2</a> provides some further details about the <span class="literal">_PC_*</span> constants that were shown in <a href="ch11.xhtml#ch11table1">Table 11-1</a>.</p>
<p class="indent">The value of the limit is returned as the function result. We can distinguish between an indeterminate return and an error return in the same manner as for <em>sysconf()</em>.</p>
<p class="indent">Unlike <em>sysconf()</em>, SUSv3 doesn&#8217;t require that the values returned by <em>pathconf()</em> and <em>fpathconf()</em> remain constant over the lifetime of a process, since, for example, a file system may be dismounted and remounted with different characteristics while a process is running.</p>
<p class="tablecap"><span epub:type="pagebreak" id="page_218"/><a id="ch11table2"/><strong>Table 11-2:</strong> Details of selected <em>pathconf()</em> <span class="literal">_PC_*</span> names</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Constant</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Notes</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">_PC_NAME_MAX</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">For a directory, this yields a value for files in the directory. Behavior for other file types is unspecified.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">_PC_PATH_MAX</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">For a directory, this yields the maximum length for a relative pathname from this directory. Behavior for other file types is unspecified.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">_PC_PIPE_BUF</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">For a FIFO or a pipe, this yields a value that applies to the referenced file.<br/>For a directory, the value applies to a FIFO created in that directory. Behavior for other file types is unspecified.</p></td>
</tr>
</tbody>
</table>
<p class="noindent"><a href="ch11.xhtml#ch11ex2">Listing 11-2</a> shows the use of <em>fpathconf()</em> to retrieve various limits for the file referred to by its standard input. When we run this program specifying standard input as a directory on an <em>ext2</em> file system, we see the following:</p>
<p class="programs">$ <span class="codestrong">./t_fpathconf &lt; .</span><br/>_PC_NAME_MAX:&#160;&#160;255<br/>_PC_PATH_MAX:&#160;&#160;4096<br/>_PC_PIPE_BUF:&#160;&#160;4096</p>
<p class="examplet"><a id="ch11ex2"/><strong>Listing 11-2:</strong> Using <em>fpathconf()</em></p>
<p class="programsli">______________________________________________________ <span class="codestrong">syslim/t_fpathconf.c</span><br/><br/>#include "tlpi_hdr.h"<br/><br/>static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Print 'msg' plus value of fpathconf(fd, name) */<br/>fpathconfPrint(const char *msg, int fd, int name)<br/>{<br/>&#160;&#160;&#160;&#160;long lim;<br/><br/>&#160;&#160;&#160;&#160;errno = 0;<br/>&#160;&#160;&#160;&#160;lim = fpathconf(fd, name);<br/>&#160;&#160;&#160;&#160;if (lim != -1) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Call succeeded, limit determinate */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s %ld\n", msg, lim);<br/>&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno == 0)&#160;&#160;&#160;&#160;&#160;/* Call succeeded, limit indeterminate */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s (indeterminate)\n", msg);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Call failed */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fpathconf %s", msg);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;fpathconfPrint("_PC_NAME_MAX: ", STDIN_FILENO, _PC_NAME_MAX);<br/>&#160;&#160;&#160;&#160;fpathconfPrint("_PC_PATH_MAX: ", STDIN_FILENO, _PC_PATH_MAX);<br/>&#160;&#160;&#160;&#160;fpathconfPrint("_PC_PIPE_BUF: ", STDIN_FILENO, _PC_PIPE_BUF);<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>______________________________________________________ <span class="codestrong">syslim/t_fpathconf.c</span></p>
<h3 class="h3" id="ch11lev1sec04"><span epub:type="pagebreak" id="page_219"/><strong>11.4 Indeterminate Limits</strong></h3>
<p class="noindentab">On occasion, we may find that some system limit is not defined by an implementation limit constant (e.g., <span class="literal">PATH_MAX</span>), and that <em>sysconf()</em> or <em>pathconf()</em> informs us that the limit (e.g., <span class="literal">_PC_PATH_MAX</span>) is indeterminate. In this case, we can employ one of the following strategies:</p>
<p class="bull">&#8226; When writing an application to be portable across multiple UNIX implementations, we could elect to use the minimum limit value specified by SUSv3. These are the constants with names of the form <span class="literal">_POSIX_*_MAX</span>, described in <a href="ch11.xhtml#ch11lev1sec01">Section 11.1</a>. Sometimes, this approach may not be viable because the limit is unrealistically low, as in the cases of <span class="literal">_POSIX_PATH_MAX</span> and <span class="literal">_POSIX_OPEN_MAX</span>.</p>
<p class="bull">&#8226; In some cases, a practical solution may be to ignore the checking of limits, and instead perform the relevant system or library function call. (Similar arguments can also apply with respect to some of the SUSv3 options described in <a href="ch11.xhtml#ch11lev1sec05">Section 11.5</a>.) If the call fails and <em>errno</em> indicates that the error occurred because some system limit was exceeded, then we can try again, modifying the application behavior as necessary. For example, most UNIX implementations impose a limit on the number of realtime signals that can be queued to a process. Once this limit is reached, attempts to send further signals (using <em>sigqueue()</em>) fail with the error <span class="literal">EAGAIN</span>. In this case, the sending process could simply retry, perhaps after some delay interval. Similarly, attempting to open a file whose name is too long yields the error <span class="literal">ENAMETOOLONG</span>, and an application could deal with this by trying again with a shorter name.</p>
<p class="bull">&#8226; We can write our own program or function to either deduce or estimate the limit. In each case, the relevant <em>sysconf()</em> or <em>pathconf()</em> call is made, and if this limit is indeterminate, the function returns a &#8220;good guess&#8221; value. While not perfect, such a solution is often viable in practice.</p>
<p class="bull">&#8226; We can employ a tool such as GNU <em>Autoconf</em>, an extensible tool that can determine the existence and settings of various system features and limits. The Autoconf program produces header files based on the information it determines, and these files can then be included in C programs. Further information about Autoconf can be found at <em><a href="http://www.gnu.org/software/autoconf/">http://www.gnu.org/software/autoconf/</a></em>.</p>
<h3 class="h3" id="ch11lev1sec05"><strong>11.5 System Options</strong></h3>
<p class="noindenta">As well as specifying limits for various system resources, SUSv3 also specifies various options that a UNIX implementation may support. These include support for features such as realtime signals, POSIX shared memory, job control, and POSIX threads. With a few exceptions, implementations are not required to support these options. Instead, SUSv3 allows an implementation to advise&#8212;at both compile time and run time&#8212;whether it supports a particular feature.</p>
<p class="indent">An implementation can advertise support for a particular SUSv3 option at compile time by defining a corresponding constant in <span class="literal">&lt;unistd.h&gt;</span>. Each such constant starts with a prefix that indicates the standard from which it originates (e.g., <span class="literal">_POSIX_</span> or <span class="literal">_XOPEN_</span>).</p>
<p class="noindentb"><span epub:type="pagebreak" id="page_220"/>Each option constant, if defined, has one of the following values:</p>
<p class="bull">&#8226; A value of &#8211;1 means that <em>the option is not supported</em>. In this case, header files, data types, and function interfaces associated with the option need not be defined by the implementation. We may need to handle this possibility by conditional compilation using <span class="literal">#if</span> preprocessor directives.</p>
<p class="bull">&#8226; A value of 0 means that <em>the option may be supported</em>. An application must check at run time to see whether the option is supported.</p>
<p class="bull">&#8226; A value greater than 0 means that <em>the option is supported</em>. All header files, data types, and function interfaces associated with this option are defined and behave as specified. In many cases, SUSv3 requires that this positive value be <span class="literal">200112L</span>, a constant corresponding to the year and month number in which SUSv3 was approved as a standard. (The analogous value for SUSv4 is <span class="literal">200809L</span>.)</p>
<p class="noindentt">Where a constant is defined with the value 0, an application can use the <em>sysconf()</em> and <em>pathconf()</em> (or <em>fpathconf()</em>) functions to check at run time whether the option is supported. The <em>name</em> arguments passed to these functions generally have the same form as the corresponding compile-time constants, but with the prefix replaced by <span class="literal">_SC_</span> or <span class="literal">_PC_</span>. The implementation must provide at least the header files, constants, and function interfaces necessary to perform the run-time check.</p>
<div class="block">
<p class="noindent">SUSv3 is unclear on whether an undefined option constant has the same meaning as defining the constant with the value 0 (&#8220;the option may be supported&#8221;) or with the value &#8211;1 (&#8220;the option is not supported&#8221;). The standards committee subsequently resolved that this case should mean the same as defining the constant with the value &#8211;1, and SUSv4 states this explicitly.</p>
</div>
<p class="noindentb"><a href="ch11.xhtml#ch11table3">Table 11-3</a> lists some of the options specified in SUSv3. The first column of the table gives the name of the associated compile-time constant for the option (defined in <span class="literal">&lt;unistd.h&gt;</span>), as well as the corresponding <em>sysconf()</em> (<span class="literal">_SC_*</span>) or <em>pathconf()</em> (<span class="literal">_PC_*</span>) <em>name</em> argument. Note the following points regarding specific options:</p>
<p class="bull">&#8226; Certain options are required by SUSv3; that is, the compile-time constant always evaluates to a value greater than 0. Historically, these options were truly optional, but nowadays they are not. These options are marked with the character <span class="literal">+</span> in the <em>Notes</em> column. (In SUSv4, a range of options that were optional in SUSv3 become mandatory.)</p>
<div class="block1">
<p class="noindent">Although such options are required by SUSv3, some UNIX systems may nevertheless be installed in a nonconforming configuration. Thus, for portable applications, it may be worth checking whether an option that affects the application is supported, regardless of whether the standard requires that option.</p>
</div>
<p class="bull">&#8226; For certain options, the compile-time constant must have a value other than &#8211;1. In other words, either the option must be supported or support at run time must be checkable. These options are marked with the character <span class="literal">*</span> in the <em>Notes</em> column.</p>
<p class="tablecap"><span epub:type="pagebreak" id="page_221"/><a id="ch11table3"/><strong>Table 11-3:</strong> Selected SUSv3 options</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Option (constant) name (<em>sysconf()</em> / <em>pathconf()</em> name)</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Description</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="tablec"><strong>Notes</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">_POSIX_ASYNCHRONOUS_IO (_SC_ASYNCHRONOUS_IO)</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><em>Asynchronous I/O</em></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">_POSIX_CHOWN_RESTRICTED (_PC_CHOWN_RESTRICTED)</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Only privileged processes can use <em>chown()</em> and <em>fchown()</em> to change the user ID and group ID of a file to arbitrary values (<a href="ch15.xhtml#ch15lev2sec04">Section 15.3.2</a>)</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="tablec"><span class="literal">*</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">_POSIX_JOB_CONTROL (_SC_JOB_CONTROL)</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><em>Job Control</em> (<a href="ch34.xhtml#ch34lev1sec07">Section 34.7</a>)</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="tablec"><span class="literal">+</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">_POSIX_MESSAGE_PASSING (_SC_MESSAGE_PASSING)</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><em>POSIX Message Queues</em> (<a href="ch52.xhtml#ch52">Chapter 52</a>)</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">_POSIX_PRIORITY_SCHEDULING (_SC_PRIORITY_SCHEDULING)</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><em>Process Scheduling</em> (<a href="ch35.xhtml#ch35lev1sec03">Section 35.3</a>)</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">_POSIX_REALTIME_SIGNALS (_SC_REALTIME_SIGNALS)</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><em>Realtime Signals Extension</em> (<a href="ch22.xhtml#ch22lev1sec08">Section 22.8</a>)</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">_POSIX_SAVED_IDS</span> (none)</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Processes have saved set-user-IDs and saved set-group-IDs (<a href="ch09.xhtml#ch09lev1sec04">Section 9.4</a>)</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="tablec"><span class="literal">+</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">_POSIX_SEMAPHORES (_SC_SEMAPHORES)</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><em>POSIX Semaphores</em> (<a href="ch53.xhtml#ch53">Chapter 53</a>)</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">_POSIX_SHARED_MEMORY_OBJECTS (_SC_SHARED_MEMORY_OBJECTS)</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><em>POSIX Shared Memory Objects</em> (<a href="ch54.xhtml#ch54">Chapter 54</a>)</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">_POSIX_THREADS (_SC_THREADS)</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><em>POSIX Threads</em></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">_XOPEN_UNIX</span> (<span class="literal">_SC_XOPEN_UNIX</span>)</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">The XSI extension is supported (<a href="ch01.xhtml#ch01lev2sec06">Section 1.3.4</a>)</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">&#160;</p></td>
</tr>
</tbody>
</table>
<h3 class="h3" id="ch11lev1sec06"><strong>11.6 Summary</strong></h3>
<p class="noindenta">SUSv3 specifies limits that an implementation may enforce and system options that an implementation may support.</p>
<p class="indent">Often, it is desirable not to hard-code assumptions about system limits and options into a program, since these may vary across implementations and also on a single implementation, either at run time or across file systems. Therefore, SUSv3 specifies methods by which an implementation can advertise the limits and options it supports. For most limits, SUSv3 specifies a minimum value that all implementations must support. Additionally, each implementation can advertise its implementation-specific limits and options at compile time (via a constant definition in <span class="literal">&lt;limits.h&gt;</span> or <span class="literal">&lt;unistd.h&gt;</span>) and/or run time (via a call to <em>sysconf()</em>, <em>pathconf()</em>, or <em>fpathconf()</em>). These techniques may similarly be used to find out which SUSv3 options an implementation supports. In some cases, it may not be possible to determine a particular limit using either of these methods. For such indeterminate limits, we must resort to ad hoc techniques to determine the limit to which an application should adhere.</p>
<h5 class="h5" id="ch11lev3sec06"><span epub:type="pagebreak" id="page_222"/><strong>Further information</strong></h5>
<p class="noindenta"><a href="ch02.xhtml#ch02">Chapter 2</a> of [<a href="bib.xhtml#bib94">Stevens &#38; Rago, 2005</a>] and <a href="ch02.xhtml#ch02">Chapter 2</a> of [<a href="bib.xhtml#bib28">Gallmeister, 1995</a>] cover similar ground to this chapter. [<a href="bib.xhtml#bib55">Lewine, 1991</a>] also provides much useful (although now slightly outdated) background. Some information about POSIX options with notes on <em>glibc</em> and Linux details can be found at <em><a href="http://people.redhat.com/drepper/posix-option-groups.html">http://people.redhat.com/drepper/posix-option-groups.html</a></em>. The following Linux manual pages are also relevant: <em>sysconf(3)</em>, <em>pathconf(3)</em>, <em>feature_test_macros(7)</em>, <em>posixoptions(7)</em>, and <em>standards(7)</em>.</p>
<p class="indent">The best sources of information (though sometimes difficult reading) are the relevant parts of SUSv3, particularly <a href="ch02.xhtml#ch02">Chapter 2</a> from the Base Definitions (XBD), and the specifications for <em>&lt;unistd.h&gt;</em>, <em>&lt;limits.h&gt;</em>, <em>sysconf()</em>, and <em>fpathconf()</em>. [<a href="bib.xhtml#bib45">Josey, 2004</a>] provides guidance on the use of SUSv3.</p>
<h3 class="h3" id="ch11lev1sec07"><strong>11.7 Exercises</strong></h3>
<p class="exer"><a id="ch11exe1"/><strong>11-1.</strong>&#160;&#160;&#160;Try running the program in <a href="ch11.xhtml#ch11ex1">Listing 11-1</a> on other UNIX implementations if you have access to them.</p>
<p class="exer"><a id="ch11exe2"/><strong>11-2.</strong>&#160;&#160;&#160;Try running the program in <a href="ch11.xhtml#ch11ex2">Listing 11-2</a> on other file systems.</p>
</body>
</html>
