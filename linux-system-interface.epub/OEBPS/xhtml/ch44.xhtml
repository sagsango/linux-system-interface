<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch44"><span epub:type="pagebreak" id="page_889"/><strong><span class="big">44</span></strong><br/><strong>PIPES AND FIFOS</strong></h2>
<p class="noindenta">This chapter describes pipes and FIFOs. Pipes are the oldest method of IPC on the UNIX system, having appeared in Third Edition UNIX in the early 1970s. Pipes provide an elegant solution to a frequent requirement: having created two processes to run different programs (commands), how can the shell allow the output produced by one process to be used as the input to the other process? Pipes can be used to pass data between related processes (the meaning of <em>related</em> will become clear later). FIFOs are a variation on the pipe concept. The important difference is that FIFOs can be used for communication between <em>any</em> processes.</p>
<h3 class="h3" id="ch44lev1sec01"><strong>44.1 Overview</strong></h3>
<p class="noindenta">Every user of the shell is familiar with the use of pipes in commands such as the following, which counts the number of files in a directory:</p>
<p class="programs">$ <span class="codestrong">ls | wc -l</span></p>
<p class="noindent">In order to execute the above command, the shell creates two processes, executing <em>ls</em> and <em>wc</em>, respectively. (This is done using <em>fork()</em> and <em>exec()</em>, which are described in <a href="ch24.xhtml#ch24">Chapters 24</a> and <a href="ch27.xhtml#ch27">27</a>.) <a href="ch44.xhtml#ch44fig1">Figure 44-1</a> shows how the two processes employ the pipe.</p>
<p class="indent">Among other things, <a href="ch44.xhtml#ch44fig1">Figure 44-1</a> is intended to illustrate how pipes got their name. We can think of a pipe as a piece of plumbing that allows data to flow from one process to another.</p>
<div class="image"><span epub:type="pagebreak" id="page_890"/><img src="../images/f44-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch44fig1"/><strong>Figure 44-1:</strong> Using a pipe to connect two processes</p>
<p class="noindent">One point to note in <a href="ch44.xhtml#ch44fig1">Figure 44-1</a> is that the two processes are connected to the pipe so that the writing process (<em>ls</em>) has its standard output (file descriptor 1) joined to the write end of the pipe, while the reading process (<em>wc</em>) has its standard input (file descriptor 0) joined to the read end of the pipe. In effect, these two processes are unaware of the existence of the pipe; they just read from and write to the standard file descriptors. The shell must do some work in order to set things up in this way, and we see how this is done in <a href="ch44.xhtml#ch44lev1sec04">Section 44.4</a>.</p>
<p class="indent">In the following paragraphs, we cover a number of important characteristics of pipes.</p>
<h5 class="h5" id="ch44lev3sec01"><strong>A pipe is a byte stream</strong></h5>
<p class="noindenta">When we say that a pipe is a byte stream, we mean that there is no concept of messages or message boundaries when using a pipe. The process reading from a pipe can read blocks of data of any size, regardless of the size of blocks written by the writing process. Furthermore, the data passes through the pipe sequentially&#8212;bytes are read from a pipe in exactly the order they were written. It is not possible to randomly access the data in a pipe using <em>lseek()</em>.</p>
<p class="indent">If we want to implement the notion of discrete messages in a pipe, we must do this within our application. While this is feasible (refer to <a href="ch44.xhtml#ch44lev1sec08">Section 44.8</a>), it may be preferable to use alternative IPC mechanisms, such as message queues and datagram sockets, which we discuss in later chapters.</p>
<h5 class="h5" id="ch44lev3sec02"><strong>Reading from a pipe</strong></h5>
<p class="noindenta">Attempts to read from a pipe that is currently empty block until at least one byte has been written to the pipe. If the write end of a pipe is closed, then a process reading from the pipe will see end-of-file (i.e., <em>read()</em> returns 0) once it has read all remaining data in the pipe.</p>
<h5 class="h5" id="ch44lev3sec03"><strong>Pipes are unidirectional</strong></h5>
<p class="noindenta">Data can travel only in one direction through a pipe. One end of the pipe is used for writing, and the other end is used for reading.</p>
<p class="indent">On some other UNIX implementations&#8212;notably those derived from System V Release 4&#8212;pipes are bidirectional (so-called <em>stream pipes</em>). Bidirectional pipes are not specified by any UNIX standards, so that, even on implementations where they are provided, it is best to avoid reliance on their semantics. As an alternative, we can use UNIX domain stream socket pairs (created using the <em>socketpair()</em> system call described in <a href="ch57.xhtml#ch57lev1sec05">Section 57.5</a>), which provide a standardized bidirectional communication mechanism that is semantically equivalent to stream pipes.</p>
<h5 class="h5" id="ch44lev3sec04"><span epub:type="pagebreak" id="page_891"/><strong>Writes of up to</strong> <span class="literal"><span class="codestrong">PIPE_BUF</span></span> <strong>bytes are guaranteed to be atomic</strong></h5>
<p class="noindenta">If multiple processes are writing to a single pipe, then it is guaranteed that their data won&#8217;t be intermingled if they write no more than <span class="literal">PIPE_BUF</span> bytes at a time.</p>
<p class="indent">SUSv3 requires that <span class="literal">PIPE_BUF</span> be at least <span class="literal">_POSIX_PIPE_BUF</span> (512). An implementation should define <span class="literal">PIPE_BUF</span> (in <span class="literal">&lt;limits.h&gt;</span>) and/or allow the call <em>fpathconf(fd, _PC_PIPE_BUF)</em> to return the actual upper limit for atomic writes. <span class="literal">PIPE_BUF</span> varies across UNIX implementations; for example, it is 512 bytes on FreeBSD 6.0, 4096 bytes on Tru64 5.1, and 5120 bytes on Solaris 8. On Linux, <span class="literal">PIPE_BUF</span> has the value 4096.</p>
<p class="indent">When writing blocks of data larger than <span class="literal">PIPE_BUF</span> bytes to a pipe, the kernel may transfer the data in multiple smaller pieces, appending further data as the reader removes bytes from the pipe. (The <em>write()</em> call blocks until all of the data has been written to the pipe.) When there is only a single process writing to a pipe (the usual case), this doesn&#8217;t matter. However, if there are multiple writer processes, then writes of large blocks may be broken into segments of arbitrary size (which may be smaller than <span class="literal">PIPE_BUF</span> bytes) and interleaved with writes by other processes.</p>
<p class="indent">The <span class="literal">PIPE_BUF</span> limit affects exactly when data is transferred to the pipe. When writing up to <span class="literal">PIPE_BUF</span> bytes, <em>write()</em> will block if necessary until sufficient space is available in the pipe so that it can complete the operation atomically. When more than <span class="literal">PIPE_BUF</span> bytes are being written, <em>write()</em> transfers as much data as possible to fill the pipe, and then blocks until data has been removed from the pipe by some reading process. If such a blocked <em>write()</em> is interrupted by a signal handler, then the call unblocks and returns a count of the number of bytes successfully transferred, which will be less than was requested (a so-called <em>partial write</em>).</p>
<div class="block">
<p class="noindent">On Linux 2.2, pipe writes of <em>any</em> size are atomic, unless interrupted by a signal handler. On Linux 2.4 and later, any write greater than <span class="literal">PIPE_BUF</span> bytes may be interleaved with writes by other processes. (The kernel code implementing pipes underwent substantial changes between kernel versions 2.2 and 2.4.)</p>
</div>
<h5 class="h5" id="ch44lev3sec05"><strong>Pipes have a limited capacity</strong></h5>
<p class="noindenta">A pipe is simply a buffer maintained in kernel memory. This buffer has a maximum capacity. Once a pipe is full, further writes to the pipe block until the reader removes some data from the pipe.</p>
<p class="indent">SUSv3 makes no requirement about the capacity of a pipe. In Linux kernels before 2.6.11, the pipe capacity is the same as the system page size (e.g., 4096 bytes on x86-32); since Linux 2.6.11, the pipe capacity is 65,536 bytes. Other UNIX implementations have different pipe capacities.</p>
<p class="indent">In general, an application never needs to know the exact capacity of a pipe. If we want to prevent the writer process(es) from blocking, the process(es) reading from the pipe should be designed to read data as soon as it is available.</p>
<div class="block">
<p class="noindent">In theory, there is no reason why a pipe couldn&#8217;t operate with smaller capacities, even with a single-byte buffer. The reason for employing large buffer sizes is efficiency: each time a writer fills the pipe, the kernel must perform a context switch to allow the reader to be scheduled so that it can empty some data from the pipe. Employing a larger buffer size means that fewer context switches are required.</p>
<p class="indent">Starting with Linux 2.6.35, the capacity of a pipe can be modified. The Linux-specific call <em>fcntl(fd, F_SETPIPE_SZ, size)</em> changes the capacity of the pipe referred to by <em>fd</em> to be at least <em>size</em> bytes. An unprivileged process can <span epub:type="pagebreak" id="page_892"/>change the pipe capacity to any value in the range from the system page size up to the value in <span class="literal">/proc/sys/fs/pipe-max-size</span>. The default value for <span class="literal">pipe-max-size</span> is 1,048,576 bytes. A privileged (<span class="literal">CAP_SYS_RESOURCE</span>) process can override this limit. When allocating space for the pipe, the kernel may round <em>size</em> up to some value convenient for the implementation. The <em>fcntl(fd, F_GETPIPE_SZ)</em> call returns the actual size allocated for the pipe.</p>
</div>
<h3 class="h3" id="ch44lev1sec02"><strong>44.2 Creating and Using Pipes</strong></h3>
<p class="noindenta">The <em>pipe()</em> system call creates a new pipe.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">pipe</span>(int <span class="font1">filedes</span>[2]);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">A successful call to <em>pipe()</em> returns two open file descriptors in the array <em>filedes</em>: one for the read end of the pipe (<em>filedes[0]</em>) and one for the write end (<em>filedes[1]</em>).</p>
<p class="indent">As with any file descriptor, we can use the <em>read()</em> and <em>write()</em> system calls to perform I/O on the pipe. Once written to the write end of a pipe, data is immediately available to be read from the read end. A <em>read()</em> from a pipe obtains the lesser of the number of bytes requested and the number of bytes currently available in the pipe (but blocks if the pipe is empty).</p>
<p class="indent">We can also use the <em>stdio</em> functions (<em>fprintf()</em>, <em>fscanf()</em>, and so on) with pipes by first using <em>fdopen()</em> to obtain a file stream corresponding to one of the descriptors in <em>filedes</em> (<a href="ch13.xhtml#ch13lev1sec07">Section 13.7</a>). However, when doing this, we must be aware of the <em>stdio</em> buffering issues described in <a href="ch44.xhtml#ch44lev1sec06">Section 44.6</a>.</p>
<div class="block">
<p class="noindent">The call <em>ioctl(fd, FIONREAD, &#38;cnt)</em> returns the number of unread bytes in the pipe or FIFO referred to by the file descriptor <em>fd</em>. This feature is also available on some other implementations, but is not specified in SUSv3.</p>
</div>
<p class="noindent"><a href="ch44.xhtml#ch44fig2">Figure 44-2</a> shows the situation after a pipe has been created by <em>pipe()</em>, with the calling process having file descriptors referring to each end.</p>
<div class="image"><img src="../images/f44-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch44fig2"/><strong>Figure 44-2:</strong> Process file descriptors after creating a pipe</p>
<p class="noindent">A pipe has few uses within a single process (we consider one in <a href="ch63.xhtml#ch63lev2sec17">Section 63.5.2</a>). Normally, we use a pipe to allow communication between two processes. To connect two processes using a pipe, we follow the <em>pipe()</em> call with a call to <em>fork()</em>. During a <em>fork()</em>, the child process inherits copies of its parent&#8217;s file descriptors (<a href="ch24.xhtml#ch24lev2sec01">Section 24.2.1</a>), bringing about the situation shown on the left side of <a href="ch44.xhtml#ch44fig3">Figure 44-3</a>.</p>
<div class="image"><span epub:type="pagebreak" id="page_893"/><img src="../images/f44-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch44fig3"/><strong>Figure 44-3:</strong> Setting up a pipe to transfer data from a parent to a child</p>
<p class="noindent">While it is possible for the parent and child to both read from and write to the pipe, this is not usual. Therefore, immediately after the <em>fork()</em>, one process closes its descriptor for the write end of the pipe, and the other closes its descriptor for the read end. For example, if the parent is to send data to the child, then it would close its read descriptor for the pipe, <em>filedes[0]</em>, while the child would close its write descriptor for the pipe, <em>filedes[1]</em>, bringing about the situation shown on the right side of <a href="ch44.xhtml#ch44fig3">Figure 44-3</a>. The code to create this setup is shown in <a href="ch44.xhtml#ch44ex1">Listing 44-1</a>.</p>
<p class="examplet"><a id="ch44ex1"/><strong>Listing 44-1:</strong> Steps in creating a pipe to transfer data from a parent to a child</p>
<p class="programsli">______________________________________________________________________<br/><br/>&#160;&#160;&#160;&#160;int filedes[2];<br/><br/>&#160;&#160;&#160;&#160;if (pipe(filedes) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create the pipe */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("pipe");<br/><br/>&#160;&#160;&#160;&#160;switch (fork()) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create a child process */<br/>&#160;&#160;&#160;&#160;case -1:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;case 0:&#160;&#160;/* Child */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (close(filedes[1]) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Close unused write end */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child now reads from pipe */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;default: /* Parent */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (close(filedes[0]) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Close unused read end */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent now writes to pipe */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;}<br/>______________________________________________________________________</p>
<p class="noindent">One reason that it is not usual to have both the parent and child reading from a single pipe is that if two processes try to simultaneously read from a pipe, we can&#8217;t <span epub:type="pagebreak" id="page_894"/>be sure which process will be the first to succeed&#8212;the two processes race for data. Preventing such races would require the use of some synchronization mechanism. However, if we require bidirectional communication, there is a simpler way: just create two pipes, one for sending data in each direction between the two processes. (If employing this technique, then we need to be wary of deadlocks that may occur if both processes block while trying to read from empty pipes or while trying to write to pipes that are already full.)</p>
<p class="indent">While it is possible to have multiple processes writing to a pipe, it is typical to have only a single writer. (We show one example of where it is useful to have multiple writers to a pipe in <a href="ch44.xhtml#ch44lev1sec03">Section 44.3</a>.) By contrast, there are situations where it can be useful to have multiple writers on a FIFO, and we see an example of this in <a href="ch44.xhtml#ch44lev1sec08">Section 44.8</a>.</p>
<div class="block">
<p class="noindent">Starting with kernel 2.6.27, Linux supports a new, nonstandard system call, <em>pipe2()</em>. This system call performs the same task as <em>pipe()</em>, but supports an additional argument, <em>flags</em>, that can be used to modify the behavior of the system call. Two flags are supported. The <span class="literal">O_CLOEXEC</span> flag causes the kernel to enable the close-on-exec flag (<span class="literal">FD_CLOEXEC</span>) for the two new file descriptors. This flag is useful for the same reasons as the <em>open()</em> <span class="literal">O_CLOEXEC</span> flag described in <a href="ch04.xhtml#ch04lev2sec01">Section 4.3.1</a>. The <span class="literal">O_NONBLOCK</span> flag causes the kernel to mark both underlying open file descriptions as nonblocking, so that future I/O operations will be nonblocking. This saves additional calls to <em>fcntl()</em> to achieve the same result.</p>
</div>
<h5 class="h5" id="ch44lev3sec06"><strong>Pipes allow communication between related processes</strong></h5>
<p class="noindenta">In the discussion so far, we have talked about using pipes for communication between a parent and a child process. However, pipes can be used for communication between any two (or more) related processes, as long as the pipe was created by a common ancestor before the series of <em>fork()</em> calls that led to the existence of the processes. (This is what we meant when we referred to <em>related processes</em> at the beginning of this chapter.) For example, a pipe could be used for communication between a process and its grandchild. The first process creates the pipe, and then forks a child that in turn forks to yield the grandchild. A common scenario is that a pipe is used for communication between two siblings&#8212;their parent creates the pipe, and then creates the two children. This is what the shell does when building a pipeline.</p>
<div class="block">
<p class="noindent">There is an exception to the statement that pipes can be used to communicate only between related processes. Passing a file descriptor over a UNIX domain socket (a technique that we briefly describe in <a href="ch61.xhtml#ch61lev2sec10">Section 61.13.3</a>) makes it possible to pass a file descriptor for a pipe to an unrelated process.</p>
</div>
<h5 class="h5" id="ch44lev3sec07"><strong>Closing unused pipe file descriptors</strong></h5>
<p class="noindenta">Closing unused pipe file descriptors is more than a matter of ensuring that a process doesn&#8217;t exhaust its limited set of file descriptors&#8212;it is essential to the correct use of pipes. We now consider why the unused file descriptors for both the read and write ends of the pipe must be closed.</p>
<p class="indent">The process reading from the pipe closes its write descriptor for the pipe, so that, when the other process completes its output and closes its write descriptor, the reader sees end-of-file (once it has read any outstanding data in the pipe).</p>
<p class="indent">If the reading process doesn&#8217;t close the write end of the pipe, then, after the other process closes its write descriptor, the reader won&#8217;t see end-of-file, even after <span epub:type="pagebreak" id="page_895"/>it has read all data from the pipe. Instead, a <em>read()</em> would block waiting for data, because the kernel knows that there is still at least one write descriptor open for the pipe. That this descriptor is held open by the reading process itself is irrelevant; in theory, that process could still write to the pipe, even if it is blocked trying to read. For example, the <em>read()</em> might be interrupted by a signal handler that writes data to the pipe. (This is a realistic scenario, as we&#8217;ll see in <a href="ch63.xhtml#ch63lev2sec17">Section 63.5.2</a>.)</p>
<p class="indent">The writing process closes its read descriptor for the pipe for a different reason. When a process tries to write to a pipe for which no process has an open read descriptor, the kernel sends the <span class="literal">SIGPIPE</span> signal to the writing process. By default, this signal kills a process. A process can instead arrange to catch or ignore this signal, in which case the <em>write()</em> on the pipe fails with the error <span class="literal">EPIPE</span> (broken pipe). Receiving the <span class="literal">SIGPIPE</span> signal or getting the <span class="literal">EPIPE</span> error is a useful indication about the status of the pipe, and this is why unused read descriptors for the pipe should be closed.</p>
<div class="block">
<p class="noindent">Note that the treatment of a <em>write()</em> that is interrupted by a <span class="literal">SIGPIPE</span> handler is special. Normally, when a <em>write()</em> (or other &#8220;slow&#8221; system call) is interrupted by a signal handler, the call is either automatically restarted or fails with the error <span class="literal">EINTR</span>, depending on whether the handler was installed with the <em>sigaction()</em> <span class="literal">SA_RESTART</span> flag (<a href="ch21.xhtml#ch21lev1sec05">Section 21.5</a>). The behavior in the case of <span class="literal">SIGPIPE</span> is different because it makes no sense either to automatically restart the <em>write()</em> or to simply indicate that the <em>write()</em> was interrupted by a handler (thus implying that the <em>write()</em> could usefully be manually restarted). In neither case can a subsequent <em>write()</em> attempt succeed, because the pipe will still be broken.</p>
</div>
<p class="noindent">If the writing process doesn&#8217;t close the read end of the pipe, then, even after the other process closes the read end of the pipe, the writing process will still be able to write to the pipe. Eventually, the writing process will fill the pipe, and a further attempt to write will block indefinitely.</p>
<p class="indent">One final reason for closing unused file descriptors is that it is only after all file descriptors in all processes that refer to a pipe are closed that the pipe is destroyed and its resources released for reuse by other processes. At this point, any unread data in the pipe is lost.</p>
<h5 class="h5" id="ch44lev3sec08"><strong>Example program</strong></h5>
<p class="noindenta">The program in <a href="ch44.xhtml#ch44ex2">Listing 44-2</a> demonstrates the use of a pipe for communication between parent and child processes. This example demonstrates the byte-stream nature of pipes referred to earlier&#8212;the parent writes its data in a single operation, while the child reads data from the pipe in small blocks.</p>
<p class="indent">The main program calls <em>pipe()</em> to create a pipe <span class="ent">&#x2460;</span>, and then calls <em>fork()</em> to create a child <span class="ent">&#x2461;</span>. After the <em>fork()</em>, the parent process closes its file descriptor for the read end of the pipe <span class="ent">&#x2467;</span>, and writes the string given as the program&#8217;s command-line argument to the write end of the pipe <span class="ent">&#x2468;</span>. The parent then closes the write end of the pipe <span class="ent">&#x2469;</span>, and calls <em>wait()</em> to wait for the child to terminate <span class="ent">&#x246A;</span>. After closing its file descriptor for the write end of the pipe <span class="ent">&#x2462;</span>, the child process enters a loop where it reads <span class="ent">&#x2463;</span> blocks of data (of up to <span class="literal">BUF_SIZE</span> bytes) from the pipe and writes <span class="ent">&#x2465;</span> them to standard output. When the child encounters end-of-file on the pipe <span class="ent">&#x2464;</span>, it exits the loop <span class="ent">&#x2466;</span>, writes a trailing newline character, closes its descriptor for the read end of the pipe, and terminates.</p>
<p class="noindent"><span epub:type="pagebreak" id="page_896"/>Here&#8217;s an example of what we might see when running the program in <a href="ch44.xhtml#ch44ex2">Listing 44-2</a>:</p>
<p class="programs">$ <span class="codestrong">./simple_pipe 'It was a bright cold day in April, '\<br/>'and the clocks were striking thirteen.'</span><br/>It was a bright cold day in April, and the clocks were striking thirteen.</p>
<p class="examplet"><a id="ch44ex2"/><strong>Listing 44-2:</strong> Using a pipe to communicate between a parent and child process</p>
<p class="programsli">______________________________________________________ <span class="codestrong">pipes/simple_pipe.c</span><br/><br/>&#160;&#160;&#160;#include &lt;sys/wait.h&gt;<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;#define BUF_SIZE 10<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int pfd[2];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Pipe file descriptors */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char buf[BUF_SIZE];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;ssize_t numRead;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s string\n", argv[0]);<br/><br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;if (pipe(pfd) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create the pipe */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("pipe");<br/><br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;switch (fork()) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;case -1:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child - reads from pipe */<br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (close(pfd[1]) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Write end is unused */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close - child");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (;;) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Read data from pipe, echo on stdout */<br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numRead = read(pfd[0], buf, BUF_SIZE);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("read");<br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* End-of-file */<br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (write(STDOUT_FILENO, buf, numRead) != numRead)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("child - partial/failed write");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;write(STDOUT_FILENO, "\n", 1);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (close(pfd[0]) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_exit(EXIT_SUCCESS);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent - writes to pipe */<br/><span class="ent">&#x2467;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (close(pfd[0]) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Read end is unused */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close - parent");<br/><br/><span class="ent">&#x2468;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (write(pfd[1], argv[1], strlen(argv[1])) != strlen(argv[1]))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("parent - partial/failed write");<br/><br/><span class="ent">&#x2469;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (close(pfd[1]) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child will see EOF */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close");<br/><span class="ent">&#x246A;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;wait(NULL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for child to finish */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/>______________________________________________________ <span class="codestrong">pipes/simple_pipe.c</span></p>
<h3 class="h3" id="ch44lev1sec03"><span epub:type="pagebreak" id="page_897"/><strong>44.3 Pipes as a Method of Process Synchronization</strong></h3>
<p class="noindenta">In <a href="ch24.xhtml#ch24lev1sec05">Section 24.5</a>, we looked at how signals could be used to synchronize the actions of parent and child processes in order to avoid race conditions. Pipes can be used to achieve a similar result, as shown by the skeleton program in <a href="ch44.xhtml#ch44ex3">Listing 44-3</a>. This program creates multiple child processes (one for each command-line argument), each of which is intended to accomplish some action, simulated in the example program by sleeping for some time. The parent waits until all children have completed their actions.</p>
<p class="indent">To perform the synchronization, the parent builds a pipe <span class="ent">&#x2460;</span> before creating the child processes <span class="ent">&#x2461;</span>. Each child inherits a file descriptor for the write end of the pipe and closes this descriptor once it has completed its action <span class="ent">&#x2462;</span>. After all of the children have closed their file descriptors for the write end of the pipe, the parent&#8217;s <em>read()</em> <span class="ent">&#x2464;</span> from the pipe will complete, returning end-of-file (0). At this point, the parent is free to carry on to do other work. (Note that closing the unused write end of the pipe in the parent <span class="ent">&#x2463;</span> is essential to the correct operation of this technique; otherwise, the parent would block forever when trying to read from the pipe.)</p>
<p class="indent">The following is an example of what we see when we use the program in <a href="ch44.xhtml#ch44ex3">Listing 44-3</a> to create three children that sleep for 4, 2, and 6 seconds:</p>
<p class="programs">$ <span class="codestrong">./pipe_sync 4 2 6</span><br/>08:22:16&#160;&#160;Parent started<br/>08:22:18&#160;&#160;Child 2 (PID=2445) closing pipe<br/>08:22:20&#160;&#160;Child 1 (PID=2444) closing pipe<br/>08:22:22&#160;&#160;Child 3 (PID=2446) closing pipe<br/>08:22:22&#160;&#160;Parent ready to go</p>
<p class="examplet"><a id="ch44ex3"/><strong>Listing 44-3:</strong> Using a pipe to synchronize multiple processes</p>
<p class="programsli">________________________________________________________ <span class="codestrong">pipes/pipe_sync.c</span><br/><br/>&#160;&#160;&#160;#include "curr_time.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declaration of currTime() */<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int pfd[2];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Process synchronization pipe */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int j, dummy;<br/><span epub:type="pagebreak" id="page_898"/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s sleep-time...\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;setbuf(stdout, NULL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Make stdout unbuffered, since we<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;terminate child with _exit() */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s Parent started\n", currTime("%T"));<br/><br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;if (pipe(pfd) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("pipe");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (j = 1; j &lt; argc; j++) {<br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (fork()) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case -1:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork %d", j);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 0: /* Child */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (close(pfd[0]) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Read end is unused */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child does some work, and lets parent know it's done */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep(getInt(argv[j], GN_NONNEG, "sleep-time"));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Simulate processing */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s Child %d (PID=%ld) closing pipe\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;currTime("%T"), j, (long) getpid());<br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (close(pfd[1]) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child now carries on to do other things... */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_exit(EXIT_SUCCESS);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default: /* Parent loops to create next child */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent comes here; close write end of pipe so we can see EOF */<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;if (close(pfd[1]) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Write end is unused */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent may do other work, then synchronizes with children */<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;if (read(pfd[0], &#38;dummy, 1) != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("parent didn't get EOF");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s Parent ready to go\n", currTime("%T"));<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent can now carry on to do other things... */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;}<br/>________________________________________________________ <span class="codestrong">pipes/pipe_sync.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_899"/>Synchronization using pipes has an advantage over the earlier example of synchronization using signals: it can be used to coordinate the actions of one process with multiple other (related) processes. The fact that multiple (standard) signals can&#8217;t be queued makes signals unsuitable in this case. (Conversely, signals have the advantage that they can be broadcast by one process to all of the members of a process group.)</p>
<p class="indent">Other synchronization topologies are possible (e.g., using multiple pipes). Furthermore, this technique could be extended so that, instead of closing the pipe, each child writes a message to the pipe containing its process ID and some status information. Alternatively, each child might write a single byte to the pipe. The parent process could then count and analyze these messages. This approach guards against the possibility of the child accidentally terminating, rather than explicitly closing the pipe.</p>
<h3 class="h3" id="ch44lev1sec04"><strong>44.4 Using Pipes to Connect Filters</strong></h3>
<p class="noindenta">When a pipe is created, the file descriptors used for the two ends of the pipe are the next lowest-numbered descriptors available. Since, in normal circumstances, descriptors 0, 1, and 2 are already in use for a process, some higher-numbered descriptors will be allocated for the pipe. So how do we bring about the situation shown in <a href="ch44.xhtml#ch44fig1">Figure 44-1</a>, where two filters (i.e., programs that read from <em>stdin</em> and write to <em>stdout</em>) are connected using a pipe, such that the standard output of one program is directed into the pipe and the standard input of the other is taken from the pipe? And in particular, how can we do this without modifying the code of the filters themselves?</p>
<p class="indent">The answer is to use the techniques described in <a href="ch05.xhtml#ch05lev1sec05">Section 5.5</a> for duplicating file descriptors. Traditionally, the following series of calls was used to accomplish the desired result:</p>
<p class="programs">int pfd[2];<br/><br/>pipe(pfd);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allocates (say) file descriptors 3 and 4 for pipe */<br/><br/>/* Other steps here, e.g., fork() */<br/><br/>close(STDOUT_FILENO);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Free file descriptor 1 */<br/>dup(pfd[1]);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Duplication uses lowest free file<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;descriptor, i.e., fd 1 */</p>
<p class="noindent">The end result of the above steps is that the process&#8217;s standard output is bound to the write end of the pipe. A corresponding set of calls can be used to bind a process&#8217;s standard input to the read end of the pipe.</p>
<p class="indent">Note that these steps depend on the assumption that file descriptors 0, 1, and 2 for a process are already open. (The shell normally ensures this for each program it executes.) If file descriptor 0 happened to be closed between the call to <em>pipe()</em> and the calls to <em>close()</em> and <em>dup()</em>, then we would erroneously bind the process&#8217;s standard <em>input</em> to the write end of the pipe. To avoid this possibility, we can replace the calls to <em>close()</em> and <em>dup()</em> with the following <em>dup2()</em> call, which allows us to explicitly specify the descriptor to be bound to the pipe end:</p>
<p class="programs">dup2(pfd[1], STDOUT_FILENO);&#160;&#160;&#160;&#160;/* Close descriptor 1, and reopen bound<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;to write end of pipe */</p>
<p class="noindent"><span epub:type="pagebreak" id="page_900"/>After duplicating <em>pfd[1]</em>, we now have two file descriptors referring to the write end of the pipe: descriptor 1 and <em>pfd[1]</em>. Since unused pipe file descriptors should be closed, after the <em>dup2()</em> call, we close the superfluous descriptor:</p>
<p class="programs">close(pfd[1]);</p>
<p class="noindent">The code we have shown so far relies on standard output having been previously open. Suppose that, prior to the <em>pipe()</em> call, standard input and standard output had both been closed. In this case, <em>pipe()</em> would have allocated these two descriptors to the pipe, perhaps with <em>pfd[0]</em> having the value 0 and <em>pfd[1]</em> having the value 1. Consequently, the preceding <em>dup2()</em> and <em>close()</em> calls would be equivalent to the following:</p>
<p class="programs">dup2(1, 1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Does nothing */<br/>close(1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Closes sole descriptor for write end of pipe */</p>
<p class="noindent">Therefore, it is good defensive programming practice to bracket these calls with an <span class="literal">if</span> statement of the following form:</p>
<p class="programs">if (pfd[1] != STDOUT_FILENO) {<br/>&#160;&#160;&#160;&#160;dup2(pfd[1], STDOUT_FILENO);<br/>&#160;&#160;&#160;&#160;close(pfd[1]);<br/>}</p>
<h5 class="h5" id="ch44lev3sec09"><strong>Example program</strong></h5>
<p class="noindenta">The program in <a href="ch44.xhtml#ch44ex4">Listing 44-4</a> uses the techniques described in this section to bring about the setup shown in <a href="ch44.xhtml#ch44fig1">Figure 44-1</a>. After building a pipe, this program creates two child processes. The first child binds its standard output to the write end of the pipe and then execs <em>ls</em>. The second child binds its standard input to the read end of the pipe and then execs <em>wc</em>.</p>
<p class="examplet"><a id="ch44ex4"/><strong>Listing 44-4:</strong> Using a pipe to connect <em>ls</em> and <em>wc</em></p>
<p class="programsli">_______________________________________________________ <span class="codestrong">pipes/pipe_ls_wc.c</span><br/><br/>#include &lt;sys/wait.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int pfd[2];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Pipe file descriptors */<br/><br/>&#160;&#160;&#160;&#160;if (pipe(pfd) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create pipe */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("pipe");<br/><br/>&#160;&#160;&#160;&#160;switch (fork()) {<br/>&#160;&#160;&#160;&#160;case -1:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;case 0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* First child: exec 'ls' to write to pipe */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (close(pfd[0]) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Read end is unused */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close 1");<br/><span epub:type="pagebreak" id="page_901"/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Duplicate stdout on write end of pipe; close duplicated descriptor */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (pfd[1] != STDOUT_FILENO) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Defensive check */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (dup2(pfd[1], STDOUT_FILENO) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("dup2 1");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (close(pfd[1]) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close 2");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;execlp("ls", "ls", (char *) NULL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Writes to pipe */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("execlp ls");<br/><br/>&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent falls through to create next child */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;switch (fork()) {<br/>&#160;&#160;&#160;&#160;case -1:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;case 0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Second child: exec 'wc' to read from pipe */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (close(pfd[1]) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Write end is unused */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close 3");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Duplicate stdin on read end of pipe; close duplicated descriptor */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (pfd[0] != STDIN_FILENO) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Defensive check */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (dup2(pfd[0], STDIN_FILENO) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("dup2 2");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (close(pfd[0]) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close 4");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;execlp("wc", "wc", "-l", (char *) NULL);&#160;&#160;&#160;&#160;/* Reads from pipe */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("execlp wc");<br/><br/>&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent falls through */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;/* Parent closes unused file descriptors for pipe, and waits for children */<br/><br/>&#160;&#160;&#160;&#160;if (close(pfd[0]) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close 5");<br/>&#160;&#160;&#160;&#160;if (close(pfd[1]) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close 6");<br/>&#160;&#160;&#160;&#160;if (wait(NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("wait 1");<br/>&#160;&#160;&#160;&#160;if (wait(NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("wait 2");<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_______________________________________________________ <span class="codestrong">pipes/pipe_ls_wc.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_902"/>When we run the program in <a href="ch44.xhtml#ch44ex4">Listing 44-4</a>, we see the following:</p>
<p class="programs">$ <span class="codestrong">./pipe_ls_wc</span><br/>&#160;&#160;&#160;&#160;&#160;24<br/>$ <span class="codestrong">ls | wc -l</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Verify the results using shell commands</span><br/>&#160;&#160;&#160;&#160;&#160;24</p>
<h3 class="h3" id="ch44lev1sec05"><strong>44.5 Talking to a Shell Command via a Pipe: <em>popen()</em></strong></h3>
<p class="noindenta">A common use for pipes is to execute a shell command and either read its output or send it some input. The <em>popen()</em> and <em>pclose()</em> functions are provided to simplify this task.</p>
<div class="box">
<p class="programsa">#include &lt;stdio.h&gt;<br/><br/>FILE *<span class="codestrong">popen</span>(const char *<span class="font1">command</span>, const char *<span class="font1">mode</span>);</p>
<p class="right">Returns file stream, or <span class="literal">NULL</span> on error</p>
<p class="programsat">int <span class="codestrong">pclose</span>(FILE *<span class="font1">stream</span>);</p>
<p class="right">Returns termination status of child process, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>popen()</em> function creates a pipe, and then forks a child process that execs a shell, which in turn creates a child process to execute the string given in <em>command</em>. The <em>mode</em> argument is a string that determines whether the calling process will read from the pipe (<em>mode</em> is <em>r</em>) or write to it (<em>mode</em> is <em>w</em>). (Since pipes are unidirectional, two-way communication with the executed <em>command</em> is not possible.) The value of <em>mode</em> determines whether the standard output of the executed command is connected to the write end of the pipe or its standard input is connected to the read end of the pipe, as shown in <a href="ch44.xhtml#ch44fig4">Figure 44-4</a>.</p>
<div class="image"><img src="../images/f44-04.jpg" alt="image"/></div>
<p class="figcap"><a id="ch44fig4"/><strong>Figure 44-4:</strong> Overview of process relationships and pipe usage for <em>popen()</em></p>
<p class="noindent">On success, <em>popen()</em> returns a file stream pointer that can be used with the <em>stdio</em> library functions. If an error occurs (e.g., <em>mode</em> is not <em>r</em> or <em>w</em>, pipe creation fails, or the <em>fork()</em> to create the child fails), then <em>popen()</em> returns <span class="literal">NULL</span> and sets <em>errno</em> to indicate the cause of the error.</p>
<p class="indent">After the <em>popen()</em> call, the calling process uses the pipe to read the output of <em>command</em> or to send input to it. Just as with pipes created using <em>pipe()</em>, when reading from the pipe, the calling process encounters end-of-file once <em>command</em> has closed <span epub:type="pagebreak" id="page_903"/>the write end of the pipe; when writing to the pipe, it is sent a <span class="literal">SIGPIPE</span> signal, and gets the <span class="literal">EPIPE</span> error, if <em>command</em> has closed the read end of the pipe.</p>
<p class="indent">Once I/O is complete, the <em>pclose()</em> function is used to close the pipe and wait for the child shell to terminate. (The <em>fclose()</em> function should not be used, since it doesn&#8217;t wait for the child.) On success, <em>pclose()</em> yields the termination status (<a href="ch26.xhtml#ch26lev2sec03">Section 26.1.3</a>) of the child shell (which is the termination status of the last command that the shell executed, unless the shell was killed by a signal). As with <em>system()</em> (<a href="ch27.xhtml#ch27lev1sec06">Section 27.6</a>), if a shell could not be execed, then <em>pclose()</em> returns a value as though the child shell had terminated with the call <em>_exit(127)</em>. If some other error occurs, <em>pclose()</em> returns &#8211;1. One possible error is that the termination status could not be obtained. We explain how this may occur shortly.</p>
<p class="indent">When performing a wait to obtain the status of the child shell, SUSv3 requires that <em>pclose()</em>, like <em>system()</em>, should automatically restart the internal call that it makes to <em>waitpid()</em> if that call is interrupted by a signal handler.</p>
<p class="indent">In general, we can make the same statements for <em>popen()</em> as were made in <a href="ch27.xhtml#ch27lev1sec06">Section 27.6</a> for <em>system()</em>. Using <em>popen()</em> offers convenience. It builds the pipe, performs descriptor duplication, closes unused descriptors, and handles all of the details of <em>fork()</em> and <em>exec()</em> on our behalf. In addition, shell processing is performed on the command. This convenience comes at the cost of efficiency. At least two extra processes must be created: one for the shell and one or more for the command(s) executed by the shell. As with <em>system()</em>, <em>popen()</em> should never be used from privileged programs.</p>
<p class="indentb">While there are several similarities between <em>system()</em> and <em>popen()</em> plus <em>pclose()</em>, there are also significant differences. These stem from the fact that, with <em>system()</em>, the execution of the shell command is encapsulated within a single function call, whereas with <em>popen()</em>, the calling process runs in parallel with the shell command and then calls <em>pclose()</em>. The differences are as follows:</p>
<p class="bull">&#8226; Since the calling process and the executed command are operating in parallel, SUSv3 requires that <em>popen()</em> should <em>not</em> ignore <span class="literal">SIGINT</span> and <span class="literal">SIGQUIT</span>. If generated from the keyboard, these signals are sent to both the calling process and the executed command. This occurs because both processes reside in the same process group, and terminal-generated signals are sent to all of the members of the (foreground) process group, as described in <a href="ch34.xhtml#ch34lev1sec05">Section 34.5</a>.</p>
<p class="bull">&#8226; Since the calling process may create other child processes between the execution of <em>popen()</em> and <em>pclose()</em>, SUSv3 requires that <em>popen()</em> should <em>not</em> block <span class="literal">SIGCHLD</span>. This means that if the calling process performs a wait operation before the <em>pclose()</em> call, it may retrieve the status of the child created by <em>popen()</em>. In this case, when <em>pclose()</em> is later called, it will return &#8211;1, with <em>errno</em> set to <span class="literal">ECHILD</span>, indicating that <em>pclose()</em> could not retrieve the status of the child.</p>
<h5 class="h5" id="ch44lev3sec10"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch44.xhtml#ch44ex5">Listing 44-5</a> demonstrates the use of <em>popen()</em> and <em>pclose()</em>. This program repeatedly reads a filename wildcard pattern <span class="ent">&#x2461;</span>, and then uses <em>popen()</em> to obtain the results from passing this pattern to the <em>ls</em> command <span class="ent">&#x2464;</span>. (Techniques similar to this were used on older UNIX implementations to perform filename generation, also known as <em>globbing</em>, prior to the existence of the <em>glob()</em> library function.)</p>
<p class="examplet"><span epub:type="pagebreak" id="page_904"/><a id="ch44ex5"/><strong>Listing 44-5:</strong> Globbing filename patterns with <em>popen()</em></p>
<p class="programsli">_______________________________________________________ <span class="codestrong">pipes/popen_glob.c</span><br/><br/>&#160;&#160;&#160;#include &lt;ctype.h&gt;<br/>&#160;&#160;&#160;#include &lt;limits.h&gt;<br/>&#160;&#160;&#160;#include "print_wait_status.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* For printWaitStatus() */<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/><span class="ent">&#x2460;</span> #define POPEN_FMT "/bin/ls -d %s 2&gt; /dev/null"<br/>&#160;&#160;&#160;#define PAT_SIZE 50<br/>&#160;&#160;&#160;#define PCMD_BUF_SIZE (sizeof(POPEN_FMT) + PAT_SIZE)<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char pat[PAT_SIZE];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Pattern for globbing */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char popenCmd[PCMD_BUF_SIZE];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;FILE *fp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* File stream returned by popen() */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;Boolean badPattern;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Invalid characters in 'pat'? */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int len, status, fileCnt, j;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char pathname[PATH_MAX];<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (;;) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Read pattern, display results of globbing */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("pattern: ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fflush(stdout);<br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (fgets(pat, PAT_SIZE, stdin) == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* EOF */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;len = strlen(pat);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (len &lt;= 1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Empty line */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (pat[len - 1] == '\n')&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Strip trailing newline */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pat[len - 1] = '\0';<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Ensure that the pattern contains only valid characters,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;i.e., letters, digits, underscore, dot, and the shell<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;globbing characters. (Our definition of valid is more<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;restrictive than the shell, which permits other characters<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;to be included in a filename if they are quoted.) */<br/><br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (j = 0, badPattern = FALSE; j &lt; len &#38;&#38; !badPattern; j++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (!isalnum((unsigned char) pat[j]) &#38;&#38;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;strchr("_*?[^-].", pat[j]) == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;badPattern = TRUE;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (badPattern) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Bad pattern character: %c\n", pat[j - 1]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Build and execute command to glob 'pat' */<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;snprintf(popenCmd, PCMD_BUF_SIZE, POPEN_FMT, pat);<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fp = popen(popenCmd, "r");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (fp == NULL) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("popen() failed\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Read resulting list of pathnames until EOF */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fileCnt = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (fgets(pathname, PATH_MAX, fp) != NULL) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s", pathname);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fileCnt++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Close pipe, fetch and display termination status */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;status = pclose(fp);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;%d matching file%s\n", fileCnt, (fileCnt != 1) ? "s" : "");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;pclose() status = %#x\n", (unsigned int) status);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (status != -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printWaitStatus("\t", status);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;}<br/>_______________________________________________________ <span class="codestrong">pipes/popen_glob.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_905"/>The following shell session demonstrates the use of the program in <a href="ch44.xhtml#ch44ex5">Listing 44-5</a>. In this example, we first provide a pattern that matches two filenames, and then a pattern that matches no filename:</p>
<p class="programs">$ <span class="codestrong">./popen_glob</span><br/>pattern: <span class="codestrong">popen_glob*</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Matches two filenames</span><br/>popen_glob<br/>popen_glob.c<br/>&#160;&#160;&#160;&#160;2 matching files<br/>&#160;&#160;&#160;&#160;pclose() status = 0<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;child exited, status=0<br/>pattern: <span class="codestrong">x*</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Matches no filename</span><br/>&#160;&#160;&#160;&#160;0 matching files<br/>&#160;&#160;&#160;&#160;pclose() status = 0x100&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">ls(1) exits with status 1</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;child exited, status=1<br/>pattern: <span class="codestrong">^D</span>$&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Type Control-D to terminate</span></p>
<p class="noindent">The construction of the command <span class="ent">&#x2460;</span><span class="ent">&#x2463;</span> for globbing in <a href="ch44.xhtml#ch44ex5">Listing 44-5</a> requires some explanation. Actual globbing of a pattern is performed by the shell. The <em>ls</em> command is merely being used to list the matching filenames, one per line. We could have tried using the <em>echo</em> command instead, but this would have had the undesirable result that if a pattern matched no filenames, then the shell would leave the pattern unchanged, and <em>echo</em> would simply display the pattern. By contrast, if <em>ls</em> is given the name of a file that doesn&#8217;t exist, it prints an error message on <em>stderr</em> (which we dispose of by redirecting <em>stderr</em> to <span class="literal">/dev/null</span>), prints nothing on <em>stdout</em>, and exits with a status of 1.</p>
<p class="indent"><span epub:type="pagebreak" id="page_906"/>Note also the input checking performed in <a href="ch44.xhtml#ch44ex5">Listing 44-5</a> <span class="ent">&#x2462;</span>. This is done to prevent invalid input causing <em>popen()</em> to execute an unexpected shell command. Suppose that these checks were omitted, and the user entered the following input:</p>
<p class="programs">pattern: <span class="codestrong">; rm *</span></p>
<p class="noindent">The program would then pass the following command to <em>popen()</em>, with disastrous results:</p>
<p class="programs">/bin/ls -d ; rm * 2&gt; /dev/null</p>
<p class="noindent">Such checking of input is always required in programs that use <em>popen()</em> (or <em>system()</em>) to execute a shell command built from user input. (An alternative would be for the application to quote any characters other than those being checked for, so that those characters don&#8217;t undergo special processing by the shell.)</p>
<h3 class="h3" id="ch44lev1sec06"><strong>44.6 Pipes and <em>stdio</em> Buffering</strong></h3>
<p class="noindenta">Since the file stream pointer returned by a call to <em>popen()</em> doesn&#8217;t refer to a terminal, the <em>stdio</em> library applies block buffering to the file stream (<a href="ch13.xhtml#ch13lev1sec02">Section 13.2</a>). This means that when we call <em>popen()</em> with a <em>mode</em> of <em>w</em>, then, by default, output is sent to the child process at the other end of the pipe only when the <em>stdio</em> buffer is filled or we close the pipe with <em>pclose()</em>. In many cases, this presents no problem. If, however, we need to ensure that the child process receives data on the pipe immediately, then we can either use periodic calls to <em>fflush()</em> or disable <em>stdio</em> buffering using the call <em>setbuf(fp, NULL)</em>. This technique can also be used if we create a pipe using the <em>pipe()</em> system call and then use <em>fdopen()</em> to obtain a <em>stdio</em> stream corresponding to the write end of the pipe.</p>
<p class="indent">If the process calling <em>popen()</em> is reading from the pipe (i.e., <em>mode</em> is <em>r</em>), things may not be so straightforward. In this case, if the child process is using the <em>stdio</em> library, then&#8212;unless it includes explicit calls to <em>fflush()</em> or <em>setbuf()</em>&#8212;its output will be available to the calling process only when the child either fills the <em>stdio</em> buffer or calls <em>fclose()</em>. (The same statement applies if we are reading from a pipe created using <em>pipe()</em> and the process writing on the other end is using the <em>stdio</em> library.) If this is a problem, there is little we can do unless we can modify the source code of the program running in the child process to include calls to <em>setbuf()</em> of <em>fflush()</em>.</p>
<p class="indent">If modifying the source code is not an option, then instead of using a pipe, we could use a pseudoterminal. A pseudoterminal is an IPC channel that appears to the process on one end as though it is a terminal. Consequently, the <em>stdio</em> library line buffers output. We describe pseudoterminals in <a href="ch64.xhtml#ch64">Chapter 64</a>.</p>
<h3 class="h3" id="ch44lev1sec07"><strong>44.7 FIFOs</strong></h3>
<p class="noindenta">Semantically, a FIFO is similar to a pipe. The principal difference is that a FIFO has a name within the file system and is opened in the same way as a regular file. This allows a FIFO to be used for communication between unrelated processes (e.g., a client and server).</p>
<p class="indent"><span epub:type="pagebreak" id="page_907"/>Once a FIFO has been opened, we use the same I/O system calls as are used with pipes and other files (i.e., <em>read()</em>, <em>write()</em>, and <em>close()</em>). Just as with pipes, a FIFO has a write end and a read end, and data is read from the pipe in the same order as it is written. This fact gives FIFOs their name: <em>first in, first out</em>. FIFOs are also sometimes known as <em>named pipes</em>.</p>
<p class="indent">As with pipes, when all descriptors referring to a FIFO have been closed, any outstanding data is discarded.</p>
<p class="indent">We can create a FIFO from the shell using the <em>mkfifo</em> command:</p>
<p class="programs">$ <span class="codestrong">mkfifo</span> [ <span class="codestrong">-m <span class="codeitalic">mode</span></span> ] <span class="codestrong"><span class="codeitalic">pathname</span></span></p>
<p class="noindent">The <em>pathname</em> is the name of the FIFO to be created, and the <em>&#8211;m</em> option is used to specify a permission <em>mode</em> in the same way as for the <em>chmod</em> command.</p>
<p class="indent">When applied to a FIFO (or pipe), <em>fstat()</em> and <em>stat()</em> return a file type of <span class="literal">S_IFIFO</span> in the <em>st_mode</em> field of the <em>stat</em> structure (<a href="ch15.xhtml#ch15lev1sec01">Section 15.1</a>). When listed with <em>ls &#8211;l</em>, a FIFO is shown with the type <em>p</em> in the first column, and <em>ls &#8211;F</em> appends a pipe symbol (<span class="literal">|</span>) to the FIFO pathname.</p>
<p class="indent">The <em>mkfifo()</em> function creates a new FIFO with the given <em>pathname</em>.</p>
<div class="box">
<p class="programsa">#include &lt;sys/stat.h&gt;<br/><br/>int <span class="codestrong">mkfifo</span>(const char *<span class="font1">pathname</span>, mode_t <span class="font1">mode</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>mode</em> argument specifies the permissions for the new FIFO. These permissions are specified by ORing the desired combination of constants from <a href="ch15.xhtml#ch15table4">Table 15-4</a>, on <a href="ch15.xhtml#page_295">page 295</a>. As usual, these permissions are masked against the process umask value (<a href="ch15.xhtml#ch15lev2sec10">Section 15.4.6</a>).</p>
<div class="block">
<p class="noindent">Historically, FIFOs were created using the system call <em>mknod(pathname, S_IFIFO, 0)</em>. POSIX.1-1990 specified <em>mkfifo()</em> as a simpler API avoiding the generality of <em>mknod()</em>, which allows creation of various types of files, including device files. (SUSv3 specifies <em>mknod()</em>, but weakly, defining only its use for creating FIFOs.) Most UNIX implementations provide <em>mkfifo()</em> as a library function layered on top of <em>mknod()</em>.</p>
</div>
<p class="noindent">Once a FIFO has been created, any process can open it, subject to the usual file permission checks (<a href="ch15.xhtml#ch15lev2sec07">Section 15.4.3</a>).</p>
<p class="indent">Opening a FIFO has somewhat unusual semantics. Generally, the only sensible use of a FIFO is to have a reading process and a writing process on each end. Therefore, by default, opening a FIFO for reading (the <em>open()</em> <span class="literal">O_RDONLY</span> flag) blocks until another process opens the FIFO for writing (the <em>open()</em> <span class="literal">O_WRONLY</span> flag). Conversely, opening the FIFO for writing blocks until another process opens the FIFO for reading. In other words, opening a FIFO synchronizes the reading and writing processes. If the opposite end of a FIFO is already open (perhaps because a pair of processes have already opened each end of the FIFO), then <em>open()</em> succeeds immediately.</p>
<p class="indent">Under most UNIX implementations (including Linux), it is possible to circumvent the blocking behavior when opening FIFOs by specifying the <span class="literal">O_RDWR</span> flag when opening a FIFO. In this case, <em>open()</em> returns immediately with a file descriptor that <span epub:type="pagebreak" id="page_908"/>can be used for reading and writing on the FIFO. Doing this rather subverts the I/O model for FIFOs, and SUSv3 explicitly notes that opening a FIFO with the <span class="literal">O_RDWR</span> flag is unspecified; therefore, for portability reasons, this technique should be avoided. In circumstances where we need to prevent blocking when opening a FIFO, the <em>open()</em> <span class="literal">O_NONBLOCK</span> flag provides a standardized method for doing so (refer to <a href="ch44.xhtml#ch44lev1sec09">Section 44.9</a>).</p>
<div class="block">
<p class="noindent">Avoiding the use of the <span class="literal">O_RDWR</span> flag when opening a FIFO can be desirable for a another reason. After such an <em>open()</em>, the calling process will never see end-of-file when reading from the resulting file descriptor, because there will always be at least one descriptor open for writing to the FIFO&#8212;the same descriptor from which the process is reading.</p>
</div>
<h5 class="h5" id="ch44lev3sec11"><strong>Using FIFOs and <em>tee(1)</em> to create a dual pipeline</strong></h5>
<p class="noindenta">One of the characteristics of shell pipelines is that they are linear; each process in the pipeline reads data produced by its predecessor and sends data to its successor. Using FIFOs, it is possible to create a fork in a pipeline, so that a duplicate copy of the output of a process is sent to another process in addition to its successor in the pipeline. In order to do this, we need to use the <em>tee</em> command, which writes two copies of what it reads from its standard input: one to standard output and the other to the file named in its command-line argument.</p>
<p class="indent">Making the <em>file</em> argument to <em>tee</em> a FIFO allows us to have two processes simultaneously reading the duplicate output produced by <em>tee</em>. We demonstrate this in the following shell session, which creates a FIFO named <span class="literal">myfifo</span>, starts a background <em>wc</em> command that opens the FIFO for reading (this will block until the FIFO is opened for writing), and then executes a pipeline that sends the output of <em>ls</em> to <em>tee</em>, which both passes the output further down the pipeline to <em>sort</em> and sends it to the <span class="literal">myfifo</span> FIFO. (The <em>&#8211;k5n</em> option to <em>sort</em> causes the output of <em>ls</em> to be sorted in increasing numerical order on the fifth space-delimited field.)</p>
<p class="programs">$ <span class="codestrong">mkfifo myfifo</span><br/>$ <span class="codestrong">wc -l &lt; myfifo &#38;</span><br/>$ <span class="codestrong">ls -l | tee myfifo | sort -k5n</span><br/><span class="font1">(Resulting output not shown)</span></p>
<p class="noindent">Diagrammatically, the above commands create the situation shown in <a href="ch44.xhtml#ch44fig5">Figure 44-5</a>.</p>
<div class="block">
<p class="noindent">The <em>tee</em> program is so named because of its shape. We can consider <em>tee</em> as functioning similarly to a pipe, but with an additional branch that sends duplicate output. Diagrammatically, this has the shape of a capital letter <em>T</em> (see <a href="ch44.xhtml#ch44fig5">Figure 44-5</a>). In addition to the purpose described here, <em>tee</em> is also useful for debugging pipelines and for saving the results produced at some intervening point in a complex pipeline.</p>
</div>
<div class="image"><img src="../images/f44-05.jpg" alt="image"/></div>
<p class="figcap"><a id="ch44fig5"/><strong>Figure 44-5:</strong> Using a FIFO and <em>tee(1)</em> to create a dual pipeline</p>
<h3 class="h3" id="ch44lev1sec08"><span epub:type="pagebreak" id="page_909"/><strong>44.8 A Client-Server Application Using FIFOs</strong></h3>
<p class="noindenta">In this section, we present a simple client-server application that employs FIFOs for IPC. The server provides the (trivial) service of assigning unique sequential numbers to each client that requests them. In the course of discussing this application, we introduce a few concepts and techniques in server design.</p>
<h5 class="h5" id="ch44lev3sec12"><strong>Application overview</strong></h5>
<p class="noindenta">In the example application, all clients send their requests to the server using a single server FIFO. The header file (<a href="ch44.xhtml#ch44ex6">Listing 44-6</a>) defines the well-known name (<span class="literal">/tmp/seqnum_sv</span>) that the server uses for its FIFO. This name is fixed, so that all clients know how to contact the server. (In this example application, we create the FIFOs in the <span class="literal">/tmp</span> directory, since this allows us to conveniently run the programs without change on most systems. However, as noted in <a href="ch38.xhtml#ch38lev1sec07">Section 38.7</a>, creating files in publicly writable directories such as <span class="literal">/tmp</span> can lead to various security vulnerabilities and should be avoided in real-world applications.)</p>
<div class="block">
<p class="noindent">In client-server applications, we&#8217;ll repeatedly encounter the concept of a <em>well-known address</em> or name used by a server to make its service visible to clients. Using a well-known address is one solution to the problem of how clients can know where to contact a server. Another possible solution is to provide some kind of name server with which servers can register the names of their services. Each client then contacts the name server to obtain the location of the service it desires. This solution allows the location of servers to be flexible, at the cost of some extra programming effort. Of course, clients and servers then need to know where to contact the name server; typically, it resides at a well-known address.</p>
</div>
<p class="noindent">It is not, however, possible to use a single FIFO to send responses to all clients, since multiple clients would race to read from the FIFO, and possibly read each other&#8217;s response messages rather than their own. Therefore, each client creates a unique FIFO that the server uses for delivering the response for that client, and the server needs to know how to find each client&#8217;s FIFO. One possible way to do this is for the client to generate its FIFO pathname, and then pass the pathname as part of its request message. Alternatively, the client and server can agree on a convention for constructing a client FIFO pathname, and, as part of its request, the client can pass the server the information required to construct the pathname specific to this client. This latter solution is used in our example. Each client&#8217;s FIFO name is built from a template (<span class="literal">CLIENT_FIFO_TEMPLATE</span>) consisting of a pathname containing the client&#8217;s process ID. The inclusion of the process ID provides an easy way of generating a name unique to this client.</p>
<p class="indent"><a href="ch44.xhtml#ch44fig6">Figure 44-6</a> shows how this application uses FIFOs for communication between the client and server processes of our application.</p>
<p class="indent">The header file (<a href="ch44.xhtml#ch44ex6">Listing 44-6</a>) defines the formats for the request messages sent from clients to the server, and for the response messages sent from the server to clients.</p>
<div class="image"><span epub:type="pagebreak" id="page_910"/><img src="../images/f44-06.jpg" alt="image"/></div>
<p class="figcap"><a id="ch44fig6"/><strong>Figure 44-6:</strong> Using FIFOs in a single-server, multiple-client application</p>
<p class="noindentb">Recall that the data in pipes and FIFOs is a byte stream; boundaries between multiple messages are not preserved. This means that when multiple messages are being delivered to a single process, such as the server in our example, then the sender and receiver must agree on some convention for separating the messages. Various approaches are possible:</p>
<p class="bull">&#8226; Terminate each message with a <em>delimiter character</em>, such as a newline character. (For an example of this technique, see the <em>readLine()</em> function in <a href="ch59.xhtml#ch59ex1">Listing 59-1</a>, on <a href="ch59.xhtml#page_1201">page 1201</a>.) In this case, either the delimiter character must be one that never appears as part of the message, or we must adopt a convention for escaping the delimiter if it does occur within the message. For example, if we use a newline delimiter, then the characters <span class="literal">\</span> plus newline could be used to represent a real newline character within the message, while <span class="literal">\\</span> could represent a real <span class="literal">\</span>. One drawback of this approach is that the process reading messages must scan data from the FIFO a byte at a time until the delimiter character is found.</p>
<p class="bull">&#8226; Include a <em>fixed-size header with a length field</em> in each message specifying the number of bytes in the remaining variable-length component of the message. In this case, the reading process first reads the header from the FIFO, and then uses the header&#8217;s length field to determine the number of bytes to read for the remainder of the message. This approach has the advantage of efficiently allowing messages of arbitrary size, but could lead to problems if a malformed message (e.g., bad <em>length</em> field) is written to the pipe.</p>
<p class="bull">&#8226; Use <em>fixed-length messages</em>, and have the server always read messages of this fixed size. This has the advantage of being simple to program. However, it places an upper limit on our message size and means that some channel capacity is wasted (since short messages must be padded to the fixed length). Furthermore, if one of the clients accidentally or deliberately sends a message that is not of the right length, then all subsequent messages will be out of step; in this situation, the server can&#8217;t easily recover.</p>
<p class="noindentt">These three techniques are illustrated in <a href="ch44.xhtml#ch44fig7">Figure 44-7</a>. Be aware that for each of these techniques, the total length of each message must be smaller than <span class="literal">PIPE_BUF</span> bytes in order to avoid the possibility of messages being broken up by the kernel and interleaved with messages from other writers.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_911"/>In the three techniques described in the main text, a single channel (FIFO) is used for all messages from all clients. An alternative is to use a <em>single connection for each message</em>. The sender opens the communication channel, sends its message, and then closes the channel. The reading process knows that the message is complete when it encounters end-of-file. If multiple writers hold a FIFO open, then this approach is not feasible, because the reader won&#8217;t see end-of-file when one of the writers closes the FIFO. This approach is, however, feasible when using stream sockets, where a server process creates a unique communication channel for each incoming client connection.</p>
</div>
<div class="image"><img src="../images/f44-07.jpg" alt="image"/></div>
<p class="figcap"><a id="ch44fig7"/><strong>Figure 44-7:</strong> Separating messages in a byte stream</p>
<p class="noindent">In our example application, we use the third of the techniques described above, with each client sending messages of a fixed size to the server. This message is defined by the <em>request</em> structure defined in <a href="ch44.xhtml#ch44ex6">Listing 44-6</a>. Each request to the server includes the client&#8217;s process ID, which enables the server to construct the name of the FIFO used by the client to receive a response. The request also contains a field (<em>seqLen</em>) specifying how many sequence numbers should be allocated to this client. The response message sent from server to client consists of a single field, <em>seqNum</em>, which is the starting value of the range of sequence numbers allocated to this client.</p>
<p class="examplet"><a id="ch44ex6"/><strong>Listing 44-6:</strong> Header file for <span class="literal">fifo_seqnum_server.c</span> and <span class="literal">fifo_seqnum_client.c</span></p>
<p class="programsli">______________________________________________________ <span class="codestrong">pipes/fifo_seqnum.h</span><br/><br/>#include &lt;sys/types.h&gt;<br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>#define SERVER_FIFO "/tmp/seqnum_sv"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Well-known name for server's FIFO */<br/>#define CLIENT_FIFO_TEMPLATE "/tmp/seqnum_cl.%ld"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Template for building client FIFO name */<br/>#define CLIENT_FIFO_NAME_LEN (sizeof(CLIENT_FIFO_TEMPLATE) + 20)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Space required for client FIFO pathname<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(+20 as a generous allowance for the PID) */<br/><br/>struct request {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Request (client --&gt; server) */<br/>&#160;&#160;&#160;&#160;pid_t pid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* PID of client */<br/>&#160;&#160;&#160;&#160;int seqLen;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Length of desired sequence */<br/>};<br/><br/>struct response {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Response (server --&gt; client) */<br/>&#160;&#160;&#160;&#160;int seqNum;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Start of sequence */<br/>};<br/>______________________________________________________ <span class="codestrong">pipes/fifo_seqnum.h</span></p>
<h5 class="h5" id="ch44lev3sec13"><span epub:type="pagebreak" id="page_912"/><strong>Server program</strong></h5>
<p class="noindentab"><a href="ch44.xhtml#ch44ex7">Listing 44-7</a> is the code for the server. The server performs the following steps:</p>
<p class="bull">&#8226; Create the server&#8217;s well-known FIFO <span class="ent">&#x2460;</span> and open the FIFO for reading <span class="ent">&#x2461;</span>. The server must be run before any clients, so that the server FIFO exists by the time a client attempts to open it. The server&#8217;s <em>open()</em> blocks until the first client opens the other end of the server FIFO for writing.</p>
<p class="bull">&#8226; Open the server&#8217;s FIFO once more <span class="ent">&#x2462;</span>, this time for writing. This will never block, since the FIFO has already been opened for reading. This second open is a convenience to ensure that the server doesn&#8217;t see end-of-file if all clients close the write end of the FIFO.</p>
<p class="bull">&#8226; Ignore the <span class="literal">SIGPIPE</span> signal <span class="ent">&#x2463;</span>, so that if the server attempts to write to a client FIFO that doesn&#8217;t have a reader, then, rather than being sent a <span class="literal">SIGPIPE</span> signal (which kills a process by default), it receives an <span class="literal">EPIPE</span> error from the <em>write()</em> system call.</p>
<p class="bull">&#8226; Enter a loop that reads and responds to each incoming client request <span class="ent">&#x2464;</span>. To send the response, the server constructs the name of the client FIFO <span class="ent">&#x2465;</span> and then opens that FIFO <span class="ent">&#x2466;</span>.</p>
<p class="bull">&#8226; If the server encounters an error in opening the client FIFO, it abandons that client&#8217;s request <span class="ent">&#x2467;</span>.</p>
<p class="noindentt">This is an example of an <em>iterative server</em>, in which the server reads and handles each client request before going on to handle the next client. An iterative server design is suitable when each client request can be quickly processed and responded to, so that other client requests are not delayed. An alternative design is a <em>concurrent server</em>, in which the main server process employs a separate child process (or thread) to handle each client request. We discuss server design further in <a href="ch60.xhtml#ch60">Chapter 60</a>.</p>
<p class="examplet"><a id="ch44ex7"/><strong>Listing 44-7:</strong> An iterative server using FIFOs</p>
<p class="programsli">________________________________________________ <span class="codestrong">pipes/fifo_seqnum_server.c</span><br/><br/>&#160;&#160;&#160;#include &lt;signal.h&gt;<br/>&#160;&#160;&#160;#include "fifo_seqnum.h"<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int serverFd, dummyFd, clientFd;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char clientFifo[CLIENT_FIFO_NAME_LEN];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct request req;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct response resp;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int seqNum = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* This is our "service" */<br/><br/><span epub:type="pagebreak" id="page_913"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create well-known FIFO, and open it for reading */<br/><br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;umask(0);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* So we get the permissions we want */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (mkfifo(SERVER_FIFO, S_IRUSR | S_IWUSR | S_IWGRP) == -1<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#38;&#38; errno != EEXIST)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mkfifo %s", SERVER_FIFO);<br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;serverFd = open(SERVER_FIFO, O_RDONLY);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (serverFd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open %s", SERVER_FIFO);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Open an extra write descriptor, so that we never see EOF */<br/><br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;dummyFd = open(SERVER_FIFO, O_WRONLY);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (dummyFd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open %s", SERVER_FIFO);<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("signal");<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;for (;;) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Read requests and send responses */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (read(serverFd, &#38;req, sizeof(struct request))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;!= sizeof(struct request)) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(stderr, "Error reading request; discarding\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Either partial read or error */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Open client FIFO (previously created by client) */<br/><br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;snprintf(clientFifo, CLIENT_FIFO_NAME_LEN, CLIENT_FIFO_TEMPLATE,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) req.pid);<br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;clientFd = open(clientFifo, O_WRONLY);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (clientFd == -1) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Open failed, give up on client */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("open %s", clientFifo);<br/><span class="ent">&#x2467;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Send response and close FIFO */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;resp.seqNum = seqNum;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (write(clientFd, &#38;resp, sizeof(struct response))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;!= sizeof(struct response))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(stderr, "Error writing to FIFO %s\n", clientFifo);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (close(clientFd) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("close");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;seqNum += req.seqLen;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Update our sequence number */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/>________________________________________________ <span class="codestrong">pipes/fifo_seqnum_server.c</span></p>
<h5 class="h5" id="ch44lev3sec14"><span epub:type="pagebreak" id="page_914"/><strong>Client program</strong></h5>
<p class="noindentab"><a href="ch44.xhtml#ch44ex8">Listing 44-8</a> is the code for the client. The client performs the following steps:</p>
<p class="bull">&#8226; Create a FIFO to be used for receiving a response from the server <span class="ent">&#x2461;</span>. This is done before sending the request, in order to ensure that the FIFO exists by the time the server attempts to open it and send a response message.</p>
<p class="bull">&#8226; Construct a message for the server containing the client&#8217;s process ID and a number (taken from an optional command-line argument) specifying the length of the sequence that the client wishes the server to assign to it <span class="ent">&#x2463;</span>. (If no command-line argument is supplied, the default sequence length is 1.)</p>
<p class="bull">&#8226; Open the server FIFO <span class="ent">&#x2464;</span> and send the message to the server <span class="ent">&#x2465;</span>.</p>
<p class="bull">&#8226; Open the client FIFO <span class="ent">&#x2466;</span>, and read and print the server&#8217;s response <span class="ent">&#x2467;</span>.</p>
<p class="noindentt">The only other detail of note is the exit handler <span class="ent">&#x2460;</span>, established with <em>atexit()</em> <span class="ent">&#x2462;</span>, which ensures that the client&#8217;s FIFO is deleted when the process exits. Alternatively, we could have simply placed an <em>unlink()</em> call immediately after the <em>open()</em> of the client FIFO. This would work because, at that point, after they have both performed blocking <em>open()</em> calls, the server and the client would each hold open file descriptors for the FIFO, and removing the FIFO name from the file system doesn&#8217;t affect these descriptors or the open file descriptions to which they refer.</p>
<p class="indent">Here is an example of what we see when we run the client and server programs:</p>
<p class="programs">$ <span class="codestrong">./fifo_seqnum_server &#38;</span><br/>[1] 5066<br/>$ <span class="codestrong">./fifo_seqnum_client 3</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Request a sequence of three numbers</span><br/>0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Assigned sequence begins at 0</span><br/>$ <span class="codestrong">./fifo_seqnum_client 2</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Request a sequence of two numbers</span><br/>3&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Assigned sequence begins at 3</span><br/>$ <span class="codestrong">./fifo_seqnum_client</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Request a single number</span><br/>5</p>
<p class="examplet"><a id="ch44ex8"/><strong>Listing 44-8:</strong> Client for the sequence-number server</p>
<p class="programsli">________________________________________________ <span class="codestrong">pipes/fifo_seqnum_client.c</span><br/><br/>&#160;&#160;&#160;#include "fifo_seqnum.h"<br/><br/>&#160;&#160;&#160;static char clientFifo[CLIENT_FIFO_NAME_LEN];<br/><br/>&#160;&#160;&#160;static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Invoked on exit to delete client FIFO */<br/><span class="ent">&#x2460;</span> removeFifo(void)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;unlink(clientFifo);<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int serverFd, clientFd;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct request req;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct response resp;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc &gt; 1 &#38;&#38; strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s [seq-len...]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create our FIFO (before sending request, to avoid a race) */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;umask(0);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* So we get the permissions we want */<br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;snprintf(clientFifo, CLIENT_FIFO_NAME_LEN, CLIENT_FIFO_TEMPLATE,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) getpid());<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (mkfifo(clientFifo, S_IRUSR | S_IWUSR | S_IWGRP) == -1<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#38;&#38; errno != EEXIST)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mkfifo %s", clientFifo);<br/><br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;if (atexit(removeFifo) != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("atexit");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Construct request message, open server FIFO, and send request */<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;req.pid = getpid();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;req.seqLen = (argc &gt; 1) ? getInt(argv[1], GN_GT_0, "seq-len") : 1;<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;serverFd = open(SERVER_FIFO, O_WRONLY);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (serverFd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open %s", SERVER_FIFO);<br/><br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;if (write(serverFd, &#38;req, sizeof(struct request)) !=<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sizeof(struct request))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("Can't write to server");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Open our FIFO, read and display response */<br/><br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;clientFd = open(clientFifo, O_RDONLY);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (clientFd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open %s", clientFifo);<br/><br/><span class="ent">&#x2467;</span>&#160;&#160;&#160;&#160;&#160;if (read(clientFd, &#38;resp, sizeof(struct response))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;!= sizeof(struct response))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("Can't read response from server");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%d\n", resp.seqNum);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;}<br/>________________________________________________ <span class="codestrong">pipes/fifo_seqnum_client.c</span></p>
<h3 class="h3" id="ch44lev1sec09"><span epub:type="pagebreak" id="page_915"/><strong>44.9 Nonblocking I/O</strong></h3>
<p class="noindenta">As noted earlier, when a process opens one end of a FIFO, it blocks if the other end of the FIFO has not yet been opened. Sometimes, it is desirable not to block, and for this purpose, the <span class="literal">O_NONBLOCK</span> flag can be specified when calling <em>open()</em>:</p>
<p class="programs">fd = open("fifopath", O_RDONLY | O_NONBLOCK);<br/>if (fd == -1)<br/>&#160;&#160;&#160;&#160;errExit("open");</p>
<p class="noindentb"><span epub:type="pagebreak" id="page_916"/>If the other end of the FIFO is already open, then the <span class="literal">O_NONBLOCK</span> flag has no effect on the <em>open()</em> call&#8212;it successfully opens the FIFO immediately, as usual. The <span class="literal">O_NONBLOCK</span> flag changes things only if the other end of the FIFO is not yet open, and the effect depends on whether we are opening the FIFO for reading or writing:</p>
<p class="bull">&#8226; If the FIFO is being opened for reading, and no process currently has the write end of the FIFO open, then the <em>open()</em> call succeeds immediately (just as though the other end of the FIFO was already open).</p>
<p class="bull">&#8226; If the FIFO is being opened for writing, and the other end of the FIFO is not already open for reading, then <em>open()</em> fails, setting <em>errno</em> to <span class="literal">ENXIO</span>.</p>
<p class="noindentt">The asymmetry of the <span class="literal">O_NONBLOCK</span> flag depending on whether the FIFO is being opened for reading or for writing can be explained as follows. It is okay to open a FIFO for reading when there is no writer at the other end of the FIFO, since any attempt to read from the FIFO simply returns no data. However, attempting to write to a FIFO for which there is no reader would result in the generation of the <span class="literal">SIGPIPE</span> signal and an <span class="literal">EPIPE</span> error from <em>write()</em>.</p>
<p class="indent"><a href="ch44.xhtml#ch44table1">Table 44-1</a> summarizes the semantics of opening a FIFO, including the effects of <span class="literal">O_NONBLOCK</span> described above.</p>
<p class="tablecap"><a id="ch44table1"/><strong>Table 44-1:</strong> Semantics of <em>open()</em> for a FIFO</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th" colspan="2"><p class="tablec"><strong>Type of <em>open()</em></strong></p></td>
<td style="vertical-align: top;" class="table_th1" colspan="2"><p class="tablec"><strong>Result of <em>open()</em></strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>open for</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>additional flags</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>other end of FIFO open</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>other end of FIFO closed</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: middle;" class="table_1b" rowspan="2"><p class="table">reading</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">none (blocking)</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">succeeds immediately</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">blocks</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">O_NONBLOCK</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">succeeds immediately</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">succeeds immediately</p></td>
</tr>
<tr>
<td style="vertical-align: middle;" class="table_1" rowspan="2"><p class="table">writing</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">none (blocking)</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">succeeds immediately</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">blocks</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">O_NONBLOCK</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">succeeds immediately</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">fails (<span class="literal">ENXIO</span>)</p></td>
</tr>
</tbody>
</table>
<p class="noindentb">Using the <span class="literal">O_NONBLOCK</span> flag when opening a FIFO serves two main purposes:</p>
<p class="bull">&#8226; It allows a single process to open both ends of a FIFO. The process first opens the FIFO for reading specifying <span class="literal">O_NONBLOCK</span>, and then opens the FIFO for writing.</p>
<p class="bull">&#8226; It prevents deadlocks between processes opening two FIFOs.</p>
<p class="noindentt">A <em>deadlock</em> is a situation where two or more process are blocked because each is waiting on the other process(es) to complete some action. The two processes shown in <a href="ch44.xhtml#ch44fig8">Figure 44-8</a> are deadlocked. Each process is blocked waiting to open a FIFO for reading. This blocking would not happen if each process could perform its second step (opening the other FIFO for writing). This particular deadlock problem could be solved by reversing the order of steps 1 and 2 in process Y, while leaving the order in process X unchanged, or vice versa. However, such an arrangement of steps may not be easy to achieve in some applications. Instead, we can resolve the problem by having either process, or both, specify the <span class="literal">O_NONBLOCK</span> flag when opening the FIFOs for reading.</p>
<div class="image"><span epub:type="pagebreak" id="page_917"/><img src="../images/f44-08.jpg" alt="image"/></div>
<p class="figcap"><a id="ch44fig8"/><strong>Figure 44-8:</strong> Deadlock between processes opening two FIFOs</p>
<h5 class="h5" id="ch44lev3sec15"><strong>Nonblocking <em>read()</em> and <em>write()</em></strong></h5>
<p class="noindenta">The <span class="literal">O_NONBLOCK</span> flag affects not only the semantics of <em>open()</em> but also&#8212;because the flag then remains set for the open file description&#8212;the semantics of subsequent <em>read()</em> and <em>write()</em> calls. We describe these effects in the next section.</p>
<p class="indentb">Sometimes, we need to change the state of the <span class="literal">O_NONBLOCK</span> flag for a FIFO (or another type of file) that is already open. Scenarios where this need may arise include the following:</p>
<p class="bull">&#8226; We opened a FIFO using <span class="literal">O_NONBLOCK</span>, but we want subsequent <em>read()</em> and <em>write()</em> calls to operate in blocking mode.</p>
<p class="bull">&#8226; We want to enable nonblocking mode for a file descriptor that was returned by <em>pipe()</em>. More generally, we might want to change the nonblocking status of any file descriptor that was obtained other than from a call to <em>open()</em>&#8212;for example, one of the three standard descriptors that are automatically opened for each new program run by the shell or a file descriptor returned by <em>socket()</em>.</p>
<p class="bull">&#8226; For some application-specific purpose, we need to switch the setting of the <span class="literal">O_NONBLOCK</span> setting of a file descriptor on and off.</p>
<p class="noindentt">For these purposes, we can use <em>fcntl()</em> to enable or disable the <span class="literal">O_NONBLOCK</span> open file status flag. To enable the flag, we write the following (omitting error checking):</p>
<p class="programs">int flags;<br/><br/>flags = fcntl(fd, F_GETFL);&#160;&#160;&#160;&#160;&#160;&#160;/* Fetch open file status flags */<br/>flags |= O_NONBLOCK;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Enable O_NONBLOCK bit */<br/>fcntl(fd, F_SETFL, flags);&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Update open file status flags */</p>
<p class="noindent">And to disable it, we write the following:</p>
<p class="programs">flags = fcntl(fd, F_GETFL);<br/>flags &#38;= ~O_NONBLOCK;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Disable O_NONBLOCK bit */<br/>fcntl(fd, F_SETFL, flags);</p>
<h3 class="h3" id="ch44lev1sec10"><strong>44.10 Semantics of <em>read()</em> and <em>write()</em> on Pipes and FIFOs</strong></h3>
<p class="noindenta"><a href="ch44.xhtml#ch44table2">Table 44-2</a> summarizes the operation of <em>read()</em> for pipes and FIFOs, and includes the effect of the <span class="literal">O_NONBLOCK</span> flag.</p>
<p class="indent">The only difference between blocking and nonblocking reads occurs when no data is present and the write end is open. In this case, a normal <em>read()</em> blocks, while a nonblocking <em>read()</em> fails with the error <span class="literal">EAGAIN</span>.</p>
<p class="tablecap"><span epub:type="pagebreak" id="page_918"/><a id="ch44table2"/><strong>Table 44-2:</strong> Semantics of reading <em>n</em> bytes from a pipe or FIFO containing <em>p</em> bytes</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th" rowspan="2"><p class="table"><span class="literal"><span class="codestrong">O_NONBLOCK</span></span> <strong>enabled?</strong></p></td>
<td style="vertical-align: top;" class="table_th1" colspan="4"><p class="tablec"><strong>Data bytes available in pipe or FIFO (<em>p</em>)</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><strong><em>p = 0</em>, write end open</strong></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><strong><em>p = 0</em>, write end closed</strong></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><strong><em>p &lt; n</em></strong></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table"><strong><em>p &gt;= n</em></strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">block</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">return 0 (EOF)</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">read <em>p</em> bytes</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">read <em>n</em> bytes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">fail (<span class="literal">EAGAIN</span>)</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">return 0 (EOF)</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">read <em>p</em> bytes</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">read <em>n</em> bytes</p></td>
</tr>
</tbody>
</table>
<p class="noindent">The impact of the <span class="literal">O_NONBLOCK</span> flag when writing to a pipe or FIFO is made complex by interactions with the <span class="literal">PIPE_BUF</span> limit. The <em>write()</em> behavior is summarized in <a href="ch44.xhtml#ch44table3">Table 44-3</a>.</p>
<p class="tablecap"><a id="ch44table3"/><strong>Table 44-3:</strong> Semantics of writing <em>n</em> bytes to a pipe or FIFO</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th" rowspan="2"><p class="table"><span class="literal"><span class="codestrong">O_NONBLOCK</span></span> <strong>enabled?</strong></p></td>
<td style="vertical-align: top;" class="table_th" colspan="2"><p class="tablec"><strong>Read end open</strong></p></td>
<td style="vertical-align: top;" class="table_th1" rowspan="2"><p class="table"><strong>Read end closed</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><strong><em>n &lt;= PIPE_BUF</em></strong></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><strong><em>n &gt; PIPE_BUF</em></strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Atomically write <em>n</em> bytes; may block until sufficient data is read for <em>write()</em> to be performed</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Write <em>n</em> bytes; may block until sufficient data is read for <em>write()</em> to complete; data may be interleaved with writes by other processes</p></td>
<td style="vertical-align: middle;" class="table_2" rowspan="2"><p class="table"><span class="literal">SIGPIPE</span> + <span class="literal">EPIPE</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">If sufficient space is available to immediately write <em>n</em> bytes, then <em>write()</em> succeeds atomically; otherwise, it fails (<span class="literal">EAGAIN</span>)</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">If there is sufficient space to immediately write some bytes, then write between 1 and <em>n</em> bytes (which may be interleaved with data written by other processes); otherwise, <em>write()</em> fails (<span class="literal">EAGAIN</span>)</p></td>
</tr>
</tbody>
</table>
<p class="noindent">The <span class="literal">O_NONBLOCK</span> flag causes a <em>write()</em> on a pipe or FIFO to fail (with the error <span class="literal">EAGAIN</span>) in any case where data can&#8217;t be transferred immediately. This means that if we are writing up to <span class="literal">PIPE_BUF</span> bytes, then the <em>write()</em> will fail if there is not sufficient space in the pipe or FIFO, because the kernel can&#8217;t complete the operation immediately and can&#8217;t perform a partial write, since that would break the requirement that writes of up to <span class="literal">PIPE_BUF</span> bytes are atomic.</p>
<p class="indent">When writing more than <span class="literal">PIPE_BUF</span> bytes at a time, a write is not required to be atomic. For this reason, <em>write()</em> transfers as many bytes as possible (a partial write) to fill up the pipe or FIFO. In this case, the return value from <em>write()</em> is the number of bytes actually transferred, and the caller must retry later in order to write the remaining bytes. However, if the pipe or FIFO is full, so that not even one byte can be transferred, then <em>write()</em> fails with the error <span class="literal">EAGAIN</span>.</p>
<h3 class="h3" id="ch44lev1sec11"><strong>44.11 Summary</strong></h3>
<p class="noindenta">Pipes were the first method of IPC under the UNIX system, and they are used frequently by the shell, as well as in other applications. A pipe is a unidirectional, limited-capacity byte stream that can be used for communication between related processes. Although blocks of data of any size can be written to a pipe, only writes that do not exceed <span class="literal">PIPE_BUF</span> bytes are guaranteed to be atomic. As well as being used as a method of IPC, pipes can also be used for process synchronization.</p>
<p class="indent"><span epub:type="pagebreak" id="page_919"/>When using pipes, we must be careful to close unused descriptors in order to ensure that reading processes detect end-of-file and writing processes receive the <span class="literal">SIGPIPE</span> signal or the <span class="literal">EPIPE</span> error. (Usually, it is easiest to have the application writing to a pipe ignore <span class="literal">SIGPIPE</span> and detect a &#8220;broken&#8221; pipe via the <span class="literal">EPIPE</span> error.)</p>
<p class="indent">The <em>popen()</em> and <em>pclose()</em> functions allow a program to transfer data to or from a standard shell command, without needing to handle the details of creating a pipe, execing a shell, and closing unused file descriptors.</p>
<p class="indent">FIFOs operate in exactly the same way as pipes, except that they are created using <em>mkfifo()</em>, have a name in the file system, and can be opened by any process with appropriate permissions. By default, opening a FIFO for reading blocks until another process opens the FIFO for writing, and vice versa.</p>
<p class="indent">In the course of this chapter, we looked at a number of related topics. First, we saw how to duplicate file descriptors in such a manner that the standard input or output of a filter can be bound to a pipe. While presenting a client-server example using FIFOs, we touched on a number of topics in client-server design, including the use of a well-known address for a server and iterative versus concurrent server design. In developing the example FIFO application, we noted that, although data transmitted through a pipe is a byte stream, it is sometimes useful for communicating processes to package the data into messages, and we looked at various ways in which this could be accomplished.</p>
<p class="indent">Finally, we noted the effect of the <span class="literal">O_NONBLOCK</span> (nonblocking I/O) flag when opening and performing I/O on a FIFO. The <span class="literal">O_NONBLOCK</span> flag is useful if we don&#8217;t want to block while opening a FIFO. It is also useful if we don&#8217;t want reads to block if no data is available, or writes to block if there is insufficient space within a pipe or FIFO.</p>
<h5 class="h5" id="ch44lev3sec16"><strong>Further information</strong></h5>
<p class="noindenta">The implementation of pipes is discussed in [<a href="bib.xhtml#bib04">Bach, 1986</a>] and [<a href="bib.xhtml#bib09">Bovet &#38; Cesati, 2005</a>]. Useful details about pipes and FIFOs can also be found in [<a href="bib.xhtml#bib104">Vahalia, 1996</a>].</p>
<h3 class="h3" id="ch44lev1sec12"><strong>44.12 Exercises</strong></h3>
<p class="exer"><a id="ch44exe1"/><strong>44-1.</strong>&#160;&#160;&#160;Write a program that uses two pipes to enable bidirectional communication between a parent and child process. The parent process should loop reading a block of text from standard input and use one of the pipes to send the text to the child, which converts it to uppercase and sends it back to the parent via the other pipe. The parent reads the data coming back from the child and echoes it on standard output before continuing around the loop once more.</p>
<p class="exer"><a id="ch44exe2"/><strong>44-2.</strong>&#160;&#160;&#160;Implement <em>popen()</em> and <em>pclose()</em>. Although these functions are simplified by not requiring the signal handling employed in the implementation of <em>system()</em> (<a href="ch27.xhtml#ch27lev1sec07">Section 27.7</a>), you will need to be careful to correctly bind the pipe ends to file streams in each process, and to ensure that all unused descriptors referring to the pipe ends are closed. Since children created by multiple calls to <em>popen()</em> may be running at one time, you will need to maintain a data structure that associates the file stream pointers allocated by <em>popen()</em> with the corresponding child process IDs. (If using an array for this purpose, the value returned by the <em>fileno()</em> function, which obtains the file descriptor corresponding to a file stream, can be used to index the <span epub:type="pagebreak" id="page_920"/>array.) Obtaining the correct process ID from this structure will allow <em>pclose()</em> to select the child upon which to wait. This structure will also assist with the SUSv3 requirement that any still-open file streams created by earlier calls to <em>popen()</em> must be closed in the new child process.</p>
<p class="exer"><a id="ch44exe3"/><strong>44-3.</strong>&#160;&#160;&#160;The server in <a href="ch44.xhtml#ch44ex7">Listing 44-7</a> (<span class="literal">fifo_seqnum_server.c</span>) always starts assigning sequence numbers from 0 each time it is started. Modify the program to use a backup file that is updated each time a sequence number is assigned. (The <em>open()</em> <span class="literal">O_SYNC</span> flag, described in <a href="ch04.xhtml#ch04lev2sec01">Section 4.3.1</a>, may be useful.) At startup, the program should check for the existence of this file, and if it is present, use the value it contains to initialize the sequence number. If the backup file can&#8217;t be found on startup, the program should create a new file and start assigning sequence numbers beginning at 0. (An alternative to this technique would be to use memory-mapped files, described in <a href="ch49.xhtml#ch49">Chapter 49</a>.)</p>
<p class="exer"><a id="ch44exe4"/><strong>44-4.</strong>&#160;&#160;&#160;Add code to the server in <a href="ch44.xhtml#ch44ex7">Listing 44-7</a> (<span class="literal">fifo_seqnum_server.c</span>) so that if the program receives the <span class="literal">SIGINT</span> or <span class="literal">SIGTERM</span> signals, it removes the server FIFO and terminates.</p>
<p class="exer"><a id="ch44exe5"/><strong>44-5.</strong>&#160;&#160;&#160;The server in <a href="ch44.xhtml#ch44ex7">Listing 44-7</a> (<span class="literal">fifo_seqnum_server.c</span>) performs a second <span class="literal">O_WRONLY</span> open of the FIFO so that it never sees end-of-file when reading from the reading descriptor (<em>serverFd</em>) of the FIFO. Instead of doing this, an alternative approach could be tried: whenever the server sees end-of-file on the reading descriptor, it closes the descriptor, and then once more opens the FIFO for reading. (This open would block until the next client opened the FIFO for writing.) What is wrong with this approach?</p>
<p class="exer"><a id="ch44exe6"/><strong>44-6.</strong>&#160;&#160;&#160;The server in <a href="ch44.xhtml#ch44ex7">Listing 44-7</a> (<span class="literal">fifo_seqnum_server.c</span>) assumes that the client process is well behaved. If a misbehaving client created a client FIFO and sent a request to the server, but did not open its FIFO, then the server&#8217;s attempt to open the client FIFO would block, and other client&#8217;s requests would be indefinitely delayed. (If done maliciously, this would constitute a <em>denial-of-service attack</em>.) Devise a scheme to deal with this problem. Extend the server (and possibly the client in <a href="ch44.xhtml#ch44ex8">Listing 44-8</a>) accordingly.</p>
<p class="exer"><a id="ch44exe7"/><strong>44-7.</strong>&#160;&#160;&#160;Write programs to verify the operation of nonblocking opens and nonblocking I/O on FIFOs (see <a href="ch44.xhtml#ch44lev1sec09">Section 44.9</a>).</p>
</body>
</html>
