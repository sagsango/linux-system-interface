<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch42"><span epub:type="pagebreak" id="page_859"/><strong><span class="big">42</span></strong><br/><strong>ADVANCED FEATURES OF SHARED LIBRARIES</strong></h2>
<p class="noindentab">The previous chapter covered the fundamentals of shared libraries. This chapter describes a number of advanced features of shared libraries, including the following:</p>
<p class="bull">&#8226; dynamically loading shared libraries;</p>
<p class="bull">&#8226; controlling the visibility of symbols defined by a shared library;</p>
<p class="bull">&#8226; using linker scripts to create versioned symbols;</p>
<p class="bull">&#8226; using initialization and finalization functions to automatically execute code when a library is loaded and unloaded;</p>
<p class="bull">&#8226; shared library preloading; and</p>
<p class="bull">&#8226; using <span class="literal">LD_DEBUG</span> to monitor the operation of the dynamic linker.</p>
<h3 class="h3" id="ch42lev1sec01"><strong>42.1 Dynamically Loaded Libraries</strong></h3>
<p class="noindenta">When an executable starts, the dynamic linker loads all of the shared libraries in the program&#8217;s dynamic dependency list. Sometimes, however, it can be useful to load libraries at a later time. For example, a plug-in is loaded only when it is needed. This functionality is provided by an API to the dynamic linker. This API, usually referred to as the <em>dlopen</em> API, originated on Solaris, and much of it is now specified in SUSv3.</p>
<p class="indent"><span epub:type="pagebreak" id="page_860"/>The <em>dlopen</em> API enables a program to open a shared library at run time, search for a function by name in that library, and then call the function. A shared library loaded at run time in this way is commonly referred to as a <em>dynamically loaded library</em>, and is created in the same way as any other shared library.</p>
<p class="indentb">The core <em>dlopen</em> API consists of the following functions (all of which are specified in SUSv3):</p>
<p class="bull">&#8226; The <em>dlopen()</em> function opens a shared library, returning a handle used by subsequent calls.</p>
<p class="bull">&#8226; The <em>dlsym()</em> function searches a library for a symbol (a string containing the name of a function or variable) and returns its address.</p>
<p class="bull">&#8226; The <em>dlclose()</em> function closes a library previously opened by <em>dlopen()</em>.</p>
<p class="bull">&#8226; The <em>dlerror()</em> function returns an error-message string, and is used after a failure return from one of the preceding functions.</p>
<p class="noindentt">The <em>glibc</em> implementation also includes a number of related functions, some of which we describe below.</p>
<p class="indent">To build programs that use the <em>dlopen</em> API on Linux, we must specify the <em>&#8211;ldl</em> option, in order to link against the <em>libdl</em> library.</p>
<h4 class="h4" id="ch42lev2sec01"><strong>42.1.1 Opening a Shared Library: <em>dlopen()</em></strong></h4>
<p class="noindenta">The <em>dlopen()</em> function loads the shared library named in <em>libfilename</em> into the calling process&#8217;s virtual address space and increments the count of open references to the library.</p>
<div class="box">
<p class="programsa">#include &lt;dlfcn.h&gt;<br/><br/>void *<span class="codestrong">dlopen</span>(const char *<span class="font1">libfilename</span>, int <span class="font1">flags</span>);</p>
<p class="right">Returns library handle on success, or <span class="literal">NULL</span> on error</p>
</div>
<p class="noindent">If <em>libfilename</em> contains a slash (<span class="literal">/</span>), <em>dlopen()</em> interprets it as an absolute or relative pathname. Otherwise, the dynamic linker searches for the shared library using the rules described in <a href="ch41.xhtml#ch41lev1sec11">Section 41.11</a>.</p>
<p class="indent">On success, <em>dlopen()</em> returns a handle that can be used to refer to the library in subsequent calls to functions in the <em>dlopen</em> API. If an error occurred (e.g., the library couldn&#8217;t be found), <em>dlopen()</em> returns <span class="literal">NULL</span>.</p>
<p class="indent">If the shared library specified by <em>libfilename</em> contains dependencies on other shared libraries, <em>dlopen()</em> also automatically loads those libraries. This procedure occurs recursively if necessary. We refer to the set of such loaded libraries as this library&#8217;s <em>dependency tree</em>.</p>
<p class="indent">It is possible to call <em>dlopen()</em> multiple times on the same library file. The library is loaded into memory only once (by the initial call), and all calls return the same <em>handle</em> value. However, the <em>dlopen</em> API maintains a reference count for each library handle. This count is incremented by each call to <em>dlopen()</em> and decremented by each call to <em>dlclose()</em>; only when the count reaches 0 does <em>dlclose()</em> unload the library from memory.</p>
<p class="indentb"><span epub:type="pagebreak" id="page_861"/>The <em>flags</em> argument is a bit mask that must include exactly one of the constants <span class="literal">RTLD_LAZY</span> or <span class="literal">RTLD_NOW</span>, with the following meanings:</p>
<p class="term"><span class="literal">RTLD_LAZY</span></p>
<p class="termlist">Undefined function symbols in the library should be resolved only as the code is executed. If a piece of code requiring a particular symbol is not executed, that symbol is never resolved. Lazy resolution is performed only for function references; references to variables are always resolved immediately. Specifying the <span class="literal">RTLD_LAZY</span> flag provides behavior that corresponds to the normal operation of the dynamic linker when loading the shared libraries identified in an executable&#8217;s dynamic dependency list.</p>
<p class="term"><span class="literal">RTLD_NOW</span></p>
<p class="termlist">All undefined symbols in the library should be immediately resolved before <em>dlopen()</em> completes, regardless of whether they will ever be required. As a consequence, opening the library is slower, but any potential undefined function symbol errors are detected immediately instead of at some later time. This can be useful when debugging an application, or simply to ensure that an application fails immediately on an unresolved symbol, rather than doing so only after executing for a long time.</p>
<div class="block">
<p class="noindent">By setting the environment variable <span class="literal">LD_BIND_NOW</span> to a nonempty string, we can force the dynamic linker to immediately resolve all symbols (i.e., like <span class="literal">RTLD_NOW</span>) when loading the shared libraries identified in an executable&#8217;s dynamic dependency list. This environment variable is effective in <em>glibc</em> 2.1.1 and later. Setting <span class="literal">LD_BIND_NOW</span> overrides the effect of the <em>dlopen()</em> <span class="literal">RTLD_LAZY</span> flag.</p>
</div>
<p class="noindentb">It is also possible to include further values in <em>flags</em>. The following flags are specified in SUSv3:</p>
<p class="term"><span class="literal">RTLD_GLOBAL</span></p>
<p class="termlist">Symbols in this library and its dependency tree are made available for resolving references in other libraries loaded by this process and also for lookups via <em>dlsym()</em>.</p>
<p class="term"><span class="literal">RTLD_LOCAL</span></p>
<p class="termlist">This is the converse of <span class="literal">RTLD_GLOBAL</span> and the default if neither constant is specified. It specifies that symbols in this library and its dependency tree are not available to resolve references in subsequently loaded libraries.</p>
<p class="noindentt">SUSv3 doesn&#8217;t specify a default if neither <span class="literal">RTLD_GLOBAL</span> nor <span class="literal">RTLD_LOCAL</span> is specified. Most UNIX implementations assume the same default (<span class="literal">RTLD_LOCAL</span>) as Linux, but a few assume a default of <span class="literal">RTLD_GLOBAL</span>.</p>
<p class="indentb">Linux also supports a number of flags that are not specified in SUSv3:</p>
<p class="term"><span class="literal">RTLD_NODELETE</span> (since <em>glibc</em> 2.2)</p>
<p class="termlist">Don&#8217;t unload the library during a <em>dlclose()</em>, even if the reference count falls to 0. This means that the library&#8217;s static variables are not reinitialized if the library is later reloaded by <em>dlopen()</em>. (We can achieve a similar effect for libraries loaded automatically by the dynamic linker by specifying the <em>gcc &#8211;Wl,&#8211;znodelete</em> option when creating the library.)</p>
<p class="term"><span epub:type="pagebreak" id="page_862"/><span class="literal">RTLD_NOLOAD</span> (since <em>glibc</em> 2.2)</p>
<p class="termlist">Don&#8217;t load the library. This serves two purposes. First, we can use this flag to check if a particular library is currently loaded as part of the process&#8217;s address space. If it is, <em>dlopen()</em> returns the library&#8217;s handle; if it is not, <em>dlopen()</em> returns <span class="literal">NULL</span>. Second, we can use this flag to &#8220;promote&#8221; the <em>flags</em> of an already loaded library. For example, we can specify <span class="literal">RTLD_NOLOAD | RTLD_GLOBAL</span> in <em>flags</em> when using <em>dlopen()</em> on a library previously opened with <span class="literal">RTLD_LOCAL</span>.</p>
<p class="term"><span class="literal">RTLD_DEEPBIND</span> (since <em>glibc</em> 2.3.4)</p>
<p class="termlist">When resolving symbol references made by this library, search for definitions in the library before searching for definitions in libraries that have already been loaded. This allows a library to be self-contained, using its own symbol definitions in preference to global symbols with the same name defined in other shared libraries that have already been loaded. (This is similar to the effect of the <em>&#8211;Bsymbolic</em> linker option described in <a href="ch41.xhtml#ch41lev1sec12">Section 41.12</a>.)</p>
<p class="noindentt">The <span class="literal">RTLD_NODELETE</span> and <span class="literal">RTLD_NOLOAD</span> flags are also implemented in the Solaris <em>dlopen</em> API, but are available on few other UNIX implementations. The <span class="literal">RTLD_DEEPBIND</span> flag is Linux-specific.</p>
<p class="indent">As a special case, we can specify <em>libfilename</em> as <span class="literal">NULL</span>. This causes <em>dlopen()</em> to return a handle for the main program. (SUSv3 refers to this as a handle for the &#8220;global symbol object.&#8221;) Specifying this handle in a subsequent call to <em>dlsym()</em> causes the requested symbol to be sought in the main program, followed by all shared libraries loaded at program startup, and then all libraries dynamically loaded with the <span class="literal">RTLD_GLOBAL</span> flag.</p>
<h4 class="h4" id="ch42lev2sec02"><strong>42.1.2 Diagnosing Errors: <em>dlerror()</em></strong></h4>
<p class="noindenta">If we receive an error return from <em>dlopen()</em> or one of the other functions in the <em>dlopen</em> API, we can use <em>dlerror()</em> to obtain a pointer to a string that indicates the cause of the error.</p>
<div class="box">
<p class="programsa">#include &lt;dlfcn.h&gt;<br/><br/>const char *<span class="codestrong">dlerror</span>(void);</p>
<p class="right">Returns pointer to error-diagnostic string, or <span class="literal">NULL</span> if no error has occurred since previous call to <em>dlerror()</em></p>
</div>
<p class="noindent">The <em>dlerror()</em> function returns <span class="literal">NULL</span> if no error has occurred since the last call to <em>dlerror()</em>. We&#8217;ll see how this is useful in the next section.</p>
<h4 class="h4" id="ch42lev2sec03"><strong>42.1.3 Obtaining the Address of a Symbol: <em>dlsym()</em></strong></h4>
<p class="noindenta">The <em>dlsym()</em> function searches for the named <em>symbol</em> (a function or variable) in the library referred to by <em>handle</em> and in the libraries in that library&#8217;s dependency tree.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_863"/>#include &lt;dlfcn.h&gt;<br/><br/>void *<span class="codestrong">dlsym</span>(void *<span class="font1">handle</span>, char *<span class="font1">symbol</span>);</p>
<p class="right">Returns address of <em>symbol</em>, or <span class="literal">NULL</span> if <em>symbol</em> is not found</p>
</div>
<p class="noindent">If <em>symbol</em> is found, <em>dlsym()</em> returns its address; otherwise, <em>dlsym()</em> returns <span class="literal">NULL</span>. The <em>handle</em> argument is normally a library handle returned by a previous call to <em>dlopen()</em>. Alternatively, it may be one of the so-called pseudohandles described below.</p>
<div class="block">
<p class="noindent">A related function, <em>dlvsym(handle, symbol, version)</em>, is similar to <em>dlsym()</em>, but can be used to search a symbol-versioned library for a symbol definition whose version matches the string specified in <em>version</em>. (We describe symbol versioning in <a href="ch42.xhtml#ch42lev2sec08">Section 42.3.2</a>.) The <span class="literal">_GNU_SOURCE</span> feature test macro must be defined in order to obtain the declaration of this function from <span class="literal">&lt;dlfcn.h&gt;</span>.</p>
</div>
<p class="noindent">The value of a symbol returned by <em>dlsym()</em> may be <span class="literal">NULL</span>, which is indistinguishable from the &#8220;symbol not found&#8221; return. In order to differentiate the two possibilities, we must call <em>dlerror()</em> beforehand (to make sure that any previously held error string is cleared) and then if, after the call to <em>dlsym()</em>, <em>dlerror()</em> returns a non-<span class="literal">NULL</span> value, we know that an error occurred.</p>
<p class="indent">If <em>symbol</em> is the name of a variable, then we can assign the return value of <em>dlsym()</em> to an appropriate pointer type, and obtain the value of the variable by dereferencing the pointer:</p>
<p class="programs">int *ip;<br/><br/>ip = (int *) dlsym(handle, symbol);<br/>if (ip != NULL)<br/>&#160;&#160;&#160;&#160;printf("Value is %d\n", *ip);</p>
<p class="noindent">If <em>symbol</em> is the name of a function, then the pointer returned by <em>dlsym()</em> can be used to call the function. We can store the value returned by <em>dlsym()</em> in a pointer of the appropriate type, such as the following:</p>
<p class="programs">int (*funcp)(int);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Pointer to a function taking an integer<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;argument and returning an integer */</p>
<p class="noindent">However, we can&#8217;t simply assign the result of <em>dlsym()</em> to such a pointer, as in the following example:</p>
<p class="programs">funcp = dlsym(handle, symbol);</p>
<p class="noindent">The reason is that the ISO C standard leaves the results of casting between function pointers and <em>void *</em> undefined. The solution is to use the following (somewhat clumsy) cast:</p>
<p class="programs">*(void **) (&#38;funcp) = dlsym(handle, symbol);</p>
<p class="noindent">Having used <em>dlsym()</em> to obtain a pointer to the function, we can then call the function using the usual C syntax for dereferencing function pointers:</p>
<p class="programs">res = (*funcp)(somearg);</p>
<p class="noindent"><span epub:type="pagebreak" id="page_864"/>Instead of the <em>*(void **)</em> syntax shown above, one might consider using the following seemingly equivalent code when assigning the return value of <em>dlsym()</em>:</p>
<p class="programs">(void *) funcp = dlsym(handle, symbol);</p>
<p class="noindent">However, for this code, <em>gcc &#8211;pedantic</em> warns that &#8220;ANSI C forbids the use of cast expressions as lvalues.&#8221; The <em>*(void **)</em> syntax doesn&#8217;t incur this warning because we are assigning to an address <em>pointed to</em> by the assignment&#8217;s lvalue.</p>
<p class="indent">On many UNIX implementations, we can use casts such as the following to eliminate warnings from the C compiler:</p>
<p class="programs">funcp = (int (*) (int)) dlsym(handle, symbol);</p>
<p class="noindent">However, the specification of <em>dlsym()</em> in SUSv3 <em>Technical Corrigendum Number 1</em> notes that the ISO C standard nevertheless requires compilers to generate a warning for such a conversion, and proposes the <em>*(void **)</em> syntax shown above.</p>
<div class="block">
<p class="noindent">SUSv3 TC1 noted that because of the need for the <em>*(void **)</em> syntax, a future version of the standard may define separate <em>dlsym()</em>-like APIs for handling data and function pointers. However, SUSv4 contains no changes with respect to this point.</p>
</div>
<h5 class="h5" id="ch42lev3sec01"><strong>Using library pseudohandles with <em>dlsym()</em></strong></h5>
<p class="noindentab">Instead of specifying a library handle returned by a call to <em>dlopen()</em>, either of the following <em>pseudohandles</em> may be specified as the <em>handle</em> argument for <em>dlsym()</em>:</p>
<p class="term"><span class="literal">RTLD_DEFAULT</span></p>
<p class="termlist">Search for <em>symbol</em> starting with the main program, and then proceeding in order through the list of all shared libraries loaded, including those libraries dynamically loaded by <em>dlopen()</em> with the <span class="literal">RTLD_GLOBAL</span> flag. This corresponds to the default search model employed by the dynamic linker.</p>
<p class="term"><span class="literal">RTLD_NEXT</span></p>
<p class="termlist">Search for <em>symbol</em> in shared libraries loaded after the one invoking <em>dlsym()</em>. This is useful when creating a wrapper function with the same name as a function defined elsewhere. For example, in our main program, we may define our own version of <em>malloc()</em> (which perhaps does some bookkeeping of memory allocation), and this function can invoke the real <em>malloc()</em> by first obtaining its address via the call <em>func = dlsym(RTLD_NEXT, &#8220;malloc&#8221;)</em>.</p>
<p class="noindentt">The pseudohandle values listed above are not required by SUSv3 (which nevertheless reserves them for future use), and are not available on all UNIX implementations. In order to get the definitions of these constants from <span class="literal">&lt;dlfcn.h&gt;</span>, we must define the <span class="literal">_GNU_SOURCE</span> feature test macro.</p>
<h5 class="h5" id="ch42lev3sec02"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch42.xhtml#ch42ex1">Listing 42-1</a> demonstrates the use of the <em>dlopen</em> API. This program takes two command-line arguments: the name of a shared library to load and the name of a function to execute within that library. The following examples demonstrate the use of this program:</p>
<p class="programs">$ <span class="codestrong">./dynload ./libdemo.so.1 x1</span><br/>Called mod1-x1<br/>$ <span class="codestrong">LD_LIBRARY_PATH=. ./dynload libdemo.so.1 x1</span><br/>Called mod1-x1</p>
<p class="noindent"><span epub:type="pagebreak" id="page_865"/>In the first of the above commands, <em>dlopen()</em> notes that the library path includes a slash and thus interprets it as a relative pathname (in this case, to a library in the current working directory). In the second command, we specify a library search path in <span class="literal">LD_LIBRARY_PATH</span>. This search path is interpreted according to the usual rules of the dynamic linker (in this case, likewise to find the library in the current working directory).</p>
<p class="examplet"><a id="ch42ex1"/><strong>Listing 42-1:</strong> Using the <em>dlopen</em> API</p>
<p class="programsli">_________________________________________________________ <span class="codestrong">shlibs/dynload.c</span><br/><br/>#include &lt;dlfcn.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;void *libHandle;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Handle for shared library */<br/>&#160;&#160;&#160;&#160;void (*funcp)(void);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Pointer to function with no arguments */<br/>&#160;&#160;&#160;&#160;const char *err;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 3 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s lib-path func-name\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;/* Load the shared library and get a handle for later use */<br/><br/>&#160;&#160;&#160;&#160;libHandle = dlopen(argv[1], RTLD_LAZY);<br/>&#160;&#160;&#160;&#160;if (libHandle == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("dlopen: %s", dlerror());<br/><br/>&#160;&#160;&#160;&#160;/* Search library for symbol named in argv[2] */<br/><br/>&#160;&#160;&#160;&#160;(void) dlerror();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Clear dlerror() */<br/>&#160;&#160;&#160;&#160;*(void **) (&#38;funcp) = dlsym(libHandle, argv[2]);<br/>&#160;&#160;&#160;&#160;err = dlerror();<br/>&#160;&#160;&#160;&#160;if (err != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("dlsym: %s", err);<br/><br/>&#160;&#160;&#160;&#160;/* Try calling the address returned by dlsym() as a function<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;that takes no arguments. */<br/><br/>&#160;&#160;&#160;&#160;(*funcp)();<br/><br/>&#160;&#160;&#160;&#160;dlclose(libHandle);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Close the library */<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________________ <span class="codestrong">shlibs/dynload.c</span></p>
<h4 class="h4" id="ch42lev2sec04"><span epub:type="pagebreak" id="page_866"/><strong>42.1.4 Closing a Shared Library: <em>dlclose()</em></strong></h4>
<p class="noindenta">The <em>dlclose()</em> function closes a library.</p>
<div class="box">
<p class="programsa">#include &lt;dlfcn.h&gt;<br/><br/>int <span class="codestrong">dlclose</span>(void *<span class="font1">handle</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>dlclose()</em> function decrements the system&#8217;s counter of open references to the library referred to by <em>handle</em>. If this reference count falls to 0, and no symbols in the library are required by other libraries, then the library is unloaded. This procedure is also (recursively) performed for the libraries in this library&#8217;s dependency tree. An implicit <em>dlclose()</em> of all libraries is performed on process termination.</p>
<div class="block">
<p class="noindent">From <em>glibc</em> 2.2.3 onward, a function within a shared library can use <em>atexit()</em> (or <em>on_exit()</em>) to establish a function that is called automatically when the library is unloaded.</p>
</div>
<h4 class="h4" id="ch42lev2sec05"><strong>42.1.5 Obtaining Information About Loaded Symbols: <em>dladdr()</em></strong></h4>
<p class="noindenta">Given an address in <em>addr</em> (typically, one obtained by an earlier call to <em>dlsym()</em>), <em>dladdr()</em> returns a structure containing information about that address.</p>
<div class="box">
<p class="programsa">#define _GNU_SOURCE<br/>#include &lt;dlfcn.h&gt;<br/><br/>int <span class="codestrong">dladdr</span>(const void *<span class="font1">addr</span>, Dl_info *<span class="font1">info</span>);</p>
<p class="right">Returns nonzero value if <em>addr</em> was found in a shared library, otherwise 0</p>
</div>
<p class="noindent">The <em>info</em> argument is a pointer to a caller-allocated structure that has the following form:</p>
<p class="programs">typedef struct {<br/>&#160;&#160;&#160;&#160;const char *dli_fname;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Pathname of shared library<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;containing 'addr' */<br/>&#160;&#160;&#160;&#160;void&#160;&#160;&#160;&#160;&#160;&#160;&#160;*dli_fbase;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Base address at which shared<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;library is loaded */<br/>&#160;&#160;&#160;&#160;const char *dli_sname;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Name of symbol whose definition<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;overlaps 'addr' */<br/>&#160;&#160;&#160;&#160;void&#160;&#160;&#160;&#160;&#160;&#160;&#160;*dli_saddr;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Actual value of the symbol<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;returned in 'dli_sname' */<br/>} Dl_info;</p>
<p class="noindent">The first two fields of the <em>Dl_info</em> structure specify the pathname and run-time base address of the shared library containing the address specified in <em>addr</em>. The last two fields return information about that address. Assuming that <em>addr</em> points to the exact address of a symbol in the shared library, then <em>dli_saddr</em> returns the same value as was passed in <em>addr</em>.</p>
<p class="indent">SUSv3 doesn&#8217;t specify <em>dladdr()</em>, and this function is not available on all UNIX implementations.</p>
<h4 class="h4" id="ch42lev2sec06"><span epub:type="pagebreak" id="page_867"/><strong>42.1.6 Accessing Symbols in the Main Program</strong></h4>
<p class="noindenta">Suppose that we use <em>dlopen()</em> to dynamically load a shared library, use <em>dlsym()</em> to obtain the address of a function <em>x()</em> from that library, and then call <em>x()</em>. If <em>x()</em> in turn calls a function <em>y()</em>, then <em>y()</em> would normally be sought in one of the shared libraries loaded by the program.</p>
<p class="indent">Sometimes, it is desirable instead to have <em>x()</em> invoke an implementation of <em>y()</em> in the main program. (This is similar to a callback mechanism.) In order to do this, we must make the (global-scope) symbols in the main program available to the dynamic linker, by linking the program using the <em>&#8211;&#8211;export&#8211;dynamic</em> linker option:</p>
<p class="programs">$ <span class="codestrong">gcc -Wl,--export-dynamic main.c</span>&#160;&#160;&#160;&#160;<span class="font1">(plus further options and arguments)</span></p>
<p class="noindent">Equivalently, we can write the following:</p>
<p class="programs">$ <span class="codestrong">gcc -export-dynamic main.c</span></p>
<p class="noindent">Using either of these options allows a dynamically loaded library to access global symbols in the main program.</p>
<div class="block">
<p class="noindent">The <em>gcc &#8211;rdynamic</em> option and the <em>gcc &#8211;Wl,&#8211;E</em> option are further synonyms for <em>&#8211;Wl,&#8211;&#8211;export&#8211;dynamic</em>.</p>
</div>
<h3 class="h3" id="ch42lev1sec02"><strong>42.2 Controlling Symbol Visibility</strong></h3>
<p class="noindentab">A well-designed shared library should make visible only those symbols (functions and variables) that form part of its specified application binary interface (ABI). The reasons for this are as follows:</p>
<p class="bull">&#8226; If the shared library designer accidentally exports unspecified interfaces, then authors of applications that use the library may choose to employ these interfaces. This creates a compatibility problem for future upgrades of the shared library. The library developer expects to be able to change or remove any interfaces other than those in the documented ABI, while the library user expects to continue using the same interfaces (with the same semantics) that they currently employ.</p>
<p class="bull">&#8226; During run-time symbol resolution, any symbols that are exported by a shared library might interpose definitions that are provided in other shared libraries (<a href="ch41.xhtml#ch41lev1sec12">Section 41.12</a>).</p>
<p class="bull">&#8226; Exporting unnecessary symbols increases the size of the dynamic symbol table that must be loaded at run time.</p>
<p class="noindenttb">All of these problems can be minimized or avoided altogether if the library designer ensures that only the symbols required by the library&#8217;s specified ABI are exported. The following techniques can be used to control the export of symbols:</p>
<p class="bull">&#8226; In a C program, we can use the <span class="literal">static</span> keyword to make a symbol private to a source-code module, thus rendering it unavailable for binding by other object files.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_868"/>As well as making a symbol private to a source-code module, the <span class="literal">static</span> keyword also has a converse effect. If a symbol is marked as <span class="literal">static</span>, then all references to the symbol in the same source file will be bound to that definition of the symbol. Consequently, these references won&#8217;t be subject to run-time interposition by definitions from other shared libraries (in the manner described in <a href="ch41.xhtml#ch41lev1sec12">Section 41.12</a>). This effect of the <span class="literal">static</span> keyword is similar to the <em>&#8211;Bsymbolic</em> linker option described in <a href="ch41.xhtml#ch41lev1sec12">Section 41.12</a>, with the difference that the <span class="literal">static</span> keyword affects a single symbol within a single source file.</p>
</div>
<p class="bull">&#8226; The GNU C complier, <em>gcc</em>, provides a compiler-specific attribute declaration that performs a similar task to the <span class="literal">static</span> keyword:</p>
<p class="programsbl">void<br/>__attribute__ ((visibility("hidden")))<br/>func(void) {<br/>&#160;&#160;&#160;&#160;/* Code */<br/>}</p>
<p class="bullp">Whereas the <span class="literal">static</span> keyword limits the visibility of a symbol to a single source code file, the <span class="literal">hidden</span> attribute makes the symbol available across all source code files that compose the shared library, but prevents it from being visible outside the library.</p>
<div class="block">
<p class="noindent">As with the <span class="literal">static</span> keyword, the <span class="literal">hidden</span> attribute also has the converse effect of preventing symbol interposition at run time.</p>
</div>
<p class="bull">&#8226; Version scripts (<a href="ch42.xhtml#ch42lev1sec03">Section 42.3</a>) can be used to precisely control symbol visibility and to select the version of a symbol to which a reference is bound.</p>
<p class="bull">&#8226; When dynamically loading a shared library (<a href="ch42.xhtml#ch42lev2sec01">Section 42.1.1</a>), the <em>dlopen()</em> <span class="literal">RTLD_GLOBAL</span> flag can be used to specify that the symbols defined by the library should be made available for binding by subsequently loaded libraries, and the <em>&#8211;&#8211;export&#8211;dynamic</em> linker option (<a href="ch42.xhtml#ch42lev2sec06">Section 42.1.6</a>) can be used to make the global symbols of the main program available to dynamically loaded libraries.</p>
<p class="noindentt">For further details on the topic of symbol visibility, see [<a href="bib.xhtml#bib21">Drepper, 2004 (b)</a>].</p>
<h3 class="h3" id="ch42lev1sec03"><strong>42.3 Linker Version Scripts</strong></h3>
<p class="noindenta">A <em>version script</em> is a text file containing instructions for the linker, <em>ld</em>. In order to use a version script, we must specify the <em>&#8211;&#8211;version&#8211;script</em> linker option:</p>
<p class="programs">$ <span class="codestrong">gcc -Wl,--version-script,<span class="codeitalic">myscriptfile.map</span> ...</span></p>
<p class="noindent">Version scripts are commonly (but not universally) identified using the extension <span class="literal">.map</span>.</p>
<p class="indent">The following sections describe some uses of version scripts.</p>
<h4 class="h4" id="ch42lev2sec07"><strong>42.3.1 Controlling Symbol Visibility with Version Scripts</strong></h4>
<p class="noindenta">One use of version scripts is to control the visibility of symbols that might otherwise accidentally be made global (i.e., visible to applications linking against the library). As a simple example, suppose that we are building a shared library from <span epub:type="pagebreak" id="page_869"/>the three source files <span class="literal">vis_comm.c</span>, <span class="literal">vis_f1.c</span>, and <span class="literal">vis_f2.c</span>, which respectively define the functions <em>vis_comm()</em>, <em>vis_f1()</em>, and <em>vis_f2()</em>. The <em>vis_comm()</em> function is called by <em>vis_f1()</em> and <em>vis_f2()</em>, but is not intended for direct use by applications linked against the library. Suppose we build the shared library in the usual way:</p>
<p class="programs">$ <span class="codestrong">gcc -g -c -fPIC -Wall vis_comm.c vis_f1.c vis_f2.c</span><br/>$ <span class="codestrong">gcc -g -shared -o vis.so vis_comm.o vis_f1.o vis_f2.o</span></p>
<p class="noindent">If we use the following <em>readelf</em> command to list the dynamic symbols exported by the library, we see the following:</p>
<p class="programs">$ <span class="codestrong">readelf --syms --use-dynamic vis.so | grep vis_</span><br/>&#160;&#160;&#160;30&#160;&#160;12: 00000790&#160;&#160;&#160;&#160;59&#160;&#160;&#160;&#160;FUNC GLOBAL DEFAULT&#160;&#160;10 vis_f1<br/>&#160;&#160;&#160;25&#160;&#160;13: 000007d0&#160;&#160;&#160;&#160;73&#160;&#160;&#160;&#160;FUNC GLOBAL DEFAULT&#160;&#160;10 vis_f2<br/>&#160;&#160;&#160;27&#160;&#160;16: 00000770&#160;&#160;&#160;&#160;20&#160;&#160;&#160;&#160;FUNC GLOBAL DEFAULT&#160;&#160;10 vis_comm</p>
<p class="noindent">This shared library exported three symbols: <em>vis_comm()</em>, <em>vis_f1()</em>, and <em>vis_f2()</em>. However, we would like to ensure that only the symbols <em>vis_f1()</em> and <em>vis_f2()</em> are exported by the library. We can achieve this result using the following version script:</p>
<p class="programs">$ <span class="codestrong">cat vis.map</span><br/>VER_1 {<br/>&#160;&#160;&#160;&#160;global:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;vis_f1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;vis_f2;<br/>&#160;&#160;&#160;&#160;local:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*;<br/>};</p>
<p class="noindent">The identifier <em>VER_1</em> is an example of a <em>version tag</em>. As we&#8217;ll see in the discussion of symbol versioning in <a href="ch42.xhtml#ch42lev2sec08">Section 42.3.2</a>, a version script may contain multiple <em>version nodes</em>, each grouped within braces (<span class="literal">{}</span>) and prefixed with a unique version tag. If we are using a version script only for the purpose of controlling symbol visibility, then the version tag is redundant; nevertheless, older versions of <em>ld</em> required it. Modern versions of <em>ld</em> allow the version tag to be omitted; in this case, the version node is said to have an anonymous version tag, and no other version nodes may be present in the script.</p>
<p class="indent">Within the version node, the <span class="literal">global</span> keyword begins a semicolon-separated list of symbols that are made visible outside the library. The <span class="literal">local</span> keyword begins a list of symbols that are to be hidden from the outside world. The asterisk (<span class="literal">*</span>) here illustrates the fact that we can use wildcard patterns in these symbol specifications. The wildcard characters are the same as those used for shell filename matching&#8212;for example, <span class="literal">*</span> and <span class="literal">?</span>. (See the <em>glob(7)</em> manual page for further details.) In this example, using an asterisk for the <span class="literal">local</span> specification says that everything that wasn&#8217;t explicitly declared <span class="literal">global</span> is hidden. If we did not say this, then <em>vis_comm()</em> would still be visible, since the default is to make C global symbols visible outside the shared library.</p>
<p class="indent">We can then build our shared library using the version script as follows:</p>
<p class="programs">$ <span class="codestrong">gcc -g -c -fPIC -Wall vis_comm.c vis_f1.c vis_f2.c</span><br/>$ <span class="codestrong">gcc -g -shared -o vis.so vis_comm.o vis_f1.o vis_f2.o \<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-Wl,--version-script,vis.map</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_870"/>Using <em>readelf</em> once more shows that <em>vis_comm()</em> is no longer externally visible:</p>
<p class="programs">$ <span class="codestrong">readelf --syms --use-dynamic vis.so | grep vis_</span><br/>&#160;&#160;&#160;25&#160;&#160;&#160;0: 00000730&#160;&#160;&#160;&#160;73&#160;&#160;&#160;&#160;FUNC GLOBAL DEFAULT&#160;&#160;11 vis_f2<br/>&#160;&#160;&#160;29&#160;&#160;16: 000006f0&#160;&#160;&#160;&#160;59&#160;&#160;&#160;&#160;FUNC GLOBAL DEFAULT&#160;&#160;11 vis_f1</p>
<h4 class="h4" id="ch42lev2sec08"><strong>42.3.2 Symbol Versioning</strong></h4>
<p class="noindenta">Symbol versioning allows a single shared library to provide multiple versions of the same function. Each program uses the version of the function that was current when the program was (statically) linked against the shared library. As a result, we can make an incompatible change to a shared library without needing to increase the library&#8217;s major version number. Carried to an extreme, symbol versioning can replace the traditional shared library major and minor versioning scheme. Symbol versioning is used in this manner in <em>glibc</em> 2.1 and later, so that all versions of <em>glibc</em> from 2.0 onward are supported within a single major library version (<span class="literal">libc.so.6</span>).</p>
<p class="indent">We demonstrate the use of symbol versioning with a simple example. We begin by creating the first version of a shared library using a version script:</p>
<p class="programs">$ <span class="codestrong">cat sv_lib_v1.c</span><br/>#include &lt;stdio.h&gt;<br/><br/>void xyz(void) { printf("v1 xyz\n"); }<br/>$ <span class="codestrong">cat sv_v1.map</span><br/>VER_1 {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;global: xyz;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;local:&#160;&#160;*;&#160;&#160;&#160;&#160;&#160;&#160;# Hide all other symbols<br/>};<br/>$ <span class="codestrong">gcc -g -c -fPIC -Wall sv_lib_v1.c</span><br/>$ <span class="codestrong">gcc -g -shared -o libsv.so sv_lib_v1.o -Wl,--version-script,sv_v1.map</span></p>
<div class="block">
<p class="noindent">Within a version script, the hash character (<span class="literal">#</span>) starts a comment.</p>
</div>
<p class="noindent">(To keep the example simple, we avoid the use of explicit library sonames and library major version numbers.)</p>
<p class="indent">At this stage, our version script, <span class="literal">sv_v1.map</span>, serves only to control the visibility of the shared library&#8217;s symbols; <em>xyz()</em> is exported, but all other symbols (of which there are none in this small example) are hidden. Next, we create a program, <em>p1</em>, which makes use of this library:</p>
<p class="programs">$ <span class="codestrong">cat sv_prog.c</span><br/>#include &lt;stdlib.h&gt;<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;void xyz(void);<br/><br/>&#160;&#160;&#160;&#160;xyz();<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>$ <span class="codestrong">gcc -g -o p1 sv_prog.c libsv.so</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_871"/>When we run this program, we see the expected result:</p>
<p class="programs">$ <span class="codestrong">LD_LIBRARY_PATH=. ./p1</span><br/>v1 xyz</p>
<p class="noindent">Now, suppose that we want to modify the definition of <em>xyz()</em> within our library, while still ensuring that program <em>p1</em> continues to use the old version of this function. To do this, we must define two versions of <em>xyz()</em> within our library:</p>
<p class="programs">$ <span class="codestrong">cat sv_lib_v2.c</span><br/>#include &lt;stdio.h&gt;<br/><br/>__asm__(".symver xyz_old,xyz@VER_1");<br/>__asm__(".symver xyz_new,xyz@@VER_2");<br/><br/>void xyz_old(void) { printf("v1 xyz\n"); }<br/><br/>void xyz_new(void) { printf("v2 xyz\n"); }<br/><br/>void pqr(void) { printf("v2 pqr\n"); }</p>
<p class="noindent">Our two versions of <em>xyz()</em> are provided by the functions <em>xyz_old()</em> and <em>xyz_new()</em>. The <em>xyz_old()</em> function corresponds to our original definition of <em>xyz()</em>, which is the one that should continue to be used by program <em>p1</em>. The <em>xyz_new()</em> function provides the definition of <em>xyz()</em> to be used by programs linking against the new version of the library.</p>
<p class="indent">The two <span class="literal">.symver</span> assembler directives are the glue that ties these two functions to different version tags in the modified version script (shown in a moment) that we use to create the new version of the shared library. The first of these directives says that <em>xyz_old()</em> is the implementation of <em>xyz()</em> to be used for applications linked against version tag <em>VER_1</em> (i.e., program <em>p1</em> in our example), and that <em>xyz_new()</em> is the implementation of <em>xyz()</em> to be used by applications linked against version tag <em>VER_2</em>.</p>
<p class="indent">The use of <span class="literal">@@</span> rather than <span class="literal">@</span> in the second <span class="literal">.symver</span> directive indicates that this is the default definition of <em>xyz()</em> to which applications should bind when statically linked against this shared library. Exactly one of the <span class="literal">.symver</span> directives for a symbol should be marked using <span class="literal">@@</span>.</p>
<p class="indent">The corresponding version script for our modified library is as follows:</p>
<p class="programs">$ <span class="codestrong">cat sv_v2.map</span><br/>VER_1 {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;global: xyz;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;local:&#160;&#160;*;&#160;&#160;&#160;&#160;&#160;&#160;# Hide all other symbols<br/>};<br/><br/>VER_2 {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;global: pqr;<br/>} VER_1;</p>
<p class="noindent">This version script provides a new version tag, <em>VER_2</em>, which depends on the tag <em>VER_1</em>. This dependency is indicated by the following line:</p>
<p class="programs">} VER_1;</p>
<p class="noindent"><span epub:type="pagebreak" id="page_872"/>Version tag dependencies indicate the relationships between successive library versions. Semantically, the only effect of version tag dependencies on Linux is that a version node inherits <span class="literal">global</span> and <span class="literal">local</span> specifications from the version node upon which it depends.</p>
<p class="indent">Dependencies can be chained, so that we could have another version node tagged <em>VER_3</em>, which depended on <em>VER_2</em>, and so on.</p>
<p class="indent">The version tag names have no meanings in themselves. Their relationship with one another is determined only by the specified version dependencies, and we chose the names <em>VER_1</em> and <em>VER_2</em> merely to be suggestive of these relationships. To assist maintenance, recommended practice is to use version tags that include the package name and a version number. For example, <em>glibc</em> uses version tags with names such as <em>GLIBC_2.0</em>, <em>GLIBC_2.1</em>, and so on.</p>
<p class="indent">The <em>VER_2</em> version tag also specifies that the new function <em>pqr()</em> is to be exported by the library and bound to the <em>VER_2</em> version tag. If we didn&#8217;t declare <em>pqr()</em> in this manner, then the <span class="literal">local</span> specification that <em>VER_2</em> version tag inherited from the <em>VER_1</em> version tag would make <em>pqr()</em> invisible outside the library. Note also that if we omitted the <span class="literal">local</span> specification altogether, then the symbols <em>xyz_old()</em> and <em>xyz_new()</em> would also be exported by the library (which is typically not what we want).</p>
<p class="indent">We now build the new version of our library in the usual way:</p>
<p class="programs">$ <span class="codestrong">gcc -g -c -fPIC -Wall sv_lib_v2.c</span><br/>$ <span class="codestrong">gcc -g -shared -o libsv.so sv_lib_v2.o -Wl,--version-script,sv_v2.map</span></p>
<p class="noindent">Now we can create a new program, <em>p2</em>, which uses the new definition of <em>xyz()</em>, while program <em>p1</em> uses the old version of <em>xyz()</em>.</p>
<p class="programs">$ <span class="codestrong">gcc -g -o p2 sv_prog.c libsv.so</span><br/>$ <span class="codestrong">LD_LIBRARY_PATH=. ./p2</span><br/>v2 xyz&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Uses xyz@VER_2</span><br/>$ <span class="codestrong">LD_LIBRARY_PATH=. ./p1</span><br/>v1 xyz&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Uses xyz@VER_1</span></p>
<p class="noindent">The version tag dependencies of an executable are recorded at static link time. We can use <em>objdump &#8211;t</em> to display the symbol tables of each executable, thus showing the different version tag dependencies of each program:</p>
<p class="programs">$ <span class="codestrong">objdump -t p1 | grep xyz</span><br/>08048380&#160;&#160;&#160;&#160;&#160;&#160;&#160;F *UND*&#160;&#160;0000002e&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;xyz@@VER_1<br/>$ <span class="codestrong">objdump -t p2 | grep xyz</span><br/>080483a0&#160;&#160;&#160;&#160;&#160;&#160;&#160;F *UND*&#160;&#160;0000002e&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;xyz@@VER_2</p>
<p class="noindent">We can also use <em>readelf &#8211;s</em> to obtain similar information.</p>
<div class="block">
<p class="noindent">Further information about symbol versioning can be found using the command <em>info ld scripts version</em> and at <em><a href="http://people.redhat.com/drepper/symbol-versioning">http://people.redhat.com/drepper/symbol-versioning</a></em>.</p>
</div>
<h3 class="h3" id="ch42lev1sec04"><strong>42.4 Initialization and Finalization Functions</strong></h3>
<p class="noindenta">It is possible to define one or more functions that are executed automatically when a shared library is loaded and unloaded. This allows us to perform initialization and finalization actions when working with shared libraries. Initialization and finalization <span epub:type="pagebreak" id="page_873"/>functions are executed regardless of whether the library is loaded automatically or loaded explicitly using the <em>dlopen</em> interface (<a href="ch42.xhtml#ch42lev1sec01">Section 42.1</a>).</p>
<p class="indent">Initialization and finalization functions are defined using the <em>gcc</em> <span class="literal">constructor</span> and <span class="literal">destructor</span> attributes. Each function that is to be executed when the library is loaded should be defined as follows:</p>
<p class="programs">void __attribute__ ((constructor)) some_name_load(void)<br/>{<br/>&#160;&#160;&#160;&#160;/* Initialization code */<br/>}</p>
<p class="noindent">Unload functions are similarly defined:</p>
<p class="programs">void __attribute__ ((destructor)) some_name_unload(void)<br/>{<br/>&#160;&#160;&#160;&#160;/* Finalization code */<br/>}</p>
<p class="noindent">The function names <em>some_name_load()</em> and <em>some_name_unload()</em> can be replaced by any desired names.</p>
<div class="block">
<p class="noindent">It is also possible to use the <em>gcc</em> <span class="literal">constructor</span> and <span class="literal">destructor</span> attributes to create initialization and finalization functions in a main program.</p>
</div>
<h5 class="h5" id="ch42lev3sec03"><strong>The <em>_init()</em> and <em>_fini()</em> functions</strong></h5>
<p class="noindenta">An older technique for shared library initialization and finalization is to create two functions, <em>_init()</em> and <em>_fini()</em>, as part of the library. The <em>void _init(void)</em> function contains code that is to be executed when the library is first loaded by a process. The <em>void _fini(void)</em> function contains code that is to be executed when the library is unloaded.</p>
<p class="indent">If we create <em>_init()</em> and <em>_fini()</em> functions, then we must specify the <em>gcc &#8211;nostartfiles</em> option when building the shared library, in order to prevent the linker from including default versions of these functions. (Using the <em>&#8211;Wl,&#8211;init</em> and <em>&#8211;Wl,&#8211;fini</em> linker options, we can choose alternative names for these two functions if desired.)</p>
<p class="indent">Use of <em>_init()</em> and <em>_fini()</em> is now considered obsolete in favor of the <em>gcc</em> <span class="literal">constructor</span> and <span class="literal">destructor</span> attributes, which, among other advantages, allow us to define multiple initialization and finalization functions.</p>
<h3 class="h3" id="ch42lev1sec05"><strong>42.5 Preloading Shared Libraries</strong></h3>
<p class="noindenta">For testing purposes, it can sometimes be useful to selectively override functions (and other symbols) that would normally be found by the dynamic linker using the rules described in <a href="ch41.xhtml#ch41lev1sec11">Section 41.11</a>. To do this, we can define the environment variable <span class="literal">LD_PRELOAD</span> as a string consisting of space-separated or colon-separated names of shared libraries that should be loaded before any other shared libraries. Since these libraries are loaded first, any functions they define will automatically be used if required by the executable, thus overriding any other functions of the same name that the dynamic linker would otherwise have searched for. For example, <span epub:type="pagebreak" id="page_874"/>suppose that we have a program that calls functions <em>x1()</em> and <em>x2()</em>, defined in our <em>libdemo</em> library. When we run this program, we see the following output:</p>
<p class="programs">$ <span class="codestrong">./prog</span><br/>Called mod1-x1 DEMO<br/>Called mod2-x2 DEMO</p>
<p class="noindent">(In this example, we assume that the shared library is in one of the standard directories, and thus we don&#8217;t need to use the <span class="literal">LD_LIBRARY_PATH</span> environment variable.)</p>
<p class="indent">We could selectively override the function <em>x1()</em> by creating another shared library, <span class="literal">libalt.so</span>, which contains a different definition of <em>x1()</em>. Preloading this library when running the program would result in the following:</p>
<p class="programs">$ <span class="codestrong">LD_PRELOAD=libalt.so ./prog</span><br/>Called mod1-x1 ALT<br/>Called mod2-x2 DEMO</p>
<p class="noindent">Here, we see that the version of <em>x1()</em> defined in <span class="literal">libalt.so</span> is invoked, but that the call to <em>x2()</em>, for which no definition is provided in <span class="literal">libalt.so</span>, results in the invocation of the <em>x2()</em> function defined in <span class="literal">libdemo.so</span>.</p>
<p class="indent">The <span class="literal">LD_PRELOAD</span> environment variable controls preloading on a per-process basis. Alternatively, the file <span class="literal">/etc/ld.so.preload</span>, which lists libraries separated by white space, can be used to perform the same task on a system-wide basis. (Libraries specified by <span class="literal">LD_PRELOAD</span> are loaded before those specified in <span class="literal">/etc/ld.so.preload</span>.)</p>
<p class="indent">For security reasons, set-user-ID and set-group-ID programs ignore <span class="literal">LD_PRELOAD</span>.</p>
<h3 class="h3" id="ch42lev1sec06"><strong>42.6 Monitoring the Dynamic Linker:</strong> <span class="literal"><span class="codestrong">LD_DEBUG</span></span></h3>
<p class="noindenta">Sometimes, it is useful to monitor the operation of the dynamic linker in order to know, for example, where it is searching for libraries. We can use the <span class="literal">LD_DEBUG</span> environment variable to do this. By setting this variable to one (or more) of a set of standard keywords, we can obtain various kinds of tracing information from the dynamic linker.</p>
<p class="indent">If we assign the value <em>help</em> to <span class="literal">LD_DEBUG</span>, the dynamic linker displays help information about <span class="literal">LD_DEBUG</span>, and the specified command is <em>not</em> executed:</p>
<p class="programs">$ <span class="codestrong">LD_DEBUG=help date</span><br/>Valid options for the LD_DEBUG environment variable are:<br/><br/>&#160;&#160;libs&#160;&#160;&#160;&#160;&#160;&#160;&#160;display library search paths<br/>&#160;&#160;reloc&#160;&#160;&#160;&#160;&#160;&#160;display relocation processing<br/>&#160;&#160;files&#160;&#160;&#160;&#160;&#160;&#160;display progress for input file<br/>&#160;&#160;symbols&#160;&#160;&#160;&#160;display symbol table processing<br/>&#160;&#160;bindings&#160;&#160;&#160;display information about symbol binding<br/>&#160;&#160;versions&#160;&#160;&#160;display version dependencies<br/>&#160;&#160;all&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;all previous options combined<br/>&#160;&#160;statistics display relocation statistics<br/>&#160;&#160;unused&#160;&#160;&#160;&#160;&#160;determine unused DSOs<br/>&#160;&#160;help&#160;&#160;&#160;&#160;&#160;&#160;&#160;display this help message and exit<br/><br/>To direct the debugging output into a file instead of standard output<br/>a filename can be specified using the LD_DEBUG_OUTPUT environment variable.</p>
<p class="noindent"><span epub:type="pagebreak" id="page_875"/>The following example shows an abridged version of the output provided when we request tracing of information about library searches:</p>
<p class="programs">$ <span class="codestrong">LD_DEBUG=libs date</span><br/>&#160;&#160;&#160;&#160;&#160;10687:&#160;&#160;&#160;&#160;&#160;find library=librt.so.1 [0]; searching<br/>&#160;&#160;&#160;&#160;&#160;10687:&#160;&#160;&#160;&#160;&#160;&#160;search cache=/etc/ld.so.cache<br/>&#160;&#160;&#160;&#160;&#160;10687:&#160;&#160;&#160;&#160;&#160;&#160;&#160;trying file=/lib/librt.so.1<br/>&#160;&#160;&#160;&#160;&#160;10687:&#160;&#160;&#160;&#160;&#160;find library=libc.so.6 [0]; searching<br/>&#160;&#160;&#160;&#160;&#160;10687:&#160;&#160;&#160;&#160;&#160;&#160;search cache=/etc/ld.so.cache<br/>&#160;&#160;&#160;&#160;&#160;10687:&#160;&#160;&#160;&#160;&#160;&#160;&#160;trying file=/lib/libc.so.6<br/>&#160;&#160;&#160;&#160;&#160;10687:&#160;&#160;&#160;&#160;&#160;find library=libpthread.so.0 [0]; searching<br/>&#160;&#160;&#160;&#160;&#160;10687:&#160;&#160;&#160;&#160;&#160;&#160;search cache=/etc/ld.so.cache<br/>&#160;&#160;&#160;&#160;&#160;10687:&#160;&#160;&#160;&#160;&#160;&#160;&#160;trying file=/lib/libpthread.so.0<br/>&#160;&#160;&#160;&#160;&#160;10687:&#160;&#160;&#160;&#160;&#160;calling init: /lib/libpthread.so.0<br/>&#160;&#160;&#160;&#160;&#160;10687:&#160;&#160;&#160;&#160;&#160;calling init: /lib/libc.so.6<br/>&#160;&#160;&#160;&#160;&#160;10687:&#160;&#160;&#160;&#160;&#160;calling init: /lib/librt.so.1<br/>&#160;&#160;&#160;&#160;&#160;10687:&#160;&#160;&#160;&#160;&#160;initialize program: date<br/>&#160;&#160;&#160;&#160;&#160;10687:&#160;&#160;&#160;&#160;&#160;transferring control: date<br/>Tue Dec 28 17:26:56 CEST 2010<br/>&#160;&#160;&#160;&#160;&#160;10687:&#160;&#160;&#160;&#160;&#160;calling fini: date [0]<br/>&#160;&#160;&#160;&#160;&#160;10687:&#160;&#160;&#160;&#160;&#160;calling fini: /lib/librt.so.1 [0]<br/>&#160;&#160;&#160;&#160;&#160;10687:&#160;&#160;&#160;&#160;&#160;calling fini: /lib/libpthread.so.0 [0]<br/>&#160;&#160;&#160;&#160;&#160;10687:&#160;&#160;&#160;&#160;&#160;calling fini: /lib/libc.so.6 [0]</p>
<p class="noindent">The value 10687 displayed at the start of each line is the process ID of the process being traced. This is useful if we are monitoring several processes (e.g., parent and child).</p>
<p class="indent">By default, <span class="literal">LD_DEBUG</span> output is written to standard error, but we can direct it elsewhere by assigning a pathname to the <span class="literal">LD_DEBUG_OUTPUT</span> environment variable.</p>
<p class="indent">If desired, we can assign multiple options to <span class="literal">LD_DEBUG</span> by separating them with commas (no spaces should appear). The output of the <em>symbols</em> option (which traces symbol resolution by the dynamic linker) is particularly voluminous.</p>
<p class="indent"><span class="literal">LD_DEBUG</span> is effective both for libraries implicitly loaded by the dynamic linker and for libraries dynamically loaded by <em>dlopen()</em>.</p>
<p class="indent">For security reasons, <span class="literal">LD_DEBUG</span> is (since <em>glibc</em> 2.2.5) ignored in set-user-ID and set-group-ID programs.</p>
<h3 class="h3" id="ch42lev1sec07"><strong>42.7 Summary</strong></h3>
<p class="noindenta">The dynamic linker provides the <em>dlopen</em> API, which allows programs to explicitly load additional shared libraries at run time. This allows programs to implement plug-in functionality.</p>
<p class="indent">An important aspect of shared library design is controlling symbol visibility, so that the library exports only those symbols (functions and variables) that should actually be used by programs linked against the library. We looked at a range of techniques that can be used to control symbol visibility. Among these techniques was the use of version scripts, which provide fine-grained control of symbol visibility.</p>
<p class="indent">We also showed how version scripts can be used to implement a scheme that allows a single shared library to export multiple definitions of a symbol for use by different applications linked against the library. (Each application uses the definition <span epub:type="pagebreak" id="page_876"/>that was current when the application was statically linked against the library.) This technique provides an alternative to the traditional library versioning approach of using major and minor version numbers in the shared library real name.</p>
<p class="indent">Defining initialization and finalization functions within a shared library allows us to automatically execute code when the library is loaded and unloaded.</p>
<p class="indent">The <span class="literal">LD_PRELOAD</span> environment variable allows us to preload shared libraries. Using this mechanism, we can selectively override functions and other symbols that the dynamic linker would normally find in other shared libraries.</p>
<p class="indent">We can assign various values to the <span class="literal">LD_DEBUG</span> environment variable in order to monitor the operation of the dynamic linker.</p>
<h5 class="h5" id="ch42lev3sec04"><strong>Further information</strong></h5>
<p class="noindenta">Refer to the sources of further information listed in <a href="ch41.xhtml#ch41lev1sec14">Section 41.14</a>.</p>
<h3 class="h3" id="ch42lev1sec08"><strong>42.8 Exercises</strong></h3>
<p class="exer"><a id="ch42exe1"/><strong>42-1.</strong>&#160;&#160;&#160;Write a program to verify that if a library is closed with <em>dlclose()</em>, it is not unloaded if any of its symbols are used by another library.</p>
<p class="exer"><a id="ch42exe2"/><strong>42-2.</strong>&#160;&#160;&#160;Add a <em>dladdr()</em> call to the program in <a href="ch42.xhtml#ch42ex1">Listing 42-1</a> (<span class="literal">dynload.c</span>) in order to retrieve information about the address returned by <em>dlsym()</em>. Print out the values of the fields of the returned <em>Dl_info</em> structure, and verify that they are as expected.</p>
</body>
</html>
