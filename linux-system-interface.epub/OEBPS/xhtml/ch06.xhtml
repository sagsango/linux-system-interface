<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_113"/><strong><span class="big">6</span></strong><br/><strong>PROCESSES</strong></h2>
<p class="noindenta">In this chapter, we look at the structure of a process, paying particular attention to the layout and contents of a process&#8217;s virtual memory. We also examine some of the attributes of a process. In later chapters, we examine further process attributes (for example, process credentials in <a href="ch09.xhtml#ch09">Chapter 9</a>, and process priorities and scheduling in <a href="ch35.xhtml#ch35">Chapter 35</a>). In <a href="ch24.xhtml#ch24">Chapters 24</a> to <a href="ch27.xhtml#ch27">27</a>, we look at how processes are created, how they terminate, and how they can be made to execute new programs.</p>
<h3 class="h3" id="ch06lev1sec01"><strong>6.1 Processes and Programs</strong></h3>
<p class="noindenta">A <em>process</em> is an instance of an executing program. In this section, we elaborate on this definition and clarify the distinction between a program and a process.</p>
<p class="indentb">A <em>program</em> is a file containing a range of information that describes how to construct a process at run time. This information includes the following:</p>
<p class="bull">&#8226; <em>Binary format identification</em>: Each program file includes metainformation describing the format of the executable file. This enables the kernel to interpret the remaining information in the file. Historically, two widely used formats for UNIX executable files were the original <em>a.out</em> (&#8220;assembler output&#8221;) format and the later, more sophisticated <em>COFF</em> (Common Object File Format). Nowadays, most UNIX implementations (including Linux) employ the Executable and Linking Format (ELF), which provides a number of advantages over the older formats.</p>
<p class="bull"><span epub:type="pagebreak" id="page_114"/>&#8226; <em>Machine-language instructions</em>: These encode the algorithm of the program.</p>
<p class="bull">&#8226; <em>Program entry-point address</em>: This identifies the location of the instruction at which execution of the program should commence.</p>
<p class="bull">&#8226; <em>Data</em>: The program file contains values used to initialize variables and also literal constants used by the program (e.g., strings).</p>
<p class="bull">&#8226; <em>Symbol and relocation tables</em>: These describe the locations and names of functions and variables within the program. These tables are used for a variety of purposes, including debugging and run-time symbol resolution (dynamic linking).</p>
<p class="bull">&#8226; <em>Shared-library and dynamic-linking information</em>: The program file includes fields listing the shared libraries that the program needs to use at run time and the pathname of the dynamic linker that should be used to load these libraries.</p>
<p class="bull">&#8226; <em>Other information</em>: The program file contains various other information that describes how to construct a process.</p>
<p class="noindent">One program may be used to construct many processes, or, put conversely, many processes may be running the same program.</p>
<p class="indent">We can recast the definition of a process given at the start of this section as follows: a process is an abstract entity, defined by the kernel, to which system resources are allocated in order to execute a program.</p>
<p class="indent">From the kernel&#8217;s point of view, a process consists of user-space memory containing program code and variables used by that code, and a range of kernel data structures that maintain information about the state of the process. The information recorded in the kernel data structures includes various identifier numbers (IDs) associated with the process, virtual memory tables, the table of open file descriptors, information relating to signal delivery and handling, process resource usages and limits, the current working directory, and a host of other information.</p>
<h3 class="h3" id="ch06lev1sec02"><strong>6.2 Process ID and Parent Process ID</strong></h3>
<p class="noindenta">Each process has a process ID (PID), a positive integer that uniquely identifies the process on the system. Process IDs are used and returned by a variety of system calls. For example, the <em>kill()</em> system call (<a href="ch20.xhtml#ch20lev1sec05">Section 20.5</a>) allows the caller to send a signal to a process with a specific process ID. The process ID is also useful if we need to build an identifier that is unique to a process. A common example of this is the use of the process ID as part of a process-unique filename.</p>
<p class="indent">The <em>getpid()</em> system call returns the process ID of the calling process.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>pid_t <span class="codestrong">getpid</span>(void);</p>
<p class="right">Always successfully returns process ID of caller</p>
</div>
<p class="noindent">The <em>pid_t</em> data type used for the return value of <em>getpid()</em> is an integer type specified by SUSv3 for the purpose of storing process IDs.</p>
<p class="indent"><span epub:type="pagebreak" id="page_115"/>With the exception of a few system processes such as <em>init</em> (process ID 1), there is no fixed relationship between a program and the process ID of the process that is created to run that program.</p>
<p class="indent">The Linux kernel limits process IDs to being less than or equal to 32,767. When a new process is created, it is assigned the next sequentially available process ID. Each time the limit of 32,767 is reached, the kernel resets its process ID counter so that process IDs are assigned starting from low integer values.</p>
<div class="block">
<p class="noindent">Once it has reached 32,767, the process ID counter is reset to 300, rather than 1. This is done because many low-numbered process IDs are in permanent use by system processes and daemons, and thus time would be wasted searching for an unused process ID in this range.</p>
<p class="indent">In Linux 2.4 and earlier, the process ID limit of 32,767 is defined by the kernel constant <span class="literal">PID_MAX</span>. With Linux 2.6, things change. While the default upper limit for process IDs remains 32,767, this limit is adjustable via the value in the Linux-specific <span class="literal">/proc/sys/kernel/pid_max</span> file (which is one greater than the maximum process ID). On 32-bit platforms, the maximum value for this file is 32,768, but on 64-bit platforms, it can be adjusted to any value up to 2<sup>22</sup> (approximately 4 million), making it possible to accommodate very large numbers of processes.</p>
</div>
<p class="noindent">Each process has a parent&#8212;the process that created it. A process can find out the process ID of its parent using the <em>getppid()</em> system call.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>pid_t <span class="codestrong">getppid</span>(void);</p>
<p class="right">Always successfully returns process ID of parent of caller</p>
</div>
<p class="noindent">In effect, the parent process ID attribute of each process represents the tree-like relationship of all processes on the system. The parent of each process has its own parent, and so on, going all the way back to process 1, <em>init</em>, the ancestor of all processes. (This &#8220;family tree&#8221; can be viewed using the <em>pstree(1)</em> command.)</p>
<p class="indent">If a child process becomes orphaned because its &#8220;birth&#8221; parent terminates, then the child is adopted by the <em>init</em> process, and subsequent calls to <em>getppid()</em> in the child return 1 (see <a href="ch26.xhtml#ch26lev1sec02">Section 26.2</a>).</p>
<p class="indent">The parent of any process can be found by looking at the <span class="literal">PPid</span> field provided in the Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/status</span> file.</p>
<h3 class="h3" id="ch06lev1sec03"><strong>6.3 Memory Layout of a Process</strong></h3>
<p class="noindentab">The memory allocated to each process is composed of a number of parts, usually referred to as <em>segments</em>. These segments are as follows:</p>
<p class="bull">&#8226; The <em>text segment</em> contains the machine-language instructions of the program run by the process. The text segment is made read-only so that a process doesn&#8217;t accidentally modify its own instructions via a bad pointer value. Since <span epub:type="pagebreak" id="page_116"/>many processes may be running the same program, the text segment is made sharable so that a single copy of the program code can be mapped into the virtual address space of all of the processes.</p>
<p class="bull">&#8226; The <em>initialized data segment</em> contains global and static variables that are explicitly initialized. The values of these variables are read from the executable file when the program is loaded into memory.</p>
<p class="bull">&#8226; The <em>uninitialized data segment</em> contains global and static variables that are not explicitly initialized. Before starting the program, the system initializes all memory in this segment to 0. For historical reasons, this is often called the <em>bss</em> segment, a name derived from an old assembler mnemonic for &#8220;block started by symbol.&#8221; The main reason for placing global and static variables that are initialized into a separate segment from those that are uninitialized is that, when a program is stored on disk, it is not necessary to allocate space for the uninitialized data. Instead, the executable merely needs to record the location and size required for the uninitialized data segment, and this space is allocated by the program loader at run time.</p>
<p class="bull">&#8226; The <em>stack</em> is a dynamically growing and shrinking segment containing stack frames. One stack frame is allocated for each currently called function. A frame stores the function&#8217;s local variables (so-called automatic variables), arguments, and return value. Stack frames are discussed in more detail in <a href="ch06.xhtml#ch06lev1sec05">Section 6.5</a>.</p>
<p class="bull">&#8226; The <em>heap</em> is an area from which memory (for variables) can be dynamically allocated at run time. The top end of the heap is called the <em>program break</em>.</p>
<p class="noindentt">Less commonly used, but more descriptive labels for the initialized and uninitialized data segments are <em>user-initialized data segment</em> and <em>zero-initialized data segment</em>.</p>
<p class="indentb">The <em>size(1)</em> command displays the size of the text, initialized data, and uninitialized data (<em>bss</em>) segments of a binary executable.</p>
<div class="block">
<p class="noindent">The term <em>segment</em> as used in the main text should not be confused with the hardware segmentation used on some hardware architectures such as x86-32. Rather, segments are logical divisions of a process&#8217;s virtual memory on UNIX systems. Sometimes, the term <em>section</em> is used instead of <em>segment</em>, since <em>section</em> is more consistent with the terminology used in the now ubiquitous ELF specification for executable file formats.</p>
<p class="indent">In many places in this book, we note that a library function returns a pointer to statically allocated memory. By this, we mean that the memory is allocated in either the initialized or the uninitialized data segment. (In some cases, the library function may instead do a one-time dynamic allocation of the memory on the heap; however, this implementation detail is irrelevant to the semantic point we describe here.) It is important to be aware of cases where a library function returns information via statically allocated memory, since that memory has an existence that is independent of the function invocation, and the memory may be overwritten by subsequent calls to the same function (or in some cases, by subsequent calls to related functions). The effect of using statically allocated memory is to render a function nonreentrant. We say more about reentrancy in <a href="ch21.xhtml#ch21lev2sec02">Sections 21.1.2</a> and <a href="ch31.xhtml#ch31lev1sec01">31.1</a>.</p>
</div>
<p class="noindent"><a href="ch06.xhtml#ch6ex1">Listing 6-1</a> shows various types of C variables along with comments indicating in which segment each variable is located. These comments assume a nonoptimizing <span epub:type="pagebreak" id="page_117"/>compiler and an application binary interface in which all arguments are passed on the stack. In practice, an optimizing compiler may allocate frequently used variables in registers, or optimize a variable out of existence altogether. Furthermore, some ABIs require function arguments and the function result to be passed via registers, rather than on the stack. Nevertheless, this example serves to demonstrate the mapping between C variables and the segments of a process.</p>
<p class="examplet"><a id="ch6ex1"/><strong>Listing 6-1:</strong> Locations of program variables in process memory segments</p>
<p class="programsli">_______________________________________________________ <span class="codestrong">proc/mem_segments.c</span><br/><br/>#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;<br/><br/>char globBuf[65536];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Uninitialized data segment */<br/>int primes[] = { 2, 3, 5, 7 };&#160;&#160;/* Initialized data segment */<br/><br/>static int<br/>square(int x)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allocated in frame for square() */<br/>{<br/>&#160;&#160;&#160;&#160;int result;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allocated in frame for square() */<br/><br/>&#160;&#160;&#160;&#160;result = x * x;<br/>&#160;&#160;&#160;&#160;return result;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Return value passed via register */<br/>}<br/><br/>static void<br/>doCalc(int val)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allocated in frame for doCalc() */<br/>{<br/>&#160;&#160;&#160;&#160;printf("The square of %d is %d\n", val, square(val));<br/><br/>&#160;&#160;&#160;&#160;if (val &lt; 1000) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int t;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allocated in frame for doCalc() */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t = val * val * val;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("The cube of %d is %d\n", val, t);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/><br/>int<br/>main(int argc, char *argv[])&#160;&#160;&#160;&#160;/* Allocated in frame for main() */<br/>{<br/>&#160;&#160;&#160;&#160;static int key = 9973;&#160;&#160;&#160;&#160;&#160;&#160;/* Initialized data segment */<br/>&#160;&#160;&#160;&#160;static char mbuf[10240000]; /* Uninitialized data segment */<br/>&#160;&#160;&#160;&#160;char *p;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allocated in frame for main() */<br/><br/>&#160;&#160;&#160;&#160;p = malloc(1024);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Points to memory in heap segment */<br/><br/>&#160;&#160;&#160;&#160;doCalc(key);<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_______________________________________________________ <span class="codestrong">proc/mem_segments.c</span></p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_118"/>An <em>application binary interface</em> (ABI) is a set of rules specifying how a binary executable should exchange information with some service (e.g., the kernel or a library) at run time. Among other things, an ABI specifies which registers and stack locations are used to exchange this information, and what meaning is attached to the exchanged values. Once compiled for a particular ABI, a binary executable should be able to run on any system presenting the same ABI. This contrasts with a standardized API (such as SUSv3), which guarantees portability only for applications compiled from source code.</p>
</div>
<p class="noindent">Although not specified in SUSv3, the C program environment on most UNIX implementations (including Linux) provides three global symbols: <em>etext</em>, <em>edata</em>, and <em>end</em>. These symbols can be used from within a program to obtain the addresses of the next byte past, respectively, the end of the program text, the end of the initialized data segment, and the end of the uninitialized data segment. To make use of these symbols, we must explicitly declare them, as follows:</p>
<p class="programs">extern char etext, edata, end;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* For example, &#38;etext gives the address of the next byte past<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;the end of the program text / start of initialized data */</p>
<p class="noindent"><a href="ch06.xhtml#ch6fig1">Figure 6-1</a> shows the arrangement of the various memory segments on the x86-32 architecture. The space labeled <em>argv, environ</em> at the top of this diagram holds the program command-line arguments (available in C via the <em>argv</em> argument of the <em>main()</em> function) and the process environment list (which we discuss shortly). The hexadecimal addresses shown in the diagram may vary, depending on kernel configuration and program linking options. The grayed-out areas represent invalid ranges in the process&#8217;s virtual address space; that is, areas for which page tables have not been created (see the following discussion of virtual memory management).</p>
<p class="indent">We revisit the topic of process memory layout in a little more detail in <a href="ch48.xhtml#ch48lev1sec05">Section 48.5</a>, where we consider where shared memory and shared libraries are placed in a process&#8217;s virtual memory.</p>
<h3 class="h3" id="ch06lev1sec04"><strong>6.4 Virtual Memory Management</strong></h3>
<p class="noindenta">The previous discussion of the memory layout of a process glossed over the fact that we were talking about the layout in <em>virtual memory</em>. Since an understanding of virtual memory is useful later on when we look at topics such as the <em>fork()</em> system call, shared memory, and mapped files, we now consider some of the details.</p>
<p class="indentb">Like most modern kernels, Linux employs a technique known as <em>virtual memory management</em>. The aim of this technique is to make efficient use of both the CPU and RAM (physical memory) by exploiting a property that is typical of most programs: <em>locality of reference</em>. Most programs demonstrate two kinds of locality:</p>
<p class="bull">&#8226; <em>Spatial locality</em> is the tendency of a program to reference memory addresses that are near those that were recently accessed (because of sequential processing of instructions, and, sometimes, sequential processing of data structures).</p>
<p class="bull">&#8226; <em>Temporal locality</em> is the tendency of a program to access the same memory addresses in the near future that it accessed in the recent past (because of loops).</p>
<div class="image"><span epub:type="pagebreak" id="page_119"/><img src="../images/f06-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch6fig1"/><strong>Figure 6-1:</strong> Typical memory layout of a process on Linux/x86-32</p>
<p class="noindent">The upshot of locality of reference is that it is possible to execute a program while maintaining only part of its address space in RAM.</p>
<p class="indent">A virtual memory scheme splits the memory used by each program into small, fixed-size units called <em>pages</em>. Correspondingly, RAM is divided into a series of <em>page frames</em> of the same size. At any one time, only some of the pages of a program need to be resident in physical memory page frames; these pages form the so-called <em>resident set</em>. Copies of the unused pages of a program are maintained in the <em>swap area</em>&#8212;a reserved area of disk space used to supplement the computer&#8217;s RAM&#8212;and loaded into physical memory only as required. When a process references a page that is not currently resident in physical memory, a <em>page fault</em> occurs, at which point the kernel suspends execution of the process while the page is loaded from disk into memory.</p>
<div class="block">
<p class="noindent">On x86-32, pages are 4096 bytes in size. Some other Linux implementations use larger page sizes. For example, Alpha uses a page size of 8192 bytes, and IA-64 has a variable page size, with the usual default being 16,384 bytes. A program can determine the system virtual memory page size using the call <em>sysconf(_SC_PAGESIZE)</em>, as described in <a href="ch11.xhtml#ch11lev1sec02">Section 11.2</a>.</p>
</div>
<div class="image"><span epub:type="pagebreak" id="page_120"/><img src="../images/f06-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch6fig2"/><strong>Figure 6-2:</strong> Overview of virtual memory</p>
<p class="noindent">In order to support this organization, the kernel maintains a <em>page table</em> for each process (<a href="ch06.xhtml#ch6fig2">Figure 6-2</a>). The page table describes the location of each page in the process&#8217;s <em>virtual address space</em> (the set of all virtual memory pages available to the process). Each entry in the page table either indicates the location of a virtual page in RAM or indicates that it currently resides on disk.</p>
<p class="indent">Not all address ranges in the process&#8217;s virtual address space require page-table entries. Typically, large ranges of the potential virtual address space are unused, so that it isn&#8217;t necessary to maintain corresponding page-table entries. If a process tries to access an address for which there is no corresponding page-table entry, it receives a <span class="literal">SIGSEGV</span> signal.</p>
<p class="indentb">A process&#8217;s range of valid virtual addresses can change over its lifetime, as the kernel allocates and deallocates pages (and page-table entries) for the process. This can happen in the following circumstances:</p>
<p class="bull">&#8226; as the stack grows downward beyond limits previously reached;</p>
<p class="bull">&#8226; when memory is allocated or deallocated on the heap, by raising the program break using <em>brk()</em>, <em>sbrk()</em>, or the <em>malloc</em> family of functions (<a href="ch07.xhtml#ch07">Chapter 7</a>);</p>
<p class="bull">&#8226; when System V shared memory regions are attached using <em>shmat()</em> and detached using <em>shmdt()</em> (<a href="ch48.xhtml#ch48">Chapter 48</a>); and</p>
<p class="bull">&#8226; when memory mappings are created using <em>mmap()</em> and unmapped using <em>munmap()</em> (<a href="ch49.xhtml#ch49">Chapter 49</a>).</p>
<div class="block">
<p class="noindent">The implementation of virtual memory requires hardware support in the form of a <em>paged memory management unit</em> (PMMU). The PMMU translates each virtual memory address reference into the corresponding physical memory address and advises the kernel of a page fault when a particular virtual memory address corresponds to a page that is not resident in RAM.</p>
</div>
<p class="noindentb"><span epub:type="pagebreak" id="page_121"/>Virtual memory management separates the virtual address space of a process from the physical address space of RAM. This provides many advantages:</p>
<p class="bull">&#8226; Processes are isolated from one another and from the kernel, so that one process can&#8217;t read or modify the memory of another process or the kernel. This is accomplished by having the page-table entries for each process point to distinct sets of physical pages in RAM (or in the swap area).</p>
<p class="bull">&#8226; Where appropriate, two or more processes can share memory. The kernel makes this possible by having page-table entries in different processes refer to the same pages of RAM. Memory sharing occurs in two common circumstances:</p>
<p class="dash1">&#8211; Multiple processes executing the same program can share a single (read-only) copy of the program code. This type of sharing is performed implicitly when multiple programs execute the same program file (or load the same shared library).</p>
<p class="dash1">&#8211; Processes can use the <em>shmget()</em> and <em>mmap()</em> system calls to explicitly request sharing of memory regions with other processes. This is done for the purpose of interprocess communication.</p>
<p class="bull">&#8226; The implementation of memory protection schemes is facilitated; that is, page-table entries can be marked to indicate that the contents of the corresponding page are readable, writable, executable, or some combination of these protections. Where multiple processes share pages of RAM, it is possible to specify that each process has different protections on the memory; for example, one process might have read-only access to a page, while another has read-write access.</p>
<p class="bull">&#8226; Programmers, and tools such as the compiler and linker, don&#8217;t need to be concerned with the physical layout of the program in RAM.</p>
<p class="bull">&#8226; Because only a part of a program needs to reside in memory, the program loads and runs faster. Furthermore, the memory footprint (i.e., virtual size) of a process can exceed the capacity of RAM.</p>
<p class="noindentt">One final advantage of virtual memory management is that since each process uses less RAM, more processes can simultaneously be held in RAM. This typically leads to better CPU utilization, since it increases the likelihood that, at any moment in time, there is at least one process that the CPU can execute.</p>
<h3 class="h3" id="ch06lev1sec05"><strong>6.5 The Stack and Stack Frames</strong></h3>
<p class="noindenta">The stack grows and shrinks linearly as functions are called and return. For Linux on the x86-32 architecture (and on most other Linux and UNIX implementations), the stack resides at the high end of memory and grows downward (toward the heap). A special-purpose register, the <em>stack pointer</em>, tracks the current top of the stack. Each time a function is called, an additional frame is allocated on the stack, and this frame is removed when the function returns.</p>
<div class="block">
<p class="noindent">Even though the stack grows downward, we still call the growing end of the stack the <em>top</em>, since, in abstract terms, that is what it is. The actual direction of stack growth is a (hardware) implementation detail. One Linux implementation, the HP PA-RISC, does use an upwardly growing stack.</p>
<p class="indent"><span epub:type="pagebreak" id="page_122"/>In virtual memory terms, the stack segment increases in size as stack frames are allocated, but on most implementations, it won&#8217;t decrease in size after these frames are deallocated (the memory is simply reused when new stack frames are allocated). When we talk about the stack segment growing and shrinking, we are considering things from the logical perspective of frames being added to and removed from the stack.</p>
</div>
<p class="noindent">Sometimes, the term <em>user stack</em> is used to distinguish the stack we describe here from the <em>kernel stack</em>. The kernel stack is a per-process memory region maintained in kernel memory that is used as the stack for execution of the functions called internally during the execution of a system call. (The kernel can&#8217;t employ the user stack for this purpose since it resides in unprotected user memory.)</p>
<p class="indentb">Each (user) stack frame contains the following information:</p>
<p class="bull">&#8226; <em>Function arguments and local variables</em>: In C these are referred to as <em>automatic</em> variables, since they are automatically created when a function is called. These variables also automatically disappear when the function returns (since the stack frame disappears), and this forms the primary semantic distinction between automatic and <span class="literal">static</span> (and global) variables: the latter have a permanent existence independent of the execution of functions.</p>
<p class="bull">&#8226; <em>Call linkage information</em>: Each function uses certain CPU registers, such as the program counter, which points to the next machine-language instruction to be executed. Each time one function calls another, a copy of these registers is saved in the called function&#8217;s stack frame so that when the function returns, the appropriate register values can be restored for the calling function.</p>
<p class="noindentt">Since functions can call one another, there may be multiple frames on the stack. (If a function calls itself recursively, there will be multiple frames on the stack for that function.) Referring to <a href="ch06.xhtml#ch6ex1">Listing 6-1</a>, during the execution of the function <em>square()</em>, the stack will contain frames as shown in <a href="ch06.xhtml#ch6fig3">Figure 6-3</a>.</p>
<div class="image"><img src="../images/f06-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch6fig3"/><strong>Figure 6-3:</strong> Example of a process stack</p>
<h3 class="h3" id="ch06lev1sec06"><strong>6.6 Command-Line Arguments (<em>argc</em>, <em>argv</em>)</strong></h3>
<p class="noindenta">Every C program must have a function called <em>main()</em>, which is the point where execution of the program starts. When the program is executed, the command-line arguments (the separate words parsed by the shell) are made available via <span epub:type="pagebreak" id="page_123"/>two arguments to the function <em>main()</em>. The first argument, <em>int argc</em>, indicates how many command-line arguments there are. The second argument, <em>char *argv[]</em>, is an array of pointers to the command-line arguments, each of which is a null-terminated character string. The first of these strings, in <em>argv[0]</em>, is (conventionally) the name of the program itself. The list of pointers in <em>argv</em> is terminated by a <span class="literal">NULL</span> pointer (i.e., <em>argv[argc]</em> is <span class="literal">NULL</span>).</p>
<p class="indent">The fact that <em>argv[0]</em> contains the name used to invoke the program can be employed to perform a useful trick. We can create multiple links to (i.e., names for) the same program, and then have the program look at <em>argv[0]</em> and take different actions depending on the name used to invoke it. An example of this technique is provided by the <em>gzip(1)</em>, <em>gunzip(1)</em>, and <em>zcat(1)</em> commands: on some distributions, these are all links to the same executable file. (If we employ this technique, we must be careful to handle the possibility that the user might invoke the program via a link with a name other than any of those that we expect.)</p>
<p class="indent"><a href="ch06.xhtml#ch6fig4">Figure 6-4</a> shows an example of the data structures associated with <em>argc</em> and <em>argv</em> when executing the program in <a href="ch06.xhtml#ch6ex2">Listing 6-2</a>. In this diagram, we show the terminating null bytes at the end of each string using the C notation <span class="literal">\0</span>.</p>
<div class="image"><img src="../images/f06-04.jpg" alt="image"/></div>
<p class="figcap"><a id="ch6fig4"/><strong>Figure 6-4:</strong> Values of <em>argc</em> and <em>argv</em> for the command <em>necho hello world</em></p>
<p class="noindent">The program in <a href="ch06.xhtml#ch6ex2">Listing 6-2</a> echoes its command-line arguments, one per line of output, preceded by a string showing which element of <em>argv</em> is being displayed.</p>
<p class="examplet"><a id="ch6ex2"/><strong>Listing 6-2:</strong> Echoing command-line arguments</p>
<p class="programsli">_____________________________________________________________ <span class="codestrong">proc/necho.c</span><br/><br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int j;<br/><br/>&#160;&#160;&#160;&#160;for (j = 0; j &lt; argc; j++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("argv[%d] = %s\n", j, argv[j]);<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_____________________________________________________________ <span class="codestrong">proc/necho.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_124"/>Since the <em>argv</em> list is terminated by a <span class="literal">NULL</span> value, we could alternatively code the body of the program in <a href="ch06.xhtml#ch6ex2">Listing 6-2</a> as follows, to output just the command-line arguments one per line:</p>
<p class="programs">char **p;<br/><br/>for (p = argv; *p != NULL; p++)<br/>&#160;&#160;&#160;&#160;puts(*p);</p>
<p class="noindent">One limitation of the <em>argc</em>/<em>argv</em> mechanism is that these variables are available only as arguments to <em>main()</em>. To portably make the command-line arguments available in other functions, we must either pass <em>argv</em> as an argument to those functions or set a global variable pointing to <em>argv</em>.</p>
<p class="indentb">There are a couple of nonportable methods of accessing part or all of this information from anywhere in a program:</p>
<p class="bull">&#8226; The command-line arguments of any process can be read via the Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/cmdline</span> file, with each argument being terminated by a null byte. (A program can access its own command-line arguments via <span class="literal">/proc/self/cmdline</span>.)</p>
<p class="bull">&#8226; The GNU C library provides two global variables that may be used anywhere in a program in order to obtain the name used to invoke the program (i.e., the first command-line argument). The first of these, <em>program_invocation_name</em>, provides the complete pathname used to invoke the program. The second, <em>program_invocation_short_name</em>, provides a version of this name with any directory prefix stripped off (i.e., the basename component of the pathname). Declarations for these two variables can be obtained from <span class="literal">&lt;errno.h&gt;</span> by defining the macro <span class="literal">_GNU_SOURCE</span>.</p>
<p class="noindentt">As shown in <a href="ch06.xhtml#ch6fig1">Figure 6-1</a>, the <em>argv</em> and <em>environ</em> arrays, as well as the strings they initially point to, reside in a single contiguous area of memory just above the process stack. (We describe <em>environ</em>, which holds the program&#8217;s environment list, in the next section.) There is an upper limit on the total number of bytes that can be stored in this area. SUSv3 prescribes the use of the <span class="literal">ARG_MAX</span> constant (defined in <span class="literal">&lt;limits.h&gt;</span>) or the call <em>sysconf(_SC_ARG_MAX)</em> to determine this limit. (We describe <em>sysconf()</em> in <a href="ch11.xhtml#ch11lev1sec02">Section 11.2</a>.) SUSv3 requires <span class="literal">ARG_MAX</span> to be at least <span class="literal">_POSIX_ARG_MAX</span> (4096) bytes. Most UNIX implementations allow a considerably higher limit than this. SUSv3 leaves it unspecified whether an implementation counts overhead bytes (for terminating null bytes, alignment bytes, and the <em>argv</em> and <em>environ</em> arrays of pointers) against the <span class="literal">ARG_MAX</span> limit.</p>
<div class="block">
<p class="noindent">On Linux, <span class="literal">ARG_MAX</span> was historically fixed at 32 pages (i.e., 131,072 bytes on Linux/x86-32), and included the space for overhead bytes. Starting with kernel 2.6.23, the limit on the total space used for <em>argv</em> and <em>environ</em> can be controlled via the <span class="literal">RLIMIT_STACK</span> resource limit, and a much larger limit is permitted for <em>argv</em> and <em>environ</em>. The limit is calculated as one-quarter of the soft <span class="literal">RLIMIT_STACK</span> resource limit that was in force at the time of the <em>execve()</em> call. For further details, see the <em>execve(2)</em> man page.</p>
</div>
<p class="noindent">Many programs (including several of the examples in this book) parse command-line options (i.e., arguments beginning with a hyphen) using the <em>getopt()</em> library function. We describe <em>getopt()</em> in <a href="app02.xhtml#app02">Appendix B</a>.</p>
<h3 class="h3" id="ch06lev1sec07"><span epub:type="pagebreak" id="page_125"/><strong>6.7 Environment List</strong></h3>
<p class="noindenta">Each process has an associated array of strings called the <em>environment list</em>, or simply the <em>environment</em>. Each of these strings is a definition of the form <em>name=value</em>. Thus, the environment represents a set of name-value pairs that can be used to hold arbitrary information. The names in the list are referred to as <em>environment variables</em>.</p>
<p class="indent">When a new process is created, it inherits a copy of its parent&#8217;s environment. This is a primitive but frequently used form of interprocess communication&#8212;the environment provides a way to transfer information from a parent process to its child(ren). Since the child gets a copy of its parent&#8217;s environment at the time it is created, this transfer of information is one-way and once-only. After the child process has been created, either process may change its own environment, and these changes are not seen by the other process.</p>
<p class="indent">A common use of environment variables is in the shell. By placing values in its own environment, the shell can ensure that these values are passed to the processes that it creates to execute user commands. For example, the environment variable <span class="literal">SHELL</span> is set to be the pathname of the shell program itself. Many programs interpret this variable as the name of the shell that should be executed if the program needs to execute a shell.</p>
<p class="indent">Some library functions allow their behavior to be modified by setting environment variables. This allows the user to control the behavior of an application using the function without needing to change the code of the application or relink it against the corresponding library. An example of this technique is provided by the <em>getopt()</em> function (<a href="app02.xhtml#app02">Appendix B</a>), whose behavior can be modified by setting the <span class="literal">POSIXLY_CORRECT</span> environment variable.</p>
<p class="indent">In most shells, a value can be added to the environment using the <em>export</em> command:</p>
<p class="programs">$ <span class="codestrong">SHELL=/bin/bash</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create a shell variable</span><br/>$ <span class="codestrong">export SHELL</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Put variable into shell process's environment</span></p>
<p class="noindent">In <em>bash</em> and the Korn shell, this can be abbreviated to:</p>
<p class="programs">$ <span class="codestrong">export SHELL=/bin/bash</span></p>
<p class="noindent">In the C shell, the <em>setenv</em> command is used instead:</p>
<p class="programs">% <span class="codestrong">setenv SHELL /bin/bash</span></p>
<p class="noindent">The above commands permanently add a value to the shell&#8217;s environment, and this environment is then inherited by all child processes that the shell creates. At any point, an environment variable can be removed with the <em>unset</em> command (<em>unsetenv</em> in the C shell).</p>
<p class="indent">In the Bourne shell and its descendants (e.g., <em>bash</em> and the Korn shell), the following syntax can be used to add values to the environment used to execute a single program, without affecting the parent shell (and subsequent commands):</p>
<p class="programs">$ <span class="codestrong"><span class="codeitalic">NAME=value</span> <span class="codeitalic">program</span></span></p>
<p class="noindent">This adds a definition to the environment of just the child process executing the named program. If desired, multiple assignments (delimited by white space) can precede the program name.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_126"/>The <em>env</em> command runs a program using a modified copy of the shell&#8217;s environment list. The environment list can be modified to both add and remove definitions from the list copied from the shell. See the <em>env(1)</em> manual page for further details.</p>
</div>
<p class="noindent">The <em>printenv</em> command displays the current environment list. Here is an example of its output:</p>
<p class="programs">$ <span class="codestrong">printenv</span><br/>LOGNAME=mtk<br/>SHELL=/bin/bash<br/>HOME=/home/mtk<br/>PATH=/usr/local/bin:/usr/bin:/bin:.<br/>TERM=xterm</p>
<p class="noindent">We describe the purpose of most of the above environment variables at appropriate points in later chapters (see also the <em>environ(7)</em> manual page).</p>
<p class="indent">From the above output, we can see that the environment list is not sorted; the order of the strings in the list is simply the arrangement that is most convenient for the implementation. In general, this is not a problem, since we normally want to access individual variables in the environment, rather than some ordered sequence of them.</p>
<p class="indent">The environment list of any process can be examined via the Linux-specific <span class="literal">/proc/</span> <em>PID</em><span class="literal">/environ</span> file, with each <em>NAME=value</em> pair being terminated by a null byte.</p>
<h5 class="h5" id="ch06lev3sec01"><strong>Accessing the environment from a program</strong></h5>
<p class="noindenta">Within a C program, the environment list can be accessed using the global variable <em>char **environ</em>. (The C run-time startup code defines this variable and assigns the location of the environment list to it.) Like <em>argv</em>, <em>environ</em> points to a <span class="literal">NULL</span>-terminated list of pointers to null-terminated strings. <a href="ch06.xhtml#ch6fig5">Figure 6-5</a> shows the environment list data structures as they would appear for the environment displayed by the <em>printenv</em> command above.</p>
<div class="image"><img src="../images/f06-05.jpg" alt="image"/></div>
<p class="figcap"><a id="ch6fig5"/><strong>Figure 6-5:</strong> Example of process environment list data structures</p>
<p class="noindent">The program in <a href="ch06.xhtml#ch6ex3">Listing 6-3</a> accesses <em>environ</em> in order to list all of the values in the process environment. This program yields the same output as the <em>printenv</em> command. The loop in this program relies on the use of pointers to walk through <em>environ</em>. While it would be possible to treat <em>environ</em> as an array (as we use <em>argv</em> in <a href="ch06.xhtml#ch6ex2">Listing 6-2</a>), this is less natural, since the items in the environment list are in no particular order <span epub:type="pagebreak" id="page_127"/>and there is no variable (corresponding to <em>argc</em>) that specifies the size of the environment list. (For similar reasons, we don&#8217;t number the elements of the <em>environ</em> array in <a href="ch06.xhtml#ch6fig5">Figure 6-5</a>.)</p>
<p class="examplet"><a id="ch6ex3"/><strong>Listing 6-3:</strong> Displaying the process environment</p>
<p class="programsli">________________________________________________________<span class="codestrong">proc/display_env.c</span><br/><br/>#include "tlpi_hdr.h"<br/><br/>extern char **environ;<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;char **ep;<br/><br/>&#160;&#160;&#160;&#160;for (ep = environ; *ep != NULL; ep++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;puts(*ep);<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>________________________________________________________<span class="codestrong">proc/display_env.c</span></p>
<p class="noindent">An alternative method of accessing the environment list is to declare a third argument to the <em>main()</em> function:</p>
<p class="programs">int main(int argc, char *argv[], char *envp[])</p>
<p class="noindent">This argument can then be treated in the same way as <em>environ</em>, with the difference that its scope is local to <em>main()</em>. Although this feature is widely implemented on UNIX systems, its use should be avoided since, in addition to the scope limitation, it is not specified in SUSv3.</p>
<p class="indent">The <em>getenv()</em> function retrieves individual values from the process environment.</p>
<div class="box">
<p class="programsa">#include &lt;stdlib.h&gt;<br/><br/>char *<span class="codestrong">getenv</span>(const char *<span class="font1">name</span>);</p>
<p class="right">Returns pointer to (value) string, or <span class="literal">NULL</span> if no such variable</p>
</div>
<p class="noindent">Given the name of an environment variable, <em>getenv()</em> returns a pointer to the corresponding value string. Thus, in the case of our example environment shown earlier, <em>/bin/bash</em> would be returned if <span class="literal">SHELL</span> was specified as the <em>name</em> argument. If no environment variable with the specified name exists, then <em>getenv()</em> returns <span class="literal">NULL</span>.</p>
<p class="indentb">Note the following portability considerations when using <em>getenv()</em>:</p>
<p class="bull">&#8226; SUSv3 stipulates that an application should not modify the string returned by <em>getenv()</em>. This is because (in most implementations) this string is actually part of the environment (i.e., the <em>value</em> part of the <em>name=value</em> string). If we need to change the value of an environment variable, then we can use the <em>setenv()</em> or <em>putenv()</em> functions (described below).</p>
<p class="bull"><span epub:type="pagebreak" id="page_128"/>&#8226; SUSv3 permits an implementation of <em>getenv()</em> to return its result using a statically allocated buffer that may be overwritten by subsequent calls to <em>getenv()</em>, <em>setenv()</em>, <em>putenv()</em>, or <em>unsetenv()</em>. Although the <em>glibc</em> implementation of <em>getenv()</em> doesn&#8217;t use a static buffer in this way, a portable program that needs to preserve the string returned by a call to <em>getenv()</em> should copy it to a different location before making a subsequent call to one of these functions.</p>
<h5 class="h5" id="ch06lev3sec02"><strong>Modifying the environment</strong></h5>
<p class="noindenta">Sometimes, it is useful for a process to modify its environment. One reason is to make a change that is visible in all child processes subsequently created by that process. Another possibility is that we want to set a variable that is visible to a new program to be loaded into the memory of this process (&#8220;execed&#8221;). In this sense, the environment is not just a form of interprocess communication, but also a method of interprogram communication. (This point will become clearer in <a href="ch27.xhtml#ch27">Chapter 27</a>, where we explain how the <em>exec()</em> functions permit a program to replace itself by a new program within the same process.)</p>
<p class="indent">The <em>putenv()</em> function adds a new variable to the calling process&#8217;s environment or modifies the value of an existing variable.</p>
<div class="box">
<p class="programsa">#include &lt;stdlib.h&gt;<br/><br/>int <span class="codestrong">putenv</span>(char *<span class="font1">string</span>);</p>
<p class="right">Returns 0 on success, or nonzero on error</p>
</div>
<p class="noindent">The <em>string</em> argument is a pointer to a string of the form <em>name=value</em>. After the <em>putenv()</em> call, this string is part of the environment. In other words, rather than duplicating the string pointed to by <em>string</em>, one of the elements of <em>environ</em> will be set to point to the same location as <em>string</em>. Therefore, if we subsequently modify the bytes pointed to by <em>string</em>, that change will affect the process environment. For this reason, <em>string</em> should not be an automatic variable (i.e., a character array allocated on the stack), since this memory area may be overwritten once the function in which the variable is defined returns.</p>
<p class="indent">Note that <em>putenv()</em> returns a nonzero value on error, rather than &#8211;1.</p>
<p class="indent">The <em>glibc</em> implementation of <em>putenv()</em> provides a nonstandard extension. If <em>string</em> doesn&#8217;t contain an equal sign (<span class="literal">=</span>), then the environment variable identified by <em>string</em> is removed from the environment list.</p>
<p class="indent">The <em>setenv()</em> function is an alternative to <em>putenv()</em> for adding a variable to the environment.</p>
<div class="box">
<p class="programsa">#include &lt;stdlib.h&gt;<br/><br/>int <span class="codestrong">setenv</span>(const char *<span class="font1">name</span>, const char *<span class="font1">value</span>, int <span class="font1">overwrite</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_129"/>The <em>setenv()</em> function creates a new environment variable by allocating a memory buffer for a string of the form <em>name=value</em>, and copying the strings pointed to by <em>name</em> and <em>value</em> into that buffer. Note that we don&#8217;t need to (in fact, must not) supply an equal sign at the end of <em>name</em> or the start of <em>value</em>, because <em>setenv()</em> adds this character when it adds the new definition to the environment.</p>
<p class="indent">The <em>setenv()</em> function doesn&#8217;t change the environment if the variable identified by <em>name</em> already exists and <em>overwrite</em> has the value 0. If <em>overwrite</em> is nonzero, the environment is always changed.</p>
<p class="indent">The fact that <em>setenv()</em> copies its arguments means that, unlike with <em>putenv()</em>, we can subsequently modify the contents of the strings pointed to by <em>name</em> and <em>value</em> without affecting the environment. It also means that using automatic variables as arguments to <em>setenv()</em> doesn&#8217;t cause any problems.</p>
<p class="indent">The <em>unsetenv()</em> function removes the variable identified by <em>name</em> from the environment.</p>
<div class="box">
<p class="programsa">#include &lt;stdlib.h&gt;<br/><br/>int <span class="codestrong">unsetenv</span>(const char *<span class="font1">name</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">As with <em>setenv()</em>, <em>name</em> should not include an equal sign.</p>
<p class="indent">Both <em>setenv()</em> and <em>unsetenv()</em> derive from BSD, and are less widespread than <em>putenv()</em>. Although not defined in the original POSIX.1 standard or in SUSv2, they are included in SUSv3.</p>
<div class="block">
<p class="noindent">In versions of <em>glibc</em> before 2.2.2, <em>unsetenv()</em> was prototyped as returning <em>void</em>. This was how <em>unsetenv()</em> was prototyped in the original BSD implementation, and some UNIX implementations still follow the BSD prototype.</p>
</div>
<p class="noindent">On occasion, it is useful to erase the entire environment, and then rebuild it with selected values. For example, we might do this in order to execute set-user-ID programs in a secure manner (<a href="ch38.xhtml#ch38lev1sec08">Section 38.8</a>). We can erase the environment by assigning <span class="literal">NULL</span> to <em>environ</em>:</p>
<p class="programs">environ = NULL;</p>
<p class="noindent">This is exactly the step performed by the <em>clearenv()</em> library function.</p>
<div class="box">
<p class="programsa">#define _BSD_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Or: #define _SVID_SOURCE */<br/>#include &lt;stdlib.h&gt;<br/><br/>int <span class="codestrong">clearenv</span>(void)</p>
<p class="right">Returns 0 on success, or a nonzero on error</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_130"/>In some circumstances, the use of <em>setenv()</em> and <em>clearenv()</em> can lead to memory leaks in a program. We noted above that <em>setenv()</em> allocates a memory buffer that is then made part of the environment. When we call <em>clearenv()</em>, it doesn&#8217;t free this buffer (it can&#8217;t, since it doesn&#8217;t know of the buffer&#8217;s existence). A program that repeatedly employed these two functions would steadily leak memory. In practice, this is unlikely to be a problem, because a program typically calls <em>clearenv()</em> just once on startup, in order to remove all entries from the environment that it inherited from its predecessor (i.e., the program that called <em>exec()</em> to start this program).</p>
<div class="block">
<p class="noindent">Many UNIX implementations provide <em>clearenv()</em>, but it is not specified in SUSv3. SUSv3 specifies that if an application directly modifies <em>environ</em>, as is done by <em>clearenv()</em>, then the behavior of <em>setenv()</em>, <em>unsetenv()</em>, and <em>getenv()</em> is undefined. (The rationale behind this is that preventing a conforming application from directly modifying the environment allows the implementation full control over the data structures that it uses to implement environment variables.) The only way that SUSv3 permits an application to clear its environment is to obtain a list of all environment variables (by getting the names from <em>environ</em>), and then using <em>unsetenv()</em> to remove each of these names.</p>
</div>
<h5 class="h5" id="ch06lev3sec03"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch06.xhtml#ch6ex4">Listing 6-4</a> demonstrates the use of all of the functions discussed in this section. After first clearing the environment, this program adds any environment definitions provided as command-line arguments. It then: adds a definition for a variable called <span class="literal">GREET</span>, if one doesn&#8217;t already exist in the environment; removes any definition for a variable named <span class="literal">BYE</span>; and, finally, prints the current environment list. Here is an example of the output produced when the program is run:</p>
<p class="programs">$ <span class="codestrong">./modify_env "GREET=Guten Tag" SHELL=/bin/bash BYE=Ciao</span><br/>GREET=Guten Tag<br/>SHELL=/bin/bash<br/>$ <span class="codestrong">./modify_env SHELL=/bin/sh BYE=byebye</span><br/>SHELL=/bin/sh<br/>GREET=Hello world</p>
<p class="noindent">If we assign <span class="literal">NULL</span> to <em>environ</em> (as is done by the call to <em>clearenv()</em> in <a href="ch06.xhtml#ch6ex4">Listing 6-4</a>), then we would expect that a loop of the following form (as used in the program) would fail, since <em>*environ</em> is invalid:</p>
<p class="programs">for (ep = environ; *ep != NULL; ep++)<br/>&#160;&#160;&#160;&#160;puts(*ep);</p>
<p class="noindent">However, if <em>setenv()</em> and <em>putenv()</em> find that <em>environ</em> is <span class="literal">NULL</span>, they create a new environment list and set <em>environ</em> pointing to it, with the result that the above loop operates correctly.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_131"/><a id="ch6ex4"/><strong>Listing 6-4:</strong> Modifying the process environment</p>
<p class="programsli">_________________________________________________________ <span class="codestrong">proc/modify_env.c</span><br/><br/>#define _GNU_SOURCE&#160;&#160;&#160;&#160;&#160;/* To get various declarations from &lt;stdlib.h&gt; */<br/>#include &lt;stdlib.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>extern char **environ;<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int j;<br/>&#160;&#160;&#160;&#160;char **ep;<br/><br/>&#160;&#160;&#160;&#160;clearenv();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Erase entire environment */<br/><br/>&#160;&#160;&#160;&#160;for (j = 1; j &lt; argc; j++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (putenv(argv[j]) != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("putenv: %s", argv[j]);<br/><br/>&#160;&#160;&#160;&#160;if (setenv("GREET", "Hello world", 0) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("setenv");<br/><br/>&#160;&#160;&#160;&#160;unsetenv("BYE");<br/><br/>&#160;&#160;&#160;&#160;for (ep = environ; *ep != NULL; ep++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;puts(*ep);<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________________ <span class="codestrong">proc/modify_env.c</span></p>
<h3 class="h3" id="ch06lev1sec08"><strong>6.8 Performing a Nonlocal Goto: <em>setjmp()</em> and <em>longjmp()</em></strong></h3>
<p class="noindenta">The <em>setjmp()</em> and <em>longjmp()</em> library functions are used to perform a <em>nonlocal goto</em>. The term <em>nonlocal</em> refers to the fact that the target of the goto is a location somewhere outside the currently executing function.</p>
<p class="indent">Like many programming languages, C includes the <span class="literal">goto</span> statement, which is open to endless abuse in making programs difficult to read and maintain, and is occasionally useful to make a program simpler, faster, or both.</p>
<p class="indent">One restriction of C&#8217;s <span class="literal">goto</span> is that it is not possible to jump out of the current function into another function. However, such functionality can occasionally be useful. Consider the following common scenario in error handling: during a deeply nested function call, we encounter an error that should be handled by abandoning the current task, returning through multiple function calls, and then continuing execution in some much higher function (perhaps even <em>main()</em>). To do this, we could have each function return a status value that is checked and appropriately <span epub:type="pagebreak" id="page_132"/>handled by its caller. This is perfectly valid, and, in many cases, the desirable method for handling this kind of scenario. However, in some cases, coding would be simpler if we could jump from the middle of the nested function call back to one of the functions that called it (the immediate caller, or the caller of the caller, and so on). This is the functionality that <em>setjmp()</em> and <em>longjmp()</em> provide.</p>
<div class="block">
<p class="noindent">The restriction that a <span class="literal">goto</span> can&#8217;t be used to jump between functions in C exists because all C functions reside at the same scope level (i.e., there is no nesting of function declarations in standard C, although <em>gcc</em> does permit this as an extension). Thus, given two functions, X and Y, the compiler has no way of knowing whether a stack frame for function X might be on the stack at the time Y is invoked, and thus whether a <span class="literal">goto</span> from function Y to function X would be possible. In languages such as Pascal, where function declarations can be nested, and a <span class="literal">goto</span> from a nested function to a function that encloses it is permitted, the static scope of a function allows the compiler to determine some information about the dynamic scope of the function. Thus, if function Y is lexically nested within function X, then the compiler knows that a stack frame for X must already be on the stack at the time Y is invoked, and can generate code for a <span class="literal">goto</span> from function Y to somewhere within function X.</p>
</div>
<div class="box">
<p class="programsa">#include &lt;setjmp.h&gt;<br/><br/>int <span class="codestrong">setjmp</span>(jmp_buf <span class="font1">env</span>);</p>
<p class="right">Returns 0 on initial call, nonzero on return via <em>longjmp()</em></p>
<p class="programsat">void <span class="codestrong">longjmp</span>(jmp_buf <span class="font1">env</span>, int <span class="font1">val</span>);</p>
</div>
<p class="noindent">Calling <em>setjmp()</em> establishes a target for a later jump performed by <em>longjmp()</em>. This target is exactly the point in the program where the <em>setjmp()</em> call occurred. From a programming point of view, after the <em>longjmp()</em>, it looks exactly as though we have just returned from the <em>setjmp()</em> call for a second time. The way in which we distinguish the second &#8220;return&#8221; from the initial return is by the integer value returned by <em>setjmp()</em>. The initial <em>setjmp()</em> returns 0, while the later &#8220;faked&#8221; return supplies whatever value is specified in the <em>val</em> argument of the <em>longjmp()</em> call. By using different values for the <em>val</em> argument, we can distinguish jumps to the same target from different points in the program.</p>
<p class="indent">Specifying the <em>val</em> argument to <em>longjmp()</em> as 0 would, if unchecked, cause the faked return from <em>setjmp()</em> to look as though it were the initial return. For this reason, if <em>val</em> is specified as 0, <em>longjmp()</em> actually uses the value 1.</p>
<p class="indent">The <em>env</em> argument used by both functions supplies the glue enabling the jump to be accomplished. The <em>setjmp()</em> call saves various information about the current process environment into <em>env</em>. This allows the <em>longjmp()</em> call, which must specify the <span epub:type="pagebreak" id="page_133"/>same <em>env</em> variable, to perform the fake return. Since the <em>setjmp()</em> and <em>longjmp()</em> calls are in different functions (otherwise, we could use a simple <span class="literal">goto</span>), <em>env</em> is declared globally or, less commonly, passed as a function argument.</p>
<p class="indentb">Along with other information, <em>env</em> stores a copy of the <em>program counter</em> register (which points to the currently executing machine-language instruction) and the <em>stack pointer</em> register (which marks the top of the stack) at the time of the call to <em>setjmp()</em>. This information enables the subsequent <em>longjmp()</em> call to accomplish two key steps:</p>
<p class="bull">&#8226; Strip off the stack frames for all of the intervening functions on the stack between the function calling <em>longjmp()</em> and the function that previously called <em>setjmp()</em>. This procedure is sometimes called &#8220;unwinding the stack,&#8221; and is accomplished by resetting the stack pointer register to the value saved in the <em>env</em> argument.</p>
<p class="bull">&#8226; Reset the program counter register so that the program continues execution from the location of the initial <em>setjmp()</em> call. Again, this is accomplished using the value saved in <em>env</em>.</p>
<h5 class="h5" id="ch06lev3sec04"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch06.xhtml#ch6ex5">Listing 6-5</a> demonstrates the use of <em>setjmp()</em> and <em>longjmp()</em>. This program sets up a jump target with an initial call to <em>setjmp()</em>. The subsequent <span class="literal">switch</span> (on the value returned by <em>setjmp()</em>) is the means of detecting whether we have just completed the initial return from <em>setjmp()</em> or whether we have arrived back after a <em>longjmp()</em>. In the case of a 0 return&#8212;meaning we have just done the initial <em>setjmp()</em>&#8212;we call <em>f1()</em>, which either immediately calls <em>longjmp()</em> or goes on to call <em>f2()</em>, depending on the value of <em>argc</em> (i.e., the number of command-line arguments). If <em>f2()</em> is reached, it does an immediate <em>longjmp()</em>. A <em>longjmp()</em> from either function takes us back to the point of the <em>setjmp()</em> call. We use different <em>val</em> arguments in the two <em>longjmp()</em> calls, so that the <span class="literal">switch</span> statement in <em>main()</em> can determine the function from which the jump occurred and print a suitable message.</p>
<p class="indent">When we run the program in <a href="ch06.xhtml#ch6ex5">Listing 6-5</a> without any command-line arguments, this is what we see:</p>
<p class="programs">$ <span class="codestrong">./longjmp</span><br/>Calling f1() after initial setjmp()<br/>We jumped back from f1()</p>
<p class="noindent">Specifying a command-line argument causes the jump to occur from <em>f2()</em>:</p>
<p class="programs">$ <span class="codestrong">./longjmp x</span><br/>Calling f1() after initial setjmp()<br/>We jumped back from f2()</p>
<p class="examplet"><span epub:type="pagebreak" id="page_134"/><a id="ch6ex5"/><strong>Listing 6-5:</strong> Demonstrate the use of <em>setjmp()</em> and <em>longjmp()</em></p>
<p class="programsli">___________________________________________________________ <span class="codestrong">proc/longjmp.c</span><br/><br/>#include &lt;setjmp.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static jmp_buf env;<br/><br/>static void<br/>f2(void)<br/>{<br/>&#160;&#160;&#160;&#160;longjmp(env, 2);<br/>}<br/><br/>static void<br/>f1(int argc)<br/>{<br/>&#160;&#160;&#160;&#160;if (argc == 1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;longjmp(env, 1);<br/>&#160;&#160;&#160;&#160;f2();<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;switch (setjmp(env)) {<br/>&#160;&#160;&#160;&#160;case 0:&#160;&#160;&#160;&#160;&#160;/* This is the return after the initial setjmp() */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Calling f1() after initial setjmp()\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;f1(argc);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Never returns... */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* ... but this is good form */<br/><br/>&#160;&#160;&#160;&#160;case 1:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("We jumped back from f1()\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;case 2:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("We jumped back from f2()\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>___________________________________________________________ <span class="codestrong">proc/longjmp.c</span></p>
<h5 class="h5" id="ch06lev3sec05"><strong>Restrictions on the use of <em>setjmp()</em></strong></h5>
<p class="noindentab">SUSv3 and C99 specify that a call to <em>setjmp()</em> may appear only in the following contexts:</p>
<p class="bull">&#8226; as the entire controlling expression of a selection or iteration statement (<span class="literal">if</span>, <span class="literal">switch</span>, <span class="literal">while</span>, and so on);</p>
<p class="bull">&#8226; as the operand of a unary <span class="literal">!</span> (<em>not</em>) operator, where the resulting expression is the entire controlling expression of a selection or iteration statement;</p>
<p class="bull"><span epub:type="pagebreak" id="page_135"/>&#8226; as part of a comparison operation (<span class="literal">==</span>, <span class="literal">!=</span>, <span class="literal">&lt;</span>, and so on), where the other operand is an integer constant expression and the resulting expression is the entire controlling expression of a selection or iteration statement; or</p>
<p class="bull">&#8226; as a free-standing function call that is not embedded inside some larger expression.</p>
<p class="noindentt">Note that the C assignment statement doesn&#8217;t figure in the list above. A statement of the following form is not standards-conformant:</p>
<p class="programs">s = setjmp(env);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* WRONG! */</p>
<p class="noindent">These restrictions are specified because an implementation of <em>setjmp()</em> as a conventional function can&#8217;t be guaranteed to have enough information to be able to save the values of all registers and temporary stack locations used in an enclosing expression so that they could then be correctly restored after a <em>longjmp()</em>. Thus, it is permitted to call <em>setjmp()</em> only inside expressions simple enough not to require temporary storage.</p>
<h5 class="h5" id="ch06lev3sec06"><strong>Abusing <em>longjmp()</em></strong></h5>
<p class="noindenta">If the <em>env</em> buffer is declared global to all functions (which is typical), then it is possible to execute the following sequence of steps:</p>
<ol>
<li class="order"><p class="orderp">Call a function <em>x()</em> that uses <em>setjmp()</em> to establish a jump target in the global variable <em>env</em>.</p></li>
<li class="order"><p class="orderp">Return from function <em>x()</em>.</p></li>
<li class="order"><p class="orderp">Call a function <em>y()</em> that does a <em>longjmp()</em> using <em>env</em>.</p></li>
</ol>
<p class="noindent">This is a serious error. We can&#8217;t do a <em>longjmp()</em> into a function that has already returned. Considering what <em>longjmp()</em> tries to do to the stack&#8212;it attempts to unwind the stack back to a frame that no longer exists&#8212;leads us to realize that chaos will result. If we are lucky, our program will simply crash. However, depending on the state of the stack, other possibilities include infinite call-return loops and the program behaving as though it really did return from a function that was not currently executing. (In a multithreaded program, a similar abuse is to call <em>longjmp()</em> in a different thread from that in which <em>setjmp()</em> was called.)</p>
<div class="block">
<p class="noindent">SUSv3 says that if <em>longjmp()</em> is called from within a nested signal handler (i.e., a handler that was invoked while the handler for another signal was executing), then the program behavior is undefined.</p>
</div>
<h5 class="h5" id="ch06lev3sec07"><strong>Problems with optimizing compilers</strong></h5>
<p class="noindenta">Optimizing compilers may rearrange the order of instructions in a program and store certain variables in CPU registers, rather than RAM. Such optimizations generally rely on the run-time flow of control reflecting the lexical structure of the program. Since jump operations performed via <em>setjmp()</em> and <em>longjmp()</em> are established and executed at run time, and are not reflected in the lexical structure of the program, a compiler optimizer is unable to take them into account when performing its task. Furthermore, the semantics of some ABI implementations require <em>longjmp()</em> to restore copies of the CPU registers saved by the earlier <em>setjmp()</em> call. <span epub:type="pagebreak" id="page_136"/>This means that optimized variables may end up with incorrect values as a consequence of a <em>longjmp()</em> operation. We can see an example of this by examining the behavior of the program in <a href="ch06.xhtml#ch6ex6">Listing 6-6</a>.</p>
<p class="examplet"><a id="ch6ex6"/><strong>Listing 6-6:</strong> A demonstration of the interaction of compiler optimization and <em>longjmp()</em></p>
<p class="programsli">________________________________________________________<span class="codestrong">proc/setjmp_vars.c</span><br/><br/>#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;setjmp.h&gt;<br/><br/>static jmp_buf env;<br/><br/>static void<br/>doJump(int nvar, int rvar, int vvar)<br/>{<br/>&#160;&#160;&#160;&#160;printf("Inside doJump(): nvar=%d rvar=%d vvar=%d\n", nvar, rvar, vvar);<br/>&#160;&#160;&#160;&#160;longjmp(env, 1);<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int nvar;<br/>&#160;&#160;&#160;&#160;register int rvar;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allocated in register if possible */<br/>&#160;&#160;&#160;&#160;volatile int vvar;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* See text */<br/><br/>&#160;&#160;&#160;&#160;nvar = 111;<br/>&#160;&#160;&#160;&#160;rvar = 222;<br/>&#160;&#160;&#160;&#160;vvar = 333;<br/><br/>&#160;&#160;&#160;&#160;if (setjmp(env) == 0) {&#160;&#160;&#160;&#160;&#160;/* Code executed after setjmp() */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nvar = 777;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rvar = 888;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;vvar = 999;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;doJump(nvar, rvar, vvar);<br/><br/>&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Code executed after longjmp() */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("After longjmp(): nvar=%d rvar=%d vvar=%d\n", nvar, rvar, vvar);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>________________________________________________________<span class="codestrong">proc/setjmp_vars.c</span></p>
<p class="noindent">When we compile the program in <a href="ch06.xhtml#ch6ex6">Listing 6-6</a> without optimization, we see the expected output:</p>
<p class="programs">$ <span class="codestrong">cc -o setjmp_vars setjmp_vars.c</span><br/>$ <span class="codestrong">./setjmp_vars</span><br/>Inside doJump(): nvar=777 rvar=888 vvar=999<br/>After longjmp(): nvar=777 rvar=888 vvar=999</p>
<p class="noindent"><span epub:type="pagebreak" id="page_137"/>However, when we compile with optimization, we get the following unexpected results:</p>
<p class="programs">$ <span class="codestrong">cc -O -o setjmp_vars setjmp_vars.c</span><br/>$ <span class="codestrong">./setjmp_vars</span><br/>Inside doJump(): nvar=777 rvar=888 vvar=999<br/>After longjmp(): nvar=111 rvar=222 vvar=999</p>
<p class="noindent">Here, we see that after the <em>longjmp()</em>, <em>nvar</em> and <em>rvar</em> have been reset to their values at the time of the <em>setjmp()</em> call. This has occurred because the code reorganization performed by the optimizer has been confused as a consequence of the <em>longjmp()</em>. Any local variables that are candidates for optimization may be subject to this sort of problem; this generally means pointer variables and variables of any of the simple types <em>char</em>, <em>int</em>, <em>float</em>, and <em>long</em>.</p>
<p class="indent">We can prevent such code reorganization by declaring variables as <span class="literal">volatile</span>, which tells the optimizer not to optimize them. In the preceding program output, we see that the variable <em>vvar</em>, which was declared <span class="literal">volatile</span>, was correctly handled, even when we compiled with optimization.</p>
<p class="indent">Since different compilers do different types of optimizations, portable programs should employ the <span class="literal">volatile</span> keyword with all of the local variables of the aforementioned types in the function that calls <em>setjmp()</em>.</p>
<p class="indent">If we specify the <em>&#8211;Wextra</em> (<em>extra warnings</em>) option to the GNU C compiler, it produces the following helpful warning for the <span class="literal">setjmp_vars.c</span> program:</p>
<p class="programs">$ <span class="codestrong">cc -Wall -Wextra -O -o setjmp_vars setjmp_vars.c</span><br/>setjmp_vars.c: In function `main':<br/>setjmp_vars.c:17: warning: variable `nvar' might be clobbered by `longjmp' or<br/>`vfork'<br/>setjmp_vars.c:18: warning: variable `rvar' might be clobbered by `longjmp' or<br/>`vfork'</p>
<div class="block">
<p class="noindent">It is instructive to look at the assembler output produced when compiling the <span class="literal">setjmp_vars.c</span> program both with and without optimization. The <em>cc &#8211;S</em> command produces a file with the extension <em>.s</em> containing the generated assembler code for a program.</p>
</div>
<h5 class="h5" id="ch06lev3sec08"><strong>Avoid <em>setjmp()</em> and <em>longjmp()</em> where possible</strong></h5>
<p class="noindenta">If <span class="literal">goto</span> statements are capable of rendering a program difficult to read, then nonlocal gotos can make things an order of magnitude worse, since they can transfer control between any two functions in a program. For this reason, <em>setjmp()</em> and <em>longjmp()</em> should be used sparingly. It is often worth the extra work in design and coding to come up with a program that avoids their use, because the program will be more readable and possibly more portable. Having said that, we revisit variants of these functions (<em>sigsetjmp()</em> and <em>siglongjmp()</em>, described in <a href="ch21.xhtml#ch21lev2sec04">Section 21.2.1</a>) when we discuss signals, since they are occasionally useful when writing signal handlers.</p>
<h3 class="h3" id="ch06lev1sec09"><span epub:type="pagebreak" id="page_138"/><strong>6.9 Summary</strong></h3>
<p class="noindenta">Each process has a unique process ID and maintains a record of its parent&#8217;s process ID.</p>
<p class="indent">The virtual memory of a process is logically divided into a number of segments: text, (initialized and uninitialized) data, stack, and heap.</p>
<p class="indent">The stack consists of a series of frames, with a new frame being added as a function is invoked and removed when the function returns. Each frame contains the local variables, function arguments, and call linkage information for a single function invocation.</p>
<p class="indent">The command-line arguments supplied when a program is invoked are made available via the <em>argc</em> and <em>argv</em> arguments to <em>main()</em>. By convention, <em>argv[0]</em> contains the name used to invoke the program.</p>
<p class="indent">Each process receives a copy of its parent&#8217;s environment list, a set of name-value pairs. The global variable <em>environ</em> and various library functions allow a process to access and modify the variables in its environment list.</p>
<p class="indent">The <em>setjmp()</em> and <em>longjmp()</em> functions provide a way to perform a nonlocal goto from one function to another (unwinding the stack). In order to avoid problems with compiler optimization, we may need to declare variables with the <span class="literal">volatile</span> modifier when making use of these functions. Nonlocal gotos can render a program difficult to read and maintain, and should be avoided whenever possible.</p>
<h5 class="h5" id="ch06lev3sec09"><strong>Further information</strong></h5>
<p class="noindenta">[<a href="bib.xhtml#bib99">Tanenbaum, 2007</a>] and [<a href="bib.xhtml#bib104">Vahalia, 1996</a>] describe virtual memory management in detail. The Linux kernel memory management algorithms and code are described in detail in [<a href="bib.xhtml#bib37">Gorman, 2004</a>].</p>
<h3 class="h3" id="ch06lev1sec10"><strong>6.10 Exercises</strong></h3>
<p class="exer"><a id="ch6exe1"/><strong>6-1.</strong>&#160;&#160;&#160;&#160;&#160;Compile the program in <a href="ch06.xhtml#ch6ex1">Listing 6-1</a> (<span class="literal">mem_segments.c</span>), and list its size using <em>ls &#8211;l</em>. Although the program contains an array (<em>mbuf</em>) that is around 10 MB in size, the executable file is much smaller than this. Why is this?</p>
<p class="exer"><a id="ch6exe2"/><strong>6-2.</strong>&#160;&#160;&#160;&#160;&#160;Write a program to see what happens if we try to <em>longjmp()</em> into a function that has already returned.</p>
<p class="exer"><a id="ch6exe3"/><strong>6-3.</strong>&#160;&#160;&#160;&#160;&#160;Implement <em>setenv()</em> and <em>unsetenv()</em> using <em>getenv()</em>, <em>putenv()</em>, and, where necessary, code that directly modifies <em>environ</em>. Your version of <em>unsetenv()</em> should check to see whether there are multiple definitions of an environment variable, and remove them all (which is what the <em>glibc</em> version of <em>unsetenv()</em> does).</p>
</body>
</html>
