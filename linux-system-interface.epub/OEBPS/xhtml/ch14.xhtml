<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch14"><span epub:type="pagebreak" id="page_251"/><strong><span class="big">14</span></strong><br/><strong>FILE SYSTEMS</strong></h2>
<p class="noindentab">In <a href="ch04.xhtml#ch04">Chapters 4</a>, <a href="ch05.xhtml#ch05">5</a>, and <a href="ch13.xhtml#ch13">13</a>, we looked at file I/O, with a particular focus on regular (i.e., disk) files. In this and the following chapters, we go into detail on a range of file-related topics:</p>
<p class="bull">&#8226; This chapter looks at file systems.</p>
<p class="bull">&#8226; <a href="ch15.xhtml#ch15">Chapter 15</a> describes various attributes associated with a file, including the timestamps, ownership, and permissions.</p>
<p class="bull">&#8226; <a href="ch16.xhtml#ch16">Chapters 16</a> and <a href="ch17.xhtml#ch17">17</a> consider two new features of Linux 2.6: extended attributes and access control lists (ACLs). Extended attributes are a method of associating arbitrary metadata with a file. ACLs are an extension of the traditional UNIX file permission model.</p>
<p class="bull">&#8226; <a href="ch18.xhtml#ch18">Chapter 18</a> looks at directories and links.</p>
<p class="noindentt">The majority of this chapter is concerned with file systems, which are organized collections of files and directories. We explain a range of file-system concepts, sometimes using the traditional Linux <em>ext2</em> file system as a specific example. We also briefly describe some of the journaling file systems available on Linux.</p>
<p class="indent">We conclude the chapter with a discussion of the system calls used to mount and unmount a file system, and the library functions used to obtain information about mounted file systems.</p>
<h3 class="h3" id="ch14lev1sec01"><span epub:type="pagebreak" id="page_252"/><strong>14.1 Device Special Files (Devices)</strong></h3>
<p class="noindenta">This chapter frequently mentions disk devices, so we start with a brief overview of the concept of a device file.</p>
<p class="indent">A device special file corresponds to a device on the system. Within the kernel, each device type has a corresponding device driver, which handles all I/O requests for the device. A <em>device driver</em> is a unit of kernel code that implements a set of operations that (normally) correspond to input and output actions on an associated piece of hardware. The API provided by device drivers is fixed, and includes operations corresponding to the system calls <em>open()</em>, <em>close()</em>, <em>read()</em>, <em>write()</em>, <em>mmap()</em>, and <em>ioctl()</em>. The fact that each device driver provides a consistent interface, hiding the differences in operation of individual devices, allows for <em>universality of I/O</em> (<a href="ch04.xhtml#ch04lev1sec02">Section 4.2</a>).</p>
<p class="indent">Some devices are real, such as mice, disks, and tape drives. Others are <em>virtual</em>, meaning that there is no corresponding hardware; rather, the kernel provides (via a device driver) an abstract device with an API that is the same as a real device.</p>
<p class="indentb">Devices can be divided into two types:</p>
<p class="bull">&#8226; <em>Character devices</em> handle data on a character-by-character basis. Terminals and keyboards are examples of character devices.</p>
<p class="bull">&#8226; <em>Block devices</em> handle data a block at a time. The size of a block depends on the type of device, but is typically some multiple of 512 bytes. Disks are a common example of block devices.</p>
<p class="noindentt">Device files appear within the file system, just like other files, usually under the <span class="literal">/dev</span> directory. The superuser can create a device file using the <em>mknod</em> command, and the same task can be performed in a privileged (<span class="literal">CAP_MKNOD</span>) program using the <em>mknod()</em> system call.</p>
<div class="block">
<p class="noindent">We don&#8217;t describe the <em>mknod()</em> (&#8220;make file-system i-node&#8221;) system call in detail since its use is straightforward, and the only purpose for which it is required nowadays is to create device files, which is not a common application requirement. We can also use <em>mknod()</em> to create FIFOs (<a href="ch44.xhtml#ch44lev1sec07">Section 44.7</a>), but the <em>mkfifo()</em> function is preferred for this task. Historically, some UNIX implementations also used <em>mknod()</em> for creating directories, but this use has now been replaced by the <em>mkdir()</em> system call. Nevertheless, some UNIX implementations&#8212;but not Linux&#8212;preserve this capability in <em>mknod()</em> for backward compatibility. See the <em>mknod(2)</em> manual page for further details.</p>
</div>
<p class="noindent">In earlier versions of Linux, <span class="literal">/dev</span> contained entries for all possible devices on the system, even if such devices weren&#8217;t actually connected to the system. This meant that <span class="literal">/dev</span> could contain literally thousands of unused entries, slowing the task of programs that needed to scan the contents of that directory, and making it impossible to use the contents of the directory as a means of discovering which devices were actually present on the system. In Linux 2.6, these problems are solved by the <em>udev</em> program. The <em>udev</em> program relies on the <em>sysfs</em> file system, which exports information about devices and other kernel objects into user space via a pseudo-file system mounted under <span class="literal">/sys</span>.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_253"/>[<a href="bib.xhtml#bib50">Kroah-Hartman, 2003</a>] provides an overview of <em>udev</em>, and outlines the reasons it is considered superior to <em>devfs</em>, the Linux 2.4 solution to the same problems. Information about the <em>sysfs</em> file system can be found in the Linux 2.6 kernel source file <span class="literal">Documentation/filesystems/sysfs.txt</span> and in [<a href="bib.xhtml#bib70">Mochel, 2005</a>].</p>
</div>
<h5 class="h5" id="ch14lev3sec01"><strong>Device IDs</strong></h5>
<p class="noindenta">Each device file has a <em>major ID number</em> and a <em>minor ID number</em>. The major ID identifies the general class of device, and is used by the kernel to look up the appropriate driver for this type of device. The minor ID uniquely identifies a particular device within a general class. The major and minor IDs of a device file are displayed by the <em>ls &#8211;l</em> command.</p>
<p class="indent">A device&#8217;s major and minor IDs are recorded in the i-node for the device file. (We describe i-nodes in <a href="ch14.xhtml#ch14lev1sec04">Section 14.4</a>.) Each device driver registers its association with a specific major device ID, and this association provides the connection between the device special file and the device driver. The name of the device file has no relevance when the kernel looks for the device driver.</p>
<p class="indent">On Linux 2.4 and earlier, the total number of devices on the system is limited by the fact that device major and minor IDs are each represented using just 8 bits. The fact that major device IDs are fixed and centrally assigned (by the Linux Assigned Names and Numbers Authority; see <em><a href="http://www.lanana.org/">http://www.lanana.org/</a></em>) further exacerbates this limitation. Linux 2.6 eases this limitation by using more bits to hold the major and minor device IDs (respectively, 12 and 20 bits).</p>
<h3 class="h3" id="ch14lev1sec02"><strong>14.2 Disks and Partitions</strong></h3>
<p class="noindenta">Regular files and directories typically reside on hard disk devices. (Files and directories may also exist on other devices, such as CD-ROMs, flash memory cards, and virtual disks, but for the present discussion, we are interested primarily in hard disk devices.) In the following sections, we look at how disks are organized and divided into partitions.</p>
<h5 class="h5" id="ch14lev3sec02"><strong>Disk drives</strong></h5>
<p class="noindenta">A hard disk drive is a mechanical device consisting of one or more platters that rotate at high speed (of the order of thousands of revolutions per minute). Magnetically encoded information on the disk surface is retrieved or modified by read/write heads that move radially across the disk. Physically, information on the disk surface is located on a set of concentric circles called <em>tracks</em>. Tracks themselves are divided into a number of <em>sectors</em>, each of which consists of a series of <em>physical</em> blocks. Physical blocks are typically 512 bytes (or some multiple thereof) in size, and represent the smallest unit of information that the drive can read or write.</p>
<p class="indent">Although modern disks are fast, reading and writing information on the disk still takes significant time. The disk head must first move to the appropriate track (seek time), then the drive must wait until the appropriate sector rotates under the head (rotational latency), and finally the required blocks must be transferred (transfer time). The total time required to carry out such an operation is typically of the order of milliseconds. By comparison, modern CPUs are capable of executing millions of instructions in this time.</p>
<h5 class="h5" id="ch14lev3sec03"><span epub:type="pagebreak" id="page_254"/><strong>Disk partitions</strong></h5>
<p class="noindenta">Each disk is divided into one or more (nonoverlapping) <em>partitions</em>. Each partition is treated by the kernel as a separate device residing under the <span class="literal">/dev</span> directory.</p>
<div class="block">
<p class="noindent">The system administrator determines the number, type, and size of partitions on a disk using the <em>fdisk</em> command. The command <em>fdisk &#8211;l</em> lists all partitions on a disk. The Linux-specific <span class="literal">/proc/partitions</span> file lists the major and minor device numbers, size, and name of each disk partition on the system.</p>
</div>
<p class="noindentb">A disk partition may hold any type of information, but usually contains one of the following:</p>
<p class="bull">&#8226; a <em>file system</em> holding regular files and directories, as described in <a href="ch14.xhtml#ch14lev1sec03">Section 14.3</a>;</p>
<p class="bull">&#8226; a <em>data area</em> accessed as a raw-mode device, as described in <a href="ch13.xhtml#ch13lev1sec06">Section 13.6</a> (some database management systems use this technique); or</p>
<p class="bull">&#8226; a <em>swap area</em> used by the kernel for memory management.</p>
<p class="noindentt">A swap area is created using the <em>mkswap(8)</em> command. A privileged (<span class="literal">CAP_SYS_ADMIN</span>) process can use the <em>swapon()</em> system call to notify the kernel that a disk partition is to be used as a swap area. The <em>swapoff()</em> system call performs the converse function, telling the kernel to cease using a disk partition as a swap area. These system calls are not standardized in SUSv3, but they exist on many UNIX implementations. See the <em>swapon(2)</em>, and <em>swapon(8)</em> manual pages for additional information.</p>
<div class="block">
<p class="noindent">The Linux-specific <span class="literal">/proc/swaps</span> file can be used to display information about the currently enabled swap areas on the system. This information includes the size of each swap area and the amount of the area that is in use.</p>
</div>
<h3 class="h3" id="ch14lev1sec03"><strong>14.3 File Systems</strong></h3>
<p class="noindenta">A file system is an organized collection of regular files and directories. A file system is created using the <em>mkfs</em> command.</p>
<p class="indentb">One of the strengths of Linux is that it supports a wide variety of file systems, including the following:</p>
<p class="bull">&#8226; the traditional <em>ext2</em> file system;</p>
<p class="bull">&#8226; various native UNIX file systems such as the Minix, System V, and BSD file systems;</p>
<p class="bull">&#8226; Microsoft&#8217;s FAT, FAT32, and NTFS file systems;</p>
<p class="bull">&#8226; the ISO 9660 CD-ROM file system;</p>
<p class="bull">&#8226; Apple Macintosh&#8217;s HFS;</p>
<p class="bull">&#8226; a range of network file systems, including Sun&#8217;s widely used NFS (information about the Linux implementation of NFS is available at <em><a href="http://nfs.sourceforge.net/">http://nfs.sourceforge.net/</a></em>), IBM and Microsoft&#8217;s SMB, Novell&#8217;s NCP, and the Coda file system developed at Carnegie Mellon University; and</p>
<p class="bull">&#8226; a range of journaling file systems, including <em>ext3</em>, <em>ext4</em>, <em>Reiserfs</em>, <em>JFS</em>, <em>XFS</em>, and <em>Btrfs</em>.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_255"/>The file-system types currently known by the kernel can be viewed in the Linux-specific <span class="literal">/proc/filesystems</span> file.</p>
<div class="block">
<p class="noindent">Linux 2.6.14 added the <em>Filesystem in Userspace</em> (FUSE) facility. This mechanism adds hooks to the kernel that allow a file system to be completely implemented via a user-space program, without needing to patch or recompile the kernel. For further details, see <em><a href="http://fuse.sourceforge.net/">http://fuse.sourceforge.net/</a></em>.</p>
</div>
<h5 class="h5" id="ch14lev3sec04"><strong>The <em>ext2</em> file system</strong></h5>
<p class="noindenta">For many years, the most widely used file system on Linux was <em>ext2</em>, the <em>Second Extended File System</em>, which is the successor to the original Linux file system, <em>ext</em>. In more recent times, the use of <em>ext2</em> has declined in favor of various journaling file systems. Sometimes, it is useful to describe generic file-system concepts in terms of a specific file-system implementation, and for this purpose, we use <em>ext2</em> as an example at various points later in this chapter.</p>
<div class="block">
<p class="noindent">The <em>ext2</em> file system was written by Remy Card. The source code for <em>ext2</em> is small (around 5000 lines of C) and forms the model for several other file-system implementations. The <em>ext2</em> home page is <em><a href="http://e2fsprogs.sourceforge.net/ext2.html">http://e2fsprogs.sourceforge.net/ext2.html</a></em>. This web site includes a good overview paper describing the implementation of <em>ext2</em>. <em>The Linux Kernel</em>, an online book by David Rusling available at <em><a href="http://www.tldp.org/">http://www.tldp.org/</a></em>, also describes <em>ext2</em>.</p>
</div>
<h5 class="h5" id="ch14lev3sec05"><strong>File-system structure</strong></h5>
<p class="noindenta">The basic unit for allocating space in a file system is a <em>logical</em> block, which is some multiple of contiguous physical blocks on the disk device on which the file system resides. For example, the logical block size on <em>ext2</em> is 1024, 2048, or 4096 bytes. (The logical block size is specified as an argument of the <em>mkfs(8)</em> command used to build the file system.)</p>
<div class="block">
<p class="noindent">A privileged (<span class="literal">CAP_SYS_RAWIO</span>) program can use the <span class="literal">FIBMAP</span> <em>ioctl()</em> operation to determine the physical location of a specified block of a file. The third argument of the call is a value-result integer. Before the call, this argument should be set to a logical block number (the first logical block is number 0); after the call, it is set to the number of the starting physical block where that logical block is stored.</p>
</div>
<p class="noindent"><a href="ch14.xhtml#ch14fig1">Figure 14-1</a> shows the relationship between disk partitions and file systems, and shows the parts of a (generic) file system.</p>
<div class="image"><img src="../images/f14-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch14fig1"/><strong>Figure 14-1:</strong> Layout of disk partitions and a file system</p>
<p class="noindentb"><span epub:type="pagebreak" id="page_256"/>A file system contains the following parts:</p>
<p class="bull">&#8226; <em>Boot block</em>: This is always the first block in a file system. The boot block is not used by the file system; rather, it contains information used to boot the operating system. Although only one boot block is needed by the operating system, all file systems have a boot block (most of which are unused).</p>
<p class="bull">&#8226; <em>Superblock</em>: This is a single block, immediately following the boot block, which contains parameter information about the file system, including:</p>
<p class="dash1">&#8211; the size of the i-node table;</p>
<p class="dash1">&#8211; the size of logical blocks in this file system; and</p>
<p class="dash1">&#8211; the size of the file system in logical blocks.</p>
<p class="bullp">Different file systems residing on the same physical device can be of different types and sizes, and have different parameter settings (e.g., block size). This is one of the reasons for splitting a disk into multiple partitions.</p>
<p class="bull">&#8226; <em>I-node table</em>: Each file or directory in the file system has a unique entry in the i-node table. This entry records various information about the file. I-nodes are discussed in greater detail in the next section. The i-node table is sometimes also called the <em>i-list</em>.</p>
<p class="bull">&#8226; <em>Data blocks</em>: The great majority of space in a file system is used for the blocks of data that form the files and directories residing in the file system.</p>
<div class="block">
<p class="noindent">In the specific case of the <em>ext2</em> file system, the picture is somewhat more complex than described in the main text. After the initial boot block, the file system is broken into a set of equal-sized <em>block groups</em>. Each block group contains a copy of the superblock, parameter information about the block group, and then the i-node table and data blocks for this block group. By attempting to store all of the blocks of a file within the same block group, the <em>ext2</em> file system aims to reduce seek time when sequentially accessing a file. For further information, see the Linux source code file <span class="literal">Documentation/filesystems/ext2.txt</span>, the source code of the <em>dumpe2fs</em> program that comes as part of the <em>e2fsprogs</em> package, and [<a href="bib.xhtml#bib09">Bovet &#38; Cesati, 2005</a>].</p>
</div>
<h3 class="h3" id="ch14lev1sec04"><strong>14.4 I-nodes</strong></h3>
<p class="noindentab">A file system&#8217;s i-node table contains one i-node (short for <em>index node</em>) for each file residing in the file system. I-nodes are identified numerically by their sequential location in the i-node table. The <em>i-node number</em> (or simply <em>i-number</em>) of a file is the first field displayed by the <em>ls &#8211;li</em> command. The information maintained in an i-node includes the following:</p>
<p class="bull">&#8226; File type (e.g., regular file, directory, symbolic link, character device).</p>
<p class="bull">&#8226; Owner (also referred to as the user ID or UID) for the file.</p>
<p class="bull">&#8226; Group (also referred to as the group ID or GID) for the file.</p>
<p class="bull">&#8226; Access permissions for three categories of user: <em>owner</em> (sometimes referred to as <em>user</em>), <em>group</em>, and <em>other</em> (the rest of the world). <a href="ch15.xhtml#ch15lev1sec04">Section 15.4</a> provides further details.</p>
<p class="bull"><span epub:type="pagebreak" id="page_257"/>&#8226; Three timestamps: time of last access to the file (shown by <em>ls &#8211;lu</em>), time of last modification of the file (the default time shown by <em>ls &#8211;l</em>), and time of last status change (last change to i-node information, shown by <em>ls &#8211;lc</em>). As on other UNIX implementations, it is notable that most Linux file systems don&#8217;t record the creation time of a file.</p>
<p class="bull">&#8226; Number of hard links to the file.</p>
<p class="bull">&#8226; Size of the file in bytes.</p>
<p class="bull">&#8226; Number of blocks actually allocated to the file, measured in units of 512-byte blocks. There may not be a simple correspondence between this number and the size of the file in bytes, since a file can contain holes (<a href="ch04.xhtml#ch04lev1sec07">Section 4.7</a>), and thus require fewer allocated blocks than would be expected according to its nominal size in bytes.</p>
<p class="bull">&#8226; Pointers to the data blocks of the file.</p>
<h5 class="h5" id="ch14lev3sec06"><strong>I-nodes and data block pointers in <em>ext2</em></strong></h5>
<p class="noindenta">Like most UNIX file systems, the <em>ext2</em> file system doesn&#8217;t store the data blocks of a file contiguously or even in sequential order (though it does attempt to store them close to one another). To locate the file data blocks, the kernel maintains a set of pointers in the i-node. The system used for doing this on the <em>ext2</em> file system is shown in <a href="ch14.xhtml#ch14fig2">Figure 14-2</a>.</p>
<div class="block">
<p class="noindent">Removing the need to store the blocks of a file contiguously allows the file system to use space in an efficient way. In particular, it reduces the incidence of <em>fragmentation</em> of free disk space&#8212;the wastage created by the existence of numerous pieces of noncontiguous free space, all of which are too small to use. Put conversely, we could say that the advantage of efficiently using the free disk space is paid for by fragmenting files in the filled disk space.</p>
</div>
<p class="noindent">Under <em>ext2</em>, each i-node contains 15 pointers. The first 12 of these pointers (numbered 0 to 11 in <a href="ch14.xhtml#ch14fig2">Figure 14-2</a>) point to the location in the file system of the first 12 blocks of the file. The next pointer is a <em>pointer to a block of pointers</em> that give the locations of the thirteenth and subsequent data blocks of the file. The number of pointers in this block depends on the block size of the file system. Each pointer requires 4 bytes, so there may be from 256 pointers (for a 1024-byte block size) to 1024 pointers (for a 4096-byte block size). This allows for quite large files. For even larger files, the fourteenth pointer (numbered 13 in the diagram) is a <em>double indirect pointer</em>&#8212;it points to blocks of pointers that in turn point to blocks of pointers that in turn point to data blocks of the file. And should the need for a truly enormous file arise, there is a further level of indirection: the last pointer in the i-node is a <em>triple-indirect pointer</em>.</p>
<p class="indent">This seemingly complex system is designed to satisfy a number of requirements. To begin with, it allows the i-node structure to be a fixed size, while at the same time allowing for files of an arbitrary size. Additionally, it allows the file system to store the blocks of a file noncontiguously, while also allowing the data to be accessed randomly via <em>lseek()</em>; the kernel just needs to calculate which pointer(s) to follow. Finally, for small files, which form the overwhelming majority of files on most systems, this scheme allows the file data blocks to be accessed rapidly via the direct pointers of the i-node.</p>
<div class="image"><span epub:type="pagebreak" id="page_258"/><img src="../images/f14-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch14fig2"/><strong>Figure 14-2:</strong> Structure of file blocks for a file in an <em>ext2</em> file system</p>
<div class="block">
<p class="noindent">As an example, the author measured one system containing somewhat more than 150,000 files. Just over 30% of the files were less than 1000 bytes in size, and 80% occupied 10,000 bytes or less. Assuming a 1024-byte block size, all of the latter files could be referenced using just the 12 direct pointers, which can refer to blocks containing a total of 12,288 bytes. Using a 4096-byte block size, this limit rises to 49,152 bytes (95% of the files on the system fell under that limit).</p>
</div>
<p class="noindent">This design also allows for enormous file sizes; for a block size of 4096 bytes, the theoretical largest file size is slightly more than 1024*1024*1024*4096, or approximately 4 terabytes (4096 GB). (We say <em>slightly more</em> because of the blocks pointed to by the direct, indirect, and double indirect pointers. These are insignificant compared to the range that can be pointed to by the triple indirect pointer.)</p>
<p class="indent"><span epub:type="pagebreak" id="page_259"/>One other benefit conferred by this design is that files can have holes, as described in <a href="ch04.xhtml#ch04lev1sec07">Section 4.7</a>. Rather than allocate blocks of null bytes for the holes in a file, the file system can just mark (with the value 0) appropriate pointers in the i-node and in the indirect pointer blocks to indicate that they don&#8217;t refer to actual disk blocks.</p>
<h3 class="h3" id="ch14lev1sec05"><strong>14.5 The Virtual File System (VFS)</strong></h3>
<p class="noindentab">Each of the file systems available on Linux differs in the details of its implementation. Such differences include, for example, the way in which the blocks of a file are allocated and the manner in which directories are organized. If every program that worked with files needed to understand the specific details of each file system, the task of writing programs that worked with all of the different file systems would be nearly impossible. The <em>virtual file system</em> (VFS, sometimes also referred to as the <em>virtual file switch</em>) is a kernel feature that resolves this problem by creating an abstraction layer for file-system operations (see <a href="ch14.xhtml#ch14fig3">Figure 14-3</a>). The ideas behind the VFS are straightforward:</p>
<p class="bull">&#8226; The VFS defines a generic interface for file-system operations. All programs that work with files specify their operations in terms of this generic interface.</p>
<p class="bull">&#8226; Each file system provides an implementation for the VFS interface.</p>
<p class="noindentt">Under this scheme, programs need to understand only the VFS interface and can ignore details of individual file-system implementations.</p>
<p class="indent">The VFS interface includes operations corresponding to all of the usual system calls for working with file systems and directories, such as <em>open()</em>, <em>read()</em>, <em>write()</em>, <em>lseek()</em>, <em>close()</em>, <em>truncate()</em>, <em>stat()</em>, <em>mount()</em>, <em>umount()</em>, <em>mmap()</em>, <em>mkdir()</em>, <em>link()</em>, <em>unlink()</em>, <em>symlink()</em>, and <em>rename()</em>.</p>
<p class="indent">The VFS abstraction layer is closely modeled on the traditional UNIX file-system model. Naturally, some file systems&#8212;especially non-UNIX file systems&#8212;don&#8217;t support all of the VFS operations (e.g., Microsoft&#8217;s VFAT doesn&#8217;t support the notion of symbolic links, created using <em>symlink()</em>). In such cases, the underlying file system passes an error code back to the VFS layer indicating the lack of support, and the VFS in turn passes this error code back to the application.</p>
<div class="image"><img src="../images/f14-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch14fig3"/><strong>Figure 14-3:</strong> The virtual file system</p>
<h3 class="h3" id="ch14lev1sec06"><span epub:type="pagebreak" id="page_260"/><strong>14.6 Journaling File Systems</strong></h3>
<p class="noindenta">The <em>ext2</em> file system is a good example of a traditional UNIX file system, and suffers from a classic limitation of such file systems: after a system crash, a file-system consistency check (<em>fsck</em>) must be performed on reboot in order to ensure the integrity of the file system. This is necessary because, at the time of the system crash, a file update may have been only partially completed, and the file-system metadata (directory entries, i-node information, and file data block pointers) may be in an inconsistent state, so that the file system might be further damaged if these inconsistencies are not repaired. A file-system consistency check ensures the consistency of the file-system metadata. Where possible, repairs are performed; otherwise, information that is not retrievable (possibly including file data) is discarded.</p>
<p class="indent">The problem is that a consistency check requires examining the entire file system. On a small file system, this may take anything from several seconds to a few minutes. On a large file system, this may require several hours, which is a serious problem for systems that must maintain high availability (e.g., network servers).</p>
<p class="indent">Journaling file systems eliminate the need for lengthy file-system consistency checks after a system crash. A journaling file system logs (journals) all metadata updates to a special on-disk journal file before they are actually carried out. The updates are logged in groups of related metadata updates (<em>transactions</em>). In the event of a system crash in the middle of a transaction, on system reboot, the log can be used to rapidly redo any incomplete updates and bring the file system back to a consistent state. (To borrow database parlance, we can say that a journaling file system ensures that file metadata transactions are always <em>committed</em> as a complete unit.) Even very large journaling file systems can typically be available within seconds after a system crash, making them very attractive for systems with high-availability requirements.</p>
<p class="indent">The most notable disadvantage of journaling is that it adds time to file updates, though good design can make this overhead low.</p>
<div class="block">
<p class="noindent">Some journaling file systems ensure only the consistency of file metadata. Because they don&#8217;t log file data, data may still be lost in the event of a crash. The <em>ext3</em>, <em>ext4</em>, and <em>Reiserfs</em> file systems provide options for logging data updates, but, depending on the workload, this may result in lower file I/O performance.</p>
</div>
<p class="noindentb">The journaling file systems available for Linux include the following:</p>
<p class="bull">&#8226; <em>Reiserfs</em> was the first of the journaling file systems to be integrated into the kernel (in version 2.4.1). <em>Reiserfs</em> provides a feature called <em>tail packing</em> (or <em>tail merging</em>): small files (and the final fragment of larger files) are packed into the same disk blocks as the file metadata. Because many systems have (and some applications create) large numbers of small files, this can save a significant amount of disk space.</p>
<p class="bull">&#8226; The <em>ext3</em> file system was a result of a project to add journaling to <em>ext2</em> with minimal impact. The migration path from <em>ext2</em> to <em>ext3</em> is very easy (no backup and restore are required), and it is possible to migrate in the reverse direction as well. The <em>ext3</em> file system was integrated into the kernel in version 2.4.15.</p>
<p class="bull"><span epub:type="pagebreak" id="page_261"/>&#8226; <em>JFS</em> was developed at IBM. It was integrated into the 2.4.20 kernel.</p>
<p class="bull">&#8226; <em>XFS</em> (<em><a href="http://oss.sgi.com/projects/xfs/">http://oss.sgi.com/projects/xfs/</a></em>) was originally developed by Silicon Graphics (SGI) in the early 1990s for Irix, its proprietary UNIX implementation. In 2001, <em>XFS</em> was ported to Linux and made available as a free software project. <em>XFS</em> was integrated into the 2.4.24 kernel.</p>
<p class="noindentt">Support for the various file systems is enabled using kernel options that are set under the <em>File systems</em> menu when configuring the kernel.</p>
<p class="indentb">At the time of writing, work is in progress on two other file systems that provide journaling and a range of other advanced features:</p>
<p class="bull">&#8226; The <em>ext4</em> file system (<em><a href="http://ext4.wiki.kernel.org/">http://ext4.wiki.kernel.org/</a></em>) is the successor to <em>ext3</em>. The first pieces of the implementation were added in kernel 2.6.19, and various features were added in later kernel versions. Among the planned (or already implemented) features for <em>ext4</em> are extents (reservation of contiguous blocks of storage) and other allocation features that aim to reduce file fragmentation, online file-system defragmentation, faster file-system checking, and support for nanosecond timestamps.</p>
<p class="bull">&#8226; <em>Btrfs</em> (B-tree FS, usually pronounced &#8220;butter FS&#8221;; <em><a href="http://btrfs.wiki.kernel.org/">http://btrfs.wiki.kernel.org/</a></em>) is a new file system designed from the ground up to provide a range of modern features, including extents, writable snapshots (which provide functionality equivalent to metadata and data journaling), checksums on data and metadata, online file-system checking, online file-system defragmentation, space-efficient packing of small files, and space-efficient indexed directories. It was integrated into the kernel in version 2.6.29.</p>
<h3 class="h3" id="ch14lev1sec07"><strong>14.7 Single Directory Hierarchy and Mount Points</strong></h3>
<p class="noindenta">On Linux, as on other UNIX systems, all files from all file systems reside under a single directory tree. At the base of this tree is the root directory, <span class="literal">/</span> (slash). Other file systems are <em>mounted</em> under the root directory and appear as subtrees within the overall hierarchy. The superuser uses a command of the following form to mount a file system:</p>
<p class="programs">$ <span class="codestrong">mount <span class="codeitalic">device directory</span></span></p>
<p class="noindent">This command attaches the file system on the named <em>device</em> into the directory hierarchy at the specified <em>directory</em>&#8212;the file system&#8217;s <em>mount point</em>. It is possible to change the location at which a file system is mounted&#8212;the file system is unmounted using the <em>umount</em> command, and then mounted once more at a different point.</p>
<div class="block">
<p class="noindent">With Linux 2.4.19 and later, things became more complicated. The kernel now supports per-process <em>mount namespaces</em>. This means that each process potentially has its own set of file-system mount points, and thus may see a different single directory hierarchy from other processes. We explain this point further when we describe the <span class="literal">CLONE_NEWNS</span> flag in <a href="ch28.xhtml#ch28lev2sec01">Section 28.2.1</a>.</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_262"/>To list the currently mounted file systems, we can use the command <em>mount</em>, with no arguments, as in the following example (whose output has been somewhat abridged):</p>
<p class="programs">$ <span class="codestrong">mount</span><br/>/dev/sda6 on / type ext4 (rw)<br/>proc on /proc type proc (rw)<br/>sysfs on /sys type sysfs (rw)<br/>devpts on /dev/pts type devpts (rw,mode=0620,gid=5)<br/>/dev/sda8 on /home type ext3 (rw,acl,user_xattr)<br/>/dev/sda1 on /windows/C type vfat (rw,noexec,nosuid,nodev)<br/>/dev/sda9 on /home/mtk/test type reiserfs (rw)</p>
<p class="noindent"><a href="ch14.xhtml#ch14fig4">Figure 14-4</a> shows a partial directory and file structure for the system on which the above <em>mount</em> command was performed. This diagram shows how the mount points map onto the directory hierarchy.</p>
<div class="image"><img src="../images/f14-04.jpg" alt="image"/></div>
<p class="figcap"><a id="ch14fig4"/><strong>Figure 14-4:</strong> Example directory hierarchy showing file-system mount points</p>
<h3 class="h3" id="ch14lev1sec08"><strong>14.8 Mounting and Unmounting File Systems</strong></h3>
<p class="noindenta">The <em>mount()</em> and <em>umount()</em> system calls allow a privileged (<span class="literal">CAP_SYS_ADMIN</span>) process to mount and unmount file systems. Most UNIX implementations provide versions of these system calls. However, they are not standardized by SUSv3, and their operation varies both across UNIX implementations and across file systems.</p>
<p class="indentb"><span epub:type="pagebreak" id="page_263"/>Before looking at these system calls, it is useful to know about three files that contain information about the file systems that are currently mounted or can be mounted:</p>
<p class="bull">&#8226; A list of the currently mounted file systems can be read from the Linux-specific <span class="literal">/proc/mounts</span> virtual file. <span class="literal">/proc/mounts</span> is an interface to kernel data structures, so it always contains accurate information about mounted file systems.</p>
<div class="block1">
<p class="noindent">With the arrival of the per-process mount namespace feature mentioned earlier, each process now has a <span class="literal">/proc/</span><em>PID</em><span class="literal">/mounts</span> file that lists the mount points constituting its mount namespace, and <span class="literal">/proc/mounts</span> is just a symbolic link to <span class="literal">/proc/self/mounts</span>.</p>
</div>
<p class="bull">&#8226; The <em>mount(8)</em> and <em>umount(8)</em> commands automatically maintain the file <span class="literal">/etc/mtab</span>, which contains information that is similar to that in <span class="literal">/proc/mounts</span>, but slightly more detailed. In particular, <span class="literal">/etc/mtab</span> includes file system&#8211;specific options given to <em>mount(8)</em>, which are not shown in <span class="literal">/proc/mounts</span>. However, because the <em>mount()</em> and <em>umount()</em> system calls don&#8217;t update <span class="literal">/etc/mtab</span>, this file may be inaccurate if some application that mounts or unmounts devices fails to update it.</p>
<p class="bull">&#8226; The <span class="literal">/etc/fstab</span> file, maintained manually by the system administrator, contains descriptions of all of the available file systems on a system, and is used by the <em>mount(8)</em>, <em>umount(8)</em>, and <em>fsck(8)</em> commands.</p>
<p class="noindentt">The <span class="literal">/proc/mounts</span>, <span class="literal">/etc/mtab</span>, and <span class="literal">/etc/fstab</span> files share a common format, described in the <em>fstab(5)</em> manual page. Here is an example of a line from the <span class="literal">/proc/mounts</span> file:</p>
<p class="programs">/dev/sda9 /boot ext3 rw 0 0</p>
<p class="noindent">This line contains six fields:</p>
<ol>
<li class="order"><p class="orderp">The name of the mounted device.</p></li>
<li class="order"><p class="orderp">The mount point for the device.</p></li>
<li class="order"><p class="orderp">The file-system type.</p></li>
<li class="order"><p class="orderp">Mount flags. In the above example, <em>rw</em> indicates that the file system was mounted read-write.</p></li>
<li class="order"><p class="orderp">A number used to control the operation of file-system backups by <em>dump(8)</em>. This field and the next are used only in the <span class="literal">/etc/fstab</span> file; for <span class="literal">/proc/mounts</span> and <span class="literal">/etc/mtab</span>, these fields are always 0.</p></li>
<li class="order"><p class="orderp">A number used to control the order in which <em>fsck(8)</em> checks file systems at system boot time.</p></li>
</ol>
<p class="noindent">The <em>getfsent(3)</em> and <em>getmntent(3)</em> manual pages document functions that can be used to read records from these files.</p>
<h4 class="h4" id="ch14lev2sec01"><span epub:type="pagebreak" id="page_264"/><strong>14.8.1 Mounting a File System: <em>mount()</em></strong></h4>
<p class="noindenta">The <em>mount()</em> system call mounts the file system contained on the device specified by <em>source</em> under the directory (the <em>mount point</em>) specified by <em>target</em>.</p>
<div class="box">
<p class="programsa">#include &lt;sys/mount.h&gt;<br/><br/>int <span class="codestrong">mount</span>(const char *<span class="font1">source</span>, const char *<span class="font1">target</span>, const char *<span class="font1">fstype</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;unsigned long <span class="font1">mountflags</span>, const void *<span class="font1">data</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The names <em>source</em> and <em>target</em> are used for the first two arguments because <em>mount()</em> can perform other tasks than mounting a disk file system under a directory.</p>
<p class="indent">The <em>fstype</em> argument is a string identifying the type of file system contained on the device, such as <em>ext4</em> or <em>btrfs</em>.</p>
<p class="indent">The <em>mountflags</em> argument is a bit mask constructed by ORing (<span class="literal">|</span>) zero or more of the flags shown in <a href="ch14.xhtml#ch14table1">Table 14-1</a>, which are described in more detail below.</p>
<p class="indent">The final <em>mount()</em> argument, <em>data</em>, is a pointer to a buffer of information whose interpretation depends on the file system. For most file-system types, this argument is a string consisting of comma-separated option settings. A full list of these options can be found in the <em>mount(8)</em> manual page (or the documentation for the file system concerned, if it is not described in <em>mount(8)</em>).</p>
<p class="tablecap"><a id="ch14table1"/><strong>Table 14-1:</strong> <em>mountflags</em> values for <em>mount()</em></p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Flag</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Purpose</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MS_BIND</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Create a bind mount (since Linux 2.4)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MS_DIRSYNC</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Make directory updates synchronous (since Linux 2.6)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MS_MANDLOCK</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Permit mandatory locking of files</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MS_MOVE</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Atomically move mount point to new location</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MS_NOATIME</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Don&#8217;t update last access time for files</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MS_NODEV</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Don&#8217;t allow access to devices</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MS_NODIRATIME</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Don&#8217;t update last access time for directories</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MS_NOEXEC</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Don&#8217;t allow programs to be executed</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MS_NOSUID</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Disable set-user-ID and set-group-ID programs</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MS_RDONLY</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Read-only mount; files can&#8217;t be created or modified</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MS_REC</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Recursive mount (since Linux 2.4.11)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MS_RELATIME</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Update last access time only if older than last modification time or last status change time (since Linux 2.6.20)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MS_REMOUNT</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Remount with new <em>mountflags</em> and <em>data</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MS_STRICTATIME</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Always update last access time (since Linux 2.6.30)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">MS_SYNCHRONOUS</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Make all file and directory updates synchronous</p></td>
</tr>
</tbody>
</table>
<p class="noindentb"><span epub:type="pagebreak" id="page_265"/>The <em>mountflags</em> argument is a bit mask of flags that modify the operation of <em>mount()</em>. Zero or more of the following flags can be specified in <em>mountflags</em>:</p>
<p class="term"><span class="literal">MS_BIND</span> (since Linux 2.4)</p>
<p class="termlist">Create a bind mount. We describe this feature in <a href="ch14.xhtml#ch14lev2sec06">Section 14.9.4</a>. If this flag is specified, then the <em>fstype</em> and <em>data</em> arguments are ignored, as are flags in <em>mountflags</em> other than <span class="literal">MS_REC</span> (described below).</p>
<p class="term"><span class="literal">MS_DIRSYNC</span> (since Linux 2.6)</p>
<p class="termlist">Make directory updates synchronous. This is similar to the effect of the <em>open()</em> <span class="literal">O_SYNC</span> flag (<a href="ch13.xhtml#ch13lev1sec03">Section 13.3</a>), but applies only to directory updates. The <span class="literal">MS_SYNCHRONOUS</span> flag described below provides a superset of the functionality of <span class="literal">MS_DIRSYNC</span>, ensuring that both file and directory updates are performed synchronously. The <span class="literal">MS_DIRSYNC</span> flag allows an application to ensure that directory updates (e.g., <em>open(pathname, O_CREAT)</em>, <em>rename()</em>, <em>link()</em>, <em>unlink()</em>, <em>symlink()</em>, and <em>mkdir()</em>) are synchronized without incurring the expense of synchronizing all file updates. The <span class="literal">FS_DIRSYNC_FL</span> flag (<a href="ch15.xhtml#ch15lev1sec05">Section 15.5</a>) serves a similar purpose to <span class="literal">MS_DIRSYNC</span>, with the difference that <span class="literal">FS_DIRSYNC_FL</span> can be applied to individual directories. In addition, on Linux, calling <em>fsync()</em> on a file descriptor that refers to a directory provides a means of synchronizing directory updates on a per-directory basis. (This Linux-specific <em>fsync()</em> behavior is not specified in SUSv3.)</p>
<p class="term"><span class="literal">MS_MANDLOCK</span></p>
<p class="termlist">Permit mandatory record locking on files in this file system. We describe record locking in <a href="ch55.xhtml#ch55">Chapter 55</a>.</p>
<p class="term"><span class="literal">MS_MOVE</span></p>
<p class="termlist">Atomically move the existing mount point specified by <em>source</em> to the new location specified by <em>target</em>. This corresponds to the <em>&#8211;&#8211;move</em> option to <em>mount(8)</em>. This is equivalent to unmounting the subtree and then remounting at a different location, except that there is no point in time when the subtree is unmounted. The <em>source</em> argument should be a string specified as a <em>target</em> in a previous <em>mount()</em> call. When this flag is specified, the <em>fstype</em> and <em>data</em> arguments are ignored, as are the remaining flags in <em>mountflags</em>.</p>
<p class="term"><span class="literal">MS_NOATIME</span></p>
<p class="termlist">Don&#8217;t update the last access time for files in this file system. The purpose of this flag, as well as the <span class="literal">MS_NODIRATIME</span> flag described below, is to eliminate the extra disk access required to update the file i-node each time a file is accessed. In some applications, maintaining this timestamp is not critical, and avoiding doing so can significantly improve performance. The <span class="literal">MS_NOATIME</span> flag serves a similar purpose to the <span class="literal">FS_NOATIME_FL</span> flag (<a href="ch15.xhtml#ch15lev1sec05">Section 15.5</a>), with the difference that <span class="literal">FS_NOATIME_FL</span> can be applied to single files. Linux also provides similar functionality via the <span class="literal">O_NOATIME</span> <em>open()</em> flag, which selects this behavior for individual open files (<a href="ch04.xhtml#ch04lev2sec01">Section 4.3.1</a>).</p>
<p class="term"><span epub:type="pagebreak" id="page_266"/><span class="literal">MS_NODEV</span></p>
<p class="termlist">Don&#8217;t allow access to block and character devices on this file system. This is a security feature designed to prevent users from doing things such as inserting a removable disk containing device special files that would allow arbitrary access to the system.</p>
<p class="term"><span class="literal">MS_NODIRATIME</span></p>
<p class="termlist">Don&#8217;t update the last access time for directories on this file system. (This flag provides a subset of the functionality of <span class="literal">MS_NOATIME</span>, which prevents updates to the last access time for all file types.)</p>
<p class="term"><span class="literal">MS_NOEXEC</span></p>
<p class="termlist">Don&#8217;t allow programs (or scripts) to be executed from this file system. This is useful if the file system contains non-Linux executables.</p>
<p class="term"><span class="literal">MS_NOSUID</span></p>
<p class="termlist">Disable set-user-ID and set-group-ID programs on this file system. This is a security feature to prevent users from running set-user-ID and set-group-ID programs from removable devices.</p>
<p class="term"><span class="literal">MS_RDONLY</span></p>
<p class="termlist">Mount the file system read-only, so that no new files can be created and no existing files can be modified.</p>
<p class="term"><span class="literal">MS_REC</span> (since Linux 2.4.11)</p>
<p class="termlist">This flag is used in conjunction with other flags (e.g., <span class="literal">MS_BIND</span>) to recursively apply the mount action to all of the mounts in a subtree.</p>
<p class="term"><span class="literal">MS_RELATIME</span> (since Linux 2.6.20)</p>
<p class="termlist">Update the last access timestamp for files on this file system only if the current setting of this timestamp is less than or equal to either the last modification or the last status change timestamp. This provides some of the performance benefits of <span class="literal">MS_NOATIME</span>, but is useful for programs that need to know if a file has been read since it was last updated. Since Linux 2.6.30, the behavior provided by <span class="literal">MS_RELATIME</span> is the default (unless the <span class="literal">MS_NOATIME</span> flag is specified), and the <span class="literal">MS_STRICTATIME</span> flag is required to obtain classical behavior. In addition, since Linux 2.6.30, the last access timestamp is always updated if its current value is more than 24 hours in the past, even if the current value is more recent than the last modification and last status change timestamps. (This is useful for certain system programs that monitor directories to see whether files have recently been accessed.)</p>
<p class="term"><span class="literal">MS_REMOUNT</span></p>
<p class="termlist">Alter the <em>mountflags</em> and <em>data</em> for a file system that is already mounted (e.g., to make a read-only file system writable). When using this flag, the <em>target</em> argument should be the same as for the original <em>mount()</em> call, and the <em>source</em> and <em>fstype</em> arguments are ignored. This flag avoids the need to unmount and remount the disk, which may not be possible in some cases. For example, we can&#8217;t unmount a file system if any process has files open on, or its current <span epub:type="pagebreak" id="page_267"/>working directory located within, the file system (this will always be true of the root file system). Another example of where we need to use <span class="literal">MS_REMOUNT</span> is with <em>tmpfs</em> (memory-based) file systems (<a href="ch14.xhtml#ch14lev1sec10">Section 14.10</a>), which can&#8217;t be unmounted without losing their contents. Not all <em>mountflags</em> are modifiable; see the <em>mount(2)</em> manual page for details.</p>
<p class="term"><span class="literal">MS_STRICTATIME</span> (since Linux 2.6.30)</p>
<p class="termlist">Always update the last access timestamp when files on this file system are accessed. This was the default behavior before Linux 2.6.30. If <span class="literal">MS_STRICTATIME</span> is specified, then <span class="literal">MS_NOATIME</span> and <span class="literal">MS_RELATIME</span> are ignored if they are also specified in <em>mountflags</em>.</p>
<p class="term"><span class="literal">MS_SYNCHRONOUS</span></p>
<p class="termlist">Make all file and directory updates on this file system synchronous. (In the case of files, this is as though files were always opened with the <em>open()</em> <span class="literal">O_SYNC</span> flag.)</p>
<div class="block2">
<p class="noindent">Starting with kernel 2.6.15, Linux provides four new mount flags to support the notion of <em>shared subtrees</em>. The new flags are <span class="literal">MS_PRIVATE</span>, <span class="literal">MS_SHARED</span>, <span class="literal">MS_SLAVE</span>, and <span class="literal">MS_UNBINDABLE</span>. (These flags can be used in conjunction with <span class="literal">MS_REC</span> to propagate their effects to all of the submounts under a mount subtree.) Shared subtrees are designed for use with certain advanced file-system features, such as per-process mount namespaces (see the description of <span class="literal">CLONE_NEWNS</span> in <a href="ch28.xhtml#ch28lev2sec01">Section 28.2.1</a>), and the <em>Filesystem in Userspace</em> (FUSE) facility. The shared subtree facility permits file-system mounts to be propagated between mount namespaces in a controlled fashion. Details on shared subtrees can be found in the kernel source code file <span class="literal">Documentation/filesystems/sharedsubtree.txt</span> and [<a href="bib.xhtml#bib108">Viro &#38; Pai, 2006</a>].</p>
</div>
<h5 class="h5" id="ch14lev3sec07"><strong>Example program</strong></h5>
<p class="noindenta">The program in <a href="ch14.xhtml#ch14ex1">Listing 14-1</a> provides a command-level interface to the <em>mount(2)</em> system call. In effect, it is a crude version of the <em>mount(8)</em> command. The following shell session log demonstrates the use of this program. We begin by creating a directory to be used as a mount point and mounting a file system:</p>
<p class="programs">$ <span class="codestrong">su</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Need privilege to mount a file system</span><br/>Password:<br/># <span class="codestrong">mkdir /testfs</span><br/># <span class="codestrong">./t_mount -t ext2 -o bsdgroups /dev/sda12 /testfs</span><br/># <span class="codestrong">cat /proc/mounts | grep sda12</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Verify the setup</span><br/>/dev/sda12 /testfs ext3 rw 0 0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Doesn't show bsdgroups</span><br/># <span class="codestrong">grep sda12 /etc/mtab</span></p>
<p class="noindent">We find that the preceding <em>grep</em> command produces no output because our program doesn&#8217;t update <span class="literal">/etc/mtab</span>. We continue, remounting the file system read-only:</p>
<p class="programs"># <span class="codestrong">./t_mount -f Rr /dev/sda12 /testfs</span><br/># <span class="codestrong">cat /proc/mounts | grep sda12</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Verify change</span><br/>/dev/sda12 /testfs ext3 ro 0 0</p>
<p class="noindent">The string <em>ro</em> in the line displayed from <span class="literal">/proc/mounts</span> indicates that this is a read-only mount.</p>
<p class="noindent"><span epub:type="pagebreak" id="page_268"/>Finally, we move the mount point to a new location within the directory hierarchy:</p>
<p class="programs"># <span class="codestrong">mkdir /demo</span><br/># <span class="codestrong">./t_mount -f m /testfs /demo</span><br/># <span class="codestrong">cat /proc/mounts | grep sda12</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Verify change</span><br/>/dev/sda12 /demo ext3 ro 0</p>
<p class="examplet"><a id="ch14ex1"/><strong>Listing 14-1:</strong> Using <em>mount()</em></p>
<p class="programsli">________________________________________________________ <span class="codestrong">filesys/t_mount.c</span><br/><br/>#include &lt;sys/mount.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static void<br/>usageError(const char *progName, const char *msg)<br/>{<br/>&#160;&#160;&#160;&#160;if (msg != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(stderr, "%s", msg);<br/><br/>&#160;&#160;&#160;&#160;fprintf(stderr, "Usage: %s [options] source target\n\n", progName);<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "Available options:\n");<br/>#define fpe(str) fprintf(stderr, "&#160;&#160;&#160;&#160;" str)&#160;&#160;&#160;&#160;/* Shorter! */<br/>&#160;&#160;&#160;&#160;fpe("-t fstype&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[e.g., 'ext2' or 'reiserfs']\n");<br/>&#160;&#160;&#160;&#160;fpe("-o data&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[file system-dependent options,\n");<br/>&#160;&#160;&#160;&#160;fpe("&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;e.g., 'bsdgroups' for ext2]\n");<br/>&#160;&#160;&#160;&#160;fpe("-f mountflags&#160;&#160;&#160;&#160;can include any of:\n");<br/>#define fpe2(str) fprintf(stderr, "&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;" str)<br/>&#160;&#160;&#160;&#160;fpe2("b - MS_BIND&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;create a bind mount\n");<br/>&#160;&#160;&#160;&#160;fpe2("d - MS_DIRSYNC&#160;&#160;&#160;&#160;&#160;&#160;synchronous directory updates\n");<br/>&#160;&#160;&#160;&#160;fpe2("l - MS_MANDLOCK&#160;&#160;&#160;&#160;&#160;permit mandatory locking\n");<br/>&#160;&#160;&#160;&#160;fpe2("m - MS_MOVE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;atomically move subtree\n");<br/>&#160;&#160;&#160;&#160;fpe2("A - MS_NOATIME&#160;&#160;&#160;&#160;&#160;&#160;don't update atime (last access time)\n");<br/>&#160;&#160;&#160;&#160;fpe2("V - MS_NODEV&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;don't permit device access\n");<br/>&#160;&#160;&#160;&#160;fpe2("D - MS_NODIRATIME&#160;&#160;&#160;don't update atime on directories\n");<br/>&#160;&#160;&#160;&#160;fpe2("E - MS_NOEXEC&#160;&#160;&#160;&#160;&#160;&#160;&#160;don't allow executables\n");<br/>&#160;&#160;&#160;&#160;fpe2("S - MS_NOSUID&#160;&#160;&#160;&#160;&#160;&#160;&#160;disable set-user/group-ID programs\n");<br/>&#160;&#160;&#160;&#160;fpe2("r - MS_RDONLY&#160;&#160;&#160;&#160;&#160;&#160;&#160;read-only mount\n");<br/>&#160;&#160;&#160;&#160;fpe2("c - MS_REC&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;recursive mount\n");<br/>&#160;&#160;&#160;&#160;fpe2("R - MS_REMOUNT&#160;&#160;&#160;&#160;&#160;&#160;remount\n");<br/>&#160;&#160;&#160;&#160;fpe2("s - MS_SYNCHRONOUS&#160;&#160;make writes synchronous\n");<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;unsigned long flags;<br/>&#160;&#160;&#160;&#160;char *data, *fstype;<br/>&#160;&#160;&#160;&#160;int j, opt;<br/><br/>&#160;&#160;&#160;&#160;flags = 0;<br/>&#160;&#160;&#160;&#160;data = NULL;<br/>&#160;&#160;&#160;&#160;fstype = NULL;<br/><br/>&#160;&#160;&#160;&#160;while ((opt = getopt(argc, argv, "o:t:f:")) != -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (opt) {<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'o':<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;data = optarg;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 't':<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fstype = optarg;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'f':<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (j = 0; j &lt; strlen(optarg); j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (optarg[j]) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'b': flags |= MS_BIND;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'd': flags |= MS_DIRSYNC;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'l': flags |= MS_MANDLOCK;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'm': flags |= MS_MOVE;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'A': flags |= MS_NOATIME;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'V': flags |= MS_NODEV;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'D': flags |= MS_NODIRATIME;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'E': flags |= MS_NOEXEC;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'S': flags |= MS_NOSUID;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'r': flags |= MS_RDONLY;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'c': flags |= MS_REC;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'R': flags |= MS_REMOUNT;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 's': flags |= MS_SYNCHRONOUS;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default: usageError(argv[0], NULL);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0], NULL);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (argc != optind + 2)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0], "Wrong number of arguments\n");<br/><br/>&#160;&#160;&#160;&#160;if (mount(argv[optind], argv[optind + 1], fstype, flags, data) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mount");<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>________________________________________________________ <span class="codestrong">filesys/t_mount.c</span></p>
<h4 class="h4" id="ch14lev2sec02"><span epub:type="pagebreak" id="page_269"/><strong>14.8.2 Unmounting a File System: <em>umount()</em> and <em>umount2()</em></strong></h4>
<p class="noindenta">The <em>umount()</em> system call unmounts a mounted file system.</p>
<div class="box">
<p class="programsa">#include &lt;sys/mount.h&gt;<br/><br/>int <span class="codestrong">umount</span>(const char *<span class="font1">target</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>target</em> argument specifies the mount point of the file system to be unmounted.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_270"/>On Linux 2.2 and earlier, the file system can be identified in two ways: by the mount point or by the name of the device containing the file system. Since kernel 2.4, Linux doesn&#8217;t allow the latter possibility, because a single file system can now be mounted at multiple locations, so that specifying a file system for <em>target</em> would be ambiguous. We explain this point in further detail in <a href="ch14.xhtml#ch14lev2sec03">Section 14.9.1</a>.</p>
</div>
<p class="noindent">It is not possible to unmount a file system that is <em>busy</em>; that is, if there are open files on the file system, or a process&#8217;s current working directory is somewhere in the file system. Calling <em>umount()</em> on a busy file system yields the error <span class="literal">EBUSY</span>.</p>
<p class="indent">The <em>umount2()</em> system call is an extended version of <em>umount()</em>. It allows finer control over the unmount operation via the <em>flags</em> argument.</p>
<div class="box">
<p class="programsa">#include &lt;sys/mount.h&gt;<br/><br/>int <span class="codestrong">umount2</span>(const char *<span class="font1">target</span>, int <span class="font1">flags</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb">This <em>flags</em> bit-mask argument consists of zero or more of the following values ORed together:</p>
<p class="term"><span class="literal">MNT_DETACH</span> (since Linux 2.4.11)</p>
<p class="termlist">Perform a <em>lazy</em> unmount. The mount point is marked so that no process can make new accesses to it, but processes that are already using it can continue to do so. The file system is actually unmounted when all processes cease using the mount.</p>
<p class="term"><span class="literal">MNT_EXPIRE</span> (since Linux 2.6.8)</p>
<p class="termlist">Mark the mount point as <em>expired</em>. If an initial <em>umount2()</em> call is made specifying this flag, and the mount point is not busy, then the call fails with the error <span class="literal">EAGAIN</span>, but the mount point is marked to expire. (If the mount point is busy, then the call fails with the error <span class="literal">EBUSY</span>, and the mount point is not marked to expire.) A mount point remains expired as long as no process subsequently makes use of it. A second <em>umount2()</em> call specifying <span class="literal">MNT_EXPIRE</span> will unmount an expired mount point. This provides a mechanism to unmount a file system that hasn&#8217;t been used for some period of time. This flag can&#8217;t be specified with <span class="literal">MNT_DETACH</span> or <span class="literal">MNT_FORCE</span>.</p>
<p class="term"><span class="literal">MNT_FORCE</span></p>
<p class="termlist">Force an unmount even if the device is busy (NFS mounts only). Employing this option can cause data loss.</p>
<p class="term"><span class="literal">UMOUNT_NOFOLLOW</span> (since Linux 2.6.34)</p>
<p class="termlist">Don&#8217;t dereference <em>target</em> if it is a symbolic link. This flag is designed for use in certain set-user-ID-<em>root</em> programs that allow unprivileged users to perform unmounts, in order to avoid the security problems that could occur if <em>target</em> is a symbolic link that is changed to point to a different location.</p>
<h3 class="h3" id="ch14lev1sec09"><span epub:type="pagebreak" id="page_271"/><strong>14.9 Advanced Mount Features</strong></h3>
<p class="noindenta">We now look at a number of more advanced features that can be employed when mounting file systems. We demonstrate the use of most of these features using the <em>mount(8)</em> command. The same effects can also be accomplished from a program via calls to <em>mount(2)</em>.</p>
<h4 class="h4" id="ch14lev2sec03"><strong>14.9.1 Mounting a File System at Multiple Mount Points</strong></h4>
<p class="noindenta">In kernel versions before 2.4, a file system could be mounted only on a single mount point. From kernel 2.4 onward, a file system can be mounted at multiple locations within the single directory hierarchy. Because each of the mount points shows the same subtree, changes made via one mount point are visible through the other(s), as demonstrated by the following shell session:</p>
<p class="programs">$ <span class="codestrong">su</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Privilege is required to use mount(8)</span><br/>Password:<br/># <span class="codestrong">mkdir /testfs</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create two directories for mount points</span><br/># <span class="codestrong">mkdir /demo</span><br/># <span class="codestrong">mount /dev/sda12 /testfs</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Mount file system at one mount point</span><br/># <span class="codestrong">mount /dev/sda12 /demo</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Mount file system at second mount point</span><br/># <span class="codestrong">mount | grep sda12</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Verify the setup</span><br/>/dev/sda12 on /testfs type ext3 (rw)<br/>/dev/sda12 on /demo type ext3 (rw)<br/># <span class="codestrong">touch /testfs/myfile</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Make a change via first mount point</span><br/># <span class="codestrong">ls /demo</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">View files at second mount point</span><br/>lost+found myfile</p>
<p class="noindent">The output of the <em>ls</em> command shows that the change made via the first mount point (<span class="literal">/testfs</span>) was visible via the second mount point (<span class="literal">/demo</span>).</p>
<p class="indent">We present one example of why it is useful to mount a file system at multiple points when we describe bind mounts in <a href="ch14.xhtml#ch14lev2sec06">Section 14.9.4</a>.</p>
<div class="block">
<p class="noindent">It is because a device can be mounted at multiple points that the <em>umount()</em> system call can&#8217;t take a device as its argument in Linux 2.4 and later.</p>
</div>
<h4 class="h4" id="ch14lev2sec04"><strong>14.9.2 Stacking Multiple Mounts on the Same Mount Point</strong></h4>
<p class="noindenta">In kernel versions before 2.4, a mount point could be used only once. Since kernel 2.4, Linux allows multiple mounts to be stacked on a single mount point. Each new mount hides the directory subtree previously visible at that mount point. When the mount at the top of the stack is unmounted, the previously hidden mount becomes visible once more, as demonstrated by the following shell session:</p>
<p class="programs">$ <span class="codestrong">su</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Privilege is required to use mount(8)</span><br/>Password:<br/># <span class="codestrong">mount /dev/sda12 /testfs</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create first mount on</span> /testfs<br/># <span class="codestrong">touch /testfs/myfile</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Make a file in this subtree</span><br/># <span class="codestrong">mount /dev/sda13 /testfs</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Stack a second mount on</span> /testfs<br/># <span class="codestrong">mount | grep testfs</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Verify the setup</span><br/>/dev/sda12 on /testfs type ext3 (rw)<br/>/dev/sda13 on /testfs type reiserfs (rw)<br/># <span class="codestrong">touch /testfs/newfile</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create a file in this subtree</span><br/># <span class="codestrong">ls /testfs</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">View files in this subtree</span><br/>newfile<br/># <span class="codestrong">umount /testfs</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Pop a mount from the stack</span><br/># <span class="codestrong">mount | grep testfs</span><br/>/dev/sda12 on /testfs type ext3 (rw)&#160;&#160;<span class="font1">Now only one mount on</span> /testfs<br/># <span class="codestrong">ls /testfs</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Previous mount is now visible</span><br/>lost+found myfile</p>
<p class="noindent"><span epub:type="pagebreak" id="page_272"/>One use of mount stacking is to stack a new mount on an existing mount point that is busy. Processes that hold file descriptors open, that are <em>chroot()</em>-jailed, or that have current working directories within the old mount point continue to operate under that mount, but processes making new accesses to the mount point use the new mount. Combined with a <span class="literal">MNT_DETACH</span> unmount, this can provide a smooth migration off a file system without needing to take the system into single-user mode. We&#8217;ll see another example of how stacking mounts is useful when we discuss the <em>tmpfs</em> file system in <a href="ch14.xhtml#ch14lev1sec10">Section 14.10</a>.</p>
<h4 class="h4" id="ch14lev2sec05"><strong>14.9.3 Mount Flags That Are Per-Mount Options</strong></h4>
<p class="noindenta">In kernel versions before 2.4, there was a one-to-one correspondence between file systems and mount points. Because this no longer holds in Linux 2.4 and later, some of the <em>mountflags</em> values described in <a href="ch14.xhtml#ch14lev2sec01">Section 14.8.1</a> can be set on a per-mount basis. These flags are <span class="literal">MS_NOATIME</span> (since Linux 2.6.16), <span class="literal">MS_NODEV</span>, <span class="literal">MS_NODIRATIME</span> (since Linux 2.6.16), <span class="literal">MS_NOEXEC</span>, <span class="literal">MS_NOSUID</span>, <span class="literal">MS_RDONLY</span> (since Linux 2.6.26), and <span class="literal">MS_RELATIME</span>. The following shell session demonstrates this effect for the <span class="literal">MS_NOEXEC</span> flag:</p>
<p class="programs">$ <span class="codestrong">su</span><br/>Password:<br/># <span class="codestrong">mount /dev/sda12 /testfs</span><br/># <span class="codestrong">mount -o noexec /dev/sda12 /demo</span><br/># <span class="codestrong">cat /proc/mounts | grep sda12</span><br/>/dev/sda12 /testfs ext3 rw 0 0<br/>/dev/sda12 /demo ext3 rw,noexec 0 0<br/># <span class="codestrong">cp /bin/echo /testfs</span><br/># <span class="codestrong">/testfs/echo "Art is something which is well done"</span><br/>Art is something which is well done<br/># <span class="codestrong">/demo/echo "Art is something which is well done"</span><br/>bash: /demo/echo: Permission denied</p>
<h4 class="h4" id="ch14lev2sec06"><strong>14.9.4 Bind Mounts</strong></h4>
<p class="noindentab">Starting with kernel 2.4, Linux permits the creation of bind mounts. A <em>bind mount</em> (created using the <em>mount()</em> <span class="literal">MS_BIND</span> flag) allows a directory or a file to be mounted at some other location in the file-system hierarchy. This results in the directory or file being visible in both locations. A bind mount is somewhat like a hard link, but differs in two respects:</p>
<p class="bull">&#8226; A bind mount can cross file-system mount points (and even <em>chroot</em> jails).</p>
<p class="bull">&#8226; It is possible to make a bind mount for a directory.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_273"/>We can create a bind mount from the shell using the <em>&#8211;&#8211;bind</em> option to <em>mount(8)</em>, as shown in the following examples.</p>
<p class="indent">In the first example, we bind mount a directory at another location and show that files created in one directory are visible at the other location:</p>
<p class="programs">$ <span class="codestrong">su</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Privilege is required to use mount(8)</span><br/>Password:<br/># <span class="codestrong">pwd</span><br/>/testfs<br/># <span class="codestrong">mkdir d1</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create directory to be bound at another location</span><br/># <span class="codestrong">touch d1/x</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create file in the directory</span><br/># <span class="codestrong">mkdir d2</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create mount point to which</span> d1 <span class="font1">will be bound</span><br/># <span class="codestrong">mount --bind d1 d2</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create bind mount:</span> d1 <span class="font1">visible via</span> d2<br/># <span class="codestrong">ls d2</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Verify that we can see contents of</span> d1 <span class="font1">via</span> d2<br/>x<br/># <span class="codestrong">touch d2/y</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create second file in directory</span> d2<br/># <span class="codestrong">ls d1</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Verify that this change is visible via</span> d1<br/>x y</p>
<p class="noindent">In the second example, we bind mount a file at another location and demonstrate that changes to the file via one mount are visible via the other mount:</p>
<p class="programs"># <span class="codestrong">cat &gt; f1</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create file to be bound to another location</span><br/><span class="codestrong">Chance is always powerful. Let your hook be always cast.</span><br/><span class="font1">Type Control-D</span><br/># <span class="codestrong">touch f2</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">This is the new mount point</span><br/># <span class="codestrong">mount --bind f1 f2</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Bind</span> f1 <span class="font1">as</span> f2<br/># <span class="codestrong">mount | egrep '(d1|f1)'</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">See how mount points look</span><br/>/testfs/d1 on /testfs/d2 type none (rw,bind)<br/>/testfs/f1 on /testfs/f2 type none (rw,bind)<br/># <span class="codestrong">cat &gt;&gt; f2</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Change</span> f2<br/><span class="codestrong">In the pool where you least expect it, will be a fish.</span><br/># <span class="codestrong">cat f1</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">The change is visible via original file</span> f1<br/>Chance is always powerful. Let your hook be always cast.<br/>In the pool where you least expect it, will be a fish.<br/># <span class="codestrong">rm f2</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Can't do this because it is a mount point</span><br/>rm: cannot unlink `f2': Device or resource busy<br/># <span class="codestrong">umount f2</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">So unmount</span><br/># <span class="codestrong">rm f2</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Now we can remove</span> f2</p>
<p class="noindent">One example of when we might use a bind mount is in the creation of a <em>chroot</em> jail (<a href="ch18.xhtml#ch18lev1sec12">Section 18.12</a>). Rather than replicating various standard directories (such as <span class="literal">/lib</span>) in the jail, we can simply create bind mounts for these directories within the jail.</p>
<h4 class="h4" id="ch14lev2sec07"><strong>14.9.5 Recursive Bind Mounts</strong></h4>
<p class="noindenta">By default, if we create a bind mount for a directory using <span class="literal">MS_BIND</span>, then only that directory is mounted at the new location; if there are any submounts under the source directory, they are not replicated under the mount <em>target</em>. Linux 2.4.11 added the <span class="literal">MS_REC</span> flag, which can be ORed with <span class="literal">MS_BIND</span> as part of the <em>flags</em> argument to <em>mount()</em> so that submounts <em>are</em> replicated under the mount target. This is referred to as a <em>recursive bind mount</em>. The <em>mount(8)</em> command provides the <em>&#8211;&#8211;rbind</em> option to achieve the same effect from the shell, as shown in the following shell session.</p>
<p class="indent"><span epub:type="pagebreak" id="page_274"/>We begin by creating a directory tree (<span class="literal">src1</span>) mounted under <span class="literal">top</span>. This tree includes a submount (<span class="literal">src2</span>) at <span class="literal">top/sub</span>.</p>
<p class="programs">$ <span class="codestrong">su</span><br/>Password:<br/># <span class="codestrong">mkdir top</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">This is our top-level mount point</span><br/># <span class="codestrong">mkdir src1</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">We'll mount this under</span> top<br/># <span class="codestrong">touch src1/aaa</span><br/># <span class="codestrong">mount --bind src1 top</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create a normal bind mount</span><br/># <span class="codestrong">mkdir top/sub</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create directory for a submount under</span> top<br/># <span class="codestrong">mkdir src2</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">We'll mount this under</span> top/sub<br/># <span class="codestrong">touch src2/bbb</span><br/># <span class="codestrong">mount --bind src2 top/sub</span>&#160;&#160;&#160;&#160;<span class="font1">Create a normal bind mount</span><br/># <span class="codestrong">find top</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Verify contents under</span> top <span class="font1">mount tree</span><br/>top<br/>top/aaa<br/>top/sub&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">This is the submount</span><br/>top/sub/bbb</p>
<p class="noindent">Now we create another bind mount (<span class="literal">dir1</span>) using <span class="literal">top</span> as the source. Since this new mount is nonrecursive, the submount is not replicated.</p>
<p class="programs"># <span class="codestrong">mkdir dir1</span><br/># <span class="codestrong">mount --bind top dir1</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Here we use a normal bind mount</span><br/># <span class="codestrong">find dir1</span><br/>dir1<br/>dir1/aaa<br/>dir1/sub</p>
<p class="noindent">The absence of <span class="literal">dir1/sub/bbb</span> in the output of <em>find</em> shows that the submount <span class="literal">top/sub</span> was not replicated.</p>
<p class="indent">Now we create a recursive bind mount (<span class="literal">dir2</span>) using <span class="literal">top</span> as the source.</p>
<p class="programs"># <span class="codestrong">mkdir dir2</span><br/># <span class="codestrong">mount --rbind top dir2</span><br/># <span class="codestrong">find dir2</span><br/>dir2<br/>dir2/aaa<br/>dir2/sub<br/>dir2/sub/bbb</p>
<p class="noindent">The presence of <span class="literal">dir2/sub/bbb</span> in the output of <em>find</em> shows that the submount <span class="literal">top/sub</span> was replicated.</p>
<h3 class="h3" id="ch14lev1sec10"><strong>14.10 A Virtual Memory File System: <em>tmpfs</em></strong></h3>
<p class="noindenta">All of the file systems we have described so far in this chapter reside on disks. However, Linux also supports the notion of <em>virtual file systems</em> that reside in memory. To applications, these look just like any other file system&#8212;the same operations (<em>open()</em>, <em>read()</em>, <em>write()</em>, <em>link()</em>, <em>mkdir()</em>, and so on) can be applied to files and directories in such file systems. There is, however, one important difference: file operations are much faster, since no disk access is involved.</p>
<p class="indent"><span epub:type="pagebreak" id="page_275"/>Various memory-based file systems have been developed for Linux. The most sophisticated of these to date is the <em>tmpfs</em> file system, which first appeared in Linux 2.4. The <em>tmpfs</em> file system differs from other memory-based file systems in that it is a <em>virtual</em> memory file system. This means that <em>tmpfs</em> uses not only RAM, but also the swap space, if RAM is exhausted. (Although the <em>tmpfs</em> file system described here is Linux-specific, most UNIX implementations provide some form of memory-based file system.)</p>
<div class="block">
<p class="noindent">The <em>tmpfs</em> file system is an optional Linux kernel component that is configured via the <span class="literal">CONFIG_TMPFS</span> option.</p>
</div>
<p class="noindent">To create a <em>tmpfs</em> file system, we use a command of the following form:</p>
<p class="programs"># <span class="codestrong">mount -t tmpfs <span class="codeitalic">source</span> <span class="codeitalic">target</span></span></p>
<p class="noindent">The <em>source</em> can be any name; its only significance is that it appears in <span class="literal">/proc/mounts</span> and is displayed by the <em>mount</em> and <em>df</em> commands. As usual, <em>target</em> is the mount point for the file system. Note that it is not necessary to use <em>mkfs</em> to create a file system first, because the kernel automatically builds a file system as part of the <em>mount()</em> system call.</p>
<p class="indent">As an example of the use of <em>tmpfs</em>, we could employ mount stacking (so that we don&#8217;t need to care if <span class="literal">/tmp</span> is already in use) and create a <em>tmpfs</em> file system mounted on <span class="literal">/tmp</span> as follows:</p>
<p class="programs"># <span class="codestrong">mount -t tmpfs newtmp /tmp</span><br/># <span class="codestrong">cat /proc/mounts | grep tmp</span><br/>newtmp /tmp tmpfs rw 0 0</p>
<p class="noindent">A command such as the above (or an equivalent entry in <span class="literal">/etc/fstab</span>) is sometimes used to improve the performance of applications (e.g., compilers) that make heavy use of the <span class="literal">/tmp</span> directory for creating temporary files.</p>
<p class="indent">By default, a <em>tmpfs</em> file system is permitted to grow to half the size of RAM, but the <em>size=nbytes mount</em> option can be used to set a different ceiling for the file-system size, either when the file system is created or during a later remount. (A <em>tmpfs</em> file system consumes only as much memory and swap space as is currently required for the files it holds.)</p>
<p class="indent">If we unmount a <em>tmpfs</em> file system, or the system crashes, then all data in the file system is lost; hence the name <em>tmpfs</em>.</p>
<p class="indentb">Aside from use by user applications, <em>tmpfs</em> file systems also serve two special purposes:</p>
<p class="bull">&#8226; An invisible <em>tmpfs</em> file system, mounted internally by the kernel, is used for implementing System V shared memory (<a href="ch48.xhtml#ch48">Chapter 48</a>) and shared anonymous memory mappings (<a href="ch49.xhtml#ch49">Chapter 49</a>).</p>
<p class="bull">&#8226; A <em>tmpfs</em> file system mounted at <span class="literal">/dev/shm</span> (<span class="literal">/run/shm</span> on some systems) is used for the <em>glibc</em> implementation of POSIX shared memory and POSIX semaphores.</p>
<h3 class="h3" id="ch14lev1sec11"><span epub:type="pagebreak" id="page_276"/><strong>14.11 Obtaining Information About a File System: <em>statvfs()</em></strong></h3>
<p class="noindenta">The <em>statvfs()</em> and <em>fstatvfs()</em> library functions obtain information about a mounted file system.</p>
<div class="box">
<p class="programsa">#include &lt;sys/statvfs.h&gt;<br/><br/>int <span class="codestrong">statvfs</span>(const char *<span class="font1">pathname</span>, struct statvfs *<span class="font1">statvfsbuf</span>);<br/>int <span class="codestrong">fstatvfs</span>(int <span class="font1">fd</span>, struct statvfs *<span class="font1">statvfsbuf</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The only difference between these two functions is in how the file system is identified. For <em>statvfs()</em>, we use <em>pathname</em> to specify the name of any file in the file system. For <em>fstatvfs()</em>, we specify an open file descriptor, <em>fd</em>, referring to any file in the file system. Both functions return a <em>statvfs</em> structure containing information about the file system in the buffer pointed to by <em>statvfsbuf</em>. This structure has the following form:</p>
<p class="programs">struct statvfs {<br/>&#160;&#160;&#160;&#160;unsigned long f_bsize;&#160;&#160;&#160;&#160;&#160;/* File-system block size (in bytes) */<br/>&#160;&#160;&#160;&#160;unsigned long f_frsize;&#160;&#160;&#160;&#160;/* Fundamental file-system block size<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(in bytes) */<br/>&#160;&#160;&#160;&#160;fsblkcnt_t&#160;&#160;&#160;&#160;f_blocks;&#160;&#160;&#160;&#160;/* Total number of blocks in file<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;system (in units of 'f_frsize') */<br/>&#160;&#160;&#160;&#160;fsblkcnt_t&#160;&#160;&#160;&#160;f_bfree;&#160;&#160;&#160;&#160;&#160;/* Total number of free blocks */<br/>&#160;&#160;&#160;&#160;fsblkcnt_t&#160;&#160;&#160;&#160;f_bavail;&#160;&#160;&#160;&#160;/* Number of free blocks available to<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;unprivileged process */<br/>&#160;&#160;&#160;&#160;fsfilcnt_t&#160;&#160;&#160;&#160;f_files;&#160;&#160;&#160;&#160;&#160;/* Total number of i-nodes */<br/>&#160;&#160;&#160;&#160;fsfilcnt_t&#160;&#160;&#160;&#160;f_ffree;&#160;&#160;&#160;&#160;&#160;/* Total number of free i-nodes */<br/>&#160;&#160;&#160;&#160;fsfilcnt_t&#160;&#160;&#160;&#160;f_favail;&#160;&#160;&#160;&#160;/* Number of i-nodes available to unprivileged<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;process (set to 'f_ffree' on Linux) */<br/>&#160;&#160;&#160;&#160;unsigned long f_fsid;&#160;&#160;&#160;&#160;&#160;&#160;/* File-system ID */<br/>&#160;&#160;&#160;&#160;unsigned long f_flag;&#160;&#160;&#160;&#160;&#160;&#160;/* Mount flags */<br/>&#160;&#160;&#160;&#160;unsigned long f_namemax;&#160;&#160;&#160;/* Maximum length of filenames on<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this file system */<br/>};</p>
<p class="noindentb">The purpose of most of the fields in the <em>statvfs</em> structure is made clear in the comments above. We note a few further points regarding some fields:</p>
<p class="bull">&#8226; The <em>fsblkcnt_t</em> and <em>fsfilcnt_t</em> data types are integer types specified by SUSv3.</p>
<p class="bull">&#8226; For most Linux file systems, the values of <em>f_bsize</em> and <em>f_frsize</em> are the same. However, some file systems support the notion of block fragments, which can be used to allocate a smaller unit of storage at the end of the file if a full block is not required. This avoids the waste of space that would otherwise occur if a full block was allocated. On such file systems, <em>f_frsize</em> is the size of a fragment, and <em>f_bsize</em> is the size of a whole block. (The notion of fragments in UNIX file systems first appeared in the early 1980s with the 4.2BSD Fast File System, described in [<a href="bib.xhtml#bib64">McKusick et al., 1984</a>].)</p>
<p class="bull"><span epub:type="pagebreak" id="page_277"/>&#8226; Many native UNIX and Linux file systems support the notion of reserving a certain portion of the blocks of a file system for the superuser, so that if the file system fills up, the superuser can still log in to the system and do some work to resolve the problem. If there are reserved blocks in the file system, then the difference in values of the <em>f_bfree</em> and <em>f_bavail</em> fields in the <em>statvfs</em> structure tells us how many blocks are reserved.</p>
<p class="bull">&#8226; The <em>f_flag</em> field is a bit mask of the flags used to mount the file system; that is, it contains information similar to the <em>mountflags</em> argument given to <em>mount(2)</em>. However, the constants used for the bits in this field have names starting with <span class="literal">ST_</span> instead of the <span class="literal">MS_</span> used for <em>mountflags</em>. SUSv3 requires only the <span class="literal">ST_RDONLY</span> and <span class="literal">ST_NOSUID</span> constants, but the <em>glibc</em> implementation supports a full range of constants with names corresponding to the <span class="literal">MS_*</span> constants described for the <em>mount() mountflags</em> argument.</p>
<p class="bull">&#8226; The <em>f_fsid</em> field is used to return a unique identifier for the file system&#8212;for example, a value based on the identifier of the device on which the file system resides. On older Linux kernels, many types of file systems return 0 in this field.</p>
<p class="noindenttb">SUSv3 specifies both <em>statvfs()</em> and <em>fstatvfs()</em>. On Linux (as on several other UNIX implementations), these functions are layered on top of the quite similar <em>statfs()</em> and <em>fstatfs()</em> system calls. (Some UNIX implementations provide a <em>statfs()</em> system call, but don&#8217;t provide <em>statvfs()</em>.) The principal differences (aside from some differently named fields) are as follows</p>
<p class="bull">&#8226; The <em>statvfs()</em> and <em>fstatvfs()</em> functions return the <em>f_flag</em> field, giving information about the file-system mount flags. (The <em>glibc</em> implementation obtains this information by scanning <span class="literal">/proc/mounts</span> or <span class="literal">/etc/mtab</span>.)</p>
<p class="bull">&#8226; The <em>statfs()</em> and <em>fstatfs()</em> system calls return the field <em>f_type</em>, giving the type of the file system (e.g., the value <span class="literal">0xef53</span> indicates that this is an <em>ext2</em> file system).</p>
<div class="block">
<p class="noindent">The <span class="literal">filesys</span> subdirectory in the source code distribution for this book contains two files, <span class="literal">t_statvfs.c</span> and <span class="literal">t_statfs.c</span>, demonstrating the use of <em>statvfs()</em> and <em>statfs()</em>.</p>
</div>
<h3 class="h3" id="ch14lev1sec12"><strong>14.12 Summary</strong></h3>
<p class="noindenta">Devices are represented by entries in the <span class="literal">/dev</span> directory. Each device has a corresponding device driver, which implements a standard set of operations, including those corresponding to the <em>open()</em>, <em>read()</em>, <em>write()</em>, and <em>close()</em> system calls. A device may be real, meaning that there is a corresponding hardware device, or virtual, meaning that no hardware device exists, but the kernel nevertheless provides a device driver that implements an API that is the same as a real device.</p>
<p class="indent">A hard disk is divided into one or more partitions, each of which may contain a file system. A file system is an organized collection of regular files and directories. Linux implements a wide variety of file systems, including the traditional <em>ext2</em> file system. The <em>ext2</em> file system is conceptually similar to early UNIX file systems, consisting of a boot block, a superblock, an i-node table, and a data area containing file data blocks. Each file has an entry in the file system&#8217;s i-node table. This entry contains <span epub:type="pagebreak" id="page_278"/>various information about the file, including its type, size, link count, ownership, permissions, timestamps, and pointers to the file&#8217;s data blocks.</p>
<p class="indent">Linux provides a range of journaling file systems, including <em>Reiserfs</em>, <em>ext3</em>, <em>ext4</em>, <em>XFS</em>, <em>JFS</em>, and <em>Btrfs</em>. A journaling file system records metadata updates (and optionally on some file systems, data updates) to a log file before the actual file updates are performed. This means that in the event of a system crash, the log file can be replayed to quickly restore the file system to a consistent state. The key benefit of journaling file systems is that they avoid the lengthy file-system consistency checks required by conventional UNIX file systems after a system crash.</p>
<p class="indent">All file systems on a Linux system are mounted under a single directory tree, with the directory <span class="literal">/</span> at its root. The location at which a file system is mounted in the directory tree is called its mount point.</p>
<p class="indent">A privileged process can mount and unmount a file system using the <em>mount()</em> and <em>umount()</em> system calls. Information about a mounted file system can be retrieved using <em>statvfs()</em>.</p>
<h5 class="h5" id="ch14lev3sec08"><strong>Further information</strong></h5>
<p class="noindenta">For detailed information about devices and device drivers, see [<a href="bib.xhtml#bib09">Bovet &#38; Cesati, 2005</a>] and especially [<a href="bib.xhtml#bib16">Corbet et al., 2005</a>]. Some useful information about devices can be found in the kernel source file <span class="literal">Documentation/devices.txt</span>.</p>
<p class="indent">Several books provide further information about file systems. [<a href="bib.xhtml#bib99">Tanenbaum, 2007</a>] is a general introduction to file-system structures and implementation. [<a href="bib.xhtml#bib04">Bach, 1986</a>] provides an introduction to the implementation of UNIX file systems, oriented primarily toward System V. [<a href="bib.xhtml#bib104">Vahalia, 1996</a>] and [<a href="bib.xhtml#bib35">Goodheart &#38; Cox, 1994</a>] also describe the System V file-system implementation. [<a href="bib.xhtml#bib59">Love, 2010</a>] and [<a href="bib.xhtml#bib09">Bovet &#38; Cesati, 2005</a>] describe the Linux VFS implementation.</p>
<p class="indent">Documentation on various file systems can be found in the kernel source subdirectory <span class="literal">Documentation/filesystems</span>. Individual web sites can be found describing most of the file-system implementations available on Linux.</p>
<h3 class="h3" id="ch14lev1sec13"><strong>14.13 Exercise</strong></h3>
<p class="exer"><a id="ch14exe1"/><strong>14-1.</strong>&#160;&#160;&#160;Write a program that measures the time required to create and then remove a large number of 1-byte files from a single directory. The program should create files with names of the form <span class="literal">xNNNNNN</span>, where <span class="literal">NNNNNN</span> is replaced by a random six-digit number. The files should be created in the random order in which their names are generated, and then deleted in increasing numerical order (i.e., an order that is different from that in which they were created). The number of files (<em>NF</em>) and the directory in which they are to be created should be specifiable on the command line. Measure the times required for different values of <em>NF</em> (e.g., in the range from 1000 to 20,000) and for different file systems (e.g., <em>ext2</em>, <em>ext3</em>, and <em>XFS</em>). What patterns do you observe on each file system as <em>NF</em> increases? How do the various file systems compare? Do the results change if the files are created in increasing numerical order (<span class="literal">x000000</span>, <span class="literal">x000001</span>, <span class="literal">x0000002</span>, and so on) and then deleted in the same order? If so, what do you think the reason(s) might be? Again, do the results vary across file-system types?</p>
</body>
</html>
