<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch61"><span epub:type="pagebreak" id="page_1253"/><strong><span class="big">61</span></strong><br/><strong>SOCKETS: ADVANCED TOPICS</strong></h2>
<p class="noindentab">This chapter considers a range of more advanced topics relating to sockets programming, including the following:</p>
<p class="bull">&#8226; the circumstances in which partial reads and writes can occur on stream sockets;</p>
<p class="bull">&#8226; the use of <em>shutdown()</em> to close one half of the bidirectional channel between two connected sockets;</p>
<p class="bull">&#8226; the <em>recv()</em> and <em>send()</em> I/O system calls, which provide socket-specific functionality not available with <em>read()</em> and <em>write()</em>;</p>
<p class="bull">&#8226; the <em>sendfile()</em> system call, which is used in certain circumstances to efficiently output data on a socket;</p>
<p class="bull">&#8226; details of the operation of the TCP protocol, with the aim of eliminating some common misunderstandings that lead to mistakes when writing programs that use TCP sockets;</p>
<p class="bull">&#8226; the use of the <em>netstat</em> and <em>tcpdump</em> commands for monitoring and debugging applications that use sockets; and</p>
<p class="bull">&#8226; the use of the <em>getsockopt()</em> and <em>setsockopt()</em> system calls to retrieve and modify options affecting the operation of a socket.</p>
<p class="noindentt">We also consider a number of other more minor topics, and conclude the chapter with a summary of some advanced sockets features.</p>
<h3 class="h3" id="ch61lev1sec01"><span epub:type="pagebreak" id="page_1254"/><strong>61.1 Partial Reads and Writes on Stream Sockets</strong></h3>
<p class="noindenta">When we first introduced the <em>read()</em> and <em>write()</em> system calls in <a href="ch04.xhtml#ch04">Chapter 4</a>, we noted that, in some circumstances, they may transfer fewer bytes than requested. Such partial transfers can occur when performing I/O on stream sockets. We now consider why they can occur and show a pair of functions that transparently handle partial transfers.</p>
<p class="indent">A partial read may occur if there are fewer bytes available in the socket than were requested in the <em>read()</em> call. In this case, <em>read()</em> simply returns the number of bytes available. (This is the same behavior that we saw with pipes and FIFOs in <a href="ch44.xhtml#ch44lev1sec10">Section 44.10</a>.)</p>
<p class="indentb">A partial write may occur if there is insufficient buffer space to transfer all of the requested bytes and one of the following is true:</p>
<p class="bull">&#8226; A signal handler interrupted the <em>write()</em> call (<a href="ch21.xhtml#ch21lev1sec05">Section 21.5</a>) after it transferred some of the requested bytes.</p>
<p class="bull">&#8226; The socket was operating in nonblocking mode (<span class="literal">O_NONBLOCK</span>), and it was possible to transfer only some of the requested bytes.</p>
<p class="bull">&#8226; An asynchronous error occurred after only some of the requested bytes had been transferred. By an <em>asynchronous error</em>, we mean an error that occurs asynchronously with respect to the application&#8217;s use of calls in the sockets API. An asynchronous error can arise, for example, because of a problem with a TCP connection, perhaps resulting from a crash by the peer application.</p>
<p class="noindentt">In all of the above cases, assuming that there was space to transfer at least 1 byte, the <em>write()</em> is successful, and returns the number of bytes that were transferred to the output buffer.</p>
<p class="indent">If a partial I/O occurs&#8212;for example, if a <em>read()</em> returns fewer bytes than requested or a blocked <em>write()</em> is interrupted by a signal handler after transferring only part of the requested data&#8212;then it is sometimes useful to restart the system call to complete the transfer. In <a href="ch61.xhtml#ch61ex1">Listing 61-1</a>, we provide two functions that do this: <em>readn()</em> and <em>writen()</em>. (The ideas for these functions are drawn from functions of the same name presented in [<a href="bib.xhtml#bib93">Stevens et al., 2004</a>].)</p>
<div class="box">
<p class="programsa">#include "rdwrn.h"<br/><br/>ssize_t <span class="codestrong">readn</span>(int <span class="font1">fd</span>, void *<span class="font1">buffer</span>, size_t <span class="font1">count</span>);</p>
<p class="right">Returns number of bytes read, 0 on EOF, or &#8211;1 on error</p>
<p class="programsat">ssize_t <span class="codestrong">writen</span>(int fd, void *<span class="font1">buffer</span>, size_t <span class="font1">count</span>);</p>
<p class="right">Returns number of bytes written, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>readn()</em> and <em>writen()</em> functions take the same arguments as <em>read()</em> and <em>write()</em>. However, they use a loop to restart these system calls, thus ensuring that the requested number of bytes is always transferred (unless an error occurs or end-of-file is detected on a <em>read()</em>).</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1255"/><a id="ch61ex1"/><strong>Listing 61-1:</strong> Implementation of <em>readn()</em> and <em>writen()</em></p>
<p class="programsli">__________________________________________________________ <span class="codestrong">sockets/rdwrn.c</span><br/><br/>#include &lt;unistd.h&gt;<br/>#include &lt;errno.h&gt;<br/>#include "rdwrn.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declares readn() and writen() */<br/><br/>ssize_t<br/>readn(int fd, void *buffer, size_t n)<br/>{<br/>&#160;&#160;&#160;&#160;ssize_t numRead;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* # of bytes fetched by last read() */<br/>&#160;&#160;&#160;&#160;size_t totRead;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Total # of bytes read so far */<br/>&#160;&#160;&#160;&#160;char *buf;<br/><br/>&#160;&#160;&#160;&#160;buf = buffer;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* No pointer arithmetic on "void *" */<br/>&#160;&#160;&#160;&#160;for (totRead = 0; totRead &lt; n; ) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numRead = read(fd, buf, n - totRead);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead == 0)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* EOF */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return totRead;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* May be 0 if this is first read() */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno == EINTR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Interrupted --&gt; restart read() */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Some other error */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;totRead += numRead;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;buf += numRead;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return totRead;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Must be 'n' bytes if we get here */<br/>}<br/><br/>ssize_t<br/>writen(int fd, const void *buffer, size_t n)<br/>{<br/>&#160;&#160;&#160;&#160;ssize_t numWritten;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* # of bytes written by last write() */<br/>&#160;&#160;&#160;&#160;size_t totWritten;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Total # of bytes written so far */<br/>&#160;&#160;&#160;&#160;const char *buf;<br/><br/>&#160;&#160;&#160;&#160;buf = buffer;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* No pointer arithmetic on "void *" */<br/>&#160;&#160;&#160;&#160;for (totWritten = 0; totWritten &lt; n; ) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numWritten = write(fd, buf, n - totWritten);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numWritten &lt;= 0) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numWritten == -1 &#38;&#38; errno == EINTR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Interrupted --&gt; restart write() */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Some other error */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;totWritten += numWritten;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;buf += numWritten;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return totWritten;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Must be 'n' bytes if we get here */<br/>}<br/>__________________________________________________________ <span class="codestrong">sockets/rdwrn.c</span></p>
<h3 class="h3" id="ch61lev1sec02"><span epub:type="pagebreak" id="page_1256"/><strong>61.2 The <em>shutdown()</em> System Call</strong></h3>
<p class="noindenta">Calling <em>close()</em> on a socket closes both halves of the bidirectional communication channel. Sometimes, it is useful to close one half of the connection, so that data can be transmitted in just one direction through the socket. The <em>shutdown()</em> system call provides this functionality.</p>
<div class="box">
<p class="programsa">#include &lt;sys/socket.h&gt;<br/><br/>int <span class="codestrong">shutdown</span>(int <span class="font1">sockfd</span>, int <span class="font1">how</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb">The <em>shutdown()</em> system call closes one or both channels of the socket <em>sockfd</em>, depending on the value of <em>how</em>, which is specified as one of the following:</p>
<p class="term"><span class="literal">SHUT_RD</span></p>
<p class="termlist">Close the reading half of the connection. Subsequent reads will return end-of-file (0). Data can still be written to the socket. After a <span class="literal">SHUT_RD</span> on a UNIX domain stream socket, the peer application receives a <span class="literal">SIGPIPE</span> signal and the <span class="literal">EPIPE</span> error if it makes further attempts to write to the peer socket. As discussed in <a href="ch61.xhtml#ch61lev2sec06">Section 61.6.6</a>, <span class="literal">SHUT_RD</span> can&#8217;t be used meaningfully for TCP sockets.</p>
<p class="term"><span class="literal">SHUT_WR</span></p>
<p class="termlist">Close the writing half of the connection. Once the peer application has read all outstanding data, it will see end-of-file. Subsequent writes to the local socket yield the <span class="literal">SIGPIPE</span> signal and an <span class="literal">EPIPE</span> error. Data written by the peer can still be read from the socket. In other words, this operation allows us to signal end-of-file to the peer while still being able to read data that the peer sends back to us. The <span class="literal">SHUT_WR</span> operation is employed by programs such as <em>ssh</em> and <em>rsh</em> (refer to <a href="ch18.xhtml#ch18lev1sec05">Section 18.5</a> of [<a href="bib.xhtml#bib91">Stevens, 1994</a>]). The <span class="literal">SHUT_WR</span> operation is the most common use of <em>shutdown()</em>, and is sometimes referred to as a <em>socket half-close</em>.</p>
<p class="term"><span class="literal">SHUT_RDWR</span></p>
<p class="termlist">Close both the read and the write halves of the connection. This is the same as performing a <span class="literal">SHUT_RD</span> followed by a <span class="literal">SHUT_WR</span>.</p>
<p class="noindentt">Aside from the semantics of the <em>how</em> argument, <em>shutdown()</em> differs from <em>close()</em> in another important respect: it closes the socket channel(s) regardless of whether there are other file descriptors referring to the socket. (In other words, <em>shutdown()</em> is performing an operation on the open file description, rather than the file descriptor. See <a href="ch05.xhtml#ch5fig2">Figure 5-2</a>, on <a href="ch05.xhtml#page_95">page 95</a>.) Suppose, for example, that <em>sockfd</em> refers to a connected stream socket. If we make the following calls, then the connection remains open, and we can still perform I/O on the connection via the file descriptor <em>fd2</em>:</p>
<p class="programs">fd2 = dup(sockfd);<br/>close(sockfd);</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1257"/>However, if we make the following sequence of calls, then both channels of the connection are closed, and I/O can no longer be performed via <em>fd2</em>:</p>
<p class="programs">fd2 = dup(sockfd);<br/>shutdown(sockfd, SHUT_RDWR);</p>
<p class="noindent">A similar scenario holds if a file descriptor for a socket is duplicated during a <em>fork()</em>. If, after the <em>fork()</em>, one process does a <span class="literal">SHUT_RDWR</span> on its copy of the descriptor, then the other process also can no longer perform I/O on its descriptor.</p>
<p class="indent">Note that <em>shutdown()</em> doesn&#8217;t close the file descriptor, even if <em>how</em> is specified as <span class="literal">SHUT_RDWR</span>. To close the file descriptor, we must additionally call <em>close()</em>.</p>
<h5 class="h5" id="ch61lev3sec01"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch61.xhtml#ch61ex2">Listing 61-2</a> demonstrates the use of the <em>shutdown()</em> <span class="literal">SHUT_WR</span> operation. This program is a TCP client for the <em>echo</em> service. (We presented a TCP server for the <em>echo</em> service in <a href="ch60.xhtml#ch60lev1sec03">Section 60.3</a>.) To shorten the implementation, we make use of functions in the Internet domain sockets library shown in <a href="ch59.xhtml#ch59lev1sec12">Section 59.12</a>.</p>
<div class="block">
<p class="noindent">In some Linux distributions, the <em>echo</em> service is not enabled by default, and therefore we must enable it before running the program in <a href="ch61.xhtml#ch61ex2">Listing 61-2</a>. Typically, this service is implemented internally by the <em>inetd(8)</em> daemon (<a href="ch60.xhtml#ch60lev1sec05">Section 60.5</a>), and, to enable the <em>echo</em> service, we must edit the file <span class="literal">/etc/inetd.conf</span> to uncomment the two lines corresponding to the UDP and TCP <em>echo</em> services (see <a href="ch60.xhtml#ch60ex5">Listing 60-5</a>, on <a href="ch60.xhtml#page_1249">page 1249</a>), and then send a <span class="literal">SIGHUP</span> signal to the <em>inetd</em> daemon.</p>
<p class="indent">Many distributions supply the more modern <em>xinetd(8)</em> instead of <em>inetd(8)</em>. Consult the <em>xinetd</em> documentation for information about how to make the equivalent changes under <em>xinetd</em>.</p>
</div>
<p class="noindent">As its single command-line argument, the program takes the name of the host on which the <em>echo</em> server is running. The client performs a <em>fork()</em>, yielding parent and child processes.</p>
<p class="indent">The client parent writes the contents of standard input to the socket, so that it can be read by the <em>echo</em> server. When the parent detects end-of-file on standard input, it uses <em>shutdown()</em> to close the writing half of its socket. This causes the <em>echo</em> server to see end-of-file, at which point it closes its socket (which causes the client child in turn to see end-of-file). The parent then terminates.</p>
<p class="indent">The client child reads the <em>echo</em> server&#8217;s response from the socket and echoes the response on standard output. The child terminates when it sees end-of-file on the socket.</p>
<p class="indent">The following shows an example of what we see when running this program:</p>
<p class="programs">$ <span class="codestrong">cat &gt; tell-tale-heart.txt</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create a file for testing</span><br/><span class="codestrong">It is impossible to say how the idea entered my brain;</span><br/><span class="codestrong">but once conceived, it haunted me day and night.</span><br/><span class="font1">Type Control-D</span><br/>$ <span class="codestrong">./is_echo_cl tekapo &lt; tell-tale-heart.txt</span><br/>It is impossible to say how the idea entered my brain;<br/>but once conceived, it haunted me day and night.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1258"/><a id="ch61ex2"/><strong>Listing 61-2:</strong> A client for the <em>echo</em> service</p>
<p class="programsli">______________________________________________________ <span class="codestrong">sockets/is_echo_cl.c</span><br/><br/>#include "inet_sockets.h"<br/>#include "tlpi_hdr.h"<br/><br/>#define BUF_SIZE 100<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int sfd;<br/>&#160;&#160;&#160;&#160;ssize_t numRead;<br/>&#160;&#160;&#160;&#160;char buf[BUF_SIZE];<br/><br/>&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s host\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;sfd = inetConnect(argv[1], "echo", SOCK_STREAM);<br/>&#160;&#160;&#160;&#160;if (sfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("inetConnect");<br/><br/>&#160;&#160;&#160;&#160;switch (fork()) {<br/>&#160;&#160;&#160;&#160;case -1:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;case 0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child: read server's response, echo on stdout */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (;;) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numRead = read(sfd, buf, BUF_SIZE);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead &lt;= 0)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Exit on EOF or error */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%.*s", (int) numRead, buf);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/><br/>&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent: write contents of stdin to socket */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (;;) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numRead = read(STDIN_FILENO, buf, BUF_SIZE);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead &lt;= 0)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Exit loop on EOF or error */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (write(sfd, buf, numRead) != numRead)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("write() failed");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Close writing channel, so server sees EOF */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (shutdown(sfd, SHUT_WR) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("shutdown");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>______________________________________________________ <span class="codestrong">sockets/is_echo_cl.c</span></p>
<h3 class="h3" id="ch61lev1sec03"><span epub:type="pagebreak" id="page_1259"/><strong>61.3 Socket-Specific I/O System Calls: <em>recv()</em> and <em>send()</em></strong></h3>
<p class="noindenta">The <em>recv()</em> and <em>send()</em> system calls perform I/O on connected sockets. They provide socket-specific functionality that is not available with the traditional <em>read()</em> and <em>write()</em> system calls.</p>
<div class="box">
<p class="programsa">#include &lt;sys/socket.h&gt;<br/><br/>ssize_t <span class="codestrong">recv</span>(int <span class="font1">sockfd</span>, void *<span class="font1">buffer</span>, size_t <span class="font1">length</span>, int <span class="font1">flags</span>);</p>
<p class="right">Returns number of bytes received, 0 on EOF, or &#8211;1 on error</p>
<p class="programsat">ssize_t <span class="codestrong">send</span>(int <span class="font1">sockfd</span>, const void *<span class="font1">buffer</span>, size_t <span class="font1">length</span>, int <span class="font1">flags</span>);</p>
<p class="right">Returns number of bytes sent, or &#8211;1 on error</p>
</div>
<p class="noindentb">The return value and the first three arguments to <em>recv()</em> and <em>send()</em> are the same as for <em>read()</em> and <em>write()</em>. The last argument, <em>flags</em>, is a bit mask that modifies the behavior of the I/O operation. For <em>recv()</em>, the bits that may be ORed in <em>flags</em> include the following:</p>
<p class="term"><span class="literal">MSG_DONTWAIT</span></p>
<p class="termlist">Perform a nonblocking <em>recv()</em>. If no data is available, then instead of blocking, return immediately with the error <span class="literal">EAGAIN</span>. We can obtain the same behavior by using <em>fcntl()</em> to set nonblocking mode (<span class="literal">O_NONBLOCK</span>) on the socket, with the difference that <span class="literal">MSG_DONTWAIT</span> allows us to control nonblocking behavior on a per-call basis.</p>
<p class="term"><span class="literal">MSG_OOB</span></p>
<p class="termlist">Receive out-of-band data on the socket. We briefly describe this feature in <a href="ch61.xhtml#ch61lev2sec08">Section 61.13.1</a>.</p>
<p class="term"><span class="literal">MSG_PEEK</span></p>
<p class="termlist">Retrieve a copy of the requested bytes from the socket buffer, but don&#8217;t actually remove them from the buffer. The data can later be reread by another <em>recv()</em> or <em>read()</em> call.</p>
<p class="term"><span class="literal">MSG_WAITALL</span></p>
<p class="termlist">Normally, a <em>recv()</em> call returns the lesser of the number of bytes requested (<em>length</em>) and the number of bytes actually available in the socket. Specifying the <span class="literal">MSG_WAITALL</span> flag causes the system call to block until <em>length</em> bytes have been received. However, even when this flag is specified, the call may return fewer bytes than requested if: (a) a signal is caught; (b) the peer on a stream socket terminated the connection; (c) an out-of-band data byte (<a href="ch61.xhtml#ch61lev2sec08">Section 61.13.1</a>) was encountered; (d) the received message from a datagram socket is less than <em>length</em> bytes; or (e) an error occurs on the socket. (The <span class="literal">MSG_WAITALL</span> flag can replace the <em>readn()</em> function that we show in <a href="ch61.xhtml#ch61ex1">Listing 61-1</a>, with the difference that our <em>readn()</em> function does restart itself if interrupted by a signal handler.)</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_1260"/>All of the above flags are specified in SUSv3, except for <span class="literal">MSG_DONTWAIT</span>, which is nevertheless available on some other UNIX implementations. The <span class="literal">MSG_WAITALL</span> flag was a later addition to the sockets API, and is not present in some older implementations.</p>
<p class="indentb">For <em>send()</em>, the bits that may be ORed in <em>flags</em> include the following:</p>
<p class="term"><span class="literal">MSG_DONTWAIT</span></p>
<p class="termlist">Perform a nonblocking <em>send()</em>. If the data can&#8217;t be immediately transferred (because the socket send buffer is full), then, instead of blocking, fail with the error <span class="literal">EAGAIN</span>. As with <em>recv()</em>, the same effect can be achieved by setting the <span class="literal">O_NONBLOCK</span> flag for the socket.</p>
<p class="term"><span class="literal">MSG_MORE</span> (since Linux 2.4.4)</p>
<p class="termlist">This flag is used with TCP sockets to achieve the same effect as the <span class="literal">TCP_CORK</span> socket option (<a href="ch61.xhtml#ch61lev1sec04">Section 61.4</a>), with the difference that it provides corking of data on a per-call basis. Since Linux 2.6, this flag can also be used with datagram sockets, where it has a different meaning. Data transmitted in successive <em>send()</em> or <em>sendto()</em> calls specifying <span class="literal">MSG_MORE</span> is packaged into a single datagram that is transmitted only when a further call is made that does not specify this flag. (Linux also provides an analogous <span class="literal">UDP_CORK</span> socket option that causes data from successive <em>send()</em> or <em>sendto()</em> calls to be accumulated into a single datagram that is transmitted when <span class="literal">UDP_CORK</span> is disabled.) The <span class="literal">MSG_MORE</span> flag has no effect for UNIX domain sockets.</p>
<p class="term"><span class="literal">MSG_NOSIGNAL</span></p>
<p class="termlist">When sending data on a connected stream socket, don&#8217;t generate a <span class="literal">SIGPIPE</span> signal if the other end of the connection has been closed. Instead, the <em>send()</em> call fails with the error <span class="literal">EPIPE</span>. This is the same behavior as can be obtained by ignoring the <span class="literal">SIGPIPE</span> signal, with the difference that the <span class="literal">MSG_NOSIGNAL</span> flag controls the behavior on a per-call basis.</p>
<p class="term"><span class="literal">MSG_OOB</span></p>
<p class="termlist">Send out-of-band data on a stream socket. Refer to <a href="ch61.xhtml#ch61lev2sec08">Section 61.13.1</a>.</p>
<p class="noindentt">Of the above flags, only <span class="literal">MSG_OOB</span> is specified by SUSv3. SUSv4 adds a specification for <span class="literal">MSG_NOSIGNAL. MSG_DONTWAIT</span> is not standardized, but appears on a few other UNIX implementations<span class="literal">. MSG_MORE</span> is Linux-specific. The <em>send(2)</em> and <em>recv(2)</em> manual pages describe further flags that we don&#8217;t cover here.</p>
<h3 class="h3" id="ch61lev1sec04"><strong>61.4 The <em>sendfile()</em> System Call</strong></h3>
<p class="noindenta">Applications such as web servers and file servers frequently need to transfer the unaltered contents of a disk file through a (connected) socket. One way to do this would be a loop of the following form:</p>
<p class="programs">while ((n = read(diskfilefd, buf, BUZ_SIZE)) &gt; 0)<br/>&#160;&#160;&#160;&#160;write(sockfd, buf, n);</p>
<p class="noindent">For many applications, such a loop is perfectly acceptable. However, if we frequently transfer large files via a socket, this technique is inefficient. In order to transmit the file, we must use two system calls (possibly multiple times within a loop): one to copy the file contents from the kernel buffer cache into user space, <span epub:type="pagebreak" id="page_1261"/>and the other to copy the user-space buffer back to kernel space in order to be transmitted via the socket. This scenario is shown on the left side of <a href="ch61.xhtml#ch61fig1">Figure 61-1</a>. Such a two-step process is wasteful if the application doesn&#8217;t perform any processing of the file contents before transmitting them. The <em>sendfile()</em> system call is designed to eliminate this inefficiency. When an application calls <em>sendfile()</em>, the file contents are transferred directly to the socket, without passing through user space, as shown on the right side of <a href="ch61.xhtml#ch61fig1">Figure 61-1</a>. This is referred to as a <em>zero-copy transfer</em>.</p>
<div class="image"><img src="../images/f61-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch61fig1"/><strong>Figure 61-1:</strong> Transferring the contents of a file to a socket</p>
<div class="box">
<p class="programsa">#include &lt;sys/sendfile.h&gt;<br/><br/>ssize_t <span class="codestrong">sendfile</span>(int <span class="font1">out_fd</span>, int <span class="font1">in_fd</span>, off_t *<span class="font1">offset</span>, size_t <span class="font1">count</span>);</p>
<p class="right">Returns number of bytes transferred, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>sendfile()</em> system call transfers bytes from the file referred to by the descriptor <em>in_fd</em> to the file referred to by the descriptor <em>out_fd</em>. The <em>out_fd</em> descriptor must refer to a socket. The <em>in_fd</em> argument must refer to a file to which <em>mmap()</em> can be applied; in practice, this usually means a regular file. This somewhat restricts the use of <em>sendfile()</em>. We can use it to pass data from a file to a socket, but not vice versa. And we can&#8217;t use <em>sendfile()</em> to pass data directly from one socket to another.</p>
<div class="block">
<p class="noindent">Performance benefits could also be obtained if <em>sendfile()</em> could be used to transfer bytes between two regular files. On Linux 2.4 and earlier, <em>out_fd</em> could refer to a regular file. Some reworking of the underlying implementation meant that this possibility disappeared in the 2.6 kernel. Some later changes restored this feature in Linux 2.6.33.</p>
</div>
<p class="noindent">If <em>offset</em> is not <span class="literal">NULL</span>, then it should point to an <em>off_t</em> value that specifies the starting file offset from which bytes should be transferred from <em>in_fd</em>. This is a value-result argument. On return, it contains the offset of the next byte following the last byte that was transferred from <em>in_fd</em>. In this case, <em>sendfile()</em> doesn&#8217;t change the file offset for <em>in_fd</em>.</p>
<p class="indent">If <em>offset</em> is <span class="literal">NULL</span>, then bytes are transferred from <em>in_fd</em> starting at the current file offset, and the file offset is updated to reflect the number of bytes transferred.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1262"/>The <em>count</em> argument specifies the number of bytes to be transferred. If end-of-file is encountered before <em>count</em> bytes are transferred, only the available bytes are transferred. On success, <em>sendfile()</em> returns the number of bytes actually transferred.</p>
<p class="indent">SUSv3 doesn&#8217;t specify <em>sendfile()</em>. Versions of <em>sendfile()</em> are available on some other UNIX implementations, but the argument list is typically different from the version on Linux.</p>
<div class="block">
<p class="noindent">Starting with kernel 2.6.17, Linux provides three new (nonstandard) system calls&#8212;<em>splice()</em>, <em>vmsplice()</em>, and <em>tee()</em>&#8212;that provide a superset of the functionality of <em>sendfile()</em>. See the manual pages for details.</p>
</div>
<h5 class="h5" id="ch61lev3sec02"><strong>The</strong> <span class="literal"><span class="codestrong">TCP_CORK</span></span> <strong>socket option</strong></h5>
<p class="noindenta">To further improve the efficiency of TCP applications using <em>sendfile()</em>, it is sometimes useful to employ the Linux-specific <span class="literal">TCP_CORK</span> socket option. As an example, consider a web server delivering a page in response to a request by a web browser. The web server&#8217;s response consists of two parts: HTTP headers, perhaps output using <em>write()</em>, followed by the page data, perhaps output using <em>sendfile()</em>. In this scenario, normally <em>two</em> TCP segments are transmitted: the headers are sent in the first (rather small) segment, and then the page data is sent in a second segment. This is an inefficient use of network bandwidth. It probably also creates unnecessary work for both the sending and the receiving TCP, since in many cases the HTTP headers and the page data would be small enough to fit inside a single TCP segment. The <span class="literal">TCP_CORK</span> option is designed to address this inefficiency.</p>
<p class="indent">When the <span class="literal">TCP_CORK</span> option is enabled on a TCP socket, all subsequent output is buffered into a single TCP segment until either the upper limit on the size of a segment is reached, the <span class="literal">TCP_CORK</span> option is disabled, the socket is closed, or a maximum of 200 milliseconds passes from the time that the first corked byte is written. (The timeout ensures that the corked data is transmitted if the application forgets to disable the <span class="literal">TCP_CORK</span> option.)</p>
<p class="indent">We enable and disable the <span class="literal">TCP_CORK</span> option using the <em>setsockopt()</em> system call (<a href="ch61.xhtml#ch61lev1sec09">Section 61.9</a>). The following code (which omits error checking) demonstrates the use of <span class="literal">TCP_CORK</span> for our hypothetical HTTP server example:</p>
<p class="programs">int optval;<br/><br/>/* Enable TCP_CORK option on 'sockfd' - subsequent TCP output is corked<br/>&#160;&#160;&#160;until this option is disabled. */<br/><br/>optval = 1;<br/>setsockopt(sockfd, IPPROTO_TCP, TCP_CORK, &#38;optval, sizeof(optval));<br/><br/>write(sockfd, ...);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Write HTTP headers */<br/>sendfile(sockfd, ...);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Send page data */<br/><br/>/* Disable TCP_CORK option on 'sockfd' - corked output is now transmitted<br/>&#160;&#160;&#160;in a single TCP segment. */<br/><br/>optval = 0<br/>setsockopt(sockfd, IPPROTO_TCP, TCP_CORK, &#38;optval, sizeof(optval));</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1263"/>We could avoid the possibility of two segments being transmitted by building a single data buffer within our application, and then transmitting that buffer with a single <em>write()</em>. (Alternatively, we could use <em>writev()</em> to combine two distinct buffers in a single output operation.) However, if we want to combine the zero-copy efficiency of <em>sendfile()</em> with the ability to include a header as part of the first segment of transmitted file data, then we need to use <span class="literal">TCP_CORK</span>.</p>
<div class="block">
<p class="noindent">In <a href="ch61.xhtml#ch61lev1sec03">Section 61.3</a>, we noted that the <span class="literal">MSG_MORE</span> flag provides similar functionality to <span class="literal">TCP_CORK</span>, but on a per-system-call basis. This is not necessarily an advantage. It is possible to set the <span class="literal">TCP_CORK</span> option on the socket, and then exec a program that performs output on the inherited file descriptor without being aware of the <span class="literal">TCP_CORK</span> option. By contrast, the use of <span class="literal">MSG_MORE</span> requires explicit changes to the source code of a program.</p>
<p class="indent">FreeBSD provides an option similar to <span class="literal">TCP_CORK</span> in the form of <span class="literal">TCP_NOPUSH</span>.</p>
</div>
<h3 class="h3" id="ch61lev1sec05"><strong>61.5 Retrieving Socket Addresses</strong></h3>
<p class="noindenta">The <em>getsockname()</em> and <em>getpeername()</em> system calls return, respectively, the local address to which a socket is bound and the address of the peer socket to which the local socket is connected.</p>
<div class="box">
<p class="programsa">#include &lt;sys/socket.h&gt;<br/><br/>int <span class="codestrong">getsockname</span>(int <span class="font1">sockfd</span>, struct sockaddr *<span class="font1">addr</span>, socklen_t *<span class="font1">addrlen</span>);<br/>int <span class="codestrong">getpeername</span>(int <span class="font1">sockfd</span>, struct sockaddr *<span class="font1">addr</span>, socklen_t *<span class="font1">addrlen</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">For both calls, <em>sockfd</em> is a file descriptor referring to a socket, and <em>addr</em> is a pointer to a suitably sized buffer that is used to return a structure containing the socket address. The size and type of this structure depend on the socket domain. The <em>addrlen</em> argument is a value-result argument. Before the call, it should be initialized to the length of the buffer pointed to by <em>addr</em>; on return, it contains the number of bytes actually written to this buffer.</p>
<p class="indent">The <em>getsockname()</em> function returns a socket&#8217;s address family and the address to which a socket is bound. This is useful if the socket was bound by another program (e.g., <em>inetd(8)</em>) and the socket file descriptor was then preserved across an <em>exec()</em>.</p>
<p class="indentb">Calling <em>getsockname()</em> is also useful if we want to determine the ephemeral port number that the kernel assigned to a socket when performing an implicit bind of an Internet domain socket. The kernel performs an implicit bind in the following circumstances:</p>
<p class="bull">&#8226; after a <em>connect()</em> or a <em>listen()</em> call on a TCP socket that has not previously been bound to an address by <em>bind()</em>;</p>
<p class="bull">&#8226; on the first <em>sendto()</em> on a UDP socket that had not previously been bound to an address; or</p>
<p class="bull">&#8226; after a <em>bind()</em> call where the port number (<em>sin_port</em>) was specified as 0. In this case, the <em>bind()</em> specifies the IP address for the socket, but the kernel selects an ephemeral port number.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_1264"/>The <em>getpeername()</em> system call returns the address of the peer socket on a stream socket connection. This is useful primarily with TCP sockets, if the server wants to find out the address of the client that has made a connection. This information could also be obtained when the <em>accept()</em> call is performed; however, if the server was execed by the program that did the <em>accept()</em> (e.g., <em>inetd</em>), then it inherits the socket file descriptor, but the address information returned by <em>accept()</em> is no longer available.</p>
<p class="indent"><a href="ch61.xhtml#ch61ex3">Listing 61-3</a> demonstrates the use of <em>getsockname()</em> and <em>getpeername()</em>. This program employs the functions that we defined in <a href="ch59.xhtml#ch59ex9">Listing 59-9</a> (on <a href="ch59.xhtml#page_1228">page 1228</a>), and performs the following steps:</p>
<ol>
<li class="order"><p class="orderp">Use our <em>inetListen()</em> function to create a listening socket, <em>listenFd</em>, bound to the wildcard IP address and the port specified in the program&#8217;s sole command-line argument. (The port can be specified numerically or as a service name.) The <em>len</em> argument returns the length of the address structure for this socket&#8217;s domain. This value is passed in a later call to <em>malloc()</em> to allocate a buffer that is used to return a socket address from calls to <em>getsockname()</em> and <em>getpeername()</em>.</p></li>
<li class="order"><p class="orderp">Use our <em>inetConnect()</em> function to create a second socket, <em>connFd</em>, which is used to send a connection request to the socket created in step 1.</p></li>
<li class="order"><p class="orderp">Call <em>accept()</em> on the listening socket in order to create a third socket, <em>acceptFd</em>, that is connected to the socket created in the previous step.</p></li>
<li class="order"><p class="orderp">Use calls to <em>getsockname()</em> and <em>getpeername()</em> to obtain the local and peer addresses for the two connected sockets, <em>connFd</em> and <em>acceptFd</em>. After each of these calls, the program uses our <em>inetAddressStr()</em> function to convert the socket address into printable form.</p></li>
<li class="order"><p class="orderp">Sleep for a few seconds so that we can run <em>netstat</em> in order to confirm the socket address information. (We describe <em>netstat</em> in <a href="ch61.xhtml#ch61lev1sec07">Section 61.7</a>.)</p></li>
</ol>
<p class="noindent">The following shell session log shows an example run of this program:</p>
<p class="programs">$ <span class="codestrong">./socknames 55555 &#38;</span><br/>getsockname(connFd):&#160;&#160;&#160;(localhost, 32835)<br/>getsockname(acceptFd): (localhost, 55555)<br/>getpeername(connFd):&#160;&#160;&#160;(localhost, 55555)<br/>getpeername(acceptFd): (localhost, 32835)<br/>[1] 8171<br/>$ <span class="codestrong">netstat -a | egrep '(Address|55555)'</span><br/>Proto Recv-Q Send-Q Local Address&#160;&#160;&#160;&#160;Foreign Address&#160;&#160;State<br/>tcp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;0 *:55555&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*:*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LISTEN<br/>tcp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;0 localhost:32835&#160;&#160;localhost:55555&#160;&#160;ESTABLISHED<br/>tcp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;0 localhost:55555&#160;&#160;localhost:32835&#160;&#160;ESTABLISHED</p>
<p class="noindent">From the above output, we can see that the connected socket (<em>connFd</em>) was bound to the ephemeral port 32835. The <em>netstat</em> command shows us information about all three sockets created by the program, and allows us to confirm the port information for the two connected sockets, which are in the ESTABLISHED state (described in <a href="ch61.xhtml#ch61lev2sec03">Section 61.6.3</a>).</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1265"/><a id="ch61ex3"/><strong>Listing 61-3:</strong> Using <em>getsockname()</em> and <em>getpeername()</em></p>
<p class="programsli">______________________________________________________ <span class="codestrong">sockets/socknames.c</span><br/><br/>#include "inet_sockets.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declares our socket functions */<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int listenFd, acceptFd, connFd;<br/>&#160;&#160;&#160;&#160;socklen_t len;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Size of socket address buffer */<br/>&#160;&#160;&#160;&#160;void *addr;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Buffer for socket address */<br/>&#160;&#160;&#160;&#160;char addrStr[IS_ADDR_STR_LEN];<br/><br/>&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s service\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;listenFd = inetListen(argv[1], 5, &#38;len);<br/>&#160;&#160;&#160;&#160;if (listenFd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("inetListen");<br/><br/>&#160;&#160;&#160;&#160;connFd = inetConnect(NULL, argv[1], SOCK_STREAM);<br/>&#160;&#160;&#160;&#160;if (connFd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("inetConnect");<br/><br/>&#160;&#160;&#160;&#160;acceptFd = accept(listenFd, NULL, NULL);<br/>&#160;&#160;&#160;&#160;if (acceptFd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("accept");<br/><br/>&#160;&#160;&#160;&#160;addr = malloc(len);<br/>&#160;&#160;&#160;&#160;if (addr == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("malloc");<br/><br/>&#160;&#160;&#160;&#160;if (getsockname(connFd, addr, &#38;len) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("getsockname");<br/>&#160;&#160;&#160;&#160;printf("getsockname(connFd): %s\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;inetAddressStr(addr, len, addrStr, IS_ADDR_STR_LEN));<br/>&#160;&#160;&#160;&#160;if (getsockname(acceptFd, addr, &#38;len) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("getsockname");<br/>&#160;&#160;&#160;&#160;printf("getsockname(acceptFd): %s\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;inetAddressStr(addr, len, addrStr, IS_ADDR_STR_LEN));<br/><br/>&#160;&#160;&#160;&#160;if (getpeername(connFd, addr, &#38;len) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("getpeername");<br/>&#160;&#160;&#160;&#160;printf("getpeername(connFd): %s\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;inetAddressStr(addr, len, addrStr, IS_ADDR_STR_LEN));<br/>&#160;&#160;&#160;&#160;if (getpeername(acceptFd, addr, &#38;len) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("getpeername");<br/>&#160;&#160;&#160;&#160;printf("getpeername(acceptFd): %s\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;inetAddressStr(addr, len, addrStr, IS_ADDR_STR_LEN));<br/><br/>&#160;&#160;&#160;&#160;sleep(30);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Give us time to run netstat(8) */<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>______________________________________________________ <span class="codestrong">sockets/socknames.c</span></p>
<h3 class="h3" id="ch61lev1sec06"><span epub:type="pagebreak" id="page_1266"/><strong>61.6 A Closer Look at TCP</strong></h3>
<p class="noindentab">Knowing some of the details of the operation of TCP helps us to debug applications that use TCP sockets, and, in some cases, to make such applications more efficient. In the following sections, we look at:</p>
<p class="bull">&#8226; the format of TCP segments;</p>
<p class="bull">&#8226; the TCP acknowledgement scheme;</p>
<p class="bull">&#8226; the TCP state machine;</p>
<p class="bull">&#8226; TCP connection establishment and termination; and</p>
<p class="bull">&#8226; the TCP TIME_WAIT state.</p>
<h4 class="h4" id="ch61lev2sec01"><strong>61.6.1 Format of a TCP Segment</strong></h4>
<p class="noindentab"><a href="ch61.xhtml#ch61fig2">Figure 61-2</a> shows the format of the TCP segments that are exchanged between the endpoints of a TCP connection. The meanings of these fields are as follows:</p>
<p class="bull">&#8226; <em>Source port number</em>: This is the port number of the sending TCP.</p>
<p class="bull">&#8226; <em>Destination port number</em>: This is the port number of the destination TCP.</p>
<p class="bull">&#8226; <em>Sequence number</em>: This is the sequence number for this segment. This is the offset of the first byte of data in this segment within the stream of data being transmitted in this direction over the connection, as described in <a href="ch58.xhtml#ch58lev2sec03">Section 58.6.3</a>.</p>
<div class="image"><img src="../images/f61-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch61fig2"/><strong>Figure 61-2:</strong> Format of a TCP segment</p>
<p class="bull"><span epub:type="pagebreak" id="page_1267"/>&#8226; <em>Acknowledgement number</em>: If the ACK bit (see below) is set, then this field contains the sequence number of the next byte of data that the receiver expects to receive from the sender.</p>
<p class="bull">&#8226; <em>Header length</em>: This is the length of the header, in units of 32-bit words. Since this is a 4-bit field, the total header length can be up to 60 bytes (15 words). This field enables the receiving TCP to determine the length of the variable-length <em>options</em> field and the starting point of the <em>data</em>.</p>
<p class="bull">&#8226; <em>Reserved</em>: This consists of 4 unused bits (must be set to 0).</p>
<p class="bull">&#8226; <em>Control bits</em>: This field consists of 8 bits that further specify the meaning of the segment:</p>
<p class="dash1">&#8211; <em>CWR</em>: the <em>congestion window reduced</em> flag.</p>
<p class="dash1">&#8211; <em>ECE</em>: the <em>explicit congestion notification echo</em> flag. The CWR and ECE flags are used as part of TCP/IP&#8217;s Explicit Congestion Notification (ECN) algorithm. ECN is a relatively recent addition to TCP/IP and is described in RFC 3168 and in [<a href="bib.xhtml#bib25">Floyd, 1994</a>]. ECN is implemented in Linux from kernel 2.4 onward, and enabled by placing a nonzero value in the Linux-specific <span class="literal">/proc/sys/net/ipv4/tcp_ecn</span> file.</p>
<p class="dash1">&#8211; <em>URG</em>: if set, then the <em>urgent pointer</em> field contains valid information.</p>
<p class="dash1">&#8211; <em>ACK</em>: if set, then the <em>acknowledgement number</em> field contains valid information (i.e., this segment acknowledges data previously sent by the peer).</p>
<p class="dash1">&#8211; <em>PSH</em>: push all received data to the receiving process. This flag is described in RFC 793 and in [<a href="bib.xhtml#bib91">Stevens, 1994</a>].</p>
<p class="dash1">&#8211; <em>RST</em>: reset the connection. This is used to handle various error situations.</p>
<p class="dash1">&#8211; <em>SYN</em>: synchronize sequence numbers. Segments with this flag set are exchanged during connection establishment to allow the two TCPs to specify the initial sequence numbers to be used for transferring data in each direction.</p>
<p class="dash1">&#8211; <em>FIN</em>: used by a sender to indicate that it has finished sending data.</p>
<p class="bullp">Multiple control bits (or none at all) may be set in a segment, which allows a single segment to serve multiple purposes. For example, we&#8217;ll see later that a segment with both the SYN and the ACK bits set is exchanged during TCP connection establishment.</p>
<p class="bull">&#8226; <em>Window size</em>: This field is used when a receiver sends an ACK to indicate the number of bytes of data that the receiver has space to accept. (This relates to the sliding window scheme briefly described in <a href="ch58.xhtml#ch58lev2sec03">Section 58.6.3</a>.)</p>
<p class="bull">&#8226; <em>Checksum</em>: This is a 16-bit checksum covering both the TCP header and the TCP data.</p>
<div class="block">
<p class="noindent">The TCP checksum covers not just the TCP header and data, but also 12 bytes usually referred to as the TCP <em>pseudoheader</em>. The pseudoheader consists of the following: the source and destination IP address (4 bytes each); 2 bytes specifying the size of the TCP segment (this value is computed, but doesn&#8217;t form part of either the IP or the TCP header); 1 byte containing the value 6, which is TCP&#8217;s unique protocol number within the TCP/IP suite of protocols; and 1 padding byte containing 0 (so that the length of the pseudoheader is a multiple of 16 bits). <span epub:type="pagebreak" id="page_1268"/>The purpose of including the pseudoheader in the checksum calculation is to allow the receiving TCP to double-check that an incoming segment has arrived at the correct destination (i.e., that IP has not wrongly accepted a datagram that was addressed to another host or passed TCP a packet that should have gone to another upper layer). UDP calculates the checksum in its packet headers in a similar manner and for similar reasons. See [<a href="bib.xhtml#bib91">Stevens, 1994</a>] for further details on the pseudoheader.</p>
</div>
<p class="bull">&#8226; <em>Urgent pointer</em>: If the URG control bit is set, then this field indicates the location of so-called urgent data within the stream of data being transmitted from the sender to the receiver. We briefly discuss urgent data in <a href="ch61.xhtml#ch61lev2sec08">Section 61.13.1</a>.</p>
<p class="bull">&#8226; <em>Options</em>: This is a variable-length field containing options controlling the operation of the TCP connection.</p>
<p class="bull">&#8226; <em>Data</em>: This field contains the user data transmitted in this segment. This field may be of length 0 if this segment doesn&#8217;t contain any data (e.g., if it is simply an ACK segment).</p>
<h4 class="h4" id="ch61lev2sec02"><strong>61.6.2 TCP Sequence Numbers and Acknowledgements</strong></h4>
<p class="noindenta">Each byte that is transmitted over a TCP connection is assigned a logical sequence number by TCP. (Each of the two streams in a connection has its own sequence numbering.) When a segment is transmitted, its <em>sequence number</em> field is set to the logical offset of the first byte of data in the segment within the stream of data being transmitted in this direction over the connection. This allows the receiving TCP to assemble the received segments in the correct order, and to indicate which data was received when sending an acknowledgement to the sender.</p>
<p class="indent">To implement reliable communication, TCP uses positive acknowledgements; that is, when a segment is successfully received, an acknowledgement message (i.e., a segment with the ACK bit set) is sent from the receiving TCP to the sending TCP, as shown in <a href="ch61.xhtml#ch61fig3">Figure 61-3</a>. The <em>acknowledgement number</em> field of this message is set to indicate the logical sequence number of the next byte of data that the receiver expects to receive. (In other words, the value in the acknowledgement number field is the sequence number of the last byte in the segment that it acknowledges, plus 1.)</p>
<div class="image"><img src="../images/f61-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch61fig3"/><strong>Figure 61-3:</strong> Acknowledgements in TCP</p>
<p class="noindent">When the sending TCP transmits a segment, it sets a timer. If an acknowledgement is not received before the timer expires, the segment is retransmitted.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_1269"/><a href="ch61.xhtml#ch61fig3">Figure 61-3</a> and later similar diagrams are intended to illustrate the exchange of TCP segments between two endpoints. An implicit time dimension is assumed when reading these diagrams from top to bottom.</p>
</div>
<h4 class="h4" id="ch61lev2sec03"><strong>61.6.3 TCP State Machine and State Transition Diagram</strong></h4>
<p class="noindentab">Maintaining a TCP connection requires the coordination of the TCPs at both ends of the connection. To reduce the complexity of this task, a TCP endpoint is modeled as a <em>state machine</em>. This means that the TCP can be in one of a fixed set of <em>states</em>, and it moves from one state to another in response to <em>events</em>, such as system calls by the application above the TCP or the arrival of TCP segments from the peer TCP. The TCP states are the following:</p>
<p class="bull">&#8226; LISTEN: The TCP is waiting for a connection request from a peer TCP.</p>
<p class="bull">&#8226; SYN_SENT: The TCP has sent a SYN on behalf of an application performing an active open and is waiting for a reply from the peer in order to complete the connection.</p>
<p class="bull">&#8226; SYN_RECV: The TCP, formerly in the LISTEN state, has received a SYN and has responded with a SYN/ACK (i.e., a TCP segment with both the SYN and ACK bits set), and is now waiting for an ACK from the peer TCP in order to complete the connection.</p>
<p class="bull">&#8226; ESTABLISHED: Establishment of the connection to the peer TCP has been completed. Data segments can now be exchanged in either direction between the two TCPs.</p>
<p class="bull">&#8226; FIN_WAIT1: The application has closed the connection. The TCP has sent a FIN to the peer TCP in order to terminate its side of the connection and is waiting for an ACK from the peer. This and the next three states are associated with an application performing an active close&#8212;that is, the first application to close its side of the connection.</p>
<p class="bull">&#8226; FIN_WAIT2: The TCP, formerly in the FIN_WAIT1 state, has now received an ACK from the peer TCP.</p>
<p class="bull">&#8226; CLOSING: The TCP, formerly awaiting an ACK in the FIN_WAIT1 state, instead received a FIN from its peer indicating that the peer simultaneously tried to perform an active close. (In other words, the two TCPs sent FIN segments at almost the same time. This is a rare scenario.)</p>
<p class="bull">&#8226; TIME_WAIT: Having done an active close, the TCP has received a FIN, indicating that the peer TCP has performed a passive close. This TCP now spends a fixed period of time in the TIME_WAIT state, in order to ensure reliable termination of the TCP connection and to ensure that any old duplicate segments expire in the network before a new incarnation of the same connection is created. (We explain the TIME_WAIT state in more detail in <a href="ch61.xhtml#ch61lev2sec07">Section 61.6.7</a>.) When this fixed time period expires, the connection is closed, and the associated kernel resources are freed.</p>
<p class="bull">&#8226; CLOSE_WAIT: The TCP has received a FIN from the peer TCP. This and the following state are associated with an application performing a passive close&#8212;that is, the second application to close the connection.</p>
<p class="bull"><span epub:type="pagebreak" id="page_1270"/>&#8226; LAST_ACK: The application performed a passive close, and the TCP, formerly in the CLOSE_WAIT state, sent a FIN to the peer TCP and is waiting for it to be acknowledged. When this ACK is received, the connection is closed, and the associated kernel resources are freed.</p>
<p class="noindentt">To the above states, RFC 793 adds one further, fictional state, CLOSED, representing the state when there is no connection (i.e., no kernel resources are allocated to describe a TCP connection).</p>
<div class="block">
<p class="noindent">In the above list we use the spellings for the TCP states as defined in the Linux source code. These differ slightly from the spellings in RFC 793.</p>
</div>
<p class="noindent"><a href="ch61.xhtml#ch61fig4">Figure 61-4</a> shows the <em>state transition diagram</em> for TCP. (This figure is based on diagrams in RFC 793 and [<a href="bib.xhtml#bib93">Stevens et al., 2004</a>].) This diagram shows how a TCP endpoint moves from one state to another in response to various events. Each arrow indicates a possible transition and is labeled with the event that triggers the transition. This label is either an action by the application (in boldface) or the string <em>recv</em>, indicating the receipt of a segment from the peer TCP. As a TCP moves from one state to another, it may transmit a segment to the peer, and this is indicated by the <em>send</em> label on the transition. For example, the arrow for the transition from the ESTABLISHED to the FIN_WAIT1 state shows that the triggering event is a <em>close()</em> by the local application, and that, during the transition, the TCP sends a FIN segment to its peer.</p>
<p class="indent">In <a href="ch61.xhtml#ch61fig4">Figure 61-4</a>, the usual transition path for a client TCP is shown with heavy solid arrows, and the usual transition path for a server TCP is shown with heavy dashed arrows. (Other arrows indicate paths less traveled.) Looking at the parenthetical numbering on the arrows in these paths, we can see that the segments sent and received by the two TCPs are mirror images of one another. (After the ESTABLISHED state, the paths traveled by the server TCP and the client TCP may be the opposite of those indicated, if it is the server that performs the active close.)</p>
<div class="block">
<p class="noindent"><a href="ch61.xhtml#ch61fig4">Figure 61-4</a> doesn&#8217;t show all possible transitions for the TCP state machine; it illustrates just those of principal interest. A more detailed TCP state transition diagram can be found at <em><a href="http://www.cl.cam.ac.uk/~pes20/Netsem/poster.pdf">http://www.cl.cam.ac.uk/~pes20/Netsem/poster.pdf</a></em>.</p>
</div>
<h4 class="h4" id="ch61lev2sec04"><strong>61.6.4 TCP Connection Establishment</strong></h4>
<p class="noindenta">At the sockets API level, two stream sockets are connected via the following steps (see <a href="ch56.xhtml#ch56fig1">Figure 56-1</a>, on <a href="ch56.xhtml#page_1156">page 1156</a>):</p>
<ol>
<li class="order"><p class="orderp">The server calls <em>listen()</em> to perform a passive open of a socket, and then calls <em>accept()</em>, which blocks until a connection is established.</p></li>
<li class="order"><p class="orderp">The client calls <em>connect()</em> to perform an active open of a socket in order to establish a connection to the server&#8217;s passive socket.</p></li>
</ol>
<p class="noindent">The steps performed by TCP to establish a connection are shown in <a href="ch61.xhtml#ch61fig5">Figure 61-5</a>. These steps are often referred to as the <em>three-way handshake</em>, since three segments pass between the two TCPs. The steps are as follows:</p>
<ol>
<li class="order"><p class="orderp">The <em>connect()</em> causes the client TCP to send a SYN segment to the server TCP. This segment informs the server TCP of the client TCP&#8217;s initial sequence number <span epub:type="pagebreak" id="page_1271"/>(labeled <em>M</em> in the diagram). This information is necessary because sequence numbers don&#8217;t begin at 0, as noted in <a href="ch58.xhtml#ch58lev2sec03">Section 58.6.3</a>.</p></li>
<li class="order"><p class="orderp">The server TCP must both acknowledge the client TCP&#8217;s SYN segment and inform the client TCP of its own initial sequence number (labeled <em>N</em> in the diagram). (Two sequence numbers are required because a stream socket is bidirectional.) The server TCP can perform both operations by returning a single segment with both the SYN and the ACK control bits set. (We say that the ACK is <em>piggybacked</em> on the SYN.)</p></li>
<li class="order"><p class="orderp">The client TCP sends an ACK segment to acknowledge the server TCP&#8217;s SYN segment.</p></li>
</ol>
<div class="image"><img src="../images/f61-04.jpg" alt="image"/></div>
<p class="figcap"><a id="ch61fig4"/><strong>Figure 61-4:</strong> TCP state transition diagram</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_1272"/>The SYN segments exchanged in the first two steps of the three-way handshake may contain information in the <em>options</em> field of the TCP header that is used to determine various parameters for the connection. See [<a href="bib.xhtml#bib93">Stevens et al., 2004</a>], [<a href="bib.xhtml#bib91">Stevens, 1994</a>], and [<a href="bib.xhtml#bib111">Wright &#38; Stevens, 1995</a>] for details.</p>
</div>
<p class="noindent">The labels inside angle brackets (e.g., &lt;LISTEN&gt;) in <a href="ch61.xhtml#ch61fig5">Figure 61-5</a> indicate the states of the TCPs on either side of the connection.</p>
<p class="indent">The SYN flag consumes a byte of the sequence-number space for the connection. This is necessary so that this flag can be acknowledged unambiguously, since segments with this flag set may also contain data bytes. This is why we show the acknowledgement of the <em>SYN M</em> segment as <em>ACK M+1</em> in <a href="ch61.xhtml#ch61fig5">Figure 61-5</a>.</p>
<div class="image"><img src="../images/f61-05.jpg" alt="image"/></div>
<p class="figcap"><a id="ch61fig5"/><strong>Figure 61-5:</strong> Three-way handshake for TCP connection establishment</p>
<h4 class="h4" id="ch61lev2sec05"><strong>61.6.5 TCP Connection Termination</strong></h4>
<p class="noindenta">Closing a TCP connection normally occurs in the following manner:</p>
<ol>
<li class="order"><p class="orderp">An application on one end of the connection performs a <em>close()</em>. (This is often, but not necessarily, the client.) We say that this application is performing an <em>active close</em>.</p></li>
<li class="order"><p class="orderp">Later, the application on the other end of the connection (the server) also performs a <em>close()</em>. This is termed a <em>passive close</em>.</p></li>
</ol>
<p class="noindent"><a href="ch61.xhtml#ch61fig6">Figure 61-6</a> shows the corresponding steps performed by the underlying TCPs (here, we assume that it is the client that does the active close). These steps are as follows:</p>
<ol>
<li class="order"><p class="orderp">The client performs an active close, which causes the client TCP to send a FIN to the server TCP.</p></li>
<li class="order"><p class="orderp">After receipt of the FIN, the server TCP responds with an ACK. Any subsequent attempt by the server to <em>read()</em> from the socket yields end-of-file (i.e., a 0 return).</p></li>
<li class="order"><p class="orderp">When the server later closes its end of the connection, the server TCP sends a FIN to the client TCP.</p></li>
<li class="order"><p class="orderp">The client TCP responds with an ACK to acknowledge the server&#8217;s FIN.</p></li>
</ol>
<p class="noindent"><span epub:type="pagebreak" id="page_1273"/>As with the SYN flag, and for the same reasons, the FIN flag consumes a byte of the sequence-number space for the connection. This is why we show the acknowledgement of the <em>FIN M</em> segment as <em>ACK M+1</em> in <a href="ch61.xhtml#ch61fig6">Figure 61-6</a>.</p>
<div class="image"><img src="../images/f61-06.jpg" alt="image"/></div>
<p class="figcap"><a id="ch61fig6"/><strong>Figure 61-6:</strong> TCP connection termination</p>
<h4 class="h4" id="ch61lev2sec06"><strong>61.6.6 Calling <em>shutdown()</em> on a TCP Socket</strong></h4>
<p class="noindenta">The discussion in the preceding section assumed a full-duplex close; that is, an application closes both the sending and receiving channels of the TCP socket using <em>close()</em>. As noted in <a href="ch61.xhtml#ch61lev1sec02">Section 61.2</a>, we can use <em>shutdown()</em> to close just one channel of the connection (a half-duplex close). This section notes some specific details for <em>shutdown()</em> on a TCP socket.</p>
<p class="indent">Specifying <em>how</em> as <span class="literal">SHUT_WR</span> or <span class="literal">SHUT_RDWR</span> initiates the TCP connection termination sequence (i.e., the active close) described in <a href="ch61.xhtml#ch61lev2sec05">Section 61.6.5</a>, regardless of whether there are other file descriptors referring to the socket. Once this sequence has been initiated, the local TCP moves into the FIN_WAIT1 state, and then into the FIN_WAIT2 state, while the peer TCP moves into the CLOSE_WAIT state (<a href="ch61.xhtml#ch61fig6">Figure 61-6</a>). If <em>how</em> is specified as <span class="literal">SHUT_WR</span>, then, since the socket file descriptor remains valid and the reading half of the connection remains open, the peer can continue to send data back to us.</p>
<p class="indent">The <span class="literal">SHUT_RD</span> operation can&#8217;t be meaningfully used with TCP sockets. This is because most TCP implementations don&#8217;t provide the expected behavior for <span class="literal">SHUT_RD</span>, and the effect of <span class="literal">SHUT_RD</span> varies across implementations. On Linux and a few other implementations, following a <span class="literal">SHUT_RD</span> (and after any outstanding data has been read), a <em>read()</em> returns end-of-file, as we expect from the description of <span class="literal">SHUT_RD</span> in <a href="ch61.xhtml#ch61lev1sec02">Section 61.2</a>. However, if the peer application subsequently writes data on its socket, then it is still possible to read that data on the local socket.</p>
<p class="indent">On some other implementations (e.g., the BSDs), <span class="literal">SHUT_RD</span> does indeed cause subsequent calls to <em>read()</em> to always return 0. However, on those implementations, if the peer continues to <em>write()</em> to the socket, then the data channel will eventually fill until the point where a further (blocking) call to <em>write()</em> by the peer will block. (With UNIX domain stream sockets, a peer would receive a <span class="literal">SIGPIPE</span> signal and the <span class="literal">EPIPE</span> error if it continued writing to its socket after a <span class="literal">SHUT_RD</span> had been performed on the local socket.)</p>
<p class="indent">In summary, the use of <span class="literal">SHUT_RD</span> should be avoided for portable TCP applications.</p>
<h4 class="h4" id="ch61lev2sec07"><span epub:type="pagebreak" id="page_1274"/><strong>61.6.7 The TIME_WAIT State</strong></h4>
<p class="noindentab">The TCP TIME_WAIT state is a frequent source of confusion in network programming. Looking at <a href="ch61.xhtml#ch61fig4">Figure 61-4</a>, we can see that a TCP performing an active close goes through this state. The TIME_WAIT state exists to serve two purposes:</p>
<p class="bull">&#8226; to implement reliable connection termination; and</p>
<p class="bull">&#8226; to allow expiration of old duplicate segments in the network so that they are not accepted by a new incarnation of the connection.</p>
<p class="noindentt">The TIME_WAIT state differs from the other states in that the event that causes a transition out of this state (to CLOSED) is a timeout. This timeout has a duration of twice the MSL (2MSL), where MSL (<em>maximum segment lifetime</em>) is the assumed maximum lifetime of a TCP segment in the network.</p>
<div class="block">
<p class="noindent">An 8-bit time-to-live (TTL) field in the IP header ensures that all IP packets are eventually discarded if they don&#8217;t reach their destination within a fixed number of hops (routers traversed) while traveling from the source to the destination host. The MSL is an estimate of the maximum time that an IP packet could take to exceed the TTL limit. Since it is represented using 8 bits, the TTL permits a maximum of 255 hops. Normally, an IP packet requires considerably fewer hops than this to complete its journey. A packet could encounter this limit because of certain types of router anomalies (e.g., a router configuration problem) that cause the packet to get caught in a network loop until it exceeds the TTL limit.</p>
</div>
<p class="noindent">The BSD sockets implementation assumes a value of 30 seconds for the MSL, and Linux follows the BSD norm. Thus, the TIME_WAIT state has a lifetime of 60 seconds on Linux. However, RFC 1122 recommends a value of 2 minutes for the MSL, and, on implementations following this recommendation, the TIME_WAIT state can thus last 4 minutes.</p>
<p class="indent">We can understand the first purpose of the TIME_WAIT state&#8212;ensuring reliable connection termination&#8212;by looking at <a href="ch61.xhtml#ch61fig6">Figure 61-6</a>. In this diagram, we can see that four segments are usually exchanged during the termination of a TCP connection. The last of these is an ACK sent from the TCP performing the active close to the TCP performing the passive close. Suppose that this ACK gets lost in the network. If this occurs, then the TCP performing the passive close will eventually retransmit its FIN. Having the TCP that performs the active close remain in the TIME_WAIT state for a fixed period ensures that it is available to resend the final ACK in this case. If the TCP that performs the active close did not still exist, then&#8212;since it wouldn&#8217;t have any state information for the connection&#8212;the TCP protocol would respond to the resent FIN by sending an RST (reset) segment to the TCP performing the passive close, and this RST would be interpreted as an error. (This explains why the duration of the TIME_WAIT state is <em>twice</em> the MSL: one MSL for the final ACK to reach the peer TCP, plus a further MSL in case a further FIN must be sent.)</p>
<div class="block">
<p class="noindent">An equivalent of the TIME_WAIT state is not required for the TCP performing the passive close, because it is the initiator of the final exchange in the connection termination. After sending the FIN, this TCP will wait for the ACK from its peer, and retransmit the FIN if its timer expires before the ACK is received.</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_1275"/>To understand the second purpose of the TIME_WAIT state&#8212;ensuring the expiration of old duplicate segments in the network&#8212;we must remember that the retransmission algorithm used by TCP means that duplicate segments may be generated, and that, depending on routing decisions, these duplicates could arrive after the connection has been closed. For example, suppose that we have a TCP connection between two socket addresses, say, <span class="literal">204.152.189.116</span> port 21 (the FTP port) and <span class="literal">200.0.0.1</span> port 50,000. Suppose also that this connection is closed, and that later a new connection is established using exactly the same IP addresses and ports. This is referred to as a new incarnation of the connection. In this case, TCP must ensure that no old duplicate segments from the previous incarnation are accepted as valid data in the new incarnation. This is done by preventing a new incarnation from being established while there is an existing TCP in the TIME_WAIT state on one of the endpoints.</p>
<p class="indent">A frequent question posted to online forums is how to disable the TIME_WAIT state, since it can lead to the error <span class="literal">EADDRINUSE</span> (&#8220;Address already in use&#8221;) when a restarted server tries to bind a socket to an address that has a TCP in the TIME_WAIT state. Although there are ways of doing this (see [<a href="bib.xhtml#bib93">Stevens et al., 2004</a>]), and also ways of assassinating a TCP in this state (i.e., causing the TIME_WAIT state to terminate prematurely, see [<a href="bib.xhtml#bib87">Snader, 2000</a>]), this should be avoided, since it would thwart the reliability guarantees that the TIME_WAIT state provides. In <a href="ch61.xhtml#ch61lev1sec10">Section 61.10</a>, we look at the use of the <span class="literal">SO_REUSEADDR</span> socket option, which can be used to avoid the usual causes of the <span class="literal">EADDRINUSE</span> error, while still allowing the TIME_WAIT to provide its reliability guarantees.</p>
<h3 class="h3" id="ch61lev1sec07"><strong>61.7 Monitoring Sockets: <em>netstat</em></strong></h3>
<p class="noindenta">The <em>netstat</em> program displays the state of Internet and UNIX domain sockets on a system. It is a useful debugging tool when writing socket applications. Most UNIX implementations provide a version of <em>netstat</em>, although there is some variation in the syntax of its command-line arguments across implementations.</p>
<p class="indent">By default, when executed with no command-line options, <em>netstat</em> displays information for connected sockets in both the UNIX and Internet domains. We can use a number of command-line options to change the information displayed. Some of these options are listed in <a href="ch61.xhtml#ch61table1">Table 61-1</a>.</p>
<p class="tablecap"><a id="ch61table1"/><strong>Table 61-1:</strong> Options for the <em>netstat</em> command</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Option</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">-a</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Display information about all sockets, including listening sockets</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">-e</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Display extended information (includes user ID of socket owner)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">-c</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Redisplay socket information continuously (each second)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">-l</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Display information only about listening sockets</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">-n</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Display IP addresses, port numbers, and usernames in numerical form</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">-p</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Show the process ID and name of program to which socket belongs</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">--inet</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Display information for Internet domain sockets</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">--tcp</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Display information for Internet domain TCP (stream) sockets</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">--udp</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Display information for Internet domain UDP (datagram) sockets</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">--unix</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Display information for UNIX domain sockets</p></td>
</tr>
</tbody>
</table>
<p class="noindent"><span epub:type="pagebreak" id="page_1276"/>Here is an abridged example of the output that we see when using <em>netstat</em> to list all Internet domain sockets on the system:</p>
<p class="programs">$ <span class="codestrong">netstat -a --inet</span><br/>Active Internet connections (servers and established)<br/>Proto Recv-Q Send-Q Local Address&#160;&#160;&#160;&#160;Foreign Address&#160;&#160;State<br/>tcp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;0 *:50000&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*:*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LISTEN<br/>tcp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;0 *:55000&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*:*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LISTEN<br/>tcp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;0 localhost:smtp&#160;&#160;&#160;*:*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LISTEN<br/>tcp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;0 localhost:32776&#160;&#160;localhost:58000&#160;&#160;TIME_WAIT<br/>tcp&#160;&#160;&#160;&#160;34767&#160;&#160;&#160;&#160;&#160;&#160;0 localhost:55000&#160;&#160;localhost:32773&#160;&#160;ESTABLISHED<br/>tcp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0 115680 localhost:32773&#160;&#160;localhost:55000&#160;&#160;ESTABLISHED<br/>udp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;0 localhost:61000&#160;&#160;localhost:60000&#160;&#160;ESTABLISHED<br/>udp&#160;&#160;&#160;&#160;&#160;&#160;684&#160;&#160;&#160;&#160;&#160;&#160;0 *:60000&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*:*</p>
<p class="noindentb">For each Internet domain socket, we see the following information:</p>
<p class="bull">&#8226; <span class="literal">Proto</span>: This is the socket protocol&#8212;for example, <span class="literal">tcp</span> or <span class="literal">udp</span>.</p>
<p class="bull">&#8226; <span class="literal">Recv-Q</span>: This is the number of bytes in the socket receive buffer that are as yet unread by the local application. For UDP sockets, this field counts not just data, but also bytes in UDP headers and other metadata.</p>
<p class="bull">&#8226; <span class="literal">Send-Q</span>: This is the number of bytes queued for transmission in the socket send buffer. As with the <span class="literal">Recv-Q</span> field, for UDP sockets, this field includes bytes in UDP headers and other metadata.</p>
<p class="bull">&#8226; <span class="literal">Local Address</span>: This is the address to which the socket is bound, expressed in the form <em>host-IP-address:port</em>. By default, both components of the address are displayed as names, unless the numeric values can&#8217;t be resolved to corresponding host and service names. An asterisk (<span class="literal">*</span>) in the host part of the address means the wildcard IP address.</p>
<p class="bull">&#8226; <span class="literal">Foreign Address</span>: This is the address of the peer socket to which this socket is bound. The string <span class="literal">*:*</span> indicates no peer address.</p>
<p class="bull">&#8226; <span class="literal">State</span>: This is the current state of the socket. For a TCP socket, this state is one of those described in <a href="ch61.xhtml#ch61lev2sec03">Section 61.6.3</a>.</p>
<p class="noindentt">For further details, see the <em>netstat(8)</em> manual page.</p>
<p class="indent">Various Linux-specific files in the directory <span class="literal">/proc/net</span> allow a program to read much of the same information that is displayed by <em>netstat</em>. These files are named <span class="literal">tcp</span>, <span class="literal">udp</span>, <span class="literal">tcp6</span>, <span class="literal">udp6</span>, and <span class="literal">unix</span>, with the obvious purposes. For further details, see the <em>proc(5)</em> manual page.</p>
<h3 class="h3" id="ch61lev1sec08"><strong>61.8 Using <em>tcpdump</em> to Monitor TCP Traffic</strong></h3>
<p class="noindenta">The <em>tcpdump</em> program is a useful debugging tool that allows the superuser to monitor the Internet traffic on a live network, generating a real-time textual equivalent of diagrams such as <a href="ch61.xhtml#ch61fig3">Figure 61-3</a>. Despite its name, <em>tcpdump</em> can be used to display traffic for all kinds of network packets (e.g., TCP segments, UDP datagrams, and ICMP packets). For each network packet, <em>tcpdump</em> displays information such as timestamps, the source and destination IP addresses, and further protocol-specific details. It is possible to select the packets to be monitored by protocol type, source <span epub:type="pagebreak" id="page_1277"/>and destination IP address and port number, and a range of other criteria. Full details are provided in the <em>tcpdump</em> manual page.</p>
<div class="block">
<p class="noindent">The <em>wireshark</em> (formerly <em>ethereal</em>; <em><a href="http://www.wireshark.org/">http://www.wireshark.org/</a></em>) program performs a similar task to <em>tcpdump</em>, but displays traffic information via a graphical interface.</p>
</div>
<p class="noindent">For each TCP segment, <em>tcpdump</em> displays a line of the following form:</p>
<div class="box2">
<p class="noindenta"><em>src</em> <span class="literal">&gt;</span> <em>dst</em><span class="literal">:</span> <em>flags data-seqno ack window urg</em> <span class="literal">&lt;</span><em>options</em><span class="literal">&gt;</span></p>
</div>
<p class="noindentb">These fields have the following meanings:</p>
<p class="bull">&#8226; <em>src</em>: This is the source IP address and port.</p>
<p class="bull">&#8226; <em>dst</em>: This is the destination IP address and port.</p>
<p class="bull">&#8226; <em>flags</em>: This field contains zero or more of the following letters, each of which corresponds to one of the TCP control bits described in <a href="ch61.xhtml#ch61lev2sec01">Section 61.6.1</a>: S (SYN), F (FIN), P (PSH), R (RST), E (ECE), and C (CWR).</p>
<p class="bull">&#8226; <em>data-seqno</em>: This is the range of the sequence-number space covered by the bytes in this packet.</p>
<div class="block1">
<p class="noindent">By default, the sequence-number range is displayed relative to the first byte monitored for this direction of the data stream. The <em>tcpdump &#8211;S</em> option causes sequence numbers to be displayed in absolute format.</p>
</div>
<p class="bull">&#8226; <em>ack</em>: This is a string of the form &#8220;<span class="literal">ack</span> <em>num</em>&#8221; indicating the sequence number of the next byte expected from the other direction on this connection.</p>
<p class="bull">&#8226; <em>window</em>: This is a string of the form &#8220;<span class="literal">win</span> <em>num</em>&#8221; indicating the number of bytes of receive buffer space available for transmission in the opposite direction on this connection.</p>
<p class="bull">&#8226; <em>urg</em>: This is a string of the form &#8220;<span class="literal">urg</span> <em>num</em>&#8221; indicating that this segment contains urgent data at the specified offset within the segment.</p>
<p class="bull">&#8226; <em>options</em>: This string describes any TCP options contained in the segment.</p>
<p class="noindentt">The <em>src</em>, <em>dst</em>, and <em>flags</em> fields always appear. The remaining fields are displayed only if appropriate.</p>
<p class="indent">The shell session below shows how <em>tcpdump</em> can be used to monitor the traffic between a client (running on the host <span class="literal">pukaki</span>) and a server (running on <span class="literal">tekapo</span>). In this shell session, we use two <em>tcpdump</em> options that make the output less verbose. The <em>&#8211;t</em> option suppresses the display of timestamp information. The <em>&#8211;N</em> option causes hostnames to be displayed without a qualifying domain name. Furthermore, for brevity, and because we don&#8217;t describe the details of TCP options, we have removed the <em>options</em> fields from the lines of <em>tcpdump</em> output.</p>
<p class="indent">The server operates on port 55555, so our <em>tcpdump</em> command selects traffic for that port. The output shows the three segments exchanged during connection establishment:</p>
<p class="programs">$ <span class="codestrong">sudo tcpdump -t -N 'port 55555'</span><br/>IP pukaki.60391 &gt; tekapo.55555: S 3412991013:3412991013(0) win 5840<br/>IP tekapo.55555 &gt; pukaki.60391: S 1149562427:1149562427(0) ack 3412991014 win 5792<br/>IP pukaki.60391 &gt; tekapo.55555: . ack 1 win 5840</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1278"/>These three segments are the SYN, SYN/ACK, and ACK segments exchanged for the three-way handshake (see <a href="ch61.xhtml#ch61fig5">Figure 61-5</a>).</p>
<p class="indent">In the following output, the client sends the server two messages, containing 16 and 32 bytes, respectively, and the server responds in each case with a 4-byte message:</p>
<p class="programs">IP pukaki.60391 &gt; tekapo.55555: P 1:17(16) ack 1 win 5840<br/>IP tekapo.55555 &gt; pukaki.60391: . ack 17 win 1448<br/>IP tekapo.55555 &gt; pukaki.60391: P 1:5(4) ack 17 win 1448<br/>IP pukaki.60391 &gt; tekapo.55555: . ack 5 win 5840<br/>IP pukaki.60391 &gt; tekapo.55555: P 17:49(32) ack 5 win 5840<br/>IP tekapo.55555 &gt; pukaki.60391: . ack 49 win 1448<br/>IP tekapo.55555 &gt; pukaki.60391: P 5:9(4) ack 49 win 1448<br/>IP pukaki.60391 &gt; tekapo.55555: . ack 9 win 5840</p>
<p class="noindent">For each of the data segments, we see an ACK sent in the opposite direction.</p>
<p class="indent">Lastly, we show the segments exchanged during connection termination (first, the client closes its end of the connection, and then the server closes the other end):</p>
<p class="programs">IP pukaki.60391 &gt; tekapo.55555: F 49:49(0) ack 9 win 5840<br/>IP tekapo.55555 &gt; pukaki.60391: . ack 50 win 1448<br/>IP tekapo.55555 &gt; pukaki.60391: F 9:9(0) ack 50 win 1448<br/>IP pukaki.60391 &gt; tekapo.55555: . ack 10 win 5840</p>
<p class="noindent">The above output shows the four segments exchanged during connection termination (see <a href="ch61.xhtml#ch61fig6">Figure 61-6</a>).</p>
<h3 class="h3" id="ch61lev1sec09"><strong>61.9 Socket Options</strong></h3>
<p class="noindenta">Socket options affect various features of the operation of a socket. In this book, we describe just a couple of the many socket options that are available. An extensive discussion covering most standard socket options is provided in [<a href="bib.xhtml#bib93">Stevens et al., 2004</a>]. See the <em>tcp(7)</em>, <em>udp(7)</em>, <em>ip(7)</em>, <em>socket(7)</em>, and <em>unix(7)</em> manual pages for additional Linux-specific details.</p>
<p class="indent">The <em>setsockopt()</em> and <em>getsockopt()</em> system calls set and retrieve socket options.</p>
<div class="box">
<p class="programsa">#include &lt;sys/socket.h&gt;<br/><br/>int <span class="codestrong">getsockopt</span>(int <span class="font1">sockfd</span>, int <span class="font1">level</span>, int <span class="font1">optname</span>, void *<span class="font1">optval</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;socklen_t *<span class="font1">optlen</span>);<br/>int <span class="codestrong">setsockopt</span>(int <span class="font1">sockfd</span>, int <span class="font1">level</span>, int <span class="font1">optname</span>, const void *<span class="font1">optval</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;socklen_t <span class="font1">optlen</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">For both <em>setsockopt()</em> and <em>getsockopt()</em>, <em>sockfd</em> is a file descriptor referring to a socket.</p>
<p class="indent">The <em>level</em> argument specifies the protocol level to which the socket option applies&#8212;for example, IP or TCP. For most of the socket options that we describe in this book, <em>level</em> is set to <span class="literal">SOL_SOCKET</span>, which indicates an option that applies at the sockets API level.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1279"/>The <em>optname</em> argument identifies the option whose value we wish to set or retrieve. The <em>optval</em> argument is a pointer to a buffer used to specify or return the option value; this argument is a pointer to an integer or a structure, depending on the option.</p>
<p class="indent">The <em>optlen</em> argument specifies the size (in bytes) of the buffer pointed to by <em>optval</em>. For <em>setsockopt()</em>, this argument is passed by value. For <em>getsockopt()</em>, <em>optlen</em> is a value-result argument. Before the call, we initialize it to the size of the buffer pointed to by <em>optval</em>; upon return, it is set to the number of bytes actually written to that buffer.</p>
<p class="indent">As detailed in <a href="ch61.xhtml#ch61lev1sec11">Section 61.11</a>, the socket file descriptor returned by a call to <em>accept()</em> inherits the values of settable socket options from the listening socket.</p>
<p class="indent">Socket options are associated with an open file description (refer to <a href="ch05.xhtml#ch5fig2">Figure 5-2</a>, on <a href="ch05.xhtml#page_95">page 95</a>). This means that file descriptors duplicated as a consequence of <em>dup()</em> (or similar) or <em>fork()</em> share the same set of socket options.</p>
<p class="indent">A simple example of a socket option is <span class="literal">SO_TYPE</span>, which can be used to find out the type of a socket, as follows:</p>
<p class="programs">int optval;<br/>socklen_t optlen;<br/><br/>optlen = sizeof(optval);<br/>if (getsockopt(sfd, SOL_SOCKET, SO_TYPE, &#38;optval, &#38;optlen) == -1)<br/>&#160;&#160;&#160;&#160;errExit("getsockopt");</p>
<p class="noindent">After this call, <em>optval</em> contains the socket type&#8212;for example, <span class="literal">SOCK_STREAM</span> or <span class="literal">SOCK_DGRAM</span>. Using this call can be useful in a program that inherited a socket file descriptor across an <em>exec()</em>&#8212;for example, a program execed by <em>inetd</em>&#8212;since that program may not know which type of socket it inherited.</p>
<p class="indent"><span class="literal">SO_TYPE</span> is an example of a read-only socket option. It is not possible to use <em>setsockopt()</em> to change a socket&#8217;s type.</p>
<h3 class="h3" id="ch61lev1sec10"><strong>61.10 The</strong> <span class="literal"><span class="codestrong">SO_REUSEADDR</span></span> <strong>Socket Option</strong></h3>
<p class="noindentab">The <span class="literal">SO_REUSEADDR</span> socket option serves a number of purposes (see <a href="ch07.xhtml#ch07">Chapter 7</a> of [<a href="bib.xhtml#bib93">Stevens et al., 2004</a>] for details). We&#8217;ll concern ourselves with only one common use: to avoid the <span class="literal">EADDRINUSE</span> (&#8220;Address already in use&#8221;) error when a TCP server is restarted and tries to bind a socket to a port that currently has an associated TCP. There are two scenarios in which this usually occurs:</p>
<p class="bull">&#8226; A previous invocation of the server that was connected to a client performed an active close, either by calling <em>close()</em>, or by crashing (e.g., it was killed by a signal). This leaves a TCP endpoint that remains in the TIME_WAIT state until the 2MSL timeout expires.</p>
<p class="bull">&#8226; A previous invocation of the server created a child process to handle a connection to a client. Later, the server terminated, while the child continues to serve the client, and thus maintain a TCP endpoint using the server&#8217;s well-known port.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_1280"/>In both of these scenarios, the outstanding TCP endpoint is unable to accept new connections. Nevertheless, in both cases, by default, most TCP implementations prevent a new listening socket from being bound to the server&#8217;s well-known port.</p>
<div class="block">
<p class="noindent">The <span class="literal">EADDRINUSE</span> error doesn&#8217;t usually occur with clients, since they typically use an ephemeral port that won&#8217;t be one of those ports currently in the TIME_WAIT state. However, if a client binds to a specific port number, then it also can encounter this error.</p>
</div>
<p class="noindent">To understand the operation of the <span class="literal">SO_REUSEADDR</span> socket option, it can help to return to our earlier telephone analogy for stream sockets (<a href="ch56.xhtml#ch56lev1sec05">Section 56.5</a>). Like a telephone call (we ignore the notion of conference calls), a TCP socket connection is identifiable by the <em>combination</em> of a pair of connected endpoints. The operation of <em>accept()</em> is analogous to the task performed by a telephone operator on an internal company switchboard (&#8220;a server&#8221;). When an external telephone call arrives, the operator transfers it to some internal telephone (&#8220;a new socket&#8221;) within the organization. From an outside perspective, there is no way of identifying that internal telephone. When multiple external calls are being handled by the switchboard, the only way of distinguishing them is via the combination of the external caller&#8217;s number and the switchboard number. (The latter is necessary when we consider that there will be multiple company switchboards within the telephone network as a whole.) Analogously, each time we accept a socket connection on a listening socket, a new socket is created. All of these sockets are associated with the same local address as the listening socket. The only way of distinguishing them is via their connections to different peer sockets.</p>
<p class="indent">In other words, a connected TCP socket is identified by a 4-tuple (i.e., a combination of four values) of the following form:</p>
<p class="programs">{ local-IP-address, local-port, foreign-IP-address, foreign-port }</p>
<p class="noindent">The TCP specification requires that each such tuple be unique; that is, only one corresponding connection incarnation (&#8220;telephone call&#8221;) can exist. The problem is that most implementations (including Linux) enforce a stricter constraint: a local port can&#8217;t be reused (i.e., specified in a call to <em>bind()</em>) if any TCP connection incarnation with a matching local port exists on the host. This rule is enforced even when the TCP could not accept new connections, as in the scenarios described at the start of this section.</p>
<p class="indent">Enabling the <span class="literal">SO_REUSEADDR</span> socket option relaxes this constraint, bringing it closer to the TCP requirement. By default, this option has the value 0, meaning that it is disabled. We enable the option by giving it a nonzero value before binding a socket, as shown in <a href="ch61.xhtml#ch61ex4">Listing 61-4</a>.</p>
<p class="indent">Setting the <span class="literal">SO_REUSEADDR</span> option means that we can bind a socket to a local port even if another TCP is bound to the same port in either of the scenarios described at the start of this section. Most TCP servers should enable this option. We have already seen some examples of the use of this option in <a href="ch59.xhtml#ch59ex6">Listing 59-6</a> (<a href="ch59.xhtml#page_1221">page 1221</a>) and <a href="ch59.xhtml#ch59ex9">Listing 59-9</a> (<a href="ch59.xhtml#page_1228">page 1228</a>).</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1281"/><a id="ch61ex4"/><strong>Listing 61-4:</strong> Setting the <span class="literal">SO_REUSEADDR</span> socket option</p>
<p class="programsli">______________________________________________________________________<br/><br/>&#160;&#160;&#160;&#160;int sockfd, optval;<br/><br/>&#160;&#160;&#160;&#160;sockfd = socket(AF_INET, SOCK_STREAM, 0);<br/>&#160;&#160;&#160;&#160;if (sockfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("socket");<br/><br/>&#160;&#160;&#160;&#160;optval = 1;<br/>&#160;&#160;&#160;&#160;if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &#38;optval,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sizeof(optval)) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("socket");<br/><br/>&#160;&#160;&#160;&#160;if (bind(sockfd, &#38;addr, addrlen) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("bind");<br/>&#160;&#160;&#160;&#160;if (listen(sockfd, backlog) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("listen");<br/>______________________________________________________________________</p>
<h3 class="h3" id="ch61lev1sec11"><strong>61.11 Inheritance of Flags and Options Across <em>accept()</em></strong></h3>
<p class="noindenta">Various flags and settings can be associated with open file descriptions and file descriptors (<a href="ch05.xhtml#ch05lev1sec04">Section 5.4</a>). Furthermore, as described in <a href="ch61.xhtml#ch61lev1sec09">Section 61.9</a>, various options can be set for a socket. If these flags and options are set on a listening socket, are they inherited by the new socket returned by <em>accept()</em>? We describe the details here.</p>
<p class="indentb">On Linux, the following attributes are not inherited by the new file descriptor returned by <em>accept()</em>:</p>
<p class="bull">&#8226; The status flags associated with an open file description&#8212;the flags that can be altered using the <em>fcntl()</em> <span class="literal">F_SETFL</span> operation (<a href="ch05.xhtml#ch05lev1sec03">Section 5.3</a>). These include flags such as <span class="literal">O_NONBLOCK</span> and <span class="literal">O_ASYNC</span>.</p>
<p class="bull">&#8226; The file descriptor flags&#8212;the flags that can be altered using the <em>fcntl()</em> <span class="literal">F_SETFD</span> operation. The only such flag is the close-on-exec flag (<span class="literal">FD_CLOEXEC</span>, described in <a href="ch27.xhtml#ch27lev1sec04">Section 27.4</a>).</p>
<p class="bull">&#8226; The <em>fcntl()</em> <span class="literal">F_SETOWN</span> (owner process ID) and <span class="literal">F_SETSIG</span> (generated signal) file descriptor attributes associated with signal-driven I/O (<a href="ch63.xhtml#ch63lev1sec03">Section 63.3</a>).</p>
<p class="noindent">On the other hand, the new descriptor returned by <em>accept()</em> inherits a copy of most of the socket options that can be set using <em>setsockopt()</em> (<a href="ch61.xhtml#ch61lev1sec09">Section 61.9</a>).</p>
<p class="indent">SUSv3 is silent on the details described here, and the inheritance rules for the new connected socket returned by <em>accept()</em> vary across UNIX implementations. Most notably, on some UNIX implementations, if open file status flags such as <span class="literal">O_NONBLOCK</span> and <span class="literal">O_ASYNC</span> are set on a listening socket, then they are inherited by the new socket returned by <em>accept()</em>. For portability, it may be necessary to explicitly reset these attributes on a socket returned by <em>accept()</em>.</p>
<h3 class="h3" id="ch61lev1sec12"><span epub:type="pagebreak" id="page_1282"/><strong>61.12 TCP Versus UDP</strong></h3>
<p class="noindentab">Given that TCP provides reliable delivery of data, while UDP does not, an obvious question is, &#8220;Why use UDP at all?&#8221; The answer to this question is covered at some length in <a href="ch22.xhtml#ch22">Chapter 22</a> of [<a href="bib.xhtml#bib93">Stevens et al., 2004</a>]. Here, we summarize some of the points that may lead us to choose UDP over TCP:</p>
<p class="bull">&#8226; A UDP server can receive (and reply to) datagrams from multiple clients, without needing to create and terminate a connection for each client (i.e., transmission of single messages using UDP has a lower overhead than is required when using TCP).</p>
<p class="bull">&#8226; For simple request-response communications, UDP can be faster than TCP, since it doesn&#8217;t require connection establishment and termination. <a href="app01.xhtml#app01">Appendix A</a> of [<a href="bib.xhtml#bib92">Stevens, 1996</a>] notes that in the best-case scenario, the time using TCP is</p>
<p class="programsbl">2 * RTT + SPT</p>
<p class="bullp">In this formula, RTT is the round-trip time (the time required to send a request and receive a response), and SPT is the time spent by the server processing the request. (On a wide area network, the SPT value may be small compared to the RTT.) For UDP, the best-case scenario for a single request-response communication is</p>
<p class="programsbl">RTT + SPT</p>
<p class="bullp">This is one RTT less than the time required for TCP. Since the RTT between hosts separated by large (i.e., intercontinental) distances or many intervening routers is typically several tenths of a second, this difference can make UDP attractive for some types of request-response communication. DNS is a good example of an application that uses UDP for this reason&#8212;using UDP allows name lookup to be performed by transmitting a single packet in each direction between servers.</p>
<p class="bull">&#8226; UDP sockets permit broadcasting and multicasting. <em>Broadcasting</em> allows a sender to transmit a datagram to the same destination port on all of the hosts connected to a network. <em>Multicasting</em> is similar, but allows a datagram to be sent to a specified set of hosts. For further details see <a href="ch21.xhtml#ch21">Chapters 21</a> and <a href="ch22.xhtml#ch22">22</a> of [<a href="bib.xhtml#bib93">Stevens et al., 2004</a>].</p>
<p class="bull">&#8226; Certain types of applications (e.g., streaming video and audio transmission) can function acceptably without the reliability provided by TCP. On the other hand, the delay that may occur after TCP tries to recover from a lost segment may result in transmission delays that are unacceptably long. (A delay in streaming media transmission may be worse than a brief loss of the transmission stream.) Therefore, such applications may prefer UDP, and adopt application-specific recovery strategies to deal with occasional packet loss.</p>
<p class="noindentt">An application that uses UDP, but nevertheless requires reliability, must implement reliability features itself. Usually, this requires at least sequence numbers, acknowledgements, retransmission of lost packets, and duplicate detection. An example of how to do this is shown in [<a href="bib.xhtml#bib93">Stevens et al., 2004</a>]. However, if more <span epub:type="pagebreak" id="page_1283"/>advanced features such as flow control and congestion control are also required, then it is probably best to use TCP instead. Trying to implement all of these features on top of UDP is complex, and, even when well implemented, the result is unlikely to perform better than TCP.</p>
<h3 class="h3" id="ch61lev1sec13"><strong>61.13 Advanced Features</strong></h3>
<p class="noindenta">UNIX and Internet domain sockets have many other features that we have not detailed in this book. We summarize a few of these features in this section. For full details, see [<a href="bib.xhtml#bib93">Stevens et al., 2004</a>].</p>
<h4 class="h4" id="ch61lev2sec08"><strong>61.13.1 Out-of-Band Data</strong></h4>
<p class="noindenta">Out-of-band data is a feature of stream sockets that allows a sender to mark transmitted data as high priority; that is, the receiver can obtain notification of the availability of out-of-band data without needing to read all of the intervening data in the stream. This feature is used in programs such as <em>telnet</em>, <em>rlogin</em>, and <em>ftp</em> to make it possible to abort previously transmitted commands. Out-of-band data is sent and received using the <span class="literal">MSG_OOB</span> flag in calls to <em>send()</em> and <em>recv()</em>. When a socket receives notification of the availability of out-of-band data, the kernel generates the <span class="literal">SIGURG</span> signal for the socket owner (normally the process using the socket), as set by the <em>fcntl()</em> <span class="literal">F_SETOWN</span> operation.</p>
<p class="indent">When employed with TCP sockets, at most 1 byte of data may be marked as being out-of-band at any one time. If the sender transmits an additional byte of out-of-band data before the receiver has processed the previous byte, then the indication for the earlier out-of-band byte is lost.</p>
<div class="block">
<p class="noindent">TCP&#8217;s limitation of out-of-band data to a single byte is an artifact of the mismatch between the generic out-of-band model of the sockets API and its specific implementation using TCP&#8217;s <em>urgent mode</em>. We touched on TCP&#8217;s urgent mode when looking at the format of TCP segments in <a href="ch61.xhtml#ch61lev2sec01">Section 61.6.1</a>. TCP indicates the presence of urgent (out-of-band) data by setting the URG bit in the TCP header and setting the urgent pointer field to point to the urgent data. However, TCP has no way of indicating the length of an urgent data sequence, so the urgent data is considered to consist of a single byte.</p>
<p class="indent">Further information about TCP urgent data can be found in RFC 793.</p>
</div>
<p class="noindent">Under some UNIX implementations, out-of-band data is supported for UNIX domain stream sockets. Linux doesn&#8217;t support this.</p>
<p class="indent">The use of out-of-band data is nowadays discouraged, and it may be unreliable in some circumstances (see [<a href="bib.xhtml#bib33">Gont &#38; Yourtchenko, 2009</a>]). An alternative is to maintain a pair of stream sockets for communication. One of these is used for normal communication, while the other is used for high-priority communication. An application can monitor both channels using one of the techniques described in <a href="ch63.xhtml#ch63">Chapter 63</a>. This approach allows multiple bytes of priority data to be transmitted. Furthermore, it can be employed with stream sockets in any communication domain (e.g., UNIX domain sockets).</p>
<h4 class="h4" id="ch61lev2sec09"><span epub:type="pagebreak" id="page_1284"/><strong>61.13.2 The <em>sendmsg()</em> and <em>recvmsg()</em> System Calls</strong></h4>
<p class="noindentab">The <em>sendmsg()</em> and <em>recvmsg()</em> system calls are the most general purpose of the socket I/O system calls. The <em>sendmsg()</em> system call can do everything that is done by <em>write()</em>, <em>send()</em>, and <em>sendto()</em>; the <em>recvmsg()</em> system call can do everything that is done by <em>read()</em>, <em>recv()</em>, and <em>recvfrom()</em>. In addition, these calls allow the following:</p>
<p class="bull">&#8226; We can perform scatter-gather I/O, as with <em>readv()</em> and <em>writev()</em> (<a href="ch05.xhtml#ch05lev1sec07">Section 5.7</a>). When we use <em>sendmsg()</em> to perform gather output on a datagram socket (or <em>writev()</em> on a connected datagram socket), a single datagram is generated. Conversely, <em>recvmsg()</em> (and <em>readv()</em>) can be used to perform scatter input on a datagram socket, dispersing the bytes of a single datagram into multiple user-space buffers.</p>
<p class="bull">&#8226; We can transmit messages containing domain-specific <em>ancillary data</em> (also known as control information). Ancillary data can be passed via both stream and datagram sockets. We describe some examples of ancillary data below.</p>
<div class="block">
<p class="noindent">Linux 2.6.33 adds a new system call, <em>recvmmsg()</em>. This system call is similar to <em>recvmsg()</em>, but allows multiple datagrams to be received in a single system call. This reduces the system-call overhead in applications that deal with high levels of network traffic. An analogous <em>sendmmsg()</em> system call is likely to be added in a future kernel version.</p>
</div>
<h4 class="h4" id="ch61lev2sec10"><strong>61.13.3 Passing File Descriptors</strong></h4>
<p class="noindenta">Using <em>sendmsg()</em> and <em>recvmsg()</em>, we can pass ancillary data containing a file descriptor from one process to another process on the same host via a UNIX domain socket. Any type of file descriptor can be passed in this manner&#8212;for example, one obtained from a call to <em>open()</em> or <em>pipe()</em>. An example that is more relevant to sockets is that a master server could accept a client connection on a TCP listening socket and pass that descriptor to one of the members of a pool of server child processes (<a href="ch60.xhtml#ch60lev1sec04">Section 60.4</a>), which would then respond to the client request.</p>
<p class="indent">Although this technique is commonly referred to as passing a file descriptor, what is really being passed between the two processes is a reference to the same open file description (<a href="ch05.xhtml#ch5fig2">Figure 5-2</a>, on <a href="ch05.xhtml#page_95">page 95</a>). The file descriptor number employed in the receiving process would typically be different from the number employed in the sender.</p>
<div class="block">
<p class="noindent">An example of passing file descriptors is provided in the files <span class="literal">scm_rights_send.c</span> and <span class="literal">scm_rights_recv.c</span> in the <span class="literal">sockets</span> subdirectory in the source code distribution for this book.</p>
</div>
<h4 class="h4" id="ch61lev2sec11"><strong>61.13.4 Receiving Sender Credentials</strong></h4>
<p class="noindenta">Another example of the use of ancillary data is for receiving sender credentials via a UNIX domain socket. These credentials consist of the user ID, the group ID, and the process ID of the sending process. The sender may specify its user and group IDs as the corresponding real, effective, or saved set IDs. This allows the receiving process to authenticate a sender on the same host. For further details, see the <em>socket(7)</em> and <em>unix(7)</em> manual pages.</p>
<p class="indent">Unlike passing file descriptors, passing sender credentials is not specified in SUSv3. Aside from Linux, this feature is implemented in some of the modern BSDs <span epub:type="pagebreak" id="page_1285"/>(where the credentials structure contains somewhat more information than on Linux), but is available on few other UNIX implementations. The details of credential passing on FreeBSD are described in [<a href="bib.xhtml#bib93">Stevens et al., 2004</a>].</p>
<p class="indent">On Linux, a privileged process can fake the user ID, group ID, and process ID that are passed as credentials if it has, respectively, the <span class="literal">CAP_SETUID</span>, <span class="literal">CAP_SETGID</span>, and <span class="literal">CAP_SYS_ADMIN</span> capabilities.</p>
<div class="block">
<p class="noindent">An example of passing credentials is provided in the files <span class="literal">scm_cred_send.c</span> and <span class="literal">scm_cred_recv.c</span> in the <span class="literal">sockets</span> subdirectory in the source code distribution for this book.</p>
</div>
<h4 class="h4" id="ch61lev2sec12"><strong>61.13.5 Sequenced-Packet Sockets</strong></h4>
<p class="noindentab">Sequenced-packet sockets combine features of both stream and datagram sockets:</p>
<p class="bull">&#8226; Like stream sockets, sequenced-packet sockets are connection-oriented. Connections are established in the same way as for stream sockets, using <em>bind()</em>, <em>listen()</em>, <em>accept()</em>, and <em>connect()</em>.</p>
<p class="bull">&#8226; Like datagram sockets, message boundaries are preserved. A <em>read()</em> from a sequenced-packet socket returns exactly one message (as written by the peer). If the message is longer than the buffer supplied by the caller, the excess bytes are discarded.</p>
<p class="bull">&#8226; Like stream sockets, and unlike datagram sockets, communication via sequenced-packet sockets is reliable. Messages are delivered to the peer application error-free, in order, and unduplicated, and they are guaranteed to arrive (assuming that there is not a system or application crash, or a network outage).</p>
<p class="noindentt">A sequenced-packet socket is created by calling <em>socket()</em> with the <em>type</em> argument specified as <span class="literal">SOCK_SEQPACKET</span>.</p>
<p class="indent">Historically, Linux, like most UNIX implementations, did not support sequenced-packet sockets in either the UNIX or the Internet domains. However, starting with kernel 2.6.4, Linux supports <span class="literal">SOCK_SEQPACKET</span> for UNIX domain sockets.</p>
<p class="indent">In the Internet domain, the UDP and TCP protocols do not support <span class="literal">SOCK_SEQPACKET</span>, but the SCTP protocol (described in the next section) does.</p>
<p class="indent">We don&#8217;t show an example of the use of sequenced-packet sockets in this book, but, other than the preservation of message boundaries, their use is very similar to stream sockets.</p>
<h4 class="h4" id="ch61lev2sec13"><strong>61.13.6 SCTP and DCCP Transport-Layer Protocols</strong></h4>
<p class="noindenta">SCTP and DCCP are two newer transport-layer protocols that are likely to become increasingly common in the future.</p>
<p class="indent">The <em>Stream Control Transmission Protocol</em> (SCTP, <em><a href="http://www.sctp.org/">http://www.sctp.org/</a></em>) was designed to support telephony signaling in particular, but is also general purpose. Like TCP, SCTP provides reliable, bidirectional, connection-oriented transport. Unlike TCP, SCTP preserves message boundaries. One of the distinctive features of SCTP is multistream support, which allows multiple logical data streams to be employed over a single connection.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1286"/>SCTP is described in [<a href="bib.xhtml#bib95">Stewart &#38; Xie, 2001</a>], [<a href="bib.xhtml#bib93">Stevens et al., 2004</a>], and in RFCs 4960, 3257, and 3286.</p>
<p class="indent">SCTP is available on Linux since kernel 2.6. Further information about this implementation can be found at <em><a href="http://lksctp.sourceforge.net/">http://lksctp.sourceforge.net/</a></em>.</p>
<p class="indent">Throughout the preceding chapters that describe the sockets API, we equated Internet domain stream sockets with TCP. However, SCTP provides an alternative protocol for implementing stream sockets, created using the following call:</p>
<p class="programs">socket(AF_INET, SOCK_STREAM, IPPROTO_SCTP);</p>
<p class="noindent">Starting in kernel 2.6.14, Linux supports a new datagram protocol, the <em>Datagram Congestion Control Protocol</em> (DCCP). Like TCP, DCCP provides congestion control (removing the need to implement congestion control at the application level) to prevent a fast transmitter from overwhelming the network. (We explained congestion control when describing TCP in <a href="ch58.xhtml#ch58lev2sec03">Section 58.6.3</a>.) However, unlike TCP (but like UDP), DCCP doesn&#8217;t provide guarantees about reliable or in-order delivery, and thus allows applications that don&#8217;t need these features to avoid the delays that they can incur. Information about DCCP can be found at <em><a href="http://www.read.cs.ucla.edu/dccp/">http://www.read.cs.ucla.edu/dccp/</a></em> and RFCs 4336 and 4340.</p>
<h3 class="h3" id="ch61lev1sec14"><strong>61.14 Summary</strong></h3>
<p class="noindenta">In various circumstances, partial reads and writes can occur when performing I/O on stream sockets. We showed the implementation of two functions, <em>readn()</em> and <em>writen()</em>, that can be used to ensure a complete buffer of data is read or written.</p>
<p class="indent">The <em>shutdown()</em> system call provides more precise control over connection termination. Using <em>shutdown()</em>, we can forcibly shut down either or both halves of a bidirectional communication stream, regardless of whether there are other open file descriptors referring to the socket.</p>
<p class="indent">Like <em>read()</em> and <em>write()</em>, <em>recv()</em> and <em>send()</em> can be used to perform I/O on a socket, but calls provide an extra argument, <em>flags</em>, that controls socket-specific I/O functionality.</p>
<p class="indent">The <em>sendfile()</em> system call allows us to efficiently copy the contents of a file to a socket. This efficiency is gained because we don&#8217;t need to copy the file data to and from user memory, as would be required with calls to <em>read()</em> and <em>write()</em>.</p>
<p class="indent">The <em>getsockname()</em> and <em>getpeername()</em> system calls retrieve, respectively, the local address to which a socket is bound and the address of the peer to which that socket is connected.</p>
<p class="indent">We considered some details of the operation of TCP, including TCP states and the TCP state transition diagram, and TCP connection establishment and termination. As part of this discussion, we saw why the TIME_WAIT state is an important part of TCP&#8217;s reliability guarantee. Although this state can lead to the &#8220;Address already in use&#8221; error when restarting a server, we later saw that the <span class="literal">SO_REUSEADDR</span> socket option can be used to avoid this error, while nevertheless allowing the TIME_WAIT state to serve its intended purpose.</p>
<p class="indent">The <em>netstat</em> and <em>tcpdump</em> commands are useful tools for monitoring and debugging applications that use sockets.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1287"/>The <em>getsockopt()</em> and <em>setsockopt()</em> system calls retrieve and modify options affecting the operation of a socket.</p>
<p class="indent">On Linux, when a new socket is created by <em>accept()</em>, it does not inherit the listening sockets open file status flags, file descriptor flags, or file descriptor attributes related to signal-driven I/O. However, it does inherit the settings of socket options. We noted that SUSv3 is silent on these details, which vary across implementations.</p>
<p class="indent">Although UDP doesn&#8217;t provide the reliability guarantees of TCP, we saw that there are nevertheless reasons why UDP can be preferable for some applications.</p>
<p class="indent">Finally, we outlined a few advanced features of sockets programming that we don&#8217;t describe in detail in this book.</p>
<h5 class="h5" id="ch61lev3sec03"><strong>Further information</strong></h5>
<p class="noindenta">Refer to the sources of further information listed in <a href="ch59.xhtml#ch59lev1sec15">Section 59.15</a>.</p>
<h3 class="h3" id="ch61lev1sec15"><strong>61.15 Exercises</strong></h3>
<p class="exer"><a id="ch61exe1"/><strong>61-1.</strong>&#160;&#160;&#160;Suppose that the program in <a href="ch61.xhtml#ch61ex2">Listing 61-2</a> (<span class="literal">is_echo_cl.c</span>) was modified so that, instead of using <em>fork()</em> to create two processes that operate concurrently, it instead used just one process that first copies its standard input to the socket and then reads the server&#8217;s response. What problem might occur when running this client? (Look at <a href="ch58.xhtml#ch58fig8">Figure 58-8</a>, on <a href="ch58.xhtml#page_1190">page 1190</a>.)</p>
<p class="exer"><a id="ch61exe2"/><strong>61-2.</strong>&#160;&#160;&#160;Implement <em>pipe()</em> in terms of <em>socketpair()</em>. Use <em>shutdown()</em> to ensure that the resulting pipe is unidirectional.</p>
<p class="exer"><a id="ch61exe3"/><strong>61-3.</strong>&#160;&#160;&#160;Implement a replacement for <em>sendfile()</em> using <em>read()</em>, <em>write()</em>, and <em>lseek()</em>.</p>
<p class="exer"><a id="ch61exe4"/><strong>61-4.</strong>&#160;&#160;&#160;Write a program that uses <em>getsockname()</em> to show that, if we call <em>listen()</em> on a TCP socket without first calling <em>bind()</em>, the socket is assigned an ephemeral port number.</p>
<p class="exer"><a id="ch61exe5"/><strong>61-5.</strong>&#160;&#160;&#160;Write a client and a server that permit the client to execute arbitrary shell commands on the server host. (If you don&#8217;t implement any security mechanism in this application, you should ensure that the server is operating under a user account where it can do no damage if invoked by malicious users.) The client should be executed with two command-line arguments:</p>
<p class="programs1">$ <span class="codestrong">./is_shell_cl <span class="codeitalic">server-host</span> '<span class="codeitalic">some-shell-command</span>'</span></p>
<p class="exerp">After connecting to the server, the client sends the given command to the server, and then closes its writing half of the socket using <em>shutdown()</em>, so that the server sees end-of-file. The server should handle each incoming connection in a separate child process (i.e., a concurrent design). For each incoming connection, the server should read the command from the socket (until end-of-file), and then exec a shell to perform the command. Here are a couple hints:</p>
<p class="bull1">&#8226; See the implementation of <em>system()</em> in <a href="ch27.xhtml#ch27lev1sec07">Section 27.7</a> for an example of how to execute a shell command.</p>
<p class="bull1">&#8226; By using <em>dup2()</em> to duplicate the socket on standard output and standard error, the execed command will automatically write to the socket.</p>
<p class="exer"><span epub:type="pagebreak" id="page_1288"/><a id="ch61exe6"/><strong>61-6.</strong>&#160;&#160;&#160;<a href="ch61.xhtml#ch61lev2sec08">Section 61.13.1</a> noted that an alternative to out-of-band data would be to create two socket connections between the client and server: one for normal data and one for priority data. Write client and server programs that implement this framework. Here are a few hints:</p>
<p class="bull1">&#8226; The server needs some way of knowing which two sockets belong to the same client. One way to do this is to have the client first create a listening socket using an ephemeral port (i.e., binding to port 0). After obtaining the ephemeral port number of its listening socket (using <em>getsockname()</em>), the client connects its &#8220;normal&#8221; socket to the server&#8217;s listening socket and sends a message containing the port number of the client&#8217;s listening socket. The client then waits for the server to use the client&#8217;s listening socket to make a connection in the opposite direction for the &#8220;priority&#8221; socket. (The server can obtain the client&#8217;s IP address during the <em>accept()</em> of the normal connection.)</p>
<p class="bull1">&#8226; Implement some type of security mechanism to prevent a rogue process from trying to connect to the client&#8217;s listening socket. To do this, the client could send a cookie (i.e., some type of unique message) to the server using the normal socket. The server would then return this cookie via the priority socket so that the client could verify it.</p>
<p class="bull1">&#8226; In order to experiment with transmitting normal and priority data from the client to the server, you will need to code the server to multiplex the input from the two sockets using <em>select()</em> or <em>poll()</em> (described in <a href="ch63.xhtml#ch63lev1sec02">Section 63.2</a>).</p>
</body>
</html>
