<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch50"><span epub:type="pagebreak" id="page_1045"/><strong><span class="big">50</span></strong><br/><strong>VIRTUAL MEMORY OPERATIONS</strong></h2>
<p class="noindentab">This chapter looks at various system calls that perform operations on a process&#8217;s virtual address space:</p>
<p class="bull">&#8226; The <em>mprotect()</em> system call changes the protection on a region of virtual memory.</p>
<p class="bull">&#8226; The <em>mlock()</em> and <em>mlockall()</em> system calls lock a region of virtual memory into physical memory, thus preventing it from being swapped out.</p>
<p class="bull">&#8226; The <em>mincore()</em> system call allows a process to determine whether the pages in a region of virtual memory are resident in physical memory.</p>
<p class="bull">&#8226; The <em>madvise()</em> system call allows a process to advise the kernel about its future patterns of usage of a virtual memory region.</p>
<p class="noindentt">Some of these system calls find particular use in conjunction with shared memory regions (<a href="ch48.xhtml#ch48">Chapters 48</a>, <a href="ch49.xhtml#ch49">49</a>, and <a href="ch54.xhtml#ch54">54</a>), but they can be applied to any region of a process&#8217;s virtual memory.</p>
<div class="block">
<p class="noindent">The techniques described in this chapter are not in fact about IPC at all, but we include them in this part of the book because they are sometimes used with shared memory.</p>
</div>
<h3 class="h3" id="ch50lev1sec01"><strong>50.1 Changing Memory Protection: <em>mprotect()</em></strong></h3>
<p class="noindenta">The <em>mprotect()</em> system call changes the protection on the virtual memory pages in the range starting at <em>addr</em> and continuing for <em>length</em> bytes.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_1046"/>#include &lt;sys/mman.h&gt;<br/><br/>int <span class="codestrong">mprotect</span>(void *<span class="font1">addr</span>, size_t <span class="font1">length</span>, int <span class="font1">prot</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The value given in <em>addr</em> must be a multiple of the system page size (as returned by <em>sysconf(_SC_PAGESIZE)</em>). (SUSv3 specified that <em>addr must</em> be page-aligned. SUSv4 says that an implementation <em>may</em> require this argument to be page-aligned.) Because protections are set on whole pages, <em>length</em> is, in effect, rounded up to the next multiple of the system page size.</p>
<p class="indent">The <em>prot</em> argument is a bit mask specifying the new protection for this region of memory. It must be specified as either <span class="literal">PROT_NONE</span> or a combination created by ORing together one or more of <span class="literal">PROT_READ</span>, <span class="literal">PROT_WRITE</span>, and <span class="literal">PROT_EXEC</span>. All of these values have the same meaning as for <em>mmap()</em> (<a href="ch49.xhtml#ch49table2">Table 49-2</a>, on <a href="ch49.xhtml#page_1020">page 1020</a>).</p>
<p class="indent">If a process attempts to access a region of memory in a manner that violates the memory protection, the kernel generates a <span class="literal">SIGSEGV</span> signal for the process.</p>
<p class="indent">One use of <em>mprotect()</em> is to change the protection of a region of mapped memory originally set in a call to <em>mmap()</em>, as shown in <a href="ch50.xhtml#ch50ex1">Listing 50-1</a>. This program creates an anonymous mapping that initially has all access denied (<span class="literal">PROT_NONE</span>). The program then changes the protection on the region to read plus write. Before and after making the change, the program uses the <em>system()</em> function to execute a shell command that displays the line from the <span class="literal">/proc/</span><em>PID</em><span class="literal">/maps</span> file corresponding to the mapped region, so that we can see the change in memory protection. (We could have obtained the mapping information by directly parsing <span class="literal">/proc/self/maps</span>, but we used the call to <em>system()</em> because it results in a shorter program.) When we run this program, we see the following:</p>
<p class="programs">$ <span class="codestrong">./t_mprotect</span><br/>Before mprotect()<br/>b7cde000-b7dde000 ---s 00000000 00:04 18258&#160;&#160;&#160;&#160;/dev/zero (deleted)<br/>After mprotect()<br/>b7cde000-b7dde000 rw-s 00000000 00:04 18258&#160;&#160;&#160;&#160;/dev/zero (deleted)</p>
<p class="noindent">From the last line of output, we can see that <em>mprotect()</em> has changed the permissions of the memory region to <span class="literal">PROT_READ | PROT_WRITE</span>. (For an explanation of the <span class="literal">(deleted)</span> string that appears after <span class="literal">/dev/zero</span> in the shell output, refer to <a href="ch48.xhtml#ch48lev1sec05">Section 48.5</a>.)</p>
<p class="examplet"><a id="ch50ex1"/><strong>Listing 50-1:</strong> Changing memory protection with <em>mprotect()</em></p>
<p class="programsli">________________________________________________________ <span class="codestrong">vmem/t_mprotect.c</span><br/><br/>#define _BSD_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get MAP_ANONYMOUS definition from &lt;sys/mman.h&gt; */<br/>#include &lt;sys/mman.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>#define LEN (1024 * 1024)<br/><br/>#define SHELL_FMT "cat /proc/%ld/maps | grep zero"<br/>#define CMD_SIZE (sizeof(SHELL_FMT) + 20)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allow extra space for integer string */<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;char cmd[CMD_SIZE];<br/>&#160;&#160;&#160;&#160;char *addr;<br/><br/>&#160;&#160;&#160;&#160;/* Create an anonymous mapping with all access denied */<br/><br/>&#160;&#160;&#160;&#160;addr = mmap(NULL, LEN, PROT_NONE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);<br/>&#160;&#160;&#160;&#160;if (addr == MAP_FAILED)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mmap");<br/><br/>&#160;&#160;&#160;&#160;/* Display line from /proc/self/maps corresponding to mapping */<br/><br/>&#160;&#160;&#160;&#160;printf("Before mprotect()\n");<br/>&#160;&#160;&#160;&#160;snprintf(cmd, CMD_SIZE, SHELL_FMT, (long) getpid());<br/>&#160;&#160;&#160;&#160;system(cmd);<br/><br/>&#160;&#160;&#160;&#160;/* Change protection on memory to allow read and write access */<br/><br/>&#160;&#160;&#160;&#160;if (mprotect(addr, LEN, PROT_READ | PROT_WRITE) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mprotect");<br/><br/>&#160;&#160;&#160;&#160;printf("After mprotect()\n");<br/>&#160;&#160;&#160;&#160;system(cmd);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Review protection via /proc/self/maps */<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>________________________________________________________ <span class="codestrong">vmem/t_mprotect.c</span></p>
<h3 class="h3" id="ch50lev1sec02"><span epub:type="pagebreak" id="page_1047"/><strong>50.2 Memory Locking: <em>mlock()</em> and <em>mlockall()</em></strong></h3>
<p class="noindenta">In some applications, it is useful to lock part or all of a process&#8217;s virtual memory so that it is guaranteed to always be in physical memory. One reason for doing this is to improve performance. Accesses to locked pages are guaranteed never to be delayed by a page fault. This is useful for applications that must ensure rapid response times.</p>
<p class="indent">Another reason for locking memory is security. If a virtual memory page containing sensitive data is never swapped out, then no copy of the page is ever written to the disk. If the page was written to the disk, it could, in theory, be read directly from the disk device at some later time. (An attacker could deliberately engineer this situation by running a program that consumes a large amount of memory, thus forcing the memory of other processes to be swapped out to disk.) Reading information from the swap space could even be done after the process has terminated, since the kernel makes no guarantees about zeroing out the data held in swap space. (Normally, only privileged processes would be able to read from the swap device.)</p>
<div class="block">
<p class="noindent">The suspend mode on laptop computers, as well some desktop systems, saves a copy of a system&#8217;s RAM to disk, regardless of memory locks.</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_1048"/>In this section, we look at the system calls used for locking and unlocking part or all of a process&#8217;s virtual memory. However, before doing this, we first look at a resource limit that governs memory locking.</p>
<h5 class="h5" id="ch50lev3sec01"><strong>The</strong> <span class="literal"><span class="codestrong">RLIMIT_MEMLOCK</span></span> <strong>resource limit</strong></h5>
<p class="noindenta">In <a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a>, we briefly described the <span class="literal">RLIMIT_MEMLOCK</span> limit, which defines a limit on the number of bytes that a process can lock into memory. We now consider this limit in more detail.</p>
<p class="indent">In Linux kernels before 2.6.9, only privileged processes (<span class="literal">CAP_IPC_LOCK</span>) can lock memory, and the <span class="literal">RLIMIT_MEMLOCK</span> soft resource limit places an upper limit on the number of bytes that a privileged process can lock.</p>
<p class="indentb">Starting with Linux 2.6.9, changes to the memory locking model allow unprivileged processes to lock small amounts of memory. This is useful for an application that needs to place a small piece of sensitive information in locked memory in order to ensure that it is never written to the swap space on disk; for example, <em>gpg</em> does this with pass phrases. As a result of these changes:</p>
<p class="bull">&#8226; no limits are placed on the amount of memory that a privileged process can lock (i.e., <span class="literal">RLIMIT_MEMLOCK</span> is ignored); and</p>
<p class="bull">&#8226; an unprivileged process is now able to lock memory up to the soft limit defined by <span class="literal">RLIMIT_MEMLOCK</span>.</p>
<p class="noindentt">The default value for both the soft and hard <span class="literal">RLIMIT_MEMLOCK</span> limits is 8 pages (i.e., 32,768 bytes on x86-32).</p>
<p class="indentb">The <span class="literal">RLIMIT_MEMLOCK</span> limit affects:</p>
<p class="bull">&#8226; <em>mlock()</em> and <em>mlockall()</em>;</p>
<p class="bull">&#8226; the <em>mmap()</em> <span class="literal">MAP_LOCKED</span> flag, which is used to lock a memory mapping when it is created, as described in <a href="ch49.xhtml#ch49lev1sec06">Section 49.6</a>; and</p>
<p class="bull">&#8226; the <em>shmctl()</em> <span class="literal">SHM_LOCK</span> operation, which is used to lock System V shared memory segments, as described in <a href="ch48.xhtml#ch48lev1sec07">Section 48.7</a>.</p>
<p class="noindentt">Since virtual memory is managed in units of pages, memory locks apply to complete pages. When performing limit checks, the <span class="literal">RLIMIT_MEMLOCK</span> limit is rounded <em>down</em> to the nearest multiple of the system page size.</p>
<p class="indentb">Although this resource limit has a single (soft) value, in effect, it defines two separate limits:</p>
<p class="bull">&#8226; For <em>mlock()</em>, <em>mlockall()</em>, and the <em>mmap()</em> <span class="literal">MAP_LOCKED</span> operation, <span class="literal">RLIMIT_MEMLOCK</span> defines a per-process limit on the number of bytes of its virtual address space that a process may lock.</p>
<p class="bull">&#8226; For the <em>shmctl()</em> <span class="literal">SHM_LOCK</span> operation, <span class="literal">RLIMIT_MEMLOCK</span> defines a per-user limit on the number of bytes in shared memory segments that may be locked by the real user ID of this process. When a process performs a <em>shmctl()</em> <span class="literal">SHM_LOCK</span> operation, the kernel checks the total number of bytes of System V shared memory that are already recorded as being locked by the real user ID of the calling process. If the size of the to-be-locked segment would not push that total over the process&#8217;s <span class="literal">RLIMIT_MEMLOCK</span> limit, the operation succeeds.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_1049"/>The reason <span class="literal">RLIMIT_MEMLOCK</span> has different semantics for System V shared memory is that a shared memory segment can continue to exist even when it is not attached by any process. (It is removed only after an explicit <em>shmctl()</em> <span class="literal">IPC_RMID</span> operation, and then only after all processes have detached it from their address space.)</p>
<h5 class="h5" id="ch50lev3sec02"><strong>Locking and unlocking memory regions</strong></h5>
<p class="noindenta">A process can use <em>mlock()</em> and <em>munlock()</em> to lock and unlock regions of memory.</p>
<div class="box">
<p class="programsa">#include &lt;sys/mman.h&gt;<br/><br/>int <span class="codestrong">mlock</span>(void *<span class="font1">addr</span>, size_t <span class="font1">length</span>);<br/>int <span class="codestrong">munlock</span>(void *<span class="font1">addr</span>, size_t <span class="font1">length</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>mlock()</em> system call locks all of the pages of the calling process&#8217;s virtual address range starting at <em>addr</em> and continuing for <em>length</em> bytes. Unlike the corresponding argument passed to several other memory-related system calls, <em>addr</em> does not need to be page-aligned: the kernel locks pages starting at the next page boundary below <em>addr</em>. However, SUSv3 optionally allows an implementation to require that <em>addr</em> be a multiple of the system page size, and portable applications should ensure that this is so when calling <em>mlock()</em> and <em>munlock()</em>.</p>
<p class="indent">Because locking is done in units of whole pages, the end of the locked region is the next page boundary greater than <em>length</em> plus <em>addr</em>. For example, on a system where the page size is 4096 bytes, the call <em>mlock(2000, 4000)</em> will lock bytes 0 through to 8191.</p>
<div class="block">
<p class="noindent">We can find out how much memory a process currently has locked by inspecting the <span class="literal">VmLck</span> entry of the Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/status</span> file.</p>
</div>
<p class="noindent">After a successful <em>mlock()</em> call, all of the pages in the specified range are guaranteed to be locked and resident in physical memory. The <em>mlock()</em> system call fails if there is insufficient physical memory to lock all of the requested pages or if the request violates the <span class="literal">RLIMIT_MEMLOCK</span> soft resource limit.</p>
<p class="indent">We show an example of the use of <em>mlock()</em> in <a href="ch50.xhtml#ch50ex2">Listing 50-2</a>.</p>
<p class="indent">The <em>munlock()</em> system call performs the converse of <em>mlock()</em>, removing a memory lock previously established by the calling process. The <em>addr</em> and <em>length</em> arguments are interpreted in the same way as for <em>mlock()</em>. Unlocking a set of pages doesn&#8217;t guarantee that they cease to be memory-resident: pages are removed from RAM only in response to memory demands by other processes.</p>
<p class="indentb">Aside from the explicit use of <em>munlock()</em>, memory locks are automatically removed in the following circumstances:</p>
<p class="bull">&#8226; on process termination;</p>
<p class="bull">&#8226; if the locked pages are unmapped via <em>munmap()</em>; or</p>
<p class="bull">&#8226; if the locked pages are overlaid using the <em>mmap()</em> <span class="literal">MAP_FIXED</span> flag.</p>
<h5 class="h5" id="ch50lev3sec03"><span epub:type="pagebreak" id="page_1050"/><strong>Details of the semantics of memory locking</strong></h5>
<p class="noindenta">In the following paragraphs, we note some details of the semantics of memory locks.</p>
<p class="indent">Memory locks are not inherited by a child created via <em>fork()</em>, and are not preserved across an <em>exec()</em>.</p>
<p class="indent">Where multiple processes share a set of pages (e.g., a <span class="literal">MAP_SHARED</span> mapping), these pages remain locked in memory as long as at least one of the processes holds a memory lock on the pages.</p>
<p class="indent">Memory locks don&#8217;t nest for a single process. If a process repeatedly calls <em>mlock()</em> on a certain virtual address range, only one lock is established, and this lock will be removed by a single call to <em>munlock()</em>. On the other hand, if we use <em>mmap()</em> to map the same set of pages (i.e., the same file) at several different locations within a single process, and then lock each of these mappings, the pages remain locked in RAM until all of the mappings have been unlocked.</p>
<p class="indent">The fact that memory locks are performed in units of pages and can&#8217;t be nested means that it isn&#8217;t logically correct to independently apply <em>mlock()</em> and <em>munlock()</em> calls to different data structures on the same virtual page. For example, suppose we have two data structures within the same virtual memory page pointed to by pointers <em>p1</em> and <em>p2</em>, and we make the following calls:</p>
<p class="programs">mlock(*p1, len1);<br/>mlock(*p2, len2);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Actually has no effect */<br/>munlock(*p1, len1);</p>
<p class="noindent">All of the above calls will succeed, but at the end of this sequence, the entire page is unlocked; that is, the data structure pointed to by <em>p2</em> is not locked into memory.</p>
<p class="indentb">Note that the semantics of the <em>shmctl()</em> <span class="literal">SHM_LOCK</span> operation (<a href="ch48.xhtml#ch48lev1sec07">Section 48.7</a>) differ from those of <em>mlock()</em> and <em>mlockall()</em>, as follows:</p>
<p class="bull">&#8226; After a <span class="literal">SHM_LOCK</span> operation, pages are locked into memory only as they are faulted in by subsequent references. By contrast, <em>mlock()</em> and <em>mlockall()</em> fault all of the locked pages into memory before the call returns.</p>
<p class="bull">&#8226; The <span class="literal">SHM_LOCK</span> operation sets a property of the shared memory segment, rather than the process. (For this reason, the value in the <span class="literal">/proc/</span><em>PID</em><span class="literal">/status VmLck</span> field doesn&#8217;t include the size of any attached System V shared memory segments that have been locked using <span class="literal">SHM_LOCK</span>.) This means that, once faulted into memory, the pages remain resident even if all processes detach the shared memory segment. By contrast, a region locked into memory using <em>mlock()</em> (or <em>mlockall()</em>) remains locked only as long as at least one process holds a lock on the region.</p>
<h5 class="h5" id="ch50lev3sec04"><strong>Locking and unlocking all of a process&#8217;s memory</strong></h5>
<p class="noindenta">A process can use <em>mlockall()</em> and <em>munlockall()</em> to lock and unlock all of its memory.</p>
<div class="box">
<p class="programsa">#include &lt;sys/mman.h&gt;<br/><br/>int <span class="codestrong">mlockall</span>(int <span class="font1">flags</span>);<br/>int <span class="codestrong">munlockall</span>(void);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb"><span epub:type="pagebreak" id="page_1051"/>The <em>mlockall()</em> system call locks all of the currently mapped pages in a process&#8217;s virtual address space, all of the pages mapped in the future, or both, according to the <em>flags</em> bit mask, which is specified by ORing together one or both of the following constants:</p>
<p class="term"><span class="literal">MCL_CURRENT</span></p>
<p class="termlist">Lock all pages that are currently mapped into the calling process&#8217;s virtual address space. This includes all pages currently allocated for the program text, data segments, memory mappings, and the stack. After a successful call specifying the <span class="literal">MCL_CURRENT</span> flag, all of the pages of the calling process are guaranteed to be memory-resident. This flag doesn&#8217;t affect pages that are subsequently allocated in the process&#8217;s virtual address space; for this, we must use <span class="literal">MCL_FUTURE</span>.</p>
<p class="term"><span class="literal">MCL_FUTURE</span></p>
<p class="termlist">Lock all pages subsequently mapped into the calling process&#8217;s virtual address space. Such pages may, for example, be part of a shared memory region mapped via <em>mmap()</em> or <em>shmat()</em>, or part of the upwardly growing heap or downwardly growing stack. As a consequence of specifying the <span class="literal">MCL_FUTURE</span> flag, a later memory allocation operation (e.g., <em>mmap()</em>, <em>sbrk()</em>, or <em>malloc()</em>) may fail, or stack growth may yield a <span class="literal">SIGSEGV</span> signal, if the system runs out of RAM to allocate to the process or the <span class="literal">RLIMIT_MEMLOCK</span> soft resource limit is encountered.</p>
<p class="noindentt">The same rules regarding the constraints, lifetime, and inheritance of memory locks created with <em>mlock()</em> also apply for memory locks created via <em>mlockall()</em>.</p>
<p class="indent">The <em>munlockall()</em> system call unlocks all of the pages of the calling process and undoes the effect of any previous <em>mlockall(MCL_FUTURE)</em> call. As with <em>munlock()</em>, unlocked pages are not guaranteed to be removed from RAM by this call.</p>
<div class="block">
<p class="noindent">Before Linux 2.6.9, privilege (<span class="literal">CAP_IPC_LOCK</span>) was required to call <em>munlockall()</em> (inconsistently, privilege was not required for <em>munlock()</em>). Since Linux 2.6.9, privilege is no longer required.</p>
</div>
<h3 class="h3" id="ch50lev1sec03"><strong>50.3 Determining Memory Residence: <em>mincore()</em></strong></h3>
<p class="noindenta">The <em>mincore()</em> system call is the complement of the memory locking system calls. It reports which pages in a virtual address range are currently resident in RAM, and thus won&#8217;t cause a page fault if accessed.</p>
<p class="indent">SUSv3 doesn&#8217;t specify <em>mincore()</em>. It is available on many, but not all, UNIX implementations. On Linux, <em>mincore()</em> has been available since kernel 2.4.</p>
<div class="box">
<p class="programsa">#define _BSD_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Or: #define _SVID_SOURCE */<br/>#include &lt;sys/mman.h&gt;<br/><br/>int <span class="codestrong">mincore</span>(void *<span class="font1">addr</span>, size_t <span class="font1">length</span>, unsigned char *<span class="font1">vec</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_1052"/>The <em>mincore()</em> system call returns memory-residence information about pages in the virtual address range starting at <em>addr</em> and running for <em>length</em> bytes. The address supplied in <em>addr</em> must be page-aligned, and, since information is returned about whole pages, <em>length</em> is effectively rounded up to the next multiple of the system page size.</p>
<p class="indent">Information about memory residency is returned in <em>vec</em>, which must be an array of <em>(length + PAGE_SIZE &#8211; 1) / PAGE_SIZE</em> bytes. (On Linux, <em>vec</em> has the type <em>unsigned char *</em>; on some other UNIX implementations, <em>vec</em> has the type <em>char *</em>.) The least significant bit of each byte is set if the corresponding page is memory-resident. The setting of the other bits is undefined on some UNIX implementations, so portable applications should test only this bit.</p>
<p class="indent">The information returned by <em>mincore()</em> can change between the time the call is made and the time the elements of <em>vec</em> are checked. The only pages guaranteed to remain memory-resident are those locked with <em>mlock()</em> or <em>mlockall()</em>.</p>
<div class="block">
<p class="noindent">Prior to Linux 2.6.21, various implementation problems meant that <em>mincore()</em> did not correctly report memory-residence information for <span class="literal">MAP_PRIVATE</span> mappings or for nonlinear mappings (established using <em>remap_file_pages()</em>).</p>
</div>
<p class="noindent"><a href="ch50.xhtml#ch50ex2">Listing 50-2</a> demonstrates the use of <em>mlock()</em> and <em>mincore()</em>. After allocating and mapping a region of memory using <em>mmap()</em>, this program uses <em>mlock()</em> to lock either the entire region or otherwise groups of pages at regular intervals. (Each of the command-line arguments to the program is expressed in terms of pages; the program converts these to bytes, as required for the calls to <em>mmap()</em>, <em>mlock()</em>, and <em>mincore()</em>.) Before and after the <em>mlock()</em> call, the program uses <em>mincore()</em> to retrieve information about the memory residency of pages in the region and displays this information graphically.</p>
<p class="examplet"><a id="ch50ex2"/><strong>Listing 50-2:</strong> Using <em>mlock()</em> and <em>mincore()</em></p>
<p class="programsli">___________________________________________________________ <span class="codestrong">vmem/memlock.c</span><br/><br/>#define _BSD_SOURCE&#160;&#160;&#160;&#160;&#160;/* Get mincore() declaration and MAP_ANONYMOUS<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;definition from &lt;sys/mman.h&gt; */<br/>#include &lt;sys/mman.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>/* Display residency of pages in range [addr .. (addr + length - 1)] */<br/><br/>static void<br/>displayMincore(char *addr, size_t length)<br/>{<br/>&#160;&#160;&#160;&#160;unsigned char *vec;<br/>&#160;&#160;&#160;&#160;long pageSize, numPages, j;<br/><br/>&#160;&#160;&#160;&#160;pageSize = sysconf(_SC_PAGESIZE);<br/><br/>&#160;&#160;&#160;&#160;numPages = (length + pageSize - 1) / pageSize;<br/>&#160;&#160;&#160;&#160;vec = malloc(numPages);<br/>&#160;&#160;&#160;&#160;if (vec == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("malloc");<br/><br/><span epub:type="pagebreak" id="page_1053"/>&#160;&#160;&#160;&#160;if (mincore(addr, length, vec) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mincore");<br/><br/>&#160;&#160;&#160;&#160;for (j = 0; j &lt; numPages; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (j % 64 == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s%10p: ", (j == 0) ? "" : "\n", addr + (j * pageSize));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%c", (vec[j] &#38; 1) ? '*' : '.');<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;printf("\n");<br/><br/>&#160;&#160;&#160;&#160;free(vec);<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;char *addr;<br/>&#160;&#160;&#160;&#160;size_t len, lockLen;<br/>&#160;&#160;&#160;&#160;long pageSize, stepSize, j;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 4 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s num-pages lock-page-step lock-page-len\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;pageSize = sysconf(_SC_PAGESIZE);<br/>&#160;&#160;&#160;&#160;if (pageSize == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sysconf(_SC_PAGESIZE)");<br/><br/>&#160;&#160;&#160;&#160;len =&#160;&#160;&#160;&#160;&#160;&#160;getInt(argv[1], GN_GT_0, "num-pages") * pageSize;<br/>&#160;&#160;&#160;&#160;stepSize = getInt(argv[2], GN_GT_0, "lock-page-step") * pageSize;<br/>&#160;&#160;&#160;&#160;lockLen =&#160;&#160;getInt(argv[3], GN_GT_0, "lock-page-len") * pageSize;<br/><br/>&#160;&#160;&#160;&#160;addr = mmap(NULL, len, PROT_READ, MAP_SHARED | MAP_ANONYMOUS, -1, 0);<br/>&#160;&#160;&#160;&#160;if (addr == MAP_FAILED)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mmap");<br/><br/>&#160;&#160;&#160;&#160;printf("Allocated %ld (%#lx) bytes starting at %p\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) len, (unsigned long) len, addr);<br/><br/>&#160;&#160;&#160;&#160;printf("Before mlock:\n");<br/>&#160;&#160;&#160;&#160;displayMincore(addr, len);<br/><br/>&#160;&#160;&#160;&#160;/* Lock pages specified by command line arguments into memory */<br/><br/>&#160;&#160;&#160;&#160;for (j = 0; j + lockLen &lt;= len; j += stepSize)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (mlock(addr + j, lockLen) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mlock");<br/><br/>&#160;&#160;&#160;&#160;printf("After mlock:\n");<br/>&#160;&#160;&#160;&#160;displayMincore(addr, len);<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>___________________________________________________________ <span class="codestrong">vmem/memlock.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_1054"/>The following shell session shows a sample run of the program in <a href="ch50.xhtml#ch50ex2">Listing 50-2</a>. In this example, we allocate 32 pages, and in each group of 8 pages, we lock 3 consecutive pages:</p>
<p class="programs">$ <span class="codestrong">su</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Assume privilege</span><br/>Password:<br/># <span class="codestrong">./memlock 32 8 3</span><br/>Allocated 131072 (0x20000) bytes starting at 0x4014a000<br/>Before mlock:<br/>0x4014a000: ................................<br/>After mlock:<br/>0x4014a000: ***.....***.....***.....***.....</p>
<p class="noindent">In the program output, dots represent pages that are not resident in memory, and asterisks represent pages that are resident in memory. As we can see from the final line of output, 3 out of each group of 8 pages are memory-resident.</p>
<p class="indent">In this example, we assumed superuser privilege so that the program can use <em>mlock()</em>. This is not necessary in Linux 2.6.9 and later if the amount of memory to be locked falls within the <span class="literal">RLIMIT_MEMLOCK</span> soft resource limit.</p>
<h3 class="h3" id="ch50lev1sec04"><strong>50.4 Advising Future Memory Usage Patterns: <em>madvise()</em></strong></h3>
<p class="noindenta">The <em>madvise()</em> system call is used to improve the performance of an application by informing the kernel about the calling process&#8217;s likely usage of the pages in the range starting at <em>addr</em> and continuing for <em>length</em> bytes. The kernel may use this information to improve the efficiency of I/O performed on the file mapping that underlies the pages. (See <a href="ch49.xhtml#ch49lev1sec04">Section 49.4</a> for a discussion of file mappings.) On Linux, <em>madvise()</em> has been available since kernel 2.4.</p>
<div class="box">
<p class="programsa">#define _BSD_SOURCE<br/>#include &lt;sys/mman.h&gt;<br/><br/>int <span class="codestrong">madvise</span>(void *<span class="font1">addr</span>, size_t <span class="font1">length</span>, int <span class="font1">advice</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb">The value specified in <em>addr</em> must be page-aligned, and <em>length</em> is effectively rounded up to the next multiple of the system page size. The <em>advice</em> argument is one of the following:</p>
<p class="term"><span class="literal">MADV_NORMAL</span></p>
<p class="termlist">This is the default behavior. Pages are transferred in clusters (a small multiple of the system page size). This results in some read-ahead and read-behind.</p>
<p class="term"><span class="literal">MADV_RANDOM</span></p>
<p class="termlist">Pages in this region will be accessed randomly, so read-ahead will yield no benefit. Thus, the kernel should fetch the minimum amount of data on each read.</p>
<p class="term"><span epub:type="pagebreak" id="page_1055"/><span class="literal">MADV_SEQUENTIAL</span></p>
<p class="termlist">Pages in this range will be accessed once, sequentially. Thus, the kernel can aggressively read ahead, and pages can be quickly freed after they have been accessed.</p>
<p class="term"><span class="literal">MADV_WILLNEED</span></p>
<p class="termlist">Read pages in this region ahead, in preparation for future access. The <span class="literal">MADV_WILLNEED</span> operation has an effect similar to the Linux-specific <em>readahead()</em> system call and the <em>posix_fadvise()</em> <span class="literal">POSIX_FADV_WILLNEED</span> operation.</p>
<p class="term"><span class="literal">MADV_DONTNEED</span></p>
<p class="termlist">The calling process no longer requires the pages in this region to be memory-resident. The precise effect of this flag varies across UNIX implementations. We first note the behavior on Linux. For a <span class="literal">MAP_PRIVATE</span> region, the mapped pages are explicitly discarded, which means that modifications to the pages are lost. The virtual memory address range remains accessible, but the next access of each page will result in a page fault reinitializing the page, either with the contents of the file from which it is mapped or with zeros in the case of an anonymous mapping. This can be used as a means of explicitly reinitializing the contents of a <span class="literal">MAP_PRIVATE</span> region. For a <span class="literal">MAP_SHARED</span> region, the kernel <em>may</em> discard modified pages in some circumstances, depending on the architecture (this behavior doesn&#8217;t occur on x86). Some other UNIX implementations also behave in the same way as Linux. However, on some UNIX implementations, <span class="literal">MADV_DONTNEED</span> simply informs the kernel that the specified pages can be swapped out if necessary. Portable applications should not rely on the Linux&#8217;s destructive semantics for <span class="literal">MADV_DONTNEED</span>.</p>
<div class="block">
<p class="noindent">Linux 2.6.16 added three new nonstandard <em>advice</em> values: <span class="literal">MADV_DONTFORK</span>, <span class="literal">MADV_DOFORK</span>, and <span class="literal">MADV_REMOVE</span>. Linux 2.6.32 and 2.6.33 added another four nonstandard <em>advice</em> values: <span class="literal">MADV_HWPOISON</span>, <span class="literal">MADV_SOFT_OFFLINE</span>, <span class="literal">MADV_MERGEABLE</span>, and <span class="literal">MADV_UNMERGEABLE</span>. These values are used in special circumstances and are described in the <em>madvise(2)</em> manual page.</p>
</div>
<p class="noindent">Most UNIX implementations provide a version of <em>madvise()</em>, typically allowing at least the <em>advice</em> constants described above. However, SUSv3 standardizes this API under a different name, <em>posix_madvise()</em>, and prefixes the corresponding <em>advice</em> constants with the string <span class="literal">POSIX_</span>. Thus, the constants are <span class="literal">POSIX_MADV_NORMAL</span>, <span class="literal">POSIX_MADV_RANDOM</span>, <span class="literal">POSIX_MADV_SEQUENTIAL</span>, <span class="literal">POSIX_MADV_WILLNEED</span>, and <span class="literal">POSIX_MADV_DONTNEED</span>. This alternative interface is implemented in <em>glibc</em> (version 2.2 and later) by calls to <em>madvise()</em>, but it is not available on all UNIX implementations.</p>
<div class="block">
<p class="noindent">SUSv3 says that <em>posix_madvise()</em> should not affect the semantics of a program. However, in <em>glibc</em> versions before 2.6, the <span class="literal">POSIX_MADV_DONTNEED</span> operation is implemented using <em>madvise()</em> <span class="literal">MADV_DONTNEED</span>, which does affect the semantics of a program, as described earlier. Since <em>glibc</em> 2.6, the <em>posix_madvise()</em> wrapper implements <span class="literal">POSIX_MADV_DONTNEED</span> to do nothing, so that it does not affect the semantics of a program.</p>
</div>
<h3 class="h3" id="ch50lev1sec05"><span epub:type="pagebreak" id="page_1056"/><strong>50.5 Summary</strong></h3>
<p class="noindentab">In this chapter, we considered various operations that can be performed on a process&#8217;s virtual memory:</p>
<p class="bull">&#8226; The <em>mprotect()</em> system call changes the protection on a region of virtual memory.</p>
<p class="bull">&#8226; The <em>mlock()</em> and <em>mlockall()</em> system calls lock part or all of a process&#8217;s virtual address space, respectively, into physical memory.</p>
<p class="bull">&#8226; The <em>mincore()</em> system call reports which pages in a virtual memory region are currently resident in physical memory.</p>
<p class="bull">&#8226; The <em>madvise()</em> system call and the <em>posix_madvise()</em> function allow a process to advise the kernel about the process&#8217;s expected patterns of memory use.</p>
<h3 class="h3" id="ch50lev1sec06"><strong>50.6 Exercises</strong></h3>
<p class="exer"><a id="ch50exe1"/><strong>50-1.</strong>&#160;&#160;&#160;Verify the effect of the <span class="literal">RLIMIT_MEMLOCK</span> resource limit by writing a program that sets a value for this limit and then attempts to lock more memory than the limit.</p>
<p class="exer"><a id="ch50exe2"/><strong>50-2.</strong>&#160;&#160;&#160;Write a program to verify the operation of the <em>madvise()</em> <span class="literal">MADV_DONTNEED</span> operation for a writable <span class="literal">MAP_PRIVATE</span> mapping.</p>
</body>
</html>
