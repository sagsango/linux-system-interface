<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch32"><span epub:type="pagebreak" id="page_671"/><strong><span class="big">32</span></strong><br/><strong>THREADS: THREAD CANCELLATION</strong></h2>
<p class="noindenta">Typically, multiple threads execute in parallel, with each thread performing its task until it decides to terminate by calling <em>pthread_exit()</em> or returning from the thread&#8217;s start function.</p>
<p class="indent">Sometimes, it can be useful to <em>cancel</em> a thread; that is, to send it a request asking it to terminate now. This could be useful, for example, if a group of threads is performing a calculation, and one thread detects an error condition that requires the other threads to terminate. Alternatively, a GUI-driven application may provide a cancel button to allow the user to terminate a task that is being performed by a thread in the background; in this case, the main thread (controlling the GUI) needs to tell the background thread to terminate.</p>
<p class="indent">In this chapter, we describe the POSIX threads cancellation mechanism.</p>
<h3 class="h3" id="ch32lev1sec01"><strong>32.1 Canceling a Thread</strong></h3>
<p class="noindenta">The <em>pthread_cancel()</em> function sends a cancellation request to the specified <em>thread</em>.</p>
<div class="box">
<p class="programsa">#include &lt;pthread.h&gt;<br/><br/>int <span class="codestrong">pthread_cancel</span>(pthread_t <span class="font1">thread</span>);</p>
<p class="right">Returns 0 on success, or a positive error number on error</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_672"/>Having made the cancellation request, <em>pthread_cancel()</em> returns immediately; that is, it doesn&#8217;t wait for the target thread to terminate.</p>
<p class="indent">Precisely what happens to the target thread, and when it happens, depends on that thread&#8217;s cancellation state and type, as described in the next section.</p>
<h3 class="h3" id="ch32lev1sec02"><strong>32.2 Cancellation State and Type</strong></h3>
<p class="noindenta">The <em>pthread_setcancelstate()</em> and <em>pthread_setcanceltype()</em> functions set flags that allow a thread to control how it responds to a cancellation request.</p>
<div class="box">
<p class="programsa">#include &lt;pthread.h&gt;<br/><br/>int <span class="codestrong">pthread_setcancelstate</span>(int <span class="font1">state</span>, int *<span class="font1">oldstate</span>);<br/>int <span class="codestrong">pthread_setcanceltype</span>(int <span class="font1">type</span>, int *<span class="font1">oldtype</span>);</p>
<p class="right">Both return 0 on success, or a positive error number on error</p>
</div>
<p class="noindentb">The <em>pthread_setcancelstate()</em> function sets the calling thread&#8217;s cancelability state to the value given in <em>state</em>. This argument has one of the following values:</p>
<p class="term"><span class="literal">PTHREAD_CANCEL_DISABLE</span></p>
<p class="termlist">The thread is not cancelable. If a cancellation request is received, it remains pending until cancelability is enabled.</p>
<p class="term"><span class="literal">PTHREAD_CANCEL_ENABLE</span></p>
<p class="termlist">The thread is cancelable. This is the default cancelability state in newly created threads.</p>
<p class="noindentt">The thread&#8217;s previous cancelability state is returned in the location pointed to by <em>oldstate</em>.</p>
<div class="block">
<p class="noindent">If we are not interested in the previous cancelability state, Linux allows <em>oldstate</em> to be specified as <span class="literal">NULL</span>. This is the case on many other implementations as well; however, SUSv3 doesn&#8217;t specify this feature, so portable applications can&#8217;t rely on it. We should always specify a non-<span class="literal">NULL</span> value for <em>oldstate</em>.</p>
</div>
<p class="noindent">Temporarily disabling cancellation (<span class="literal">PTHREAD_CANCEL_DISABLE</span>) is useful if a thread is executing a section of code where <em>all</em> of the steps must be completed.</p>
<p class="indentb">If a thread is cancelable (<span class="literal">PTHREAD_CANCEL_ENABLE</span>), then the treatment of a cancellation request is determined by the thread&#8217;s cancelability type, which is specified by the <em>type</em> argument in a call to <em>pthread_setcanceltype()</em>. This argument has one of the following values:</p>
<p class="term"><span class="literal">PTHREAD_CANCEL_ASYNCHRONOUS</span></p>
<p class="termlist">The thread may be canceled at any time (perhaps, but not necessarily, immediately). Asynchronous cancelability is rarely useful, and we defer discussion of it until <a href="ch32.xhtml#ch32lev1sec06">Section 32.6</a>.</p>
<p class="term"><span class="literal">PTHREAD_CANCEL_DEFERRED</span></p>
<p class="termlist">The cancellation remains pending until a cancellation point (see the next section) is reached. This is the default cancelability type in newly created threads. We say more about deferred cancelability in the following sections.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_673"/>The thread&#8217;s previous cancelability type is returned in the location pointed to by <em>oldtype</em>.</p>
<div class="block">
<p class="noindent">As with the <em>pthread_setcancelstate() oldstate</em> argument, many implementations, including Linux, allow <em>oldtype</em> to be specified as <span class="literal">NULL</span> if we are not interested in the previous cancelability type. Again, SUSv3 doesn&#8217;t specify this feature, and portable applications can&#8217;t rely on it We should always specify a non-<span class="literal">NULL</span> value for <em>oldtype</em>.</p>
</div>
<p class="noindent">When a thread calls <em>fork()</em>, the child inherits the calling thread&#8217;s cancelability type and state. When a thread calls <em>exec()</em>, the cancelability state and type of the main thread of the new program are reset to <span class="literal">PTHREAD_CANCEL_ENABLE</span> and <span class="literal">PTHREAD_CANCEL_DEFERRED</span>, respectively.</p>
<h3 class="h3" id="ch32lev1sec03"><strong>32.3 Cancellation Points</strong></h3>
<p class="noindenta">When cancelability is enabled and deferred, a cancellation request is acted upon only when a thread next reaches a <em>cancellation point</em>. A cancellation point is a call to one of a set of functions defined by the implementation.</p>
<p class="indent">SUSv3 specifies that the functions shown in <a href="ch32.xhtml#ch32table1">Table 32-1</a> <em>must</em> be cancellation points if they are provided by an implementation. Most of these are functions that are capable of blocking the thread for an indefinite period of time.</p>
<p class="tablecap"><a id="ch32table1"/><strong>Table 32-1:</strong> Functions required to be cancellation points by SUSv3</p>
<table class="all">
<tbody>
<tr>
<td style="vertical-align: top;" class="table_3a"><p class="table"><em>accept()</em><br/><em>aio_suspend()</em><br/><em>clock_nanosleep()</em><br/><em>close()</em><br/><em>connect()</em><br/><em>creat()</em><br/><em>fcntl(F_SETLKW)</em><br/><em>fsync()</em><br/><em>fdatasync()</em><br/><em>getmsg()</em><br/><em>getpmsg()</em><br/><em>lockf(F_LOCK)</em><br/><em>mq_receive()</em><br/><em>mq_send()</em><br/><em>mq_timedreceive()</em><br/><em>mq_timedsend()</em><br/><em>msgrcv()</em><br/><em>msgsnd()</em><br/><em>msync()</em><br/><em>nanosleep()</em><br/><em>open()</em><br/><em>pause()</em><br/><em>poll()</em><br/><em>pread()</em><br/><em>pselect()</em><br/><em>pthread_cond_timedwait()</em><br/><em>pthread_cond_wait()</em><br/><em>pthread_join()</em><br/><em>pthread_testcancel()</em><br/><em>putmsg()</em><br/><em>putpmsg()</em><br/><em>pwrite()</em><br/><em>read()</em><br/><em>readv()</em><br/><em>recv()</em><br/><em>recvfrom()</em><br/><em>recvmsg()</em><br/><em>select()</em><br/><em>sem_timedwait()</em><br/><em>sem_wait()</em><br/><em>send()</em><br/><em>sendmsg()</em><br/><em>sendto()</em><br/><em>sigpause()</em><br/><em>sigsuspend()</em><br/><em>sigtimedwait()</em><br/><em>sigwait()</em><br/><em>sigwaitinfo()</em><br/><em>sleep()</em><br/><em>system()</em><br/><em>tcdrain()</em><br/><em>usleep()</em><br/><em>wait()</em><br/><em>waitid()</em><br/><em>waitpid()</em><br/><em>write()</em><br/><em>writev()</em></p></td>
</tr>
</tbody>
</table>
<p class="noindent">In addition to the functions in <a href="ch32.xhtml#ch32table1">Table 32-1</a>, SUSv3 specifies a larger group of functions that an implementation <em>may</em> define as cancellation points. These include the <em>stdio</em> functions, the <em>dlopen</em> API, the <em>syslog</em> API, <em>nftw()</em>, <em>popen()</em>, <em>semop()</em>, <em>unlink()</em>, and <span epub:type="pagebreak" id="page_674"/>various functions that retrieve information from system files such as the <em>utmp</em> file. A portable program must correctly handle the possibility that a thread may be canceled when calling these functions.</p>
<p class="indent">SUSv3 specifies that aside from the two lists of functions that must and may be cancellation points, none of the other functions in the standard may act as cancellation points (i.e., a portable program doesn&#8217;t need to handle the possibility that calling these other functions could precipitate thread cancellation).</p>
<p class="indent">SUSv4 adds <em>openat()</em> to the list of functions that must be cancellation points, and removes <em>sigpause()</em> (it moves to the list of functions that <em>may</em> be cancellation points) and <em>usleep()</em> (which is dropped from the standard).</p>
<div class="block">
<p class="noindent">An implementation is free to mark additional functions that are not specified in the standard as cancellation points. Any function that might block (perhaps because it might access a file) is a likely candidate to be a cancellation point. Within <em>glibc</em>, many nonstandard functions are marked as cancellation points for this reason.</p>
</div>
<p class="noindent">Upon receiving a cancellation request, a thread whose cancelability is enabled and deferred terminates when it next reaches a cancellation point. If the thread was not detached, then some other thread in the process must join with it, in order to prevent it from becoming a zombie thread. When a canceled thread is joined, the value returned in the second argument to <em>pthread_join()</em> is a special thread return value: <span class="literal">PTHREAD_CANCELED</span>.</p>
<h5 class="h5" id="ch32lev3sec01"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch32.xhtml#ch32ex1">Listing 32-1</a> shows a simple example of the use of <em>pthread_cancel()</em>. The main program creates a thread that executes an infinite loop, sleeping for a second and printing the value of a loop counter. (This thread will terminate only if it is sent a cancellation request or if the process exits.) Meanwhile, the main program sleeps for 3 seconds, and then sends a cancellation request to the thread that it created. When we run this program, we see the following:</p>
<p class="programs">$ <span class="codestrong">./thread_cancel</span><br/>New thread started<br/>Loop 1<br/>Loop 2<br/>Loop 3<br/>Thread was canceled</p>
<p class="examplet"><a id="ch32ex1"/><strong>Listing 32-1:</strong> Canceling a thread with <em>pthread_cancel()</em></p>
<p class="programsli">___________________________________________________ <span class="codestrong">threads/thread_cancel.c</span><br/><br/>#include &lt;pthread.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static void *<br/>threadFunc(void *arg)<br/>{<br/>&#160;&#160;&#160;&#160;int j;<br/>&#160;&#160;&#160;&#160;printf("New thread started\n");&#160;&#160;&#160;&#160;/* May be a cancellation point */<br/>&#160;&#160;&#160;&#160;for (j = 1; ; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Loop %d\n", j);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* May be a cancellation point */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep(1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* A cancellation point */<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;/* NOTREACHED */<br/>&#160;&#160;&#160;&#160;return NULL;<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;pthread_t thr;<br/>&#160;&#160;&#160;&#160;int s;<br/>&#160;&#160;&#160;&#160;void *res;<br/><br/>&#160;&#160;&#160;&#160;s = pthread_create(&#38;thr, NULL, threadFunc, NULL);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_create");<br/><br/>&#160;&#160;&#160;&#160;sleep(3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allow new thread to run a while */<br/><br/>&#160;&#160;&#160;&#160;s = pthread_cancel(thr);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_cancel");<br/><br/>&#160;&#160;&#160;&#160;s = pthread_join(thr, &#38;res);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_join");<br/><br/>&#160;&#160;&#160;&#160;if (res == PTHREAD_CANCELED)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Thread was canceled\n");<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Thread was not canceled (should not happen!)\n");<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>___________________________________________________ <span class="codestrong">threads/thread_cancel.c</span></p>
<h3 class="h3" id="ch32lev1sec04"><span epub:type="pagebreak" id="page_675"/><strong>32.4 Testing for Thread Cancellation</strong></h3>
<p class="noindenta">In <a href="ch32.xhtml#ch32ex1">Listing 32-1</a>, the thread created by <em>main()</em> accepted the cancellation request because it executed a function that was a cancellation point (<em>sleep()</em> is a cancellation point; <em>printf()</em> may be one). However, suppose a thread executes a loop that contains no cancellation points (e.g., a compute-bound loop). In this case, the thread would never honor the cancellation request.</p>
<p class="indent">The purpose of <em>pthread_testcancel()</em> is simply to be a cancellation point. If a cancellation is pending when this function is called, then the calling thread is terminated.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_676"/>#include &lt;pthread.h&gt;<br/><br/>void <span class="codestrong">pthread_testcancel</span>(void);</p>
</div>
<p class="noindent">A thread that is executing code that does not otherwise include cancellation points can periodically call <em>pthread_testcancel()</em> to ensure that it responds in a timely fashion to a cancellation request sent by another thread.</p>
<h3 class="h3" id="ch32lev1sec05"><strong>32.5 Cleanup Handlers</strong></h3>
<p class="noindenta">If a thread with a pending cancellation were simply terminated when it reached a cancellation point, then shared variables and Pthreads objects (e.g., mutexes) might be left in an inconsistent state, perhaps causing the remaining threads in the process to produce incorrect results, deadlock, or crash. To get around this problem, a thread can establish one or more <em>cleanup handlers</em>&#8212;functions that are automatically executed if the thread is canceled. A cleanup handler can perform tasks such as modifying the values of global variables and unlocking mutexes before the thread is terminated.</p>
<p class="indent">Each thread can have a stack of cleanup handlers. When a thread is canceled, the cleanup handlers are executed working down from the top of the stack; that is, the most recently established handler is called first, then the next most recently established, and so on. When all of the cleanup handlers have been executed, the thread terminates.</p>
<p class="indent">The <em>pthread_cleanup_push()</em> and <em>pthread_cleanup_pop()</em> functions respectively add and remove handlers on the calling thread&#8217;s stack of cleanup handlers.</p>
<div class="box">
<p class="programsa">#include &lt;pthread.h&gt;<br/><br/>void <span class="codestrong">pthread_cleanup_push</span>(void (*<span class="font1">routine</span>)(void*), void *<span class="font1">arg</span>);<br/>void <span class="codestrong">pthread_cleanup_pop</span>(int <span class="font1">execute</span>);</p>
</div>
<p class="noindent">The <em>pthread_cleanup_push()</em> function adds the function whose address is specified in <em>routine</em> to the top of the calling thread&#8217;s stack of cleanup handlers. The <em>routine</em> argument is a pointer to a function that has the following form:</p>
<p class="programs">void<br/>routine(void *arg)<br/>{<br/>&#160;&#160;&#160;&#160;/* Code to perform cleanup */<br/>}</p>
<p class="noindent">The <em>arg</em> value given to <em>pthread_cleanup_push()</em> is passed as the argument of the cleanup handler when it is invoked. This argument is typed as <em>void *</em>, but, using judicious casting, other data types can be passed in this argument.</p>
<p class="indent">Typically, a cleanup action is needed only if a thread is canceled during the execution of a particular section of code. If the thread reaches the end of that section without being canceled, then the cleanup action is no longer required. Thus, each <span epub:type="pagebreak" id="page_677"/>call to <em>pthread_cleanup_push()</em> has an accompanying call to <em>pthread_cleanup_pop()</em>. This function removes the topmost function from the stack of cleanup handlers. If the <em>execute</em> argument is nonzero, the handler is also executed. This is convenient if we want to perform the cleanup action even if the thread was not canceled.</p>
<p class="indent">Although we have described <em>pthread_cleanup_push()</em> and <em>pthread_cleanup_pop()</em> as functions, SUSv3 permits them to be implemented as macros that expand to statement sequences that include an opening (<span class="literal">{</span>) and closing (<span class="literal">}</span>) brace, respectively. Not all UNIX implementations do things this way, but Linux and many others do. This means that each use of <em>pthread_cleanup_push()</em> must be paired with exactly one corresponding <em>pthread_cleanup_pop()</em> in the same lexical block. (On implementations that do things this way, variables declared between the <em>pthread_cleanup_push()</em> and <em>pthread_cleanup_pop()</em> will be limited to that lexical scope.) For example, it is not correct to write code such as the following:</p>
<p class="programs">pthread_cleanup_push(func, arg);<br/>...<br/>if (cond) {<br/>&#160;&#160;&#160;&#160;pthread_cleanup_pop(0);<br/>}</p>
<p class="noindent">As a coding convenience, any cleanup handlers that have not been popped are also executed automatically if a thread terminates by calling <em>pthread_exit()</em> (but not if it does a simple <span class="literal">return</span>).</p>
<h5 class="h5" id="ch32lev3sec02"><strong>Example program</strong></h5>
<p class="noindenta">The program in <a href="ch32.xhtml#ch32ex2">Listing 32-2</a> provides a simple example of the use of a cleanup handler. The main program creates a thread <span class="ent">&#x2467;</span> whose first actions are to allocate a block of memory <span class="ent">&#x2462;</span> whose location is stored in <em>buf</em>, and then lock the mutex <em>mtx</em> <span class="ent">&#x2463;</span>. Since the thread may be canceled, it uses <em>pthread_cleanup_push()</em> <span class="ent">&#x2464;</span> to install a cleanup handler that is called with the address stored in <em>buf</em>. If it is invoked, the cleanup handler deallocates the freed memory <span class="ent">&#x2460;</span> and unlocks the mutex <span class="ent">&#x2461;</span>.</p>
<p class="indentb">The thread then enters a loop waiting for the condition variable <em>cond</em> to be signaled <span class="ent">&#x2465;</span>. This loop will terminate in one of two ways, depending on whether the program is supplied with a command-line argument:</p>
<p class="bull">&#8226; If no command-line argument is supplied, the thread is canceled by <em>main()</em> <span class="ent">&#x2468;</span>. In this case, cancellation will occur at the call to <em>pthread_cond_wait()</em> <span class="ent">&#x2465;</span>, which is one of the cancellation points shown in <a href="ch32.xhtml#ch32table1">Table 32-1</a>. As part of cancellation, the cleanup handler established using <em>pthread_cleanup_push()</em> is invoked automatically. (When a <em>pthread_cond_wait()</em> call is canceled, the mutex is automatically relocked before the cleanup handler is invoked. This means the mutex can be safely unlocked in the cleanup handler.)</p>
<p class="bull">&#8226; If a command-line argument is supplied, the condition variable is signaled <span class="ent">&#x2469;</span> after the associated global variable, <em>glob</em>, is first set to a nonzero value. In this case, the thread falls through to execute <em>pthread_cleanup_pop()</em> <span class="ent">&#x2466;</span>, which, given a nonzero argument, also causes the cleanup handler to be invoked.</p>
<p class="noindentt">The main program joins with the terminated thread <span class="ent">&#x246A;</span>, and reports whether the thread was canceled or terminated normally.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_678"/><a id="ch32ex2"/><strong>Listing 32-2:</strong> Using cleanup handlers</p>
<p class="programsli">__________________________________________________ <span class="codestrong">threads/thread_cleanup.c</span><br/><br/>&#160;&#160;&#160;#include &lt;pthread.h&gt;<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;<br/>&#160;&#160;&#160;static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;<br/>&#160;&#160;&#160;static int glob = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Predicate variable */<br/><br/>&#160;&#160;&#160;static void&#160;&#160;&#160;&#160;&#160;/* Free memory pointed to by 'arg' and unlock mutex */<br/>&#160;&#160;&#160;cleanupHandler(void *arg)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int s;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("cleanup: freeing block at %p\n", arg);<br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;free(arg);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("cleanup: unlocking mutex\n");<br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;s = pthread_mutex_unlock(&#38;mtx);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_unlock");<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;static void *<br/>&#160;&#160;&#160;threadFunc(void *arg)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int s;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;void *buf = NULL&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Buffer allocated by thread */<br/><br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;buf = malloc(0x10000);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Not a cancellation point */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("thread: allocated memory at %p\n", buf);<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;s = pthread_mutex_lock(&#38;mtx);&#160;&#160;&#160;&#160;&#160;&#160;/* Not a cancellation point */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_lock");<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;pthread_cleanup_push(cleanupHandler, buf);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (glob == 0) {<br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_cond_wait(&#38;cond, &#38;mtx);&#160;&#160;&#160;&#160;/* A cancellation point */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_cond_wait");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("thread: condition wait loop completed\n");<br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;pthread_cleanup_pop(1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Executes cleanup handler */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;return NULL;<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;pthread_t thr;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;void *res;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int s;<br/><br/><span class="ent">&#x2467;</span>&#160;&#160;&#160;&#160;&#160;s = pthread_create(&#38;thr, NULL, threadFunc, NULL);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_create");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep(2);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Give thread a chance to get started */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc == 1) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Cancel thread */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("main:&#160;&#160;&#160;&#160;about to cancel thread\n");<br/><span class="ent">&#x2468;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_cancel(thr);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_cancel");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Signal condition variable */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("main:&#160;&#160;&#160;&#160;about to signal condition variable\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;glob = 1;<br/><span class="ent">&#x2469;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_cond_signal(&#38;cond);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_cond_signal");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/><span class="ent">&#x246A;</span>&#160;&#160;&#160;&#160;&#160;s = pthread_join(thr, &#38;res);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_join");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (res == PTHREAD_CANCELED)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("main:&#160;&#160;&#160;&#160;thread was canceled\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("main:&#160;&#160;&#160;&#160;thread terminated normally\n");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;}<br/>__________________________________________________ <span class="codestrong">threads/thread_cleanup.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_679"/>If we invoke the program in <a href="ch32.xhtml#ch32ex2">Listing 32-2</a> without any command-line arguments, then <em>main()</em> calls <em>pthread_cancel()</em>, the cleanup handler is invoked automatically, and we see the following:</p>
<p class="programs">$ .<span class="codestrong">/thread_cleanup</span><br/>thread:&#160;&#160;allocated memory at 0x804b050<br/>main:&#160;&#160;&#160;&#160;about to cancel thread<br/>cleanup: freeing block at 0x804b050<br/>cleanup: unlocking mutex<br/>main:&#160;&#160;&#160;&#160;thread was canceled</p>
<p class="noindent">If we invoke the program with a command-line argument, then <em>main()</em> sets <em>glob</em> to 1 and signals the condition variable, the cleanup handler is invoked by <em>pthread_cleanup_pop()</em>, and we see the following:</p>
<p class="programs">$ <span class="codestrong">./thread_cleanup s</span><br/>thread:&#160;&#160;allocated memory at 0x804b050<br/>main:&#160;&#160;&#160;&#160;about to signal condition variable<br/>thread:&#160;&#160;condition wait loop completed<br/>cleanup: freeing block at 0x804b050<br/>cleanup: unlocking mutex<br/>main:&#160;&#160;&#160;&#160;thread terminated normally</p>
<h3 class="h3" id="ch32lev1sec06"><span epub:type="pagebreak" id="page_680"/><strong>32.6 Asynchronous Cancelability</strong></h3>
<p class="noindenta">When a thread is made asynchronously cancelable (cancelability type <span class="literal">PTHREAD_CANCEL_ASYNCHRONOUS</span>), it may be canceled at any time (i.e., at any machine-language instruction); delivery of a cancellation is not held off until the thread next reaches a cancellation point.</p>
<p class="indent">The problem with asynchronous cancellation is that, although cleanup handlers are still invoked, the handlers have no way of determining the state of a thread. In the program in <a href="ch32.xhtml#ch32ex2">Listing 32-2</a>, which employs the deferred cancelability type, the thread can be canceled only when it executes the call to <em>pthread_cond_wait()</em>, which is the only cancellation point. By this time, we know that <em>buf</em> has been initialized to point to a block of allocated memory and that the mutex <em>mtx</em> has been locked. However, with asynchronous cancelability, the thread could be canceled at any point; for example, before the <em>malloc()</em> call, between the <em>malloc()</em> call and locking the mutex, or after locking the mutex. The cleanup handler has no way of knowing where cancellation has occurred, or precisely which cleanup steps are required. Furthermore, the thread might even be canceled <em>during</em> the <em>malloc()</em> call, after which chaos is likely to result (<a href="ch07.xhtml#ch07lev2sec03">Section 7.1.3</a>).</p>
<p class="indent">As a general principle, an asynchronously cancelable thread can&#8217;t allocate any resources or acquire any mutexes, semaphores, or locks. This precludes the use of a wide range of library functions, including most of the Pthreads functions. (SUSv3 makes exceptions for <em>pthread_cancel()</em>, <em>pthread_setcancelstate()</em>, and <em>pthread_setcanceltype()</em>, which are explicitly required to be <em>async-cancel-safe</em>; that is, an implementation must make them safe to call from a thread that is asynchronously cancelable.) In other words, there are few circumstances where asynchronous cancellation is useful. One such circumstance is canceling a thread that is in a compute-bound loop.</p>
<h3 class="h3" id="ch32lev1sec07"><strong>32.7 Summary</strong></h3>
<p class="noindenta">The <em>pthread_cancel()</em> function allows one thread to send another thread a cancellation request, which is a request that the target thread should terminate.</p>
<p class="indent">How the target thread reacts to this request is determined by its cancelability state and type. If the cancelability state is currently set to disabled, the request will remain pending until the cancelability state is set to enabled. If cancelability is enabled, the cancelability type determines when the target thread reacts to the request. If the type is deferred, the cancellation occurs when the thread next calls one of a number of functions specified as cancellation points by SUSv3. If the type is asynchronous, cancellation may occur at any time (this is rarely useful).</p>
<p class="indent">A thread can establish a stack of cleanup handlers, which are programmer-defined functions that are invoked automatically to perform cleanups (e.g., restoring the states of shared variables, or unlocking mutexes) if the thread is canceled.</p>
<h5 class="h5" id="ch32lev3sec03"><strong>Further information</strong></h5>
<p class="noindenta">Refer to the sources of further information listed in <a href="ch29.xhtml#ch29lev1sec10">Section 29.10</a>.</p>
</body>
</html>
