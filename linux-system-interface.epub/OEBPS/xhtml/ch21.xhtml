<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch21"><span epub:type="pagebreak" id="page_421"/><strong><span class="big">21</span></strong><br/><strong>SIGNALS: SIGNAL HANDLERS</strong></h2>
<p class="noindentab">This chapter continues the description of signals begun in the previous chapter. It focuses on signal handlers, and extends the discussion started in <a href="ch20.xhtml#ch20lev1sec04">Section 20.4</a>. Among the topics we consider are the following:</p>
<p class="bull">&#8226; how to design a signal handler, which necessitates a discussion of reentrancy and async-signal-safe functions;</p>
<p class="bull">&#8226; alternatives to performing a normal return from a signal handler, in particular, the use of a nonlocal goto for this purpose;</p>
<p class="bull">&#8226; handling of signals on an alternate stack;</p>
<p class="bull">&#8226; the use of the <em>sigaction()</em> <span class="literal">SA_SIGINFO</span> flag to allow a signal handler to obtain more detailed information about the signal that caused its invocation; and</p>
<p class="bull">&#8226; how a blocking system call may be interrupted by a signal handler, and how the call can be restarted if desired.</p>
<h3 class="h3" id="ch21lev1sec01"><span epub:type="pagebreak" id="page_422"/><strong>21.1 Designing Signal Handlers</strong></h3>
<p class="noindentab">In general, it is preferable to write simple signal handlers. One important reason for this is to reduce the risk of creating race conditions. Two common designs for signal handlers are the following:</p>
<p class="bull">&#8226; The signal handler sets a global flag and exits. The main program periodically checks this flag and, if it is set, takes appropriate action. (If the main program cannot perform such periodic checks because it needs to monitor one or more file descriptors to see if I/O is possible, then the signal handler can also write a single byte to a dedicated pipe whose read end is included among the file descriptors monitored by the main program. We show an example of this technique in <a href="ch63.xhtml#ch63lev2sec17">Section 63.5.2</a>.)</p>
<p class="bull">&#8226; The signal handler performs some type of cleanup and then either terminates the process or uses a nonlocal goto (<a href="ch21.xhtml#ch21lev2sec04">Section 21.2.1</a>) to unwind the stack and return control to a predetermined location in the main program.</p>
<p class="noindentt">In the following sections, we explore these ideas, as well as other concepts that are important in the design of signal handlers.</p>
<h4 class="h4" id="ch21lev2sec01"><strong>21.1.1 Signals Are Not Queued (Revisited)</strong></h4>
<p class="noindenta">In <a href="ch20.xhtml#ch20lev1sec10">Section 20.10</a>, we noted that delivery of a signal is blocked during the execution of its handler (unless we specify the <span class="literal">SA_NODEFER</span> flag to <em>sigaction()</em>). If the signal is (again) generated while the handler is executing, then it is marked as pending and later delivered when the handler returns. We also already noted that signals are not queued. If the signal is generated more than once while the handler is executing, then it is still marked as pending, and it will later be delivered only once.</p>
<p class="indent">That signals can &#8220;disappear&#8221; in this way has implications for how we design signal handlers. To begin with, we can&#8217;t reliably count the number of times a signal is generated. Furthermore, we may need to code our signal handlers to deal with the possibility that multiple events of the type corresponding to the signal have occurred. We&#8217;ll see an example of this when we consider the use of the <span class="literal">SIGCHLD</span> signal in <a href="ch26.xhtml#ch26lev2sec07">Section 26.3.1</a>.</p>
<h4 class="h4" id="ch21lev2sec02"><strong>21.1.2 Reentrant and Async-Signal-Safe Functions</strong></h4>
<p class="noindenta">Not all system calls and library functions can be safely called from a signal handler. To understand why requires an explanation of two concepts: reentrant functions and async-signal-safe functions.</p>
<h5 class="h5" id="ch21lev3sec01"><strong>Reentrant and nonreentrant functions</strong></h5>
<p class="noindenta">To explain what a reentrant function is, we need to first distinguish between single-threaded and multithreaded programs. Classical UNIX programs have a single <em>thread of execution</em>: the CPU processes instructions for a single logical flow of execution through the program. In a multithreaded program, there are multiple, independent, concurrent logical flows of execution within the same process.</p>
<p class="indent">In <a href="ch29.xhtml#ch29">Chapter 29</a>, we&#8217;ll see how to explicitly create programs that contain multiple threads of execution. However, the concept of multiple threads of execution is also <span epub:type="pagebreak" id="page_423"/>relevant for programs that employ signal handlers. Because a signal handler may asynchronously interrupt the execution of a program at any point in time, the main program and the signal handler in effect form two independent (although not concurrent) threads of execution within the same process.</p>
<p class="indent">A function is said to be <em>reentrant</em> if it can safely be simultaneously executed by multiple threads of execution in the same process. In this context, &#8220;safe&#8221; means that the function achieves its expected result, regardless of the state of execution of any other thread of execution.</p>
<div class="block">
<p class="noindent">The SUSv3 definition of a reentrant function is one &#8220;whose effect, when called by two or more threads, is guaranteed to be as if the threads each executed the function one after the other in an undefined order, even if the actual execution is interleaved.&#8221;</p>
</div>
<p class="noindent">A function may be <em>nonreentrant</em> if it updates global or static data structures. (A function that employs only local variables is guaranteed to be reentrant.) If two invocations of (i.e., two threads executing) the function simultaneously attempt to update the same global variable or data structure, then these updates are likely to interfere with each other and produce incorrect results. For example, suppose that one thread of execution is in the middle of updating a linked list data structure to add a new list item when another thread also attempts to update the same linked list. Since adding a new item to the list requires updating multiple pointers, if another thread interrupts these steps and updates the same pointers, chaos will result.</p>
<p class="indent">Such possibilities are in fact rife within the standard C library. For example, we already noted in <a href="ch07.xhtml#ch07lev2sec03">Section 7.1.3</a> that <em>malloc()</em> and <em>free()</em> maintain a linked list of freed memory blocks available for reallocation from the heap. If a call to <em>malloc()</em> in the main program is interrupted by a signal handler that also calls <em>malloc()</em>, then this linked list can be corrupted. For this reason, the <em>malloc()</em> family of functions, and other library functions that use them, are nonreentrant.</p>
<p class="indent">Other library functions are nonreentrant because they return information using statically allocated memory. Examples of such functions (described elsewhere in this book) include <em>crypt()</em>, <em>getpwnam()</em>, <em>gethostbyname()</em>, and <em>getservbyname()</em>. If a signal handler also uses one of these functions, then it will overwrite information returned by any earlier call to the same function from within the main program (or vice versa).</p>
<p class="indent">Functions can also be nonreentrant if they use static data structures for their internal bookkeeping. The most obvious examples of such functions are the members of the <em>stdio</em> library (<em>printf()</em>, <em>scanf()</em>, and so on), which update internal data structures for buffered I/O. Thus, when using <em>printf()</em> from within a signal handler, we may sometimes see strange output&#8212;or even a program crash or data corruption&#8212;if the handler interrupts the main program in the middle of executing a call to <em>printf()</em> or another <em>stdio</em> function.</p>
<p class="indent">Even if we are not using nonreentrant library functions, reentrancy issues can still be relevant. If a signal handler updates programmer-defined global data structures that are also updated within the main program, then we can say that the signal handler is nonreentrant with respect to the main program.</p>
<p class="indent">If a function is nonreentrant, then its manual page will normally provide an explicit or implicit indication of this fact. In particular, watch out for statements that the function uses or returns information in statically allocated variables.</p>
<h5 class="h5" id="ch21lev3sec02"><span epub:type="pagebreak" id="page_424"/><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch21.xhtml#ch21ex1">Listing 21-1</a> demonstrates the nonreentrant nature of the <em>crypt()</em> function (<a href="ch08.xhtml#ch08lev1sec05">Section 8.5</a>). As command-line arguments, this program accepts two strings. The program performs the following steps:</p>
<ol>
<li class="order"><p class="orderp">Call <em>crypt()</em> to encrypt the string in the first command-line argument, and copy this string to a separate buffer using <em>strdup()</em>.</p></li>
<li class="order"><p class="orderp">Establish a handler for <span class="literal">SIGINT</span> (generated by typing <em>Control-C</em>). The handler calls <em>crypt()</em> to encrypt the string supplied in the second command-line argument.</p></li>
<li class="order"><p class="orderp">Enter an infinite <span class="literal">for</span> loop that uses <em>crypt()</em> to encrypt the string in the first command-line argument and check that the returned string is the same as that saved in step 1.</p></li>
</ol>
<p class="noindent">In the absence of a signal, the strings will always match in step 3. However, if a <span class="literal">SIGINT</span> signal arrives and the execution of the signal handler interrupts the main program just after the execution of the <em>crypt()</em> call in the <span class="literal">for</span> loop, but before the check to see if the strings match, then the main program will report a mismatch. When we run the program, this is what we see:</p>
<p class="programs">$ <span class="codestrong">./non_reentrant abc def</span><br/><span class="font1">Repeatedly type Control-C to generate</span> SIGINT<br/>Mismatch on call 109871 (mismatch=1 handled=1)<br/>Mismatch on call 128061 (mismatch=2 handled=2)<br/><span class="font1">Many lines of output removed</span><br/>Mismatch on call 727935 (mismatch=149 handled=156)<br/>Mismatch on call 729547 (mismatch=150 handled=157)<br/><span class="font1">Type Control-\ to generate</span> SIGQUIT<br/>Quit (core dumped)</p>
<p class="noindent">Comparing the <em>mismatch</em> and <em>handled</em> values in the above output, we see that in the majority of cases where the signal handler is invoked, it overwrites the statically allocated buffer between the call to <em>crypt()</em> and the string comparison in <em>main()</em>.</p>
<p class="examplet"><a id="ch21ex1"/><strong>Listing 21-1:</strong> Calling a nonreentrant function from both <em>main()</em> and a signal handler</p>
<p class="programsli">____________________________________________________ <span class="codestrong">signals/nonreentrant.c</span><br/><br/>#define _XOPEN_SOURCE 600<br/>#include &lt;unistd.h&gt;<br/>#include &lt;signal.h&gt;<br/>#include &lt;string.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static char *str2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Set from argv[2] */<br/>static int handled = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Counts number of calls to handler */<br/><br/>static void<br/>handler(int sig)<br/>{<br/>&#160;&#160;&#160;&#160;crypt(str2, "xx");<br/>&#160;&#160;&#160;&#160;handled++;<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;char *cr1;<br/>&#160;&#160;&#160;&#160;int callNum, mismatch;<br/>&#160;&#160;&#160;&#160;struct sigaction sa;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 3)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s str1 str2\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;str2 = argv[2];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Make argv[2] available to handler */<br/>&#160;&#160;&#160;&#160;cr1 = strdup(crypt(argv[1], "xx"));&#160;&#160;/* Copy statically allocated string<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;to another buffer */<br/>&#160;&#160;&#160;&#160;if (cr1 == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("strdup");<br/><br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;sa.sa_flags = 0;<br/>&#160;&#160;&#160;&#160;sa.sa_handler = handler;<br/>&#160;&#160;&#160;&#160;if (sigaction(SIGINT, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;/* Repeatedly call crypt() using argv[1]. If interrupted by a<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;signal handler, then the static storage returned by crypt()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;will be overwritten by the results of encrypting argv[2], and<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;strcmp() will detect a mismatch with the value in 'cr1'. */<br/><br/>&#160;&#160;&#160;&#160;for (callNum = 1, mismatch = 0; ; callNum++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (strcmp(crypt(argv[1], "xx"), cr1) != 0) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mismatch++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Mismatch on call %d (mismatch=%d handled=%d)\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;callNum, mismatch, handled);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>____________________________________________________ <span class="codestrong">signals/nonreentrant.c</span></p>
<h5 class="h5" id="ch21lev3sec03"><span epub:type="pagebreak" id="page_425"/><strong>Standard async-signal-safe functions</strong></h5>
<p class="noindenta">An <em>async-signal-safe</em> function is one that the implementation guarantees to be safe when called from a signal handler. A function is async-signal-safe either because it is reentrant or because it is not interruptible by a signal handler.</p>
<p class="indent"><a href="ch21.xhtml#ch21table1">Table 21-1</a> lists the functions that various standards require to be async-signal-safe. In this table, the functions whose names are not followed by a <em>v2</em> or <em>v3</em> were specified as async-signal-safe in POSIX.1-1990. SUSv2 added the functions marked <em>v2</em> to the list, and those marked <em>v3</em> were added by SUSv3. Individual UNIX implementations may make other functions async-signal-safe, but all standards-conformant UNIX implementations must ensure that at least these functions are async-signal-safe (if they are provided by the implementation; not all of these functions are provided on Linux).</p>
<p class="indentb">SUSv4 makes the following changes to <a href="ch21.xhtml#ch21table1">Table 21-1</a>:</p>
<p class="bull">&#8226; The following functions are removed: <em>fpathconf()</em>, <em>pathconf()</em>, and <em>sysconf()</em>.</p>
<p class="bull"><span epub:type="pagebreak" id="page_426"/>&#8226; The following functions are added: <em>execl()</em>, <em>execv()</em>, <em>faccessat()</em>, <em>fchmodat()</em>, <em>fchownat()</em>, <em>fexecve()</em>, <em>fstatat()</em>, <em>futimens()</em>, <em>linkat()</em>, <em>mkdirat()</em>, <em>mkfifoat()</em>, <em>mknod()</em>, <em>mknodat()</em>, <em>openat()</em>, <em>readlinkat()</em>, <em>renameat()</em>, <em>symlinkat()</em>, <em>unlinkat()</em>, <em>utimensat()</em>, and <em>utimes()</em>.</p>
<p class="tablecap"><a id="ch21table1"/><strong>Table 21-1:</strong> Functions required to be async-signal-safe by POSIX.1-1990, SUSv2, and SUSv3</p>
<table class="all">
<tbody>
<tr>
<td style="vertical-align: top;" class="table_3a"><p class="table"><em>_Exit() (v3)</em></p>
<p class="table"><em>_exit()</em></p>
<p class="table"><em>abort() (v3)</em></p>
<p class="table"><em>accept() (v3)</em></p>
<p class="table"><em>access()</em></p>
<p class="table"><em>aio_error() (v2)</em></p>
<p class="table"><em>aio_return() (v2)</em></p>
<p class="table"><em>aio_suspend() (v2)</em></p>
<p class="table"><em>alarm()</em></p>
<p class="table"><em>bind() (v3)</em></p>
<p class="table"><em>cfgetispeed()</em></p>
<p class="table"><em>cfgetospeed()</em></p>
<p class="table"><em>cfsetispeed()</em></p>
<p class="table"><em>cfsetospeed()</em></p>
<p class="table"><em>chdir()</em></p>
<p class="table"><em>chmod()</em></p>
<p class="table"><em>chown()</em></p>
<p class="table"><em>clock_gettime() (v2)</em></p>
<p class="table"><em>close()</em></p>
<p class="table"><em>connect() (v3)</em></p>
<p class="table"><em>creat()</em></p>
<p class="table"><em>dup()</em></p>
<p class="table"><em>dup2()</em></p>
<p class="table"><em>execle()</em></p>
<p class="table"><em>execve()</em></p>
<p class="table"><em>fchmod() (v3)</em></p>
<p class="table"><em>fchown() (v3)</em></p>
<p class="table"><em>fcntl()</em></p>
<p class="table"><em>fdatasync() (v2)</em></p>
<p class="table"><em>fork()</em></p>
<p class="table"><em>fpathconf() (v2)</em></p>
<p class="table"><em>fstat()</em></p>
<p class="table"><em>fsync() (v2)</em></p>
<p class="table"><em>ftruncate() (v3)</em></p>
<p class="table"><em>getegid()</em></p>
<p class="table"><em>geteuid()</em></p>
<p class="table"><em>getgid()</em></p>
<p class="table"><em>getgroups()</em></p>
<p class="table"><em>getpeername() (v3)</em></p>
<p class="table"><em>getpgrp()</em></p>
<p class="table"><em>getpid()</em></p>
<p class="table"><em>getppid()</em></p>
<p class="table"><em>getsockname() (v3)</em></p>
<p class="table"><em>getsockopt() (v3)</em></p>
<p class="table"><em>getuid()</em></p>
<p class="table"><em>kill()</em></p>
<p class="table"><em>link()</em></p>
<p class="table"><em>listen() (v3)</em></p>
<p class="table"><em>lseek()</em></p>
<p class="table"><em>lstat() (v3)</em></p>
<p class="table"><em>mkdir()</em></p>
<p class="table"><em>mkfifo()</em></p>
<p class="table"><em>open()</em></p>
<p class="table"><em>pathconf()</em></p>
<p class="table"><em>pause()</em></p>
<p class="table"><em>pipe()</em></p>
<p class="table"><em>poll() (v3)</em></p>
<p class="table"><em>posix_trace_event() (v3)</em></p>
<p class="table"><em>pselect() (v3)</em></p>
<p class="table"><em>raise() (v2)</em></p>
<p class="table"><em>read()</em></p>
<p class="table"><em>readlink() (v3)</em></p>
<p class="table"><em>recv() (v3)</em></p>
<p class="table"><em>recvfrom() (v3)</em></p>
<p class="table"><em>recvmsg() (v3)</em></p>
<p class="table"><em>rename()</em></p>
<p class="table"><em>rmdir()</em></p>
<p class="table"><em>select() (v3)</em></p>
<p class="table"><em>sem_post() (v2)</em></p>
<p class="table"><em>send() (v3)</em></p>
<p class="table"><em>sendmsg() (v3)</em></p>
<p class="table"><em>sendto() (v3)</em></p>
<p class="table"><em>setgid()</em></p>
<p class="table"><em>setpgid()</em></p>
<p class="table"><em>setsid()</em></p>
<p class="table"><em>setsockopt() (v3)</em></p>
<p class="table"><em>setuid()</em></p>
<p class="table"><em>shutdown() (v3)</em></p>
<p class="table"><em>sigaction()</em></p>
<p class="table"><em>sigaddset()</em></p>
<p class="table"><em>sigdelset()</em></p>
<p class="table"><em>sigemptyset()</em></p>
<p class="table"><em>sigfillset()</em></p>
<p class="table"><em>sigismember()</em></p>
<p class="table"><em>signal() (v2)</em></p>
<p class="table"><em>sigpause() (v2)</em></p>
<p class="table"><em>sigpending()</em></p>
<p class="table"><em>sigprocmask()</em></p>
<p class="table"><em>sigqueue() (v2)</em></p>
<p class="table"><em>sigset() (v2)</em></p>
<p class="table"><em>sigsuspend()</em></p>
<p class="table"><em>sleep()</em></p>
<p class="table"><em>socket() (v3)</em></p>
<p class="table"><em>sockatmark() (v3)</em></p>
<p class="table"><em>socketpair() (v3)</em></p>
<p class="table"><em>stat()</em></p>
<p class="table"><em>symlink() (v3)</em></p>
<p class="table"><em>sysconf()</em></p>
<p class="table"><em>tcdrain()</em></p>
<p class="table"><em>tcflow()</em></p>
<p class="table"><em>tcflush()</em></p>
<p class="table"><em>tcgetattr()</em></p>
<p class="table"><em>tcgetpgrp()</em></p>
<p class="table"><em>tcsendbreak()</em></p>
<p class="table"><em>tcsetattr()</em></p>
<p class="table"><em>tcsetpgrp()</em></p>
<p class="table"><em>time()</em></p>
<p class="table"><em>timer_getoverrun() (v2)</em></p>
<p class="table"><em>timer_gettime() (v2)</em></p>
<p class="table"><em>timer_settime() (v2)</em></p>
<p class="table"><em>times()</em></p>
<p class="table"><em>umask()</em></p>
<p class="table"><em>uname()</em></p>
<p class="table"><em>unlink()</em></p>
<p class="table"><em>utime()</em></p>
<p class="table"><em>wait()</em></p>
<p class="table"><em>waitpid()</em></p>
<p class="table"><em>write()</em></p></td>
</tr>
</tbody>
</table>
<p class="noindentb"><span epub:type="pagebreak" id="page_427"/>SUSv3 notes that all functions not listed in <a href="ch21.xhtml#ch21table1">Table 21-1</a> are considered to be unsafe with respect to signals, but points out that a function is unsafe only when invocation of a signal handler interrupts the execution of an unsafe function, and the handler itself also calls an unsafe function. In other words, when writing signal handlers, we have two choices:</p>
<p class="bull">&#8226; Ensure that the code of the signal handler itself is reentrant and that it calls only async-signal-safe functions.</p>
<p class="bull">&#8226; Block delivery of signals while executing code in the main program that calls unsafe functions or works with global data structures also updated by the signal handler.</p>
<p class="noindentt">The problem with the second approach is that, in a complex program, it can be difficult to ensure that a signal handler will never interrupt the main program while it is calling an unsafe function. For this reason, the above rules are often simplified to the statement that we must not call unsafe functions from within a signal handler.</p>
<div class="block">
<p class="noindent">If we set up the same handler function to deal with several different signals or use the <span class="literal">SA_NODEFER</span> flag to <em>sigaction()</em>, then a handler may interrupt itself. As a consequence, the handler may be nonreentrant if it updates global (or static) variables, even if they are not used by the main program.</p>
</div>
<h5 class="h5" id="ch21lev3sec04"><strong>Use of <em>errno</em> inside signal handlers</strong></h5>
<p class="noindenta">Because they may update <em>errno</em>, use of the functions listed in <a href="ch21.xhtml#ch21table1">Table 21-1</a> can nevertheless render a signal handler nonreentrant, since they may overwrite the <em>errno</em> value that was set by a function called from the main program. The workaround is to save the value of <em>errno</em> on entry to a signal handler that uses any of the functions in <a href="ch21.xhtml#ch21table1">Table 21-1</a> and restore the <em>errno</em> value on exit from the handler, as in the following example:</p>
<p class="programs">void<br/>handler(int sig)<br/>{<br/>&#160;&#160;&#160;&#160;int savedErrno;<br/><br/>&#160;&#160;&#160;&#160;savedErrno = errno;<br/><br/>&#160;&#160;&#160;&#160;/* Now we can execute a function that might modify errno */<br/><br/>&#160;&#160;&#160;&#160;errno = savedErrno;<br/>}</p>
<h5 class="h5" id="ch21lev3sec05"><strong>Use of unsafe functions in example programs in this book</strong></h5>
<p class="noindenta">Although <em>printf()</em> is not async-signal-safe, we use it in signal handlers in various example programs in this book. We do so because <em>printf()</em> provides an easy and concise way to demonstrate that a signal handler has been called, and to display the contents of relevant variables within the handler. For similar reasons, we occasionally use a few other unsafe functions in signal handlers, including other <em>stdio</em> functions and <em>strsignal()</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_428"/>Real-world applications should avoid calling non-async-signal-safe functions from signal handlers. To make this clear, each signal handler in the example programs that uses one of these functions is marked with a comment indicating that the usage is unsafe:</p>
<p class="programs">printf("Some message\n");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* UNSAFE */</p>
<h4 class="h4" id="ch21lev2sec03"><strong>21.1.3 Global Variables and the <em>sig_atomic_t</em> Data Type</strong></h4>
<p class="noindenta">Notwithstanding reentrancy issues, it can be useful to share global variables between the main program and a signal handler. This can be safe as long as the main program correctly handles the possibility that the signal handler may change the global variable at any time. For example, one common design is to make a signal handler&#8217;s sole action the setting of a global flag. This flag is periodically checked by the main program, which then takes appropriate action in response to the delivery of the signal (and clears the flag). When global variables are accessed in this way from a signal handler, we should always declare them using the <span class="literal">volatile</span> keyword (see <a href="ch06.xhtml#ch06lev1sec08">Section 6.8</a>) in order to prevent the compiler from performing optimizations that result in the variable being stored in a register.</p>
<p class="indent">Reading and writing global variables may involve more than one machine-language instruction, and a signal handler may interrupt the main program in the middle of such an instruction sequence. (We say that access to the variable is <em>nonatomic</em>.) For this reason, the C language standards and SUSv3 specify an integer data type, <em>sig_atomic_t</em>, for which reads and writes are guaranteed to be atomic. Thus, a global flag variable that is shared between the main program and a signal handler should be declared as follows:</p>
<p class="programs">volatile sig_atomic_t flag;</p>
<p class="noindent">We show an example of the use of the <em>sig_atomic_t</em> data type in <a href="ch22.xhtml#ch22ex5">Listing 22-5</a>, on <a href="ch22.xhtml#page_466">page 466</a>.</p>
<p class="indent">Note that the C increment (<span class="literal">++</span>) and decrement (<span class="literal">--</span>) operators don&#8217;t fall within the guarantee provided for <em>sig_atomic_t</em>. On some hardware architectures, these operations may not be atomic (refer to <a href="ch30.xhtml#ch30lev1sec01">Section 30.1</a> for more details). All that we are guaranteed to be safely allowed to do with a <em>sig_atomic_t</em> variable is set it within the signal handler, and check it in the main program (or vice versa).</p>
<p class="indent">C99 and SUSv3 specify that an implementation should define two constants (in <span class="literal">&lt;stdint.h&gt;</span>), <span class="literal">SIG_ATOMIC_MIN</span> and <span class="literal">SIG_ATOMIC_MAX</span>, that define the range of values that may be assigned to variables of type <em>sig_atomic_t</em>. The standards require that this range be at least &#8211;127 to 127 if <em>sig_atomic_t</em> is represented as a signed value, or 0 to 255 if it is represented as an unsigned value. On Linux, these two constants equate to the negative and positive limits for signed 32-bit integers.</p>
<h3 class="h3" id="ch21lev1sec02"><strong>21.2 Other Methods of Terminating a Signal Handler</strong></h3>
<p class="noindenta">All of the signal handlers that we have looked at so far complete by returning to the main program. However, simply returning from a signal handler sometimes isn&#8217;t desirable, or in some cases, isn&#8217;t even useful. (We&#8217;ll see an example of where <span epub:type="pagebreak" id="page_429"/>returning from a signal handler isn&#8217;t useful when we discuss hardware-generated signals in <a href="ch22.xhtml#ch22lev1sec04">Section 22.4</a>.)</p>
<p class="indentb">There are various other ways of terminating a signal handler:</p>
<p class="bull">&#8226; Use <em>_exit()</em> to terminate the process. Beforehand, the handler may carry out some cleanup actions. Note that we can&#8217;t use <em>exit()</em> to terminate a signal handler, because it is not one of safe functions listed in <a href="ch21.xhtml#ch21table1">Table 21-1</a>. It is unsafe because it flushes <em>stdio</em> buffers prior to calling <em>_exit()</em>, as described in <a href="ch25.xhtml#ch25lev1sec01">Section 25.1</a>.</p>
<p class="bull">&#8226; Use <em>kill()</em> or <em>raise()</em> to send a signal that kills the process (i.e., a signal whose default action is process termination).</p>
<p class="bull">&#8226; Perform a nonlocal goto from the signal handler.</p>
<p class="bull">&#8226; Use the <em>abort()</em> function to terminate the process with a core dump.</p>
<p class="noindentt">The last two of these options are described in further detail in the following sections.</p>
<h4 class="h4" id="ch21lev2sec04"><strong>21.2.1 Performing a Nonlocal Goto from a Signal Handler</strong></h4>
<p class="noindenta"><a href="ch06.xhtml#ch06lev1sec08">Section 6.8</a> described the use of <em>setjmp()</em> and <em>longjmp()</em> to perform a nonlocal goto from a function to one of its callers. We can also use this technique from a signal handler. This provides a way to recover after delivery of a signal caused by a hardware exception (e.g., a memory access error), and also allows us to catch a signal and return control to a particular point in a program. For example, upon receipt of a <span class="literal">SIGINT</span> signal (normally generated by typing <em>Control-C</em>), the shell performs a nonlocal goto to return control to its main input loop (and thus read a new command).</p>
<p class="indent">However, there is a problem with using the standard <em>longjmp()</em> function to exit from a signal handler. We noted earlier that, upon entry to the signal handler, the kernel automatically adds the invoking signal, as well as any signals specified in the <em>act.sa_mask</em> field, to the process signal mask, and then removes these signals from the mask when the handler does a normal return.</p>
<p class="indent">What happens to the signal mask if we exit the signal handler using <em>longjmp()</em>? The answer depends on the genealogy of the particular UNIX implementation. Under System V, <em>longjmp()</em> doesn&#8217;t restore the signal mask, so that blocked signals are not unblocked upon leaving the handler. Linux follows the System V behavior. (This is usually not what we want, since it leaves the signal that caused invocation of the handler blocked.) Under BSD-derived implementations, <em>setjmp()</em> saves the signal mask in its <em>env</em> argument, and the saved signal mask is restored by <em>longjmp()</em>. (BSD-derived implementations also provide two other functions, <em>_setjmp()</em> and <em>_longjmp()</em>, which have the System V semantics.) In other words, we can&#8217;t portably use <em>longjmp()</em> to exit a signal handler.</p>
<div class="block">
<p class="noindent">If we define the <span class="literal">_BSD_SOURCE</span> feature test macro when compiling a program, then (the <em>glibc</em>) <em>setjmp()</em> follows the BSD semantics.</p>
</div>
<p class="noindent">Because of this difference in the two main UNIX variants, POSIX.1-1990 chose not to specify the handling of the signal mask by <em>setjmp()</em> and <em>longjmp()</em>. Instead, it defined a pair of new functions, <em>sigsetjmp()</em> and <em>siglongjmp()</em>, that provide explicit control of the signal mask when performing a nonlocal goto.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_430"/>#include &lt;setjmp.h&gt;<br/><br/>int <span class="codestrong">sigsetjmp</span>(sigjmp_buf <span class="font1">env</span>, int <span class="font1">savesigs</span>);</p>
<p class="right">Returns 0 on initial call, nonzero on return via <em>siglongjmp()</em></p>
<p class="programsat">void <span class="codestrong">siglongjmp</span>(sigjmp_buf <span class="font1">env</span>, int <span class="font1">val</span>);</p>
</div>
<p class="noindent">The <em>sigsetjmp()</em> and <em>siglongjmp()</em> functions operate similarly to <em>setjmp()</em> and <em>longjmp()</em>. The only differences are in the type of the <em>env</em> argument (<em>sigjmp_buf</em> instead of <em>jmp_buf</em>) and the extra <em>savesigs</em> argument to <em>sigsetjmp()</em>. If <em>savesigs</em> is nonzero, then the process signal mask that is current at the time of the <em>sigsetjmp()</em> call is saved in <em>env</em> and restored by a later <em>siglongjmp()</em> call specifying the same <em>env</em> argument. If <em>savesigs</em> is 0, then the process signal mask is not saved and restored.</p>
<p class="indent">The <em>longjmp()</em> and <em>siglongjmp()</em> functions are not listed among the async-signal-safe functions in <a href="ch21.xhtml#ch21table1">Table 21-1</a>. This is because calling any non-async-signal-safe function after performing a nonlocal goto carries the same risks as calling that function from within the signal handler. Furthermore, if a signal handler interrupts the main program while it is part-way through updating a data structure, and the handler exits by performing a nonlocal goto, then the incomplete update may leave that data structure in an inconsistent state. One technique that can help to avoid problems is to use <em>sigprocmask()</em> to temporarily block the signal while sensitive updates are being performed.</p>
<h5 class="h5" id="ch21lev3sec06"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch21.xhtml#ch21ex2">Listing 21-2</a> demonstrates the difference in signal mask handling for the two types of nonlocal gotos. This program establishes a handler for <span class="literal">SIGINT</span>. The program is designed to allow either <em>setjmp()</em> plus <em>longjmp()</em> or <em>sigsetjmp()</em> plus <em>siglongjmp()</em> to be used to exit the signal handler, depending on whether the program is compiled with the <span class="literal">USE_SIGSETJMP</span> macro defined. The program displays the current settings of the signal mask both on entry to the signal handler and after the nonlocal goto has transferred control from the handler back to the main program.</p>
<p class="indent">When we build the program so that <em>longjmp()</em> is used to exit the signal handler, this is what we see when we run the program:</p>
<p class="programs">$ <span class="codestrong">make -s sigmask_longjmp</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Default compilation causes setjmp() to be used</span><br/>$ <span class="codestrong">./sigmask_longjmp</span><br/>Signal mask at startup:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;empty signal set&gt;<br/>Calling setjmp()<br/><span class="font1">Type Control-C to generate</span> SIGINT<br/>Received signal 2 (Interrupt), signal mask is:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2 (Interrupt)<br/>After jump from handler, signal mask is:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2 (Interrupt)<br/><span class="font1">(At this point, typing Control-C again has no effect, since</span> SIGINT <span class="font1">is blocked)</span><br/><span class="font1">Type Control-\ to kill the program</span><br/>Quit</p>
<p class="noindent"><span epub:type="pagebreak" id="page_431"/>From the program output, we can see that, after a <em>longjmp()</em> from the signal handler, the signal mask remains set to the value to which it was set on entry to the signal handler.</p>
<div class="block">
<p class="noindent">In the above shell session, we built the program using the makefile supplied with the source code distribution for this book. The <em>&#8211;s</em> option tells <em>make</em> not to echo the commands that it is executing. We use this option to avoid cluttering the session log. ([<a href="bib.xhtml#bib68">Mecklenburg, 2005</a>] provides a description of the GNU <em>make</em> program.)</p>
</div>
<p class="noindent">When we compile the same source file to build an executable that uses <em>siglongjmp()</em> to exit the handler, we see the following:</p>
<p class="programs">$ <span class="codestrong">make -s sigmask_siglongjmp</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Compiles using cc &#8211;DUSE_SIGSETJMP</span><br/>$ <span class="codestrong">./sigmask_siglongjmp</span><br/>Signal mask at startup:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;empty signal set&gt;<br/>Calling sigsetjmp()<br/><span class="font1">Type Control-C</span><br/>Received signal 2 (Interrupt), signal mask is:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2 (Interrupt)<br/>After jump from handler, signal mask is:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;empty signal set&gt;</p>
<p class="noindent">At this point, <span class="literal">SIGINT</span> is not blocked, because <em>siglongjmp()</em> restored the signal mask to its original state. Next, we type <em>Control-C</em> again, so that the handler is once more invoked:</p>
<p class="programs"><span class="font1">Type Control-C</span><br/>Received signal 2 (Interrupt), signal mask is:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2 (Interrupt)<br/>After jump from handler, signal mask is:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;empty signal set&gt;<br/><span class="font1">Type Control-\ to kill the program</span><br/>Quit</p>
<p class="noindent">From the above output, we can see that <em>siglongjmp()</em> restores the signal mask to the value it had at the time of the <em>sigsetjmp()</em> call (i.e., an empty signal set).</p>
<p class="indent"><a href="ch21.xhtml#ch21ex2">Listing 21-2</a> also demonstrates a useful technique for use with a signal handler that performs a nonlocal goto. Because a signal can be generated at any time, it may actually occur before the target of the goto has been set up by <em>sigsetjmp()</em> (or <em>setjmp()</em>). To prevent this possibility (which would cause the handler to perform a nonlocal goto using an uninitialized <em>env</em> buffer), we employ a guard variable, <em>canJump</em>, to indicate whether the <em>env</em> buffer has been initialized. If <em>canJump</em> is false, then instead of doing a nonlocal goto, the handler simply returns. An alternative approach is to arrange the program code so that the call to <em>sigsetjmp()</em> (or <em>setjmp()</em>) occurs before the signal handler is established. However, in complex programs, it may be difficult to ensure that these two steps are performed in that order, and the use of a guard variable may be simpler.</p>
<p class="indent"><span epub:type="pagebreak" id="page_432"/>Note that using <span class="literal">#ifdef</span> was the simplest way of writing the program in <a href="ch21.xhtml#ch21ex2">Listing 21-2</a> in a standards-conformant fashion. In particular, we could not have replaced the <span class="literal">#ifdef</span> with the following run-time check:</p>
<p class="programs">if (useSiglongjmp)<br/>&#160;&#160;&#160;&#160;s = sigsetjmp(senv, 1);<br/>else<br/>&#160;&#160;&#160;&#160;s = setjmp(env);<br/>if (s == 0)<br/>&#160;&#160;&#160;&#160;...</p>
<p class="noindent">This is not permitted because SUSv3 doesn&#8217;t allow <em>setjmp()</em> and <em>sigsetjmp()</em> to be used within an assignment statement (see <a href="ch06.xhtml#ch06lev1sec08">Section 6.8</a>).</p>
<p class="examplet"><a id="ch21ex2"/><strong>Listing 21-2:</strong> Performing a nonlocal goto from a signal handler</p>
<p class="programsli">__________________________________________________<span class="codestrong">signals/sigmask_longjmp.c</span><br/><br/>#define _GNU_SOURCE&#160;&#160;&#160;&#160;&#160;/* Get strsignal() declaration from &lt;string.h&gt; */<br/>#include &lt;string.h&gt;<br/>#include &lt;setjmp.h&gt;<br/>#include &lt;signal.h&gt;<br/>#include "signal_functions.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declaration of printSigMask() */<br/>#include "tlpi_hdr.h"<br/><br/>static volatile sig_atomic_t canJump = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Set to 1 once "env" buffer has been<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;initialized by [sig]setjmp() */<br/>#ifdef USE_SIGSETJMP<br/>static sigjmp_buf senv;<br/>#else<br/>static jmp_buf env;<br/>#endif<br/><br/>static void<br/>handler(int sig)<br/>{<br/>&#160;&#160;&#160;&#160;/* UNSAFE: This handler uses non-async-signal-safe functions<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;(printf(), strsignal(), printSigMask(); see <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>) */<br/><br/>&#160;&#160;&#160;&#160;printf("Received signal %d (%s), signal mask is:\n", sig,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;strsignal(sig));<br/>&#160;&#160;&#160;&#160;printSigMask(stdout, NULL);<br/><br/>&#160;&#160;&#160;&#160;if (!canJump) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("'env' buffer not yet set, doing a simple return\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return;<br/>&#160;&#160;&#160;&#160;}<br/><br/>#ifdef USE_SIGSETJMP<br/>&#160;&#160;&#160;&#160;siglongjmp(senv, 1);<br/>#else<br/>&#160;&#160;&#160;&#160;longjmp(env, 1);<br/>#endif<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct sigaction sa;<br/><br/>&#160;&#160;&#160;&#160;printSigMask(stdout, "Signal mask at startup:\n");<br/><br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;sa.sa_flags = 0;<br/>&#160;&#160;&#160;&#160;sa.sa_handler = handler;<br/>&#160;&#160;&#160;&#160;if (sigaction(SIGINT, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>#ifdef USE_SIGSETJMP<br/>&#160;&#160;&#160;&#160;printf("Calling sigsetjmp()\n");<br/>&#160;&#160;&#160;&#160;if (sigsetjmp(senv, 1) == 0)<br/>#else<br/>&#160;&#160;&#160;&#160;printf("Calling setjmp()\n");<br/>&#160;&#160;&#160;&#160;if (setjmp(env) == 0)<br/>#endif<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;canJump = 1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Executed after [sig]setjmp() */<br/><br/>&#160;&#160;&#160;&#160;else&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Executed after [sig]longjmp() */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printSigMask(stdout, "After jump from handler, signal mask is:\n" );<br/><br/>&#160;&#160;&#160;&#160;for (;;)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for signals until killed */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pause();<br/>}<br/>__________________________________________________<span class="codestrong">signals/sigmask_longjmp.c</span></p>
<h4 class="h4" id="ch21lev2sec05"><span epub:type="pagebreak" id="page_433"/><strong>21.2.2 Terminating a Process Abnormally: <em>abort()</em></strong></h4>
<p class="noindenta">The <em>abort()</em> function terminates the calling process and causes it to produce a core dump.</p>
<div class="box">
<p class="programsa">#include &lt;stdlib.h&gt;<br/><br/>void <span class="codestrong">abort</span>(void);</p>
</div>
<p class="noindent">The <em>abort()</em> function terminates the calling process by raising a <span class="literal">SIGABRT</span> signal. The default action for <span class="literal">SIGABRT</span> is to produce a core dump file and terminate the process. The core dump file can then be used within a debugger to examine the state of the program at the time of the <em>abort()</em> call.</p>
<p class="indent">SUSv3 requires that <em>abort()</em> override the effect of blocking or ignoring <span class="literal">SIGABRT</span>. Furthermore, SUSv3 specifies that <em>abort()</em> must terminate the process unless the process catches the signal with a handler that doesn&#8217;t return. This last statement requires a moment&#8217;s thought. Of the methods of terminating a signal handler described in <a href="ch21.xhtml#ch21lev1sec02">Section 21.2</a>, the one that is relevant here is the use of a nonlocal goto to exit the handler. If this is done, then the effect of <em>abort()</em> will be nullified; otherwise, <span epub:type="pagebreak" id="page_434"/><em>abort()</em> always terminates the process. In most implementations, termination is guaranteed as follows: if the process still hasn&#8217;t terminated after raising <span class="literal">SIGABRT</span> once (i.e., a handler catches the signal and returns, so that execution of <em>abort()</em> is resumed), <em>abort()</em> resets the handling of <span class="literal">SIGABRT</span> to <span class="literal">SIG_DFL</span> and raises a second <span class="literal">SIGABRT</span>, which is guaranteed to kill the process.</p>
<p class="indent">If <em>abort()</em> does successfully terminate the process, then it also flushes and closes <em>stdio</em> streams.</p>
<p class="indent">An example of the use of <em>abort()</em> is provided in the error-handling functions of <a href="ch03.xhtml#ch3ex3">Listing 3-3</a>, on <a href="ch03.xhtml#page_54">page 54</a>.</p>
<h3 class="h3" id="ch21lev1sec03"><strong>21.3 Handling a Signal on an Alternate Stack: <em>sigaltstack()</em></strong></h3>
<p class="noindenta">Normally, when a signal handler is invoked, the kernel creates a frame for it on the process stack. However, this may not be possible if a process attempts to extend the stack beyond the maximum possible size. For example, this may occur because the stack grows so large that it encounters a region of mapped memory (<a href="ch48.xhtml#ch48lev1sec05">Section 48.5</a>) or the upwardly growing heap, or it reaches the <span class="literal">RLIMIT_STACK</span> resource limit (<a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a>).</p>
<p class="indent">When a process attempts to grow its stack beyond the maximum possible size, the kernel generates a <span class="literal">SIGSEGV</span> signal for the process. However, since the stack space is exhausted, the kernel can&#8217;t create a frame for any <span class="literal">SIGSEGV</span> handler that the program may have established. Consequently, the handler is not invoked, and the process is terminated (the default action for <span class="literal">SIGSEGV</span>).</p>
<p class="indent">If we instead need to ensure that the <span class="literal">SIGSEGV</span> signal is handled in these circumstances, we can do the following:</p>
<ol>
<li class="order"><p class="orderp">Allocate an area of memory, called an <em>alternate signal stack</em>, to be used for the stack frame of a signal handler.</p></li>
<li class="order"><p class="orderp">Use the <em>sigaltstack()</em> system call to inform the kernel of the existence of the alternate signal stack.</p></li>
<li class="order"><p class="orderp">When establishing the signal handler, specify the <span class="literal">SA_ONSTACK</span> flag, to tell the kernel that the frame for this handler should be created on the alternate stack.</p></li>
</ol>
<p class="noindent">The <em>sigaltstack()</em> system call both establishes an alternate signal stack and returns information about any alternate signal stack that is already established.</p>
<div class="box">
<p class="programsa">#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">sigaltstack</span>(const stack_t *<span class="font1">sigstack</span>, stack_t *<span class="font1">old_sigstack</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>sigstack</em> argument points to a structure specifying the location and attributes of the new alternate signal stack. The <em>old_sigstack</em> argument points to a structure used to return information about the previously established alternate signal stack (if there was one). Either one of these arguments can be specified as <span class="literal">NULL</span>. For example, we can find out about the existing alternate signal stack, without changing it, by <span epub:type="pagebreak" id="page_435"/>specifying <span class="literal">NULL</span> for the <em>sigstack</em> argument. Otherwise, each of these arguments points to a structure of the following type:</p>
<p class="programs">typedef struct {<br/>&#160;&#160;&#160;&#160;void&#160;&#160;*ss_sp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Starting address of alternate stack */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;ss_flags;&#160;&#160;&#160;&#160;&#160;/* Flags: SS_ONSTACK, SS_DISABLE */<br/>&#160;&#160;&#160;&#160;size_t ss_size;&#160;&#160;&#160;&#160;&#160;&#160;/* Size of alternate stack */<br/>} stack_t;</p>
<p class="noindent">The <em>ss_sp</em> and <em>ss_size</em> fields specify the size and location of the alternate signal stack. When actually using the alternate signal stack, the kernel automatically takes care of aligning the value given in <em>ss_sp</em> to an address boundary that is suitable for the hardware architecture.</p>
<p class="indent">Typically, the alternate signal stack is either statically allocated or dynamically allocated on the heap. SUSv3 specifies the constant <span class="literal">SIGSTKSZ</span> to be used as a typical value when sizing the alternate stack, and <span class="literal">MINSIGSTKSZ</span> as the minimum size required to invoke a signal handler. On Linux/x86-32, these constants are defined with the values 8192 and 2048, respectively.</p>
<p class="indent">The kernel doesn&#8217;t resize an alternate signal stack. If the stack overflows the space we have allocated for it, then chaos results (e.g., overwriting of variables beyond the limits of the stack). This is not usually a problem&#8212;because we normally use an alternate signal stack to handle the special case of the standard stack overflowing, typically only one or a few frames are allocated on the stack. The job of the <span class="literal">SIGSEGV</span> handler is either to perform some cleanup and terminate the process or to unwind the standard stack using a nonlocal goto.</p>
<p class="indentb">The <em>ss_flags</em> field contains one of the following values:</p>
<p class="term"><span class="literal">SS_ONSTACK</span></p>
<p class="termlist">If this flag is set when retrieving information about the currently established alternate signal stack (<em>old_sigstack</em>), it indicates that the process is currently executing on the alternate signal stack. Attempts to establish a new alternate signal stack while the process is already running on an alternate signal stack result in an error (<span class="literal">EPERM</span>) from <em>sigaltstack()</em>.</p>
<p class="term"><span class="literal">SS_DISABLE</span></p>
<p class="termlist">Returned in <em>old_sigstack</em>, this flag indicates that there is no currently established alternate signal stack. When specified in <em>sigstack</em>, this disables a currently established alternate signal stack.</p>
<p class="noindentt"><a href="ch21.xhtml#ch21ex3">Listing 21-3</a> demonstrates the establishment and use of an alternate signal stack. After establishing an alternate signal stack and a handler for <span class="literal">SIGSEGV</span>, this program calls a function that infinitely recurses, so that the stack overflows and the process is sent a <span class="literal">SIGSEGV</span> signal. When we run the program, this is what we see:</p>
<p class="programs">$ <span class="codestrong">ulimit -s unlimited</span><br/>$ <span class="codestrong">./t_sigaltstack</span><br/>Top of standard stack is near 0xbffff6b8<br/>Alternate stack is at&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0x804a948-0x804cfff<br/>Call&#160;&#160;&#160;&#160;1 - top of stack near 0xbff0b3ac<br/>Call&#160;&#160;&#160;&#160;2 - top of stack near 0xbfe1714c<br/><span class="font1">Many intervening lines of output removed</span><br/>Call 2144 - top of stack near 0x4034120c<br/>Call 2145 - top of stack near 0x4024cfac<br/>Caught signal 11 (Segmentation fault)<br/>Top of handler stack near&#160;&#160;&#160;&#160;&#160;&#160;0x804c860</p>
<p class="noindent"><span epub:type="pagebreak" id="page_436"/>In this shell session, the <em>ulimit</em> command is used to remove any <span class="literal">RLIMIT_STACK</span> resource limit that may have been set in the shell. We explain this resource limit in <a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a>.</p>
<p class="examplet"><a id="ch21ex3"/><strong>Listing 21-3:</strong> Using <em>sigaltstack()</em></p>
<p class="programsli">___________________________________________________ <span class="codestrong">signals/t_sigaltstack.c</span><br/><br/>#define _GNU_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get strsignal() declaration from &lt;string.h&gt; */<br/>#include &lt;string.h&gt;<br/>#include &lt;signal.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static void<br/>sigsegvHandler(int sig)<br/>{<br/>&#160;&#160;&#160;&#160;int x;<br/><br/>&#160;&#160;&#160;&#160;/* UNSAFE: This handler uses non-async-signal-safe functions<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;(printf(), strsignal(), fflush(); see <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>) */<br/><br/>&#160;&#160;&#160;&#160;printf("Caught signal %d (%s)\n", sig, strsignal(sig));<br/>&#160;&#160;&#160;&#160;printf("Top of handler stack near&#160;&#160;&#160;&#160;&#160;%10p\n", (void *) &#38;x);<br/>&#160;&#160;&#160;&#160;fflush(NULL);<br/><br/>&#160;&#160;&#160;&#160;_exit(EXIT_FAILURE);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Can't return after SIGSEGV */<br/>}<br/><br/>static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* A recursive function that overflows the stack */<br/>overflowStack(int callNum)<br/>{<br/>&#160;&#160;&#160;&#160;char a[100000];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Make this stack frame large */<br/><br/>&#160;&#160;&#160;&#160;printf("Call %4d - top of stack near %10p\n", callNum, &#38;a[0]);<br/>&#160;&#160;&#160;&#160;overflowStack(callNum+1);<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;stack_t sigstack;<br/>&#160;&#160;&#160;&#160;struct sigaction sa;<br/>&#160;&#160;&#160;&#160;int j;<br/><br/>&#160;&#160;&#160;&#160;printf("Top of standard stack is near %10p\n", (void *) &#38;j);<br/><br/>&#160;&#160;&#160;&#160;/* Allocate alternate stack and inform kernel of its existence */<br/><br/>&#160;&#160;&#160;&#160;sigstack.ss_sp = malloc(SIGSTKSZ);<br/>&#160;&#160;&#160;&#160;if (sigstack.ss_sp == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("malloc");<br/>&#160;&#160;&#160;&#160;sigstack.ss_size = SIGSTKSZ;<br/>&#160;&#160;&#160;&#160;sigstack.ss_flags = 0;<br/>&#160;&#160;&#160;&#160;if (sigaltstack(&#38;sigstack, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaltstack");<br/>&#160;&#160;&#160;&#160;printf("Alternate stack is at&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;%10p-%p\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigstack.ss_sp, (char *) sbrk(0) - 1);<br/><br/>&#160;&#160;&#160;&#160;sa.sa_handler = sigsegvHandler;&#160;&#160;&#160;&#160;&#160;/* Establish handler for SIGSEGV */<br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;sa.sa_flags = SA_ONSTACK;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Handler uses alternate stack */<br/>&#160;&#160;&#160;&#160;if (sigaction(SIGSEGV, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;overflowStack(1);<br/>}<br/>___________________________________________________ <span class="codestrong">signals/t_sigaltstack.c</span></p>
<h3 class="h3" id="ch21lev1sec04"><span epub:type="pagebreak" id="page_437"/><strong>21.4 The</strong> <span class="literal"><span class="codestrong">SA_SIGINFO</span></span> <strong>Flag</strong></h3>
<p class="noindenta">Setting the <span class="literal">SA_SIGINFO</span> flag when establishing a handler with <em>sigaction()</em> allows the handler to obtain additional information about a signal when it is delivered. In order to obtain this information, we must declare the handler as follows:</p>
<p class="programs">void handler(int sig, siginfo_t *siginfo, void *ucontext);</p>
<p class="noindent">The first argument, <em>sig</em>, is the signal number, as for a standard signal handler. The second argument, <em>siginfo</em>, is a structure used to provide the additional information about the signal. We describe this structure below. The last argument, <em>ucontext</em>, is also described below.</p>
<p class="indent">Since the above signal handler has a different prototype from a standard signal handler, C typing rules mean that we can&#8217;t use the <em>sa_handler</em> field of the <em>sigaction</em> structure to specify the address of the handler. Instead, we must use an alternative field: <em>sa_sigaction</em>. In other words, the definition of the <em>sigaction</em> structure is somewhat more complex than was shown in <a href="ch20.xhtml#ch20lev1sec13">Section 20.13</a>. In full, the structure is defined as follows:</p>
<p class="programs">struct sigaction {<br/>&#160;&#160;&#160;&#160;union {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;void (*sa_handler)(int);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;void (*sa_sigaction)(int, siginfo_t *, void *);<br/>&#160;&#160;&#160;&#160;} __sigaction_handler;<br/>&#160;&#160;&#160;&#160;sigset_t&#160;&#160;&#160;sa_mask;<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa_flags;<br/>&#160;&#160;&#160;&#160;void&#160;&#160;&#160;&#160;&#160;(*sa_restorer)(void);<br/>};<br/><br/>/* Following defines make the union fields look like simple fields<br/>&#160;&#160;&#160;in the parent structure */<br/><br/>#define sa_handler __sigaction_handler.sa_handler<br/>#define sa_sigaction __sigaction_handler.sa_sigaction</p>
<p class="noindent"><span epub:type="pagebreak" id="page_438"/>The <em>sigaction</em> structure uses a union to combine the <em>sa_sigaction</em> and <em>sa_handler</em> fields. (Most other UNIX implementations similarly use a union for this purpose.) Using a union is possible because only one of these fields is required during a particular call to <em>sigaction()</em>. (However, this can lead to strange bugs if we naively expect to be able to set the <em>sa_handler</em> and <em>sa_sigaction</em> fields independently of one another, perhaps because we reuse a single <em>sigaction</em> structure in multiple <em>sigaction()</em> calls to establish handlers for different signals.)</p>
<p class="indent">Here is an example of the use of <span class="literal">SA_SIGINFO</span> to establish a signal handler:</p>
<p class="programs">struct sigaction act;<br/><br/>sigemptyset(&#38;act.sa_mask);<br/>act.sa_sigaction = handler;<br/>act.sa_flags = SA_SIGINFO;<br/><br/>if (sigaction(SIGINT, &#38;act, NULL) == -1)<br/>&#160;&#160;&#160;&#160;errExit("sigaction");</p>
<p class="noindent">For complete examples of the use of the <span class="literal">SA_SIGINFO</span> flag, see <a href="ch22.xhtml#ch22ex3">Listing 22-3</a> (<a href="ch22.xhtml#page_462">page 462</a>) and <a href="ch23.xhtml#ch23ex5">Listing 23-5</a> (<a href="ch23.xhtml#page_500">page 500</a>).</p>
<h5 class="h5" id="ch21lev3sec07"><strong>The <em>siginfo_t</em> structure</strong></h5>
<p class="noindenta">The <em>siginfo_t</em> structure passed as the second argument to a signal handler that is established with <span class="literal">SA_SIGINFO</span> has the following form:</p>
<p class="programs">typedef struct {<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;si_signo;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Signal number */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;si_code;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Signal code */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;si_trapno;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Trap number for hardware-generated signal<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(unused on most architectures) */<br/>&#160;&#160;&#160;&#160;union sigval si_value;&#160;&#160;&#160;&#160;/* Accompanying data from sigqueue() */<br/>&#160;&#160;&#160;&#160;pid_t&#160;&#160;&#160;si_pid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Process ID of sending process */<br/>&#160;&#160;&#160;&#160;uid_t&#160;&#160;&#160;si_uid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Real user ID of sender */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;si_errno;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Error number (generally unused) */<br/>&#160;&#160;&#160;&#160;void&#160;&#160;&#160;*si_addr;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Address that generated signal<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(hardware-generated signals only) */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;si_overrun;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Overrun count (Linux 2.6, POSIX timers) */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;si_timerid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* (Kernel-internal) Timer ID<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(Linux 2.6, POSIX timers) */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;si_band;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Band event (SIGPOLL/SIGIO) */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;si_fd;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* File descriptor (SIGPOLL/SIGIO) */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;si_status;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Exit status or signal (SIGCHLD) */<br/>&#160;&#160;&#160;&#160;clock_t si_utime;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* User CPU time (SIGCHLD) */<br/>&#160;&#160;&#160;&#160;clock_t si_stime;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* System CPU time (SIGCHLD) */<br/>} siginfo_t;</p>
<p class="noindent">The <span class="literal">_POSIX_C_SOURCE</span> feature test macro must be defined with a value greater than or equal to 199309 in order to make the declaration of the <em>siginfo_t</em> structure visible from <span class="literal">&lt;signal.h&gt;</span>.</p>
<p class="indent">On Linux, as on most UNIX implementations, many of the fields in the <em>siginfo_t</em> structure are combined into a union, since not all of the fields are needed for each signal. (See <span class="literal">&lt;bits/siginfo.h&gt;</span> for details.)</p>
<p class="noindentb"><span epub:type="pagebreak" id="page_439"/>Upon entry to a signal handler, the fields of the <em>siginfo_t</em> structure are set as follows:</p>
<p class="term"><em>si_signo</em></p>
<p class="termlist">This field is set for all signals. It contains the number of the signal causing invocation of the handler&#8212;that is, the same value as the <em>sig</em> argument to the handler.</p>
<p class="term"><em>si_code</em></p>
<p class="termlist">This field is set for all signals. It contains a code providing further information about the origin of the signal, as shown in <a href="ch21.xhtml#ch21table2">Table 21-2</a>.</p>
<p class="term"><em>si_value</em></p>
<p class="termlist">This field contains the accompanying data for a signal sent via <em>sigqueue()</em>. We describe <em>sigqueue()</em> in <a href="ch22.xhtml#ch22lev2sec01">Section 22.8.1</a>.</p>
<p class="term"><em>si_pid</em></p>
<p class="termlist">For signals sent via <em>kill()</em> or <em>sigqueue()</em>, this field is set to the process ID of the sending process.</p>
<p class="term"><em>si_uid</em></p>
<p class="termlist">For signals sent via <em>kill()</em> or <em>sigqueue()</em>, this field is set to the real user ID of the sending process. The system provides the real user ID of the sending process because that is more informative than providing the effective user ID. Consider the permission rules for sending signals described in <a href="ch20.xhtml#ch20lev1sec05">Section 20.5</a>: if the effective user ID grants the sender permission to send the signal, then that user ID must either be 0 (i.e., a privileged process), or be the same as the real user ID or saved set-user-ID of the receiving process. In this case, it could be useful for the receiver to know the sender&#8217;s real user ID, which may be different from the effective user ID (e.g., if the sender is a set-user-ID program).</p>
<p class="term"><em>si_errno</em></p>
<p class="termlist">If this field is set to a nonzero value, then it contains an error number (like <em>errno</em>) that identifies the cause of the signal. This field is generally unused on Linux.</p>
<p class="term"><em>si_addr</em></p>
<p class="termlist">This field is set only for hardware-generated <span class="literal">SIGBUS</span>, <span class="literal">SIGSEGV</span>, <span class="literal">SIGILL</span>, and <span class="literal">SIGFPE</span> signals. For the <span class="literal">SIGBUS</span> and <span class="literal">SIGSEGV</span> signals, this field contains the address that caused the invalid memory reference. For the <span class="literal">SIGILL</span> and <span class="literal">SIGFPE</span> signals, this field contains the address of the program instruction that caused the signal.</p>
<p class="noindenttb">The following fields, which are nonstandard Linux extensions, are set only on the delivery of a signal generated on expiration of a POSIX timer (see <a href="ch23.xhtml#ch23lev1sec06">Section 23.6</a>):</p>
<p class="term"><em>si_timerid</em></p>
<p class="termlist">This field contains an ID that the kernel uses internally to identify the timer.</p>
<p class="term"><em>si_overrun</em></p>
<p class="termlist">This field is set to the overrun count for the timer.</p>
<p class="noindenttb"><span epub:type="pagebreak" id="page_440"/>The following two fields are set only for the delivery of a <span class="literal">SIGIO</span> signal (<a href="ch63.xhtml#ch63lev1sec03">Section 63.3</a>):</p>
<p class="term"><em>si_band</em></p>
<p class="termlist">This field contains the &#8220;band event&#8221; value associated with the I/O event. (In versions of <em>glibc</em> up until 2.3.2, <em>si_band</em> was typed as <em>int</em>.)</p>
<p class="term"><em>si_fd</em></p>
<p class="termlist">This field contains the number of the file descriptor associated with the I/O event. This field is not specified in SUSv3, but it is present on many other implementations.</p>
<p class="noindenttb">The following fields are set only for the delivery of a <span class="literal">SIGCHLD</span> signal (<a href="ch26.xhtml#ch26lev1sec03">Section 26.3</a>):</p>
<p class="term"><em>si_status</em></p>
<p class="termlist">This field contains either the exit status of the child (if <em>si_code</em> is <span class="literal">CLD_EXITED</span>) or the number of the signal sent to the child (i.e., the number of the signal that terminated or stopped the child, as described in <a href="ch26.xhtml#ch26lev2sec03">Section 26.1.3</a>).</p>
<p class="term"><em>si_utime</em></p>
<p class="termlist">This field contains the user CPU time used by the child process. In kernels before 2.6, and since 2.6.27, this is measured in system clock ticks (divide by <em>sysconf(_SC_CLK_TCK)</em>). In 2.6 kernels before 2.6.27, a bug meant that this field reported times measured in (user-configurable) jiffies (see <a href="ch10.xhtml#ch10lev1sec06">Section 10.6</a>). This field is not specified in SUSv3, but it is present on many other implementations.</p>
<p class="term"><em>si_stime</em></p>
<p class="termlist">This field contains the system CPU time used by the child process. See the description of the <em>si_utime</em> field. This field is not specified in SUSv3, but it is present on many other implementations.</p>
<p class="noindentt">The <em>si_code</em> field provides further information about the origin of the signal, using the values shown in <a href="ch21.xhtml#ch21table2">Table 21-2</a>. Not all of the signal-specific values shown in the second column of this table occur on all UNIX implementations and hardware architectures (especially in the case of the four hardware-generated signals <span class="literal">SIGBUS</span>, <span class="literal">SIGSEGV</span>, <span class="literal">SIGILL</span>, and <span class="literal">SIGFPE</span>), although all of these constants are defined on Linux and most appear in SUSv3.</p>
<p class="indentb">Note the following additional points about the values shown in <a href="ch21.xhtml#ch21table2">Table 21-2</a>:</p>
<p class="bull">&#8226; The values <span class="literal">SI_KERNEL</span> and <span class="literal">SI_SIGIO</span> are Linux-specific. They are not specified in SUSv3 and do not appear on other UNIX implementations.</p>
<p class="bull">&#8226; <span class="literal">SI_SIGIO</span> is employed only in Linux 2.2. From kernel 2.4 onward, Linux instead employs the <span class="literal">POLL_*</span> constants shown in the table.</p>
<div class="block1">
<p class="noindent">SUSv4 specifies the <em>psiginfo()</em> function, whose purpose is similar to <em>psignal()</em> (<a href="ch20.xhtml#ch20lev1sec08">Section 20.8</a>). The <em>psiginfo()</em> function takes two arguments: a pointer to a <em>siginfo_t</em> structure and a message string. It prints the message string on standard error, followed by information about the signal described in the <em>siginfo_t</em> structure. The <em>psiginfo()</em> function is provided by <em>glibc</em> since version 2.10. The <em>glibc</em> implementation prints the signal description, the origin of the signal (as indicated by the <em>si_code</em> field), and, for some signals, other fields from the <em>siginfo_t</em> structure. The <em>psiginfo()</em> function is new in SUSv4, and it is not available on all systems.</p>
</div>
<p class="tablecap"><span epub:type="pagebreak" id="page_441"/><a id="ch21table2"/><strong>Table 21-2:</strong> Values returned in the <em>si_code</em> field of the <em>siginfo_t</em> structure</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Signal</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><em>si_code</em> value</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Origin of signal</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Any</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SI_ASYNCIO</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Completion of an asynchronous I/O (AIO) operation</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SI_KERNEL</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Sent by the kernel (e.g., a signal from terminal driver)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SI_MESGQ</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Message arrival on POSIX message queue (since Linux 2.6.6)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SI_QUEUE</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">A realtime signal from a user process via <em>sigqueue()</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SI_SIGIO</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">SIGIO</span> signal (Linux 2.2 only)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SI_TIMER</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Expiration of a POSIX (realtime) timer</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SI_TKILL</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">A user process via <em>tkill()</em> or <em>tgkill()</em> (since Linux 2.4.19)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">SI_USER</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">A user process via <em>kill()</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGBUS</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">BUS_ADRALN</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Invalid address alignment</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">BUS_ADRERR</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Nonexistent physical address</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">BUS_MCEERR_AO</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Hardware memory error; action optional (since Linux 2.6.32)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">BUS_MCEERR_AR</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Hardware memory error; action required (since Linux 2.6.32)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">BUS_OBJERR</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Object-specific hardware error</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGCHLD</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLD_CONTINUED</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Child continued by <span class="literal">SIGCONT</span> (since Linux 2.6.9)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLD_DUMPED</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Child terminated abnormally, with core dump</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLD_EXITED</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Child exited</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLD_KILLED</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Child terminated abnormally, without core dump</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLD_STOPPED</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Child stopped</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">CLD_TRAPPED</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Traced child has stopped</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGFPE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">FPE_FLTDIV</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Floating-point divide-by-zero</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">FPE_FLTINV</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Invalid floating-point operation</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">FPE_FLTOVF</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Floating-point overflow</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">FPE_FLTRES</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Floating-point inexact result</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">FPE_FLTUND</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Floating-point underflow</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">FPE_INTDIV</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Integer divide-by-zero</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">FPE_INTOVF</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Integer overflow</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">FPE_SUB</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Subscript out of range</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGILL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ILL_BADSTK</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Internal stack error</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ILL_COPROC</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Coprocessor error</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ILL_ILLADR</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Illegal addressing mode</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ILL_ILLOPC</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Illegal opcode</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ILL_ILLOPN</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Illegal operand</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ILL_ILLTRP</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Illegal trap</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ILL_PRVOPC</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Privileged opcode</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">ILL_PRVREG</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Privileged register</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGPOLL</span>/<span class="literal">SIGIO</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLL_ERR</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">I/O error</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLL_HUP</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Device disconnected</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLL_IN</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Input data available</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLL_MSG</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Input message available</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLL_OUT</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Output buffers available</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">POLL_PRI</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">High-priority input available</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGSEGV</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SEGV_ACCERR</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Invalid permissions for mapped object</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">SEGV_MAPERR</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Address not mapped to object</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGTRAP</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">TRAP_BRANCH</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span epub:type="pagebreak" id="page_442"/>Process branch trap</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">TRAP_BRKPT</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Process breakpoint</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">TRAP_HWBKPT</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Hardware breakpoint/watchpoint</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">TRAP_TRACE</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Process trace trap</p></td>
</tr>
</tbody>
</table>
<h5 class="h5" id="ch21lev3sec08"><strong>The <em>ucontext</em> argument</strong></h5>
<p class="noindenta">The final argument passed to a handler established with the <span class="literal">SA_SIGINFO</span> flag, <em>ucontext</em>, is a pointer to a structure of type <em>ucontext_t</em> (defined in <span class="literal">&lt;ucontext.h&gt;</span>). (SUSv3 uses a <em>void</em> pointer for this argument because it doesn&#8217;t specify any of the details of the argument.) This structure provides so-called user-context information describing the process state prior to invocation of the signal handler, including the previous process signal mask and saved register values (e.g., program counter and stack pointer). This information is rarely used in signal handlers, so we don&#8217;t go into further details.</p>
<div class="block">
<p class="noindent">Another use of <em>ucontext_t</em> structures is with the functions <em>getcontext()</em>, <em>makecontext()</em>, <em>setcontext()</em>, and <em>swapcontext()</em>, which allow a process to retrieve, create, change, and swap execution contexts, respectively. (These operations are somewhat like <em>setjmp()</em> and <em>longjmp()</em>, but more general.) These functions can be used to implement coroutines, where the thread of execution of a process alternates between two (or more) functions. SUSv3 specifies these functions, but marks them obsolete. SUSv4 removes the specifications, and suggests that applications should be rewritten to use POSIX threads instead. The <em>glibc</em> manual provides further information about these functions.</p>
</div>
<h3 class="h3" id="ch21lev1sec05"><strong>21.5 Interruption and Restarting of System Calls</strong></h3>
<p class="noindenta">Consider the following scenario:</p>
<ol>
<li class="order"><p class="orderp">We establish a handler for some signal.</p></li>
<li class="order"><p class="orderp">We make a blocking system call, for example, a <em>read()</em> from a terminal device, which blocks until input is supplied.</p></li>
<li class="order"><p class="orderp">While the system call is blocked, the signal for which we established a handler is delivered, and its signal handler is invoked.</p></li>
</ol>
<p class="noindent">What happens after the signal handler returns? By default, the system call fails with the error <span class="literal">EINTR</span> (&#8220;Interrupted function&#8221;). This can be a useful feature. In <a href="ch23.xhtml#ch23lev1sec03">Section 23.3</a>, we&#8217;ll see how to use a timer (which results in the delivery of a <span class="literal">SIGALRM</span> signal) to set a timeout on a blocking system call such as <em>read()</em>.</p>
<p class="indent">Often, however, we would prefer to continue the execution of an interrupted system call. To do this, we could use code such as the following to manually restart a system call in the event that it is interrupted by a signal handler:</p>
<p class="programs">while ((cnt = read(fd, buf, BUF_SIZE)) == -1 &#38;&#38; errno == EINTR)<br/>&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Do nothing loop body */<br/><br/>if (cnt == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* read() failed with other than EINTR */<br/>&#160;&#160;&#160;&#160;errExit("read");</p>
<p class="noindent"><span epub:type="pagebreak" id="page_443"/>If we frequently write code such as the above, it can be useful to define a macro such as the following:</p>
<p class="programs">#define NO_EINTR(stmt) while ((stmt) == -1 &#38;&#38; errno == EINTR);</p>
<p class="noindent">Using this macro, we can rewrite the earlier <em>read()</em> call as follows:</p>
<p class="programs">NO_EINTR(cnt = read(fd, buf, BUF_SIZE));<br/><br/>if (cnt == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* read() failed with other than EINTR */<br/>&#160;&#160;&#160;&#160;errExit("read");</p>
<div class="block">
<p class="noindent">The GNU C library provides a (nonstandard) macro with the same purpose as our <span class="literal">NO_EINTR()</span> macro in <span class="literal">&lt;unistd.h&gt;</span>. The macro is called <span class="literal">TEMP_FAILURE_RETRY()</span> and is made available if the <span class="literal">_GNU_SOURCE</span> feature test macro is defined.</p>
</div>
<p class="noindent">Even if we employ a macro like <span class="literal">NO_EINTR()</span>, having signal handlers interrupt system calls can be inconvenient, since we must add code to each blocking system call (assuming that we want to restart the call in each case). Instead, we can specify the <span class="literal">SA_RESTART</span> flag when establishing the signal handler with <em>sigaction()</em>, so that system calls are automatically restarted by the kernel on the process&#8217;s behalf. This means that we don&#8217;t need to handle a possible <span class="literal">EINTR</span> error return for these system calls.</p>
<p class="indent">The <span class="literal">SA_RESTART</span> flag is a per-signal setting. In other words, we can allow handlers for some signals to interrupt blocking system calls, while others permit automatic restarting of system calls.</p>
<h5 class="h5" id="ch21lev3sec09"><strong>System calls (and library functions) for which</strong> <span class="literal"><span class="codestrong">SA_RESTART</span></span> <strong>is effective</strong></h5>
<p class="noindentab">Unfortunately, not all blocking system calls automatically restart as a result of specifying <span class="literal">SA_RESTART</span>. The reasons for this are partly historical:</p>
<p class="bull">&#8226; Restarting of system calls was introduced in 4.2BSD, and covered interrupted calls to <em>wait()</em> and <em>waitpid()</em>, as well as the following I/O system calls: <em>read()</em>, <em>readv()</em>, <em>write()</em>, <em>writev()</em>, and blocking <em>ioctl()</em> operations. The I/O system calls are interruptible, and hence automatically restarted by <span class="literal">SA_RESTART</span>, only when operating on a &#8220;slow&#8221; device. Slow devices include terminals, pipes, FIFOs, and sockets. On these file types, various I/O operations may block. (By contrast, disk files don&#8217;t fall into the category of slow devices, because disk I/O operations generally can be immediately satisfied via the buffer cache. If a disk I/O is required, the kernel puts the process to sleep until the I/O completes.)</p>
<p class="bull">&#8226; A number of other blocking system calls are derived from System V, which did not initially provide for restarting of system calls.</p>
<p class="noindenttb">On Linux, the following blocking system calls (and library functions layered on top of system calls) are automatically restarted if interrupted by a signal handler established using the <span class="literal">SA_RESTART</span> flag:</p>
<p class="bull">&#8226; The system calls used to wait for a child process (<a href="ch26.xhtml#ch26lev1sec01">Section 26.1</a>): <em>wait()</em>, <em>waitpid()</em>, <em>wait3()</em>, <em>wait4()</em>, and <em>waitid()</em>.</p>
<p class="bull">&#8226; The I/O system calls <em>read()</em>, <em>readv()</em>, <em>write()</em>, <em>writev()</em>, and <em>ioctl()</em> when applied to &#8220;slow&#8221; devices. In cases where data has already been partially transferred at the <span epub:type="pagebreak" id="page_444"/>time of signal delivery, the input and output system calls will be interrupted, but return a success status: an integer indicating how many bytes were successfully transferred.</p>
<p class="bull">&#8226; The <em>open()</em> system call, in cases where it can block (e.g., when opening FIFOs, as described in <a href="ch44.xhtml#ch44lev1sec07">Section 44.7</a>).</p>
<p class="bull">&#8226; Various system calls used with sockets: <em>accept()</em>, <em>accept4()</em>, <em>connect()</em>, <em>send()</em>, <em>sendmsg()</em>, <em>sendto()</em>, <em>recv()</em>, <em>recvfrom()</em>, and <em>recvmsg()</em>. (On Linux, these system calls are not automatically restarted if a timeout has been set on the socket using <em>setsockopt()</em>. See the <em>signal(7)</em> manual page for details.)</p>
<p class="bull">&#8226; The system calls used for I/O on POSIX message queues: <em>mq_receive()</em>, <em>mq_timedreceive()</em>, <em>mq_send()</em>, and <em>mq_timedsend()</em>.</p>
<p class="bull">&#8226; The system calls and library functions used to place file locks: <em>flock()</em>, <em>fcntl()</em>, and <em>lockf()</em>.</p>
<p class="bull">&#8226; The <span class="literal">FUTEX_WAIT</span> operation of the Linux-specific <em>futex()</em> system call.</p>
<p class="bull">&#8226; The <em>sem_wait()</em> and <em>sem_timedwait()</em> functions used to decrement a POSIX semaphore. (On some UNIX implementations, <em>sem_wait() is</em> restarted if the <span class="literal">SA_RESTART</span> flag is specified.)</p>
<p class="bull">&#8226; The functions used to synchronize POSIX threads: <em>pthread_mutex_lock()</em>, <em>pthread_mutex_trylock()</em>, <em>pthread_mutex_timedlock()</em>, <em>pthread_cond_wait()</em>, and <em>pthread_cond_timedwait()</em>.</p>
<p class="noindentt">In kernels before 2.6.22, <em>futex()</em>, <em>sem_wait()</em>, and <em>sem_timedwait()</em> always failed with the error <span class="literal">EINTR</span> when interrupted, regardless of the setting of the <span class="literal">SA_RESTART</span> flag.</p>
<p class="indentb">The following blocking system calls (and library functions layered on top of system calls) are never automatically restarted (even if <span class="literal">SA_RESTART</span> is specified):</p>
<p class="bull">&#8226; The <em>poll()</em>, <em>ppoll()</em>, <em>select()</em>, and <em>pselect()</em> I/O multiplexing calls. (SUSv3 explicitly states that the behavior of <em>select()</em> and <em>pselect()</em> when interrupted by a signal handler is unspecified, regardless of the setting of <span class="literal">SA_RESTART</span>.)</p>
<p class="bull">&#8226; The Linux-specific <em>epoll_wait()</em> and <em>epoll_pwait()</em> system calls.</p>
<p class="bull">&#8226; The Linux-specific <em>io_getevents()</em> system call.</p>
<p class="bull">&#8226; The blocking system calls used with System V message queues and semaphores: <em>semop()</em>, <em>semtimedop()</em>, <em>msgrcv()</em>, and <em>msgsnd()</em>. (Although System V did not originally provide automatic restarting of system calls, on some UNIX implementations, these system calls <em>are</em> restarted if the <span class="literal">SA_RESTART</span> flag is specified.)</p>
<p class="bull">&#8226; A <em>read()</em> from an <em>inotify</em> file descriptor.</p>
<p class="bull">&#8226; The system calls and library functions designed to suspend execution of a program for a specified period: <em>sleep()</em>, <em>nanosleep()</em>, and <em>clock_nanosleep()</em>.</p>
<p class="bull">&#8226; The system calls designed specifically to wait until a signal is delivered: <em>pause()</em>, <em>sigsuspend()</em>, <em>sigtimedwait()</em>, and <em>sigwaitinfo()</em>.</p>
<h5 class="h5" id="ch21lev3sec10"><strong>Modifying the</strong> <span class="literal"><span class="codestrong">SA_RESTART</span></span> <strong>flag for a signal</strong></h5>
<p class="noindenta">The <em>siginterrupt()</em> function changes the <span class="literal">SA_RESTART</span> setting associated with a signal.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_445"/>#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">siginterrupt</span>(int <span class="font1">sig</span>, int <span class="font1">flag</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">If <em>flag</em> is true (1), then a handler for the signal <em>sig</em> will interrupt blocking system calls. If <em>flag</em> is false (0), then blocking system calls will be restarted after execution of a handler for <em>sig</em>.</p>
<p class="indent">The <em>siginterrupt()</em> function works by using <em>sigaction()</em> to fetch a copy of the signal&#8217;s current disposition, tweaking the <span class="literal">SA_RESTART</span> flag in the returned <em>oldact</em> structure, and then calling <em>sigaction()</em> once more to update the signal&#8217;s disposition.</p>
<p class="indent">SUSv4 marks <em>siginterrupt()</em> obsolete, recommending the use of <em>sigaction()</em> instead for this purpose.</p>
<h5 class="h5" id="ch21lev3sec11"><strong>Unhandled stop signals can generate</strong> <span class="literal"><span class="codestrong">EINTR</span></span> <strong>for some Linux system calls</strong></h5>
<p class="noindenta">On Linux, certain blocking system calls can return <span class="literal">EINTR</span> even in the absence of a signal handler. This can occur if the system call is blocked and the process is stopped by a signal (<span class="literal">SIGSTOP</span>, <span class="literal">SIGTSTP</span>, <span class="literal">SIGTTIN</span>, or <span class="literal">SIGTTOU</span>), and then resumed by delivery of a <span class="literal">SIGCONT</span> signal.</p>
<p class="indent">The following system calls and functions exhibit this behavior: <em>epoll_pwait()</em>, <em>epoll_wait()</em>, <em>read()</em> from an <em>inotify</em> file descriptor, <em>semop()</em>, <em>semtimedop()</em>, <em>sigtimedwait()</em>, and <em>sigwaitinfo()</em>.</p>
<p class="indent">In kernels before 2.6.24, <em>poll()</em> also exhibited this behavior, as did <em>sem_wait()</em>, <em>sem_timedwait()</em>, <em>futex(FUTEX_WAIT)</em>, in kernels before 2.6.22, <em>msgrcv()</em> and <em>msgsnd()</em> in kernels before 2.6.9, and <em>nanosleep()</em> in Linux 2.4 and earlier.</p>
<p class="indent">In Linux 2.4 and earlier, <em>sleep()</em> can also be interrupted in this manner, but, instead of returning an error, it returns the number of remaining unslept seconds.</p>
<p class="indent">The upshot of this behavior is that if there is a chance that our program may be stopped and restarted by signals, then we may need to include code to restart these system calls, even in a program that doesn&#8217;t install handlers for the stop signals.</p>
<h3 class="h3" id="ch21lev1sec06"><strong>21.6 Summary</strong></h3>
<p class="noindenta">In this chapter, we considered a range of factors that affect the operation and design of signal handlers.</p>
<p class="indent">Because signals are not queued, a signal handler must sometimes be coded to deal with the possibility that multiple events of a particular type have occurred, even though only one signal was delivered. The issue of reentrancy affects how we can update global variables and limits the set of functions that we can safely call from a signal handler.</p>
<p class="indent">Instead of returning, a signal handler can terminate in a variety of other ways, including calling <em>_exit()</em>, terminating the process by sending a signal (<em>kill()</em>, <em>raise()</em>, or <em>abort()</em>), or performing a nonlocal goto. Using <em>sigsetjmp()</em> and <em>siglongjmp()</em> provides a program with explicit control of the treatment of the process signal mask when a nonlocal goto is performed.</p>
<p class="indent"><span epub:type="pagebreak" id="page_446"/>We can use <em>sigaltstack()</em> to define an alternate signal stack for a process. This is an area of memory that is used instead of the standard process stack when invoking a signal handler. An alternate signal stack is useful in cases where the standard stack has been exhausted by growing too large (at which point the kernel sends a <span class="literal">SIGSEGV</span> signal to the process).</p>
<p class="indent">The <em>sigaction()</em> <span class="literal">SA_SIGINFO</span> flag allows us to establish a signal handler that receives additional information about a signal. This information is supplied via a <em>siginfo_t</em> structure whose address is passed as an argument to the signal handler.</p>
<p class="indent">When a signal handler interrupts a blocked system call, the system call fails with the error <span class="literal">EINTR</span>. We can take advantage of this behavior to, for example, set a timer on a blocking system call. Interrupted system calls can be manually restarted if desired. Alternatively, establishing the signal handler with the <em>sigaction()</em> <span class="literal">SA_RESTART</span> flag causes many (but not all) system calls to be automatically restarted.</p>
<h5 class="h5" id="ch21lev3sec12"><strong>Further information</strong></h5>
<p class="noindenta">See the sources listed in <a href="ch20.xhtml#ch20lev1sec15">Section 20.15</a>.</p>
<h3 class="h3" id="ch21lev1sec07"><strong>21.7 Exercise</strong></h3>
<p class="exer"><a id="ch21exe1"/><strong>21-1.</strong>&#160;&#160;&#160;Implement <em>abort()</em>.</p>
</body>
</html>
