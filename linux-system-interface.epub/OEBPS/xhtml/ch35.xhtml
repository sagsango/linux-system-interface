<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch35"><span epub:type="pagebreak" id="page_733"/><strong><span class="big">35</span></strong><br/><strong>PROCESS PRIORITIES AND SCHEDULING</strong></h2>
<p class="noindenta">This chapter discusses various system calls and process attributes that determine when and which processes obtain access to the CPU(s). We begin by describing the <em>nice</em> value, a process characteristic that influences the amount of CPU time that a process is allocated by the kernel scheduler. We follow this with a description of the POSIX realtime scheduling API. This API allows us to define the policy and priority used for scheduling processes, giving us much tighter control over how processes are allocated to the CPU. We conclude with a discussion of the system calls for setting a process&#8217;s CPU affinity mask, which determines the set of CPUs on which a process running on a multiprocessor system will run.</p>
<h3 class="h3" id="ch35lev1sec01"><strong>35.1 Process Priorities (Nice Values)</strong></h3>
<p class="noindentab">On Linux, as with most other UNIX implementations, the default model for scheduling processes for use of the CPU is <em>round-robin time-sharing</em>. Under this model, each process in turn is permitted to use the CPU for a brief period of time, known as a <em>time slice</em> or <em>quantum</em>. Round-robin time-sharing satisfies two important requirements of an interactive multitasking system:</p>
<p class="bull">&#8226; <em>Fairness</em>: Each process gets a share of the CPU.</p>
<p class="bull">&#8226; <em>Responsiveness</em>: A process doesn&#8217;t need to wait for long periods before it receives use of the CPU.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_734"/>Under the round-robin time-sharing algorithm, processes can&#8217;t exercise direct control over when and for how long they will be able to use the CPU. By default, each process in turn receives use of the CPU until its time slice runs out or it voluntarily gives up the CPU (for example, by putting itself to sleep or performing a disk read). If all processes attempt to use the CPU as much as possible (i.e., no process ever sleeps or blocks on an I/O operation), then they will receive a roughly equal share of the CPU.</p>
<p class="indent">However, one process attribute, the <em>nice value</em>, allows a process to indirectly influence the kernel&#8217;s scheduling algorithm. Each process has a nice value in the range &#8211;20 (high priority) to +19 (low priority); the default is 0 (refer to <a href="ch35.xhtml#ch35fig1">Figure 35-1</a>). In traditional UNIX implementations, only privileged processes can assign themselves (or other processes) a negative (high) priority. (We&#8217;ll explain some Linux differences in <a href="ch35.xhtml#ch35lev2sec05">Section 35.3.2</a>.) Unprivileged processes can only lower their priority, by assuming a nice value greater than the default of 0. By doing this, they are being &#8220;nice&#8221; to other processes, and this fact gives the attribute its name.</p>
<p class="indent">The nice value is inherited by a child created via <em>fork()</em> and preserved across an <em>exec()</em>.</p>
<div class="block">
<p class="noindent">Rather than returning the actual nice value, the <em>getpriority()</em> system call service routine returns a number in the range 1 (low priority) to 40 (high priority), calculated according to the formula <em>unice = 20 &#8211; knice</em>. This is done to avoid having a negative return value from a system call service routine, which is used to indicate an error. (See the description of system call service routines in <a href="ch03.xhtml#ch03lev1sec01">Section 3.1</a>.) Applications are unaware of the manipulated value returned by the system call service routine, since the C library <em>getpriority()</em> wrapper function reverses the calculation, returning the value <em>20 &#8211; unice</em> to the calling program.</p>
</div>
<div class="image"><img src="../images/f35-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch35fig1"/><strong>Figure 35-1:</strong> Range and interpretation of the process nice value</p>
<h5 class="h5" id="ch35lev3sec01"><strong>Effect of the nice value</strong></h5>
<p class="noindenta">Processes are not scheduled in a strict hierarchy by nice value; rather, the nice value acts as weighting factor that causes the kernel scheduler to favor processes with higher priorities. Giving a process a low priority (i.e., high nice value) won&#8217;t cause it to be completely starved of the CPU, but causes it to receive relatively less CPU time. The extent to which the nice value influences the scheduling of a process has varied across Linux kernel versions, as well as across UNIX systems.</p>
<div class="block">
<p class="noindent">Starting in kernel 2.6.23, a new kernel scheduling algorithm means that relative differences in nice values have a much stronger effect than in previous kernels. As a result, processes with low priorities receive less CPU than before, and processes with high priorities obtain a greater proportion of the CPU.</p>
</div>
<h5 class="h5" id="ch35lev3sec02"><span epub:type="pagebreak" id="page_735"/><strong>Retrieving and modifying priorities</strong></h5>
<p class="noindenta">The <em>getpriority()</em> and <em>setpriority()</em> system calls allow a process to retrieve and change its own nice value or that of another process.</p>
<div class="box">
<p class="programsa">#include &lt;sys/resource.h&gt;<br/><br/>int <span class="codestrong">getpriority</span>(int <span class="font1">which</span>, id_t <span class="font1">who</span>);</p>
<p class="right">Returns (possibly negative) nice value of specified process on success, or &#8211;1 on error</p>
<p class="programsat">int <span class="codestrong">setpriority</span>(int <span class="font1">which</span>, id_t <span class="font1">who</span>, int <span class="font1">prio</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb">Both system calls take the arguments <em>which</em> and <em>who</em>, identifying the process(es) whose priority is to be retrieved or modified. The <em>which</em> argument determines how <em>who</em> is interpreted. This argument takes one of the following values:</p>
<p class="term"><span class="literal">PRIO_PROCESS</span></p>
<p class="termlist">Operate on the process whose process ID equals <em>who</em>. If <em>who</em> is 0, use the caller&#8217;s process ID.</p>
<p class="term"><span class="literal">PRIO_PGRP</span></p>
<p class="termlist">Operate on all of the members of the process group whose process group ID equals <em>who</em>. If <em>who</em> is 0, use the caller&#8217;s process group.</p>
<p class="term"><span class="literal">PRIO_USER</span></p>
<p class="termlist">Operate on all processes whose real user ID equals <em>who</em>. If <em>who</em> is 0, use the caller&#8217;s real user ID.</p>
<p class="noindentt">The <em>id_t</em> data type, used for the <em>who</em> argument, is an integer type of sufficient size to accommodate a process ID or a user ID.</p>
<p class="indent">The <em>getpriority()</em> system call returns the nice value of the process specified by <em>which</em> and <em>who</em>. If multiple processes match the criteria specified (which may occur if <em>which</em> is <span class="literal">PRIO_PGRP</span> or <span class="literal">PRIO_USER</span>), then the nice value of the process with the highest priority (i.e., lowest numerical value) is returned. Since <em>getpriority()</em> may legitimately return a value of &#8211;1 on a successful call, we must test for an error by setting <em>errno</em> to 0 prior to the call, and then checking for a &#8211;1 return status and a nonzero <em>errno</em> value after the call.</p>
<p class="indent">The <em>setpriority()</em> system call sets the nice value of the process(es) specified by <em>which</em> and <em>who</em> to the value specified in <em>prio</em>. Attempts to set a nice value to a number outside the permitted range (&#8211;20 to +19) are silently bounded to this range.</p>
<div class="block">
<p class="noindent">Historically, the nice value was changed using the call <em>nice(incr)</em>, which added <em>incr</em> to the calling process&#8217;s nice value. This function is still available, but it is superseded by the more general <em>setpriority()</em> system call.</p>
<p class="indent">The command-line analogs of <em>setpriority()</em> are <em>nice(1)</em>, which can be used by unprivileged users to run a command with a lower priority or by privileged users to run a command with a raised priority, and <em>renice(8)</em>, which can be used by the superuser to change the nice value of an existing process.</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_736"/>A privileged (<span class="literal">CAP_SYS_NICE</span>) process can change the priority of any process. An unprivileged process may change its own priority (by specifying <em>which</em> as <span class="literal">PRIO_PROCESS</span>, and <em>who</em> as 0) or the priority of another (target) process, if its effective user ID matches the real or effective user ID of the target process. The Linux permission rules for <em>setpriority()</em> differ from SUSv3, which specifies that an unprivileged process can change the priority of another process if its real or effective user ID matches the effective user ID of the target process. UNIX implementations show some variation on this point. Some follow the SUSv3 rules, but others&#8212;notably the BSDs&#8212;behave in the same way as Linux.</p>
<div class="block">
<p class="noindent">In Linux kernels before 2.6.12, the permission rules for calls to <em>setpriority()</em> by unprivileged processes are different from later kernels (and also deviate from SUSv3). An unprivileged process can change the priority of another process if its real or effective user ID matches the real user ID of the target process. From Linux 2.6.12 onward, the permissions checks were changed to be consistent with other similar APIs available on Linux, such as <em>sched_setscheduler()</em> and <em>sched_setaffinity()</em>.</p>
</div>
<p class="noindent">In Linux kernels before 2.6.12, an unprivileged process may use <em>setpriority()</em> only to (irreversibly) lower its own or another process&#8217;s priority. A privileged (<span class="literal">CAP_SYS_NICE</span>) process can use <em>setpriority()</em> to raise priorities.</p>
<p class="indent">Since kernel 2.6.12, Linux provides the <span class="literal">RLIMIT_NICE</span> resource limit, which permits unprivileged processes to raise priorities. An unprivileged process can set its own nice value to the maximum specified by the formula <em>20 &#8211; rlim_cur</em>, where <em>rlim_cur</em> is the current <span class="literal">RLIMIT_NICE</span> soft resource limit. As an example, if a process&#8217;s <span class="literal">RLIMIT_NICE</span> soft limit is 25, then its nice value can be set to &#8211;5. From this formula, and the knowledge that the nice value has the range +19 (low) to &#8211;20 (high), we can deduce that the effectively useful range of the <span class="literal">RLIMIT_NICE</span> limit is 1 (low) to 40 (high). (<span class="literal">RLIMIT_NICE</span> doesn&#8217;t use the number range +19 to &#8211;20 because some negative resource-limit values have special meanings&#8212;for example, <span class="literal">RLIM_INFINITY</span> has the same representation as &#8211;1.)</p>
<p class="indent">An unprivileged process can make a <em>setpriority()</em> call to change the nice value of another (target) process, if the effective user ID of the process calling <em>setpriority()</em> matches the real or effective user ID of the target process, and the change to the nice value is consistent with the target process&#8217;s <span class="literal">RLIMIT_NICE</span> limit.</p>
<p class="indent">The program in <a href="ch35.xhtml#ch35ex1">Listing 35-1</a> uses <em>setpriority()</em> to change the nice value of the process(es) specified by its command-line arguments (which correspond to the arguments of <em>setpriority()</em>), and then calls <em>getpriority()</em> to verify the change.</p>
<p class="examplet"><a id="ch35ex1"/><strong>Listing 35-1:</strong> Modifying and retrieving a process&#8217;s nice value</p>
<p class="programsli">___________________________________________________ <span class="codestrong">procpri/t_setpriority.c</span><br/><br/>#include &lt;sys/time.h&gt;<br/>#include &lt;sys/resource.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int which, prio;<br/>&#160;&#160;&#160;&#160;id_t who;<br/>&#160;&#160;&#160;&#160;if (argc != 4 || strchr("pgu", argv[1][0]) == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s {p|g|u} who priority\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"&#160;&#160;&#160;&#160;set priority of: p=process; g=process group; "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"u=processes for user\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;/* Set nice value according to command-line arguments */<br/><br/>&#160;&#160;&#160;&#160;which = (argv[1][0] == 'p') ? PRIO_PROCESS :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(argv[1][0] == 'g') ? PRIO_PGRP : PRIO_USER;<br/>&#160;&#160;&#160;&#160;who = getLong(argv[2], 0, "who");<br/>&#160;&#160;&#160;&#160;prio = getInt(argv[3], 0, "prio");<br/><br/>&#160;&#160;&#160;&#160;if (setpriority(which, who, prio) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("setpriority");<br/><br/>&#160;&#160;&#160;&#160;/* Retrieve nice value to check the change */<br/><br/>&#160;&#160;&#160;&#160;errno = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Because successful call may return -1 */<br/>&#160;&#160;&#160;&#160;prio = getpriority(which, who);<br/>&#160;&#160;&#160;&#160;if (prio == -1 &#38;&#38; errno != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("getpriority");<br/><br/>&#160;&#160;&#160;&#160;printf("Nice value = %d\n", prio);<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>___________________________________________________ <span class="codestrong">procpri/t_setpriority.c</span></p>
<h3 class="h3" id="ch35lev1sec02"><span epub:type="pagebreak" id="page_737"/><strong>35.2 Overview of Realtime Process Scheduling</strong></h3>
<p class="noindentab">The standard kernel scheduling algorithm usually provides adequate performance and responsiveness for the mixture of interactive and background processes typically run on a system. However, realtime applications have more stringent requirements of a scheduler, including the following:</p>
<p class="bull">&#8226; A realtime application must provide a guaranteed maximum response time for external inputs. In many cases, these guaranteed maximum response times must be quite small (e.g., of the order of a fraction of a second). For example, a slow response by a vehicle navigation system could be catastrophic. To satisfy this requirement, the kernel must provide the facility for a high-priority process to obtain control of the CPU in a timely fashion, preempting any process that may currently be running.</p>
<div class="block">
<p class="noindent">A time-critical application may need to take other steps to avoid unacceptable delays. For example, to avoid being delayed by a page fault, an application can lock all of its virtual memory into RAM using <em>mlock()</em> or <em>mlockall()</em> (described in <a href="ch50.xhtml#ch50lev1sec02">Section 50.2</a>).</p>
</div>
<p class="bull">&#8226; A high-priority process should be able to maintain exclusive access to the CPU until it completes or voluntarily relinquishes the CPU.</p>
<p class="bull"><span epub:type="pagebreak" id="page_738"/>&#8226; A realtime application should be able to control the precise order in which its component processes are scheduled.</p>
<p class="noindentt">SUSv3 specifies a realtime process scheduling API (originally defined in POSIX.1b) that partly addresses these requirements. This API provides two realtime scheduling policies: <span class="literal">SCHED_RR</span> and <span class="literal">SCHED_FIFO</span>. Processes operating under either of these policies always have priority over processes scheduled using the standard round-robin timesharing policy described in <a href="ch35.xhtml#ch35lev1sec01">Section 35.1</a>, which the realtime scheduling API identifies using the constant <span class="literal">SCHED_OTHER</span>.</p>
<p class="indent">Each of the realtime policies allows for a range of priority levels. SUSv3 requires that an implementation provide at least 32 discrete priorities for the real-time policies. In each scheduling policy, runnable processes with higher priority always have precedence over lower-priority processes when seeking access to the CPU.</p>
<div class="block">
<p class="noindent">The statement that runnable processes with higher priority always have precedence over lower-priority processes needs to be qualified for multiprocessor Linux systems (including hyperthreaded systems). On a multiprocessor system, each CPU has a separate run queue (this provides better performance than a single system-wide run queue), and processes are prioritized only per CPU run queue. For example, on a dual-processor system with three processes, process A with realtime priority 20 could be queued waiting for CPU 0, which is currently running process B with priority 30, even though CPU 1 is running process C with a priority of 10.</p>
<p class="indent">Realtime applications that employ multiple processes (or threads) can use the CPU affinity API described in <a href="ch35.xhtml#ch35lev1sec04">Section 35.4</a> to avoid any problems that might result from this scheduling behavior. For example, on a four-processor system, all noncritical processes could be isolated onto a single CPU, leaving the other three CPUs available for use by the application.</p>
</div>
<p class="noindent">Linux provides 99 realtime priority levels, numbered 1 (lowest) to 99 (highest), and this range applies in both realtime scheduling policies. The priorities in each policy are equivalent. This means that, given two processes with the same priority, one operating under the <span class="literal">SCHED_RR</span> policy and the other under <span class="literal">SCHED_FIFO</span>, either may be the next one eligible for execution, depending on the order in which they were scheduled. In effect, each priority level maintains a queue of runnable processes, and the next process to run is selected from the front of the highest-priority nonempty queue.</p>
<h5 class="h5" id="ch35lev3sec03"><strong>POSIX realtime versus hard realtime</strong></h5>
<p class="noindenta">Applications with all of the requirements listed at the start of this section are sometimes referred to as <em>hard</em> realtime applications. However, the POSIX realtime process scheduling API doesn&#8217;t satisfy all of these requirements. In particular, it provides no way for an application to guarantee response times for handling input. To make such guarantees requires operating system features that are not part of the mainline Linux kernel (nor most other standard operating systems). The POSIX API merely provides us with so-called <em>soft</em> realtime, allowing us to control which processes are scheduled for use of the CPU.</p>
<p class="indent"><span epub:type="pagebreak" id="page_739"/>Adding support for hard realtime applications is difficult to achieve without imposing an overhead on the system that conflicts with the performance requirements of the time-sharing applications that form the majority of applications on typical desktop and server systems. This is why most UNIX kernels&#8212;including, historically, Linux&#8212;have not natively supported realtime applications. Nevertheless, starting from around version 2.6.18, various features have been added to the Linux kernel with the eventual aim of allowing Linux to natively provide full support for hard realtime applications, without imposing the aforementioned overhead for time-sharing operation.</p>
<h4 class="h4" id="ch35lev2sec01"><strong>35.2.1 The</strong> <span class="literal"><span class="codestrong">SCHED_RR</span></span> <strong>Policy</strong></h4>
<p class="noindentab">Under the <span class="literal">SCHED_RR</span> (round-robin) policy, processes of equal priority are executed in a round-robin time-sharing fashion. A process receives a fixed-length time slice each time it uses the CPU. Once scheduled, a process employing the <span class="literal">SCHED_RR</span> policy maintains control of the CPU until either:</p>
<p class="bull">&#8226; it reaches the end of its time slice;</p>
<p class="bull">&#8226; it voluntarily relinquishes the CPU, either by performing a blocking system call or by calling the <em>sched_yield()</em> system call (described in <a href="ch35.xhtml#ch35lev2sec06">Section 35.3.3</a>);</p>
<p class="bull">&#8226; it terminates; or</p>
<p class="bull">&#8226; it is preempted by a higher-priority process.</p>
<p class="noindentt">For the first two events above, when a process running under the <span class="literal">SCHED_RR</span> policy loses access to the CPU, it is placed at the back of the queue for its priority level. In the final case, when the higher-priority process has ceased execution, the preempted process continues execution, consuming the remainder of its time slice (i.e., the preempted process remains at the head of the queue for its priority level).</p>
<p class="indentb">In both the <span class="literal">SCHED_RR</span> and the <span class="literal">SCHED_FIFO</span> policies, the currently running process may be preempted for one of the following reasons:</p>
<p class="bull">&#8226; a higher-priority process that was blocked became unblocked (e.g., an I/O operation on which it was waiting completed);</p>
<p class="bull">&#8226; the priority of another process was raised to a higher level than the currently running process; or</p>
<p class="bull">&#8226; the priority of the currently running process was decreased to a lower value than that of some other runnable process.</p>
<p class="noindentt">The <span class="literal">SCHED_RR</span> policy is similar to the standard round-robin time-sharing scheduling algorithm (<span class="literal">SCHED_OTHER</span>), in that it allows a group of processes with the same priority to share access to the CPU. The most notable difference is that the <span class="literal">SCHED_RR</span> policy has strictly distinct priority levels, with higher-priority processes always taking precedence over lower-priority processes. By contrast, a low nice value (i.e., high priority) doesn&#8217;t give a process exclusive access to the CPU; it merely gives the process a favorable weighting in scheduling decisions. As noted in <a href="ch35.xhtml#ch35lev1sec01">Section 35.1</a>, a process with a low priority (i.e., high nice value) always receives at least some CPU time. The other important difference is that the <span class="literal">SCHED_RR</span> policy allows us to precisely control the order in which processes are scheduled.</p>
<h4 class="h4" id="ch35lev2sec02"><span epub:type="pagebreak" id="page_740"/><strong>35.2.2 The</strong> <span class="literal"><span class="codestrong">SCHED_FIFO</span></span> <strong>Policy</strong></h4>
<p class="noindentab">The <span class="literal">SCHED_FIFO</span> (first-in, first-out) policy is similar to the <span class="literal">SCHED_RR</span> policy. The major difference is that there is no time slice. Once a <span class="literal">SCHED_FIFO</span> process gains access to the CPU, it executes until either:</p>
<p class="bull">&#8226; it voluntarily relinquishes the CPU (in the same manner as described for the <span class="literal">SCHED_RR</span> policy above);</p>
<p class="bull">&#8226; it terminates; or</p>
<p class="bull">&#8226; it is preempted by a higher-priority process (in the same circumstances as described for the <span class="literal">SCHED_RR</span> policy above).</p>
<p class="noindentt">In the first case, the process is placed at the back of the queue for its priority level. In the last case, when the higher-priority process has ceased execution (by blocking or terminating), the preempted process continues execution (i.e., the preempted process remains at the head of the queue for its priority level).</p>
<h4 class="h4" id="ch35lev2sec03"><strong>35.2.3 The</strong> <span class="literal"><span class="codestrong">SCHED_BATCH</span></span> <strong>and</strong> <span class="literal"><span class="codestrong">SCHED_IDLE</span></span> <strong>Policies</strong></h4>
<p class="noindenta">The Linux 2.6 kernel series added two nonstandard scheduling policies: <span class="literal">SCHED_BATCH</span> and <span class="literal">SCHED_IDLE</span>. Although these policies are set via the POSIX realtime scheduling API, they are not actually realtime policies.</p>
<p class="indent">The <span class="literal">SCHED_BATCH</span> policy, added in kernel 2.6.16, is similar to the default <span class="literal">SCHED_OTHER</span> policy. This policy is intended for batch-style execution of processes. The scheduler takes account of the nice value, but assumes that this is a CPU-intensive job that does not require low latency scheduling in response to wake-up events, and thus mildly disfavors it in scheduling decisions.</p>
<p class="indent">The <span class="literal">SCHED_IDLE</span> policy, added in kernel 2.6.23, is also similar to <span class="literal">SCHED_OTHER</span>, but schedules the process with a very low priority (lower even than a nice value of +19). The process nice value has no meaning for this policy. It is intended for running low-priority jobs that will receive a significant proportion of the CPU only if no other job on the system requires the CPU.</p>
<h3 class="h3" id="ch35lev1sec03"><strong>35.3 Realtime Process Scheduling API</strong></h3>
<p class="noindenta">We now look at the various system calls constituting the realtime process scheduling API. These system calls allow us to control process scheduling policies and priorities.</p>
<div class="block">
<p class="noindent">Although realtime scheduling has been a part of Linux since version 2.0 of the kernel, several problems persisted for a long time in the implementation. A number of features of the implementation remained broken in the 2.2 kernel, and even in early 2.4 kernels. Most of these problems were rectified by about kernel 2.4.20.</p>
</div>
<h4 class="h4" id="ch35lev2sec04"><strong>35.3.1 Realtime Priority Ranges</strong></h4>
<p class="noindenta">The <em>sched_get_priority_min()</em> and <em>sched_get_priority_max()</em> system calls return the available priority range for a scheduling policy.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_741"/>#include &lt;sched.h&gt;<br/><br/>int <span class="codestrong">sched_get_priority_min</span>(int <span class="font1">policy</span>);<br/>int <span class="codestrong">sched_get_priority_max</span>(int <span class="font1">policy</span>);</p>
<p class="right">Both return nonnegative integer priority on success, or &#8211;1 on error</p>
</div>
<p class="noindent">For both system calls, <em>policy</em> specifies the scheduling policy about which we wish to obtain information. For this argument, we specify either <span class="literal">SCHED_RR</span> or <span class="literal">SCHED_FIFO</span>. The <em>sched_get_priority_min()</em> system call returns the minimum priority for the specified policy, and <em>sched_get_priority_max()</em> returns the maximum priority. On Linux, these system calls return the numbers 1 and 99, respectively, for both the <span class="literal">SCHED_RR</span> and <span class="literal">SCHED_FIFO</span> policies. In other words, the priority ranges of the two realtime policies completely coincide, and <span class="literal">SCHED_RR</span> and <span class="literal">SCHED_FIFO</span> processes with the same priority are equally eligible for scheduling. (Which one is scheduled first depends on their order in the queue for that priority level.)</p>
<p class="indent">The range of realtime priorities differs from one UNIX implementation to another. Therefore, instead of hard-coding priority values into an application, we should specify priorities relative to the return value from one of these functions. Thus, the lowest <span class="literal">SCHED_RR</span> priority would be specified as <em>sched_get_priority_min(SCHED_RR)</em>, the next higher priority as <em>sched_get_priority_min(SCHED_RR) + 1</em>, and so on.</p>
<div class="block">
<p class="noindent">SUSv3 doesn&#8217;t require that the <span class="literal">SCHED_RR</span> and <span class="literal">SCHED_FIFO</span> policies use the same priority ranges, but they do so on most UNIX implementations. For example, on Solaris 8, the priority range for both policies is 0 to 59, and on FreeBSD 6.1, it is 0 to 31.</p>
</div>
<h4 class="h4" id="ch35lev2sec05"><strong>35.3.2 Modifying and Retrieving Policies and Priorities</strong></h4>
<p class="noindenta">In this section, we look at the system calls that modify and retrieve scheduling policies and priorities.</p>
<h5 class="h5" id="ch35lev3sec04"><strong>Modifying scheduling policies and priorities</strong></h5>
<p class="noindenta">The <em>sched_setscheduler()</em> system call changes both the scheduling policy and the priority of the process whose process ID is specified in <em>pid</em>. If <em>pid</em> is specified as 0, the attributes of the calling process are changed.</p>
<div class="box">
<p class="programsa">#include &lt;sched.h&gt;<br/><br/>int <span class="codestrong">sched_setscheduler</span>(pid_t <span class="font1">pid</span>, int <span class="font1">policy</span>, const struct sched_param *<span class="font1">param</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>param</em> argument is a pointer to a structure of the following form:</p>
<p class="programs">struct sched_param {<br/>&#160;&#160;&#160;&#160;int sched_priority;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Scheduling priority */<br/>};</p>
<p class="noindent"><span epub:type="pagebreak" id="page_742"/>SUSv3 defines the <em>param</em> argument as a structure to allow an implementation to include additional implementation-specific fields, which may be useful if an implementation provides additional scheduling policies. However, like most UNIX implementations, Linux provides just the <em>sched_priority</em> field, which specifies the scheduling priority. For the <span class="literal">SCHED_RR</span> and <span class="literal">SCHED_FIFO</span> policies, this must be a value in the range indicated by <em>sched_get_priority_min()</em> and <em>sched_get_priority_max()</em>; for other policies, the priority must be 0.</p>
<p class="indent">The <em>policy</em> argument determines the scheduling policy for the process. It is specified as one of the policies shown in <a href="ch35.xhtml#ch35table1">Table 35-1</a>.</p>
<p class="tablecap"><a id="ch35table1"/><strong>Table 35-1:</strong> Linux realtime and nonrealtime scheduling policies</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Policy</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Description</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="tablec"><strong>SUSv3</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SCHED_FIFO</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Realtime first-in first-out</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">SCHED_RR</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Realtime round-robin</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SCHED_OTHER</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Standard round-robin time-sharing</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SCHED_BATCH</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Similar to <span class="literal">SCHED_OTHER</span>, but intended for batch execution (since Linux 2.6.16)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">SCHED_IDLE</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">Similar to <span class="literal">SCHED_OTHER</span>, but with priority even lower than nice value +19 (since Linux 2.6.23)</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">&#160;</p></td>
</tr>
</tbody>
</table>
<p class="noindent">A successful <em>sched_setscheduler()</em> call moves the process specified by <em>pid</em> to the back of the queue for its priority level.</p>
<p class="indent">SUSv3 specifies that the return value of a successful <em>sched_setscheduler()</em> call should be the previous scheduling policy. However, Linux deviates from the standard in that a successful call returns 0. A portable application should test for success by checking that the return status is not &#8211;1.</p>
<p class="indent">The scheduling policy and priority are inherited by a child created via <em>fork()</em>, and they are preserved across an <em>exec()</em>.</p>
<p class="indent">The <em>sched_setparam()</em> system call provides a subset of the functionality of <em>sched_setscheduler()</em>. It modifies the scheduling priority of a process while leaving the policy unchanged.</p>
<div class="box">
<p class="programsa">#include &lt;sched.h&gt;<br/><br/>int <span class="codestrong">sched_setparam</span>(pid_t <span class="font1">pid</span>, const struct sched_param *<span class="font1">param</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>pid</em> and <em>param</em> arguments are the same as for <em>sched_setscheduler()</em>.</p>
<p class="indent">A successful <em>sched_setparam()</em> call moves the process specified by <em>pid</em> to the back of the queue for its priority level.</p>
<p class="indent">The program in <a href="ch35.xhtml#ch35ex2">Listing 35-2</a> uses <em>sched_setscheduler()</em> to set the policy and priority of the processes specified by its command-line arguments. The first argument is a letter specifying a scheduling policy, the second is an integer priority, and the remaining arguments are the process IDs of the processes whose scheduling attributes are to be changed.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_743"/><a id="ch35ex2"/><strong>Listing 35-2:</strong> Modifying process scheduling policies and priorities</p>
<p class="programsli">______________________________________________________ <span class="codestrong">procpri/sched_set.c</span><br/><br/>#include &lt;sched.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int j, pol;<br/>&#160;&#160;&#160;&#160;struct sched_param sp;<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 3 || strchr("rfobi", argv[1][0]) == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s policy priority [pid...]\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"&#160;&#160;&#160;&#160;policy is 'r' (RR), 'f' (FIFO), "<br/>#ifdef SCHED_BATCH&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Linux-specific */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"'b' (BATCH), "<br/>#endif<br/>#ifdef SCHED_IDLE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Linux-specific */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"'i' (IDLE), "<br/>#endif<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"or 'o' (OTHER)\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;argv[0]);<br/><br/>&#160;&#160;&#160;&#160;pol = (argv[1][0] == 'r') ? SCHED_RR :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(argv[1][0] == 'f') ? SCHED_FIFO :<br/>#ifdef SCHED_BATCH<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(argv[1][0] == 'b') ? SCHED_BATCH :<br/>#endif<br/>#ifdef SCHED_IDLE<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(argv[1][0] == 'i') ? SCHED_IDLE :<br/>#endif<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SCHED_OTHER;<br/>&#160;&#160;&#160;&#160;sp.sched_priority = getInt(argv[2], 0, "priority");<br/><br/>&#160;&#160;&#160;&#160;for (j = 3; j &lt; argc; j++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sched_setscheduler(getLong(argv[j], 0, "pid"), pol, &#38;sp) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sched_setscheduler");<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>______________________________________________________ <span class="codestrong">procpri/sched_set.c</span></p>
<h5 class="h5" id="ch35lev3sec05"><strong>Privileges and resource limits affecting changes to scheduling parameters</strong></h5>
<p class="noindenta">In kernels before 2.6.12, a process generally must be privileged (<span class="literal">CAP_SYS_NICE</span>) to make changes to scheduling policies and priorities. The one exception to this requirement is that an unprivileged process can change the scheduling policy of a process to <span class="literal">SCHED_OTHER</span> if the effective user ID of the caller matches either the real or effective user ID of the target process.</p>
<p class="indentb">Since kernel 2.6.12, the rules about setting realtime scheduling policies and priorities have changed with the introduction of a new, nonstandard resource limit, <span class="literal">RLIMIT_RTPRIO</span>. As with older kernels, privileged (<span class="literal">CAP_SYS_NICE</span>) processes can <span epub:type="pagebreak" id="page_744"/>make arbitrary changes to the scheduling policy and priority of any process. However, an unprivileged process can also change scheduling policies and priorities, according to the following rules:</p>
<p class="bull">&#8226; If the process has a nonzero <span class="literal">RLIMIT_RTPRIO</span> soft limit, then it can make arbitrary changes to its scheduling policy and priority, subject to the constraint that the upper limit on the realtime priority that it may set is the maximum of its current realtime priority (if the process is currently operating under a realtime policy) and the value of its <span class="literal">RLIMIT_RTPRIO</span> soft limit.</p>
<p class="bull">&#8226; If the value of a process&#8217;s <span class="literal">RLIMIT_RTPRIO</span> soft limit is 0, then the only change that it can make is to lower its realtime scheduling priority or to switch from a real-time policy to a nonrealtime policy.</p>
<p class="bull">&#8226; The <span class="literal">SCHED_IDLE</span> policy is special. A process that is operating under this policy can&#8217;t make any changes to its policy, regardless of the value of the <span class="literal">RLIMIT_RTPRIO</span> resource limit.</p>
<p class="bull">&#8226; Policy and priority changes can also be performed from another unprivileged process, as long as the effective user ID of that process matches either the real or effective user ID of the target process.</p>
<p class="bull">&#8226; A process&#8217;s soft <span class="literal">RLIMIT_RTPRIO</span> limit determines only what changes can be made to its own scheduling policy and priority, either by the process itself or by another unprivileged process. A nonzero limit doesn&#8217;t give an unprivileged process the ability to change the scheduling policy and priority of other processes.</p>
<div class="block">
<p class="noindent">Starting with kernel 2.6.25, Linux adds the concept of realtime scheduling groups, configurable via the <span class="literal">CONFIG_RT_GROUP_SCHED</span> kernel option, which also affect the changes that can be made when setting realtime scheduling policies. See the kernel source file <span class="literal">Documentation/scheduler/sched-rt-group.txt</span> for details.</p>
</div>
<h5 class="h5" id="ch35lev3sec06"><strong>Retrieving scheduling policies and priorities</strong></h5>
<p class="noindenta">The <em>sched_getscheduler()</em> and <em>sched_getparam()</em> system calls retrieve the scheduling policy and priority of a process.</p>
<div class="box">
<p class="programsa">#include &lt;sched.h&gt;<br/><br/>int <span class="codestrong">sched_getscheduler</span>(pid_t <span class="font1">pid</span>);</p>
<p class="right">Returns scheduling policy, or &#8211;1 on error</p>
<p class="programsat">int <span class="codestrong">sched_getparam</span>(pid_t <span class="font1">pid</span>, struct sched_param *<span class="font1">param</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">For both of these system calls, <em>pid</em> specifies the ID of the process about which information is to be retrieved. If <em>pid</em> is 0, information is retrieved about the calling process. Both system calls can be used by an unprivileged process to retrieve information about any process, regardless of credentials.</p>
<p class="indent">The <em>sched_getparam()</em> system call returns the realtime priority of the specified process in the <em>sched_priority</em> field of the <em>sched_param</em> structure pointed to by <em>param</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_745"/>Upon successful execution, <em>sched_getscheduler()</em> returns one of the policies shown earlier in <a href="ch35.xhtml#ch35table1">Table 35-1</a>.</p>
<p class="indent">The program in <a href="ch35.xhtml#ch35ex3">Listing 35-3</a> uses <em>sched_getscheduler()</em> and <em>sched_getparam()</em> to retrieve the policy and priority of all of the processes whose process IDs are given as command-line arguments. The following shell session demonstrates the use of this program, as well as the program in <a href="ch35.xhtml#ch35ex2">Listing 35-2</a>:</p>
<p class="programs">$ <span class="codestrong">su</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Assume privilege so we can set realtime policies</span><br/>Password:<br/># <span class="codestrong">sleep 100 &#38;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create a process</span><br/>[1] 2006<br/># <span class="codestrong">./sched_view 2006</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">View initial policy and priority of sleep process</span><br/>2006: OTHER 0<br/># <span class="codestrong">./sched_set f 25 2006</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Switch process to</span> SCHED_FIFO <span class="font1">policy, priority 25</span><br/># <span class="codestrong">./sched_view 2006</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Verify change</span><br/>2006: FIFO 25</p>
<p class="examplet"><a id="ch35ex3"/><strong>Listing 35-3:</strong> Retrieving process scheduling policies and priorities</p>
<p class="programsli">______________________________________________________ <span class="codestrong">procpri/sched_view.c</span><br/><br/>#include &lt;sched.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int j, pol;<br/>&#160;&#160;&#160;&#160;struct sched_param sp;<br/><br/>&#160;&#160;&#160;&#160;for (j = 1; j &lt; argc; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pol = sched_getscheduler(getLong(argv[j], 0, "pid"));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (pol == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sched_getscheduler");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sched_getparam(getLong(argv[j], 0, "pid"), &#38;sp) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sched_getparam");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s: %-5s %2d\n", argv[j],<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(pol == SCHED_OTHER) ? "OTHER" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(pol == SCHED_RR) ? "RR" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(pol == SCHED_FIFO) ? "FIFO" :<br/>#ifdef SCHED_BATCH&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Linux-specific */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(pol == SCHED_BATCH) ? "BATCH" :<br/>#endif<br/>#ifdef SCHED_IDLE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Linux-specific */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(pol == SCHED_IDLE) ? "IDLE" :<br/>#endif<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"???", sp.sched_priority);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>______________________________________________________ <span class="codestrong">procpri/sched_view.c</span></p>
<h5 class="h5" id="ch35lev3sec07"><span epub:type="pagebreak" id="page_746"/><strong>Preventing realtime processes from locking up the system</strong></h5>
<p class="noindentab">Since <span class="literal">SCHED_RR</span> and <span class="literal">SCHED_FIFO</span> processes preempt any lower-priority processes (e.g., the shell under which the program is run), when developing applications that use these policies, we need to be aware of the possibility that a runaway realtime process could lock up the system by hogging the CPU. Programmatically, there are a few of ways to avoid this possibility:</p>
<p class="bull">&#8226; Establish a suitably low soft CPU time resource limit (<span class="literal">RLIMIT_CPU</span>, described in <a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a>) using <em>setrlimit()</em>. If the process consumes too much CPU time, it will be sent a <span class="literal">SIGXCPU</span> signal, which kills the process by default.</p>
<p class="bull">&#8226; Set an alarm timer using <em>alarm()</em>. If the process continues running for a wall clock time that exceeds the number of seconds specified in the <em>alarm()</em> call, then it will be killed by a <span class="literal">SIGALRM</span> signal.</p>
<p class="bull">&#8226; Create a watchdog process that runs with a high realtime priority. This process can loop repeatedly, sleeping for a specified interval, and then waking and monitoring the status of other processes. Such monitoring could include measuring the value of the CPU time clock for each process (see the discussion of the <em>clock_getcpuclockid()</em> function in <a href="ch23.xhtml#ch23lev2sec05">Section 23.5.3</a>) and checking its scheduling policy and priority using <em>sched_getscheduler()</em> and <em>sched_getparam()</em>. If a process is deemed to be misbehaving, the watchdog thread could lower the process&#8217;s priority, or stop or terminate it by sending an appropriate signal.</p>
<p class="bull">&#8226; Since kernel 2.6.25, Linux provides a nonstandard resource limit, <span class="literal">RLIMIT_RTTIME</span>, for controlling the amount of CPU time that can be consumed in a single burst by a process running under a realtime scheduling policy. Specified in microseconds, <span class="literal">RLIMIT_RTTIME</span> limits the amount of CPU time that the process may consume without performing a system call that blocks. When the process does perform such a call, the count of consumed CPU time is reset to 0. The count of consumed CPU time is not reset if the process is preempted by a higher-priority process, is scheduled off the CPU because its time slice expired (for a <span class="literal">SCHED_RR</span> process), or calls <em>sched_yield()</em> (<a href="ch35.xhtml#ch35lev2sec06">Section 35.3.3</a>). If the process reaches its limit of CPU time, then, as with <span class="literal">RLIMIT_CPU</span>, it will be sent a <span class="literal">SIGXCPU</span> signal, which kills the process by default.</p>
<div class="block">
<p class="noindent">The changes in kernel 2.6.25 can also help prevent runaway realtime processes from locking up the system. For details, see the kernel source file <span class="literal">Documentation/scheduler/sched-rt-group.txt</span>.</p>
</div>
<h5 class="h5" id="ch35lev3sec08"><strong>Preventing child processes from inheriting privileged scheduling policies</strong></h5>
<p class="noindentab">Linux 2.6.32 added <span class="literal">SCHED_RESET_ON_FORK</span> as a value that can be specified in <em>policy</em> when calling <em>sched_setscheduler()</em>. This is a flag value that is ORed with one of the policies in <a href="ch35.xhtml#ch35table1">Table 35-1</a>. If this flag is set, then children that are created by this process using <em>fork()</em> do not inherit privileged scheduling policies and priorities. The rules are as follows:</p>
<p class="bull">&#8226; If the calling process has a realtime scheduling policy (<span class="literal">SCHED_RR</span> or <span class="literal">SCHED_FIFO</span>), then the policy in child processes is reset to the standard round-robin timesharing policy, <span class="literal">SCHED_OTHER</span>.</p>
<p class="bull">&#8226; If the process has a negative (i.e., high) nice value, then the nice value in child processes is reset to 0.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_747"/>The <span class="literal">SCHED_RESET_ON_FORK</span> flag was designed to be used in media-playback applications. It permits the creation of single processes that have realtime scheduling policies that can&#8217;t be passed to child processes. Using the <span class="literal">SCHED_RESET_ON_FORK</span> flag prevents the creation of fork bombs that try to evade the ceiling set by the <span class="literal">RLIMIT_RTTIME</span> resource limit by creating multiple children running under realtime scheduling policies.</p>
<p class="indent">Once the <span class="literal">SCHED_RESET_ON_FORK</span> flag has been enabled for a process, only a privileged process (<span class="literal">CAP_SYS_NICE</span>) can disable it. When a child process is created, its reset-on-fork flag is disabled.</p>
<h4 class="h4" id="ch35lev2sec06"><strong>35.3.3 Relinquishing the CPU</strong></h4>
<p class="noindenta">A realtime process may voluntarily relinquish the CPU in two ways: by invoking a system call that blocks the process (e.g., a <em>read()</em> from a terminal) or by calling <em>sched_yield()</em>.</p>
<div class="box">
<p class="programsa">#include &lt;sched.h&gt;<br/><br/>int <span class="codestrong">sched_yield</span>(void);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The operation of <em>sched_yield()</em> is simple. If there are any other queued runnable processes at the same priority level as the calling process, then the calling process is placed at the back of the queue, and the process at the head of the queue is scheduled to use the CPU. If no other runnable processes are queued at this priority, then <em>sched_yield()</em> does nothing; the calling process simply continues using the CPU.</p>
<p class="indent">Although SUSv3 permits a possible error return from <em>sched_yield()</em>, this system call always succeeds on Linux, as well as on many other UNIX implementations. Portable applications should nevertheless always check for an error return.</p>
<p class="indent">The use of <em>sched_yield()</em> for nonrealtime processes is undefined.</p>
<h4 class="h4" id="ch35lev2sec07"><strong>35.3.4 The</strong> <span class="literal"><span class="codestrong">SCHED_RR</span></span> <strong>Time Slice</strong></h4>
<p class="noindenta">The <em>sched_rr_get_interval()</em> system call enables us to find out the length of the time slice allocated to a <span class="literal">SCHED_RR</span> process each time it is granted use of the CPU.</p>
<div class="box">
<p class="programsa">#include &lt;sched.h&gt;<br/><br/>int <span class="codestrong">sched_rr_get_interval</span>(pid_t <span class="font1">pid</span>, struct timespec *<span class="font1">tp</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">As with the other process scheduling system calls, <em>pid</em> identifies the process about which we want to obtain information, and specifying <em>pid</em> as 0 means the calling process. The time slice is returned in the <em>timespec</em> structure pointed to by <em>tp</em>:</p>
<p class="programs">struct timespec {<br/>&#160;&#160;&#160;&#160;time_t tv_sec;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Seconds */<br/>&#160;&#160;&#160;&#160;long tv_nsec;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Nanoseconds */<br/>};</p>
<div class="block">
<p class="noindent">On recent 2.6 kernels, the realtime round-robin time slice is 0.1 seconds.</p>
</div>
<h3 class="h3" id="ch35lev1sec04"><span epub:type="pagebreak" id="page_748"/><strong>35.4 CPU Affinity</strong></h3>
<p class="noindenta">When a process is rescheduled to run on a multiprocessor system, it doesn&#8217;t necessarily run on the same CPU on which it last executed. The usual reason it may run on another CPU is that the original CPU is already busy.</p>
<p class="indent">When a process changes CPUs, there is a performance impact: in order for a line of the process&#8217;s data to be loaded into the cache of the new CPU, it must first be invalidated (i.e., either discarded if it is unmodified, or flushed to main memory if it was modified), if present in the cache of the old CPU. (To prevent cache inconsistencies, multiprocessor architectures allow data to be kept in only one CPU cache at a time.) This invalidation costs execution time. Because of this performance impact, the Linux (2.6) kernel tries to ensure <em>soft</em> CPU affinity for a process&#8212;wherever possible, the process is rescheduled to run on the same CPU.</p>
<div class="block">
<p class="noindent">A <em>cache line</em> is the cache analog of a page in a virtual memory management system. It is the size of the unit used for transfers between the CPU cache and main memory. Typical line sizes range from 32 to 128 bytes. For further information, see [<a href="bib.xhtml#bib86">Schimmel, 1994</a>] and [<a href="bib.xhtml#bib22">Drepper, 2007</a>].</p>
<p class="indent">One of the fields in the Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/stat</span> file displays the number of the CPU on which a process is currently executing or last executed. See the <em>proc(5)</em> manual page for details.</p>
</div>
<p class="noindentb">Sometimes, it is desirable to set <em>hard</em> CPU affinity for a process, so that it is explicitly restricted to always running on one, or a subset, of the available CPUs. Among the reasons we may want to do this are the following:</p>
<p class="bull">&#8226; We can avoid the performance impacts caused by invalidation of cached data.</p>
<p class="bull">&#8226; If multiple threads (or processes) are accessing the same data, then we may obtain performance benefits by confining them all to the same CPU, so that they don&#8217;t contend for the data and thus cause cache misses.</p>
<p class="bull">&#8226; For a time-critical application, it may be desirable to confine most processes on the system to other CPUs, while reserving one or more CPUs for the time-critical application.</p>
<div class="block">
<p class="noindent">The <em>isolcpus</em> kernel boot option can be used to isolate one or more CPUs from the normal kernel scheduling algorithms. The only way to move a process on or off a CPU that has been isolated is via the CPU affinity system calls described in this section. The <em>isolcpus</em> boot option is the preferred method of implementing the last of the scenarios listed above. For details, see the kernel source file <span class="literal">Documentation/kernel-parameters.txt</span>.</p>
<p class="indent">Linux also provides a <em>cpuset</em> kernel option, which can be used on systems containing large numbers of CPUs to achieve more sophisticated control over how the CPUs and memory are allocated to processes. For details, see the kernel source file <span class="literal">Documentation/cpusets.txt</span>.</p>
</div>
<p class="noindent">Linux 2.6 provides a pair of nonstandard system calls to modify and retrieve the hard CPU affinity of a process: <em>sched_setaffinity()</em> and <em>sched_getaffinity()</em>.</p>
<div class="block">
<p class="noindent">Many other UNIX implementations provide interfaces for controlling CPU affinity. For example, HP-UX and Solaris provide a <em>pset_bind()</em> system call.</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_749"/>The <em>sched_setaffinity()</em> system call sets the CPU affinity of the process specified by <em>pid</em>. If <em>pid</em> is 0, the CPU affinity of the calling process is changed.</p>
<div class="box">
<p class="programsa">#define _GNU_SOURCE<br/>#include &lt;sched.h&gt;<br/><br/>int <span class="codestrong">sched_setaffinity</span>(pid_t <span class="font1">pid</span>, size_t <span class="font1">len</span>, cpu_set_t *<span class="font1">set</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The CPU affinity to be assigned to the process is specified in the <em>cpu_set_t</em> structure pointed to by <em>set</em>.</p>
<div class="block">
<p class="noindent">CPU affinity is actually a per-thread attribute that can be adjusted independently for each of the threads in a thread group. If we want to change the CPU affinity of a specific thread in a multithreaded process, we can specify <em>pid</em> as the value returned by a call to <em>gettid()</em> in that thread. Specifying <em>pid</em> as 0 means the calling thread.</p>
</div>
<p class="noindent">Although the <em>cpu_set_t</em> data type is implemented as a bit mask, we should treat it as an opaque structure. All manipulations of the structure should be done using the macros <span class="literal">CPU_ZERO()</span>, <span class="literal">CPU_SET()</span>, <span class="literal">CPU_CLR()</span>, and <span class="literal">CPU_ISSET()</span>.</p>
<div class="box">
<p class="programsa">#define _GNU_SOURCE<br/>#include &lt;sched.h&gt;<br/><br/>void <span class="codestrong">CPU_ZERO</span>(cpu_set_t *<span class="font1">set</span>);<br/>void <span class="codestrong">CPU_SET</span>(int <span class="font1">cpu</span>, cpu_set_t *<span class="font1">set</span>);<br/>void <span class="codestrong">CPU_CLR</span>(int <span class="font1">cpu</span>, cpu_set_t *<span class="font1">set</span>);<br/><br/>int <span class="codestrong">CPU_ISSET</span>(int <span class="font1">cpu</span>, cpu_set_t *<span class="font1">set</span>);</p>
<p class="right">Returns true (1) if <em>cpu</em> is in <em>set</em>, or false (0) otherwise</p>
</div>
<p class="noindentb">These macros operate on the CPU set pointed to by <em>set</em> as follows:</p>
<p class="bull">&#8226; <span class="literal">CPU_ZERO()</span> initializes <em>set</em> to be empty.</p>
<p class="bull">&#8226; <span class="literal">CPU_SET()</span> adds the CPU <em>cpu</em> to <em>set</em>.</p>
<p class="bull">&#8226; <span class="literal">CPU_CLR()</span> removes the CPU <em>cpu</em> from <em>set</em>.</p>
<p class="bull">&#8226; <span class="literal">CPU_ISSET()</span> returns true if the CPU <em>cpu</em> is a member of <em>set</em>.</p>
<div class="block">
<p class="noindent">The GNU C library also provides a number of other macros for working with CPU sets. See the <em>CPU_SET(3)</em> manual page for details.</p>
</div>
<p class="noindent">The CPUs in a CPU set are numbered starting at 0. The <span class="literal">&lt;sched.h&gt;</span> header file defines the constant <span class="literal">CPU_SETSIZE</span> to be one greater than the maximum CPU number that can be represented in a <em>cpu_set_t</em> variable. <span class="literal">CPU_SETSIZE</span> has the value 1024.</p>
<p class="indent">The <em>len</em> argument given to <em>sched_setaffinity()</em> should specify the number of bytes in the <em>set</em> argument (i.e., <em>sizeof(cpu_set_t)</em>).</p>
<p class="indent"><span epub:type="pagebreak" id="page_750"/>The following code confines the process identified by <em>pid</em> to running on any CPU other than the first CPU of a four-processor system:</p>
<p class="programs">cpu_set_t set;<br/><br/>CPU_ZERO(&#38;set);<br/>CPU_SET(1, &#38;set);<br/>CPU_SET(2, &#38;set);<br/>CPU_SET(3, &#38;set);<br/><br/>sched_setaffinity(pid, sizeof(cpu_set_t), &#38;set);</p>
<p class="noindent">If the CPUs specified in <em>set</em> don&#8217;t correspond to any CPUs on the system, then <em>sched_setaffinity()</em> fails with the error <span class="literal">EINVAL</span>.</p>
<p class="indent">If <em>set</em> doesn&#8217;t include the CPU on which the calling process is currently running, then the process is migrated to one of the CPUs in <em>set</em>.</p>
<p class="indent">An unprivileged process may set the CPU affinity of another process only if its effective user ID matches the real or effective user ID of the target process. A privileged (<span class="literal">CAP_SYS_NICE</span>) process may set the CPU affinity of any process.</p>
<p class="indent">The <em>sched_getaffinity()</em> system call retrieves the CPU affinity mask of the process specified by <em>pid</em>. If <em>pid</em> is 0, the CPU affinity mask of the calling process is returned.</p>
<div class="box">
<p class="programsa">#define _GNU_SOURCE<br/>#include &lt;sched.h&gt;<br/><br/>int <span class="codestrong">sched_getaffinity</span>(pid_t <span class="font1">pid</span>, size_t <span class="font1">len</span>, cpu_set_t *<span class="font1">set</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The CPU affinity mask is returned in the <em>cpu_set_t</em> structure pointed to by <em>set</em>. The <em>len</em> argument should be set to indicate the number of bytes in this structure (i.e., <em>sizeof(cpu_set_t)</em>). We can use the <span class="literal">CPU_ISSET()</span> macro to determine which CPUs are in the returned <em>set</em>.</p>
<p class="indent">If the CPU affinity mask of the target process has not otherwise been modified, <em>sched_getaffinity()</em> returns a set containing all of the CPUs on the system.</p>
<p class="indent">No permission checking is performed by <em>sched_getaffinity()</em>; an unprivileged process can retrieve the CPU affinity mask of any process on the system.</p>
<p class="indent">A child process created by <em>fork()</em> inherits its parent&#8217;s CPU affinity mask, and this mask is preserved across an <em>exec()</em>.</p>
<p class="indent">The <em>sched_setaffinity()</em> and <em>sched_getaffinity()</em> system calls are Linux-specific.</p>
<div class="block">
<p class="noindent">The <span class="literal">t_sched_setaffinity.c</span> and <span class="literal">t_sched_getaffinity.c</span> programs in the <span class="literal">procpri</span> subdirectory in the source code distribution for this book demonstrate the use of <em>sched_setaffinity()</em> and <em>sched_getaffinity()</em>.</p>
</div>
<h3 class="h3" id="ch35lev1sec05"><span epub:type="pagebreak" id="page_751"/><strong>35.5 Summary</strong></h3>
<p class="noindenta">The default kernel scheduling algorithm employs a round-robin time-sharing policy. By default, all processes have equal access to the CPU under this policy, but we can set a process&#8217;s nice value to a number in the range &#8211;20 (high priority) to +19 (low priority) to cause the scheduler to favor or disfavor that process. However, even if we give a process the lowest priority, it is not completely starved of the CPU.</p>
<p class="indent">Linux also implements the POSIX realtime scheduling extensions. These allow an application to precisely control the allocation of the CPU to processes. Processes operating under the two realtime scheduling policies, <span class="literal">SCHED_RR</span> (round-robin) and <span class="literal">SCHED_FIFO</span> (first-in, first-out), always have priority over processes operating under nonrealtime policies. Realtime processes have priorities in the range 1 (low) to 99 (high). As long as it is runnable, a higher-priority process completely excludes lower-priority processes from the CPU. A process operating under the <span class="literal">SCHED_FIFO</span> policy maintains exclusive access to the CPU until either it terminates, it voluntarily relinquishes the CPU, or it is preempted because a higher-priority process became runnable. Similar rules apply to the <span class="literal">SCHED_RR</span> policy, with the addition that if multiple processes are running at the same priority, then the CPU is shared among these processes in a round-robin fashion.</p>
<p class="indent">A process&#8217;s CPU affinity mask can be used to restrict the process to running on a subset of the CPUs available on a multiprocessor system. This can improve the performance of certain types of applications.</p>
<h5 class="h5" id="ch35lev3sec09"><strong>Further information</strong></h5>
<p class="noindenta">[<a href="bib.xhtml#bib59">Love, 2010</a>] provides background detail on process priorities and scheduling on Linux. [<a href="bib.xhtml#bib28">Gallmeister, 1995</a>] provides further information about the POSIX realtime scheduling API. Although targeted at POSIX threads, much of the discussion of the realtime scheduling API in [<a href="bib.xhtml#bib10">Butenhof, 1996</a>] is useful background to the real-time scheduling discussion in this chapter.</p>
<p class="indent">For further information about CPU affinity and controlling the allocation of threads to CPUs and memory nodes on multiprocessor systems, see the kernel source file <span class="literal">Documentation/cpusets.txt</span>, and the <em>mbind(2)</em>, <em>set_mempolicy(2)</em>, and <em>cpuset(7)</em> manual pages.</p>
<h3 class="h3" id="ch35lev1sec06"><strong>35.6 Exercises</strong></h3>
<p class="exer"><a id="ch35exe1"/><strong>35-1.</strong>&#160;&#160;&#160;Implement the <em>nice(1)</em> command.</p>
<p class="exer"><a id="ch35exe2"/><strong>35-2.</strong>&#160;&#160;&#160;Write a set-user-ID-<em>root</em> program that is the realtime scheduling analog of <em>nice(1)</em>. The command-line interface of this program should be as follows:</p>
<p class="programs1"># <span class="codestrong">./rtsched <span class="codeitalic">policy priority command arg...</span></span></p>
<p class="exerp">In the above command, <em>policy</em> is <em>r</em> for <span class="literal">SCHED_RR</span> or <em>f</em> for <span class="literal">SCHED_FIFO</span>. This program should drop its privileged ID before execing the command, for the reasons described in <a href="ch09.xhtml#ch09lev2sec01">Sections 9.7.1</a> and <a href="ch38.xhtml#ch38lev1sec03">38.3</a>.</p>
<p class="exer"><span epub:type="pagebreak" id="page_752"/><a id="ch35exe3"/><strong>35-3.</strong>&#160;&#160;&#160;Write a program that places itself under the <span class="literal">SCHED_FIFO</span> scheduling policy and then creates a child process. Both processes should execute a function that causes the process to consume a maximum of 3 seconds of CPU time. (This can be done by using a loop in which the <em>times()</em> system call is repeatedly called to determine the amount of CPU time so far consumed.) After each quarter of a second of consumed CPU time, the function should print a message that displays the process ID and the amount of CPU time so far consumed. After each second of consumed CPU time, the function should call <em>sched_yield()</em> to yield the CPU to the other process. (Alternatively, the processes could raise each other&#8217;s scheduling priority using <em>sched_setparam()</em>.) The program&#8217;s output should demonstrate that the two processes alternately execute for 1 second of CPU time. (Note carefully the advice given in <a href="ch35.xhtml#ch35lev2sec05">Section 35.3.2</a> about preventing a runaway realtime process from hogging the CPU.)</p>
<div class="block3">
<p class="noindent">If your system has multiple CPUs, then, in order to demonstrate the behavior described in this exercise, you will need to confine all processes to a single CPU. This can be done by calling <em>sched_setaffinity()</em> before creating the child process or from the command line by using the <em>taskset</em> command.</p>
</div>
<p class="exer"><a id="ch35exe4"/><strong>35-4.</strong>&#160;&#160;&#160;If two processes use a pipe to exchange a large amount of data on a multiprocessor system, the communication should be faster if the processes run on the same CPU than if they run on different CPUs. The reason is that when the two processes run on the same CPU, the pipe data will be more quickly accessed because it can remain in that CPU&#8217;s cache. By contrast, when the processes run on separate CPUs, the benefits of the CPU cache are lost. If you have access to a multiprocessor system, write a program that uses <em>sched_setaffinity()</em> to demonstrate this effect, by forcing the processes either onto the same CPUs or onto different CPUs. (<a href="ch44.xhtml#ch44">Chapter 44</a> describes the use of pipes.)</p>
<div class="block3">
<p class="noindent">The advantage in favor of processes running on the same CPU won&#8217;t hold true on hyperthreaded systems and on some modern multiprocessor architectures where the CPUs do share the cache. In these cases, the advantage will be in favor of processes running on different CPUs. Information about the CPU topology of a multiprocessor system can be obtained by inspecting the contents of the Linux-specific <span class="literal">/proc/cpuinfo</span> file.</p>
</div>
</body>
</html>
