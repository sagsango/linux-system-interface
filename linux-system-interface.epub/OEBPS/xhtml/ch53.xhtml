<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch53"><span epub:type="pagebreak" id="page_1089"/><strong><span class="big">53</span></strong><br/><strong>POSIX SEMAPHORES</strong></h2>
<p class="noindenta">This chapter describes POSIX semaphores, which allow processes and threads to synchronize access to shared resources. In <a href="ch47.xhtml#ch47">Chapter 47</a>, we described System V semaphores, and we&#8217;ll assume that the reader is familiar with the general semaphore concepts and rationale for using semaphores that were presented at the start of that chapter. During the course of this chapter, we&#8217;ll make comparisons between POSIX semaphores and System V semaphores to clarify the ways in which these two semaphore APIs are the same and the ways in which they differ.</p>
<h3 class="h3" id="ch53lev1sec01"><strong>53.1 Overview</strong></h3>
<p class="noindentab">SUSv3 specifies two types of POSIX semaphores:</p>
<p class="bull">&#8226; <em>Named semaphores</em>: This type of semaphore has a name. By calling <em>sem_open()</em> with the same name, unrelated processes can access the same semaphore.</p>
<p class="bull">&#8226; <em>Unnamed semaphores</em>: This type of semaphore doesn&#8217;t have a name; instead, it resides at an agreed-upon location in memory. Unnamed semaphores can be shared between processes or between a group of threads. When shared between processes, the semaphore must reside in a region of (System V, POSIX, or <em>mmap()</em>) shared memory. When shared between threads, the semaphore may reside in an area of memory shared by the threads (e.g., on the heap or in a global variable).</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_1090"/>POSIX semaphores operate in a manner similar to System V semaphores; that is, a POSIX semaphore is an integer whose value is not permitted to fall below 0. If a process attempts to decrease the value of a semaphore below 0, then, depending on the function used, the call either blocks or fails with an error indicating that the operation was not currently possible.</p>
<p class="indent">Some systems don&#8217;t provide a full implementation of POSIX semaphores. A typical restriction is that only unnamed thread-shared semaphores are supported. That was the situation on Linux 2.4; with Linux 2.6 and a <em>glibc</em> that provides NPTL, a full implementation of POSIX semaphores is available.</p>
<div class="block">
<p class="noindent">On Linux 2.6 with NPTL, semaphore operations (increment and decrement) are implemented using the <em>futex(2)</em> system call.</p>
</div>
<h3 class="h3" id="ch53lev1sec02"><strong>53.2 Named Semaphores</strong></h3>
<p class="noindentab">To work with a named semaphore, we employ the following functions:</p>
<p class="bull">&#8226; The <em>sem_open()</em> function opens or creates a semaphore, initializes the semaphore if it is created by the call, and returns a handle for use in later calls.</p>
<p class="bull">&#8226; The <em>sem_post()</em> and <em>sem_wait()</em> functions respectively increment and decrement a semaphore&#8217;s value.</p>
<p class="bull">&#8226; The <em>sem_getvalue()</em> function retrieves a semaphore&#8217;s current value.</p>
<p class="bull">&#8226; The <em>sem_close()</em> function removes the calling process&#8217;s association with a semaphore that it previously opened.</p>
<p class="bull">&#8226; The <em>sem_unlink()</em> function removes a semaphore name and marks the semaphore for deletion when all processes have closed it.</p>
<p class="noindentt">SUSv3 doesn&#8217;t specify how named semaphores are to be implemented. Some UNIX implementations create them as files in a special location in the standard file system. On Linux, they are created as small POSIX shared memory objects with names of the form <span class="literal">sem.</span><em>name</em>, in a dedicated <em>tmpfs</em> file system (<a href="ch14.xhtml#ch14lev1sec10">Section 14.10</a>) mounted under the directory <span class="literal">/dev/shm</span> (<span class="literal">/run/shm</span> on some systems). This file system has kernel persistence&#8212;the semaphore objects that it contains will persist, even if no process currently has them open, but they will be lost if the system is shut down.</p>
<p class="indent">Named semaphores are supported on Linux since kernel 2.6.</p>
<h4 class="h4" id="ch53lev2sec01"><strong>53.2.1 Opening a Named Semaphore</strong></h4>
<p class="noindenta">The <em>sem_open()</em> function creates and opens a new named semaphore or opens an existing semaphore.</p>
<div class="box">
<p class="programsa">#include &lt;fcntl.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Defines O_* constants */<br/>#include &lt;sys/stat.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Defines mode constants */<br/>#include &lt;semaphore.h&gt;<br/><br/>sem_t *<span class="codestrong">sem_open</span>(const char *<span class="font1">name</span>, int <span class="font1">oflag</span>, ...<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* mode_t <span class="font1">mode</span>, unsigned int <span class="font1">value</span> */ );</p>
<p class="right">Returns pointer to semaphore on success, or <span class="literal">SEM_FAILED</span> on error</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_1091"/>The <em>name</em> argument identifies the semaphore. It is specified according to the rules given in <a href="ch51.xhtml#ch51lev1sec01">Section 51.1</a>.</p>
<p class="indent">The <em>oflag</em> argument is a bit mask that determines whether we are opening an existing semaphore or creating and opening a new semaphore. If <em>oflag</em> is 0, we are accessing an existing semaphore. If <span class="literal">O_CREAT</span> is specified in <em>oflag</em>, then a new semaphore is created if one with the given <em>name</em> doesn&#8217;t already exist. If <em>oflag</em> specifies both <span class="literal">O_CREAT</span> and <span class="literal">O_EXCL</span>, and a semaphore with the given <em>name</em> already exists, then <em>sem_open()</em> fails.</p>
<p class="indentb">If <em>sem_open()</em> is being used to open an existing semaphore, the call requires only two arguments. However, if <span class="literal">O_CREAT</span> is specified in <em>oflag</em>, then two further arguments are required: <em>mode</em> and <em>value</em>. (If the semaphore specified by <em>name</em> already exists, then these two arguments are ignored.) These arguments are as follows:</p>
<p class="bull">&#8226; The <em>mode</em> argument is a bit mask that specifies the permissions to be placed on the new semaphore. The bit values are the same as for files (<a href="ch15.xhtml#ch15table4">Table 15-4</a>, on <a href="ch15.xhtml#page_295">page 295</a>), and, as with <em>open()</em>, the value in <em>mode</em> is masked against the process umask (<a href="ch15.xhtml#ch15lev2sec10">Section 15.4.6</a>). SUSv3 doesn&#8217;t specify any access mode flags (<span class="literal">O_RDONLY</span>, <span class="literal">O_WRONLY</span>, and <span class="literal">O_RDWR</span>) for <em>oflag</em>. Many implementations, including Linux, assume an access mode of <span class="literal">O_RDWR</span> when opening a semaphore, since most applications using semaphores must employ both <em>sem_post()</em> and <em>sem_wait()</em>, which involve reading and modifying a semaphore&#8217;s value. This means that we should ensure that both read and write permissions are granted to each category of user&#8212;owner, group, and other&#8212;that needs to access the semaphore.</p>
<p class="bull">&#8226; The <em>value</em> argument is an unsigned integer that specifies the initial value to be assigned to the new semaphore. The creation and initialization of the semaphore are performed atomically. This avoids the complexities required for the initialization of System V semaphores (<a href="ch47.xhtml#ch47lev1sec05">Section 47.5</a>).</p>
<p class="noindentt">Regardless of whether we are creating a new semaphore or opening an existing semaphore, <em>sem_open()</em> returns a pointer to a <em>sem_t</em> value, and we employ this pointer in subsequent calls to functions that operate on the semaphore. On error, <em>sem_open()</em> returns the value <span class="literal">SEM_FAILED</span>. (On most implementations, <span class="literal">SEM_FAILED</span> is defined as either <em>((sem_t *) 0)</em> or <em>((sem_t *) &#8211;1)</em>; Linux defines it as the former.)</p>
<p class="indent">SUSv3 states that the results are undefined if we attempt to perform operations (<em>sem_post()</em>, <em>sem_wait()</em>, and so on) on a <em>copy</em> of the <em>sem_t</em> variable pointed to by the return value of <em>sem_open()</em>. In other words, the following use of <em>sem2</em> is not permissible:</p>
<p class="programs">sem_t *sp, sem2<br/>sp = sem_open(...);<br/>sem2 = *sp;<br/>sem_wait(&#38;sem2);</p>
<p class="noindent">When a child is created via <em>fork()</em>, it inherits references to all of the named semaphores that are open in its parent. After the <em>fork()</em>, the parent and child can use these semaphores to synchronize their actions.</p>
<h5 class="h5" id="ch53lev3sec01"><strong>Example program</strong></h5>
<p class="noindenta">The program in <a href="ch53.xhtml#ch53ex1">Listing 53-1</a> provides a simple command-line interface to the <em>sem_open()</em> function. The command format for this program is shown in the <em>usageError()</em> function.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1092"/>The following shell session log demonstrates the use of this program. We first use the <em>umask</em> command to deny all permissions to users in the class other. We then exclusively create a semaphore and examine the contents of the Linux-specific virtual directory that contains named semaphores.</p>
<p class="programs">$ <span class="codestrong">umask 007</span><br/>$ <span class="codestrong">./psem_create -cx /demo 666</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">666 means read+write for all users</span><br/>$ <span class="codestrong">ls -l /dev/shm/sem.*</span><br/>-rw-rw----&#160;&#160;1 mtk users 16 Jul&#160;&#160;6 12:09 /dev/shm/sem.demo</p>
<p class="noindent">The output of the <em>ls</em> command shows that the process umask overrode the specified permissions of read plus write for the user class other.</p>
<p class="indent">If we try once more to exclusively create a semaphore with the same name, the operation fails, because the name already exists.</p>
<p class="programs">$ <span class="codestrong">./psem_create -cx /demo 666</span><br/>ERROR [EEXIST File exists] sem_open&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Failed because of</span> O_EXCL</p>
<p class="examplet"><a id="ch53ex1"/><strong>Listing 53-1:</strong> Using <em>sem_open()</em> to open or create a POSIX named semaphore</p>
<p class="programsli">_______________________________________________________ <span class="codestrong">psem/psem_create.c</span><br/><br/>#include &lt;semaphore.h&gt;<br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static void<br/>usageError(const char *progName)<br/>{<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "Usage: %s [-cx] name [octal-perms [value]]\n", progName);<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-c&#160;&#160;&#160;Create semaphore (O_CREAT)\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-x&#160;&#160;&#160;Create exclusively (O_EXCL)\n");<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int flags, opt;<br/>&#160;&#160;&#160;&#160;mode_t perms;<br/>&#160;&#160;&#160;&#160;unsigned int value;<br/>&#160;&#160;&#160;&#160;sem_t *sem;<br/><br/>&#160;&#160;&#160;&#160;flags = 0;<br/>&#160;&#160;&#160;&#160;while ((opt = getopt(argc, argv, "cx")) != -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (opt) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'c':&#160;&#160;&#160;flags |= O_CREAT;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'x':&#160;&#160;&#160;flags |= O_EXCL;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default: usageError(argv[0]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (optind &gt;= argc)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0]);<br/><br/>&#160;&#160;&#160;&#160;/* Default permissions are rw-------; default semaphore initialization<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;value is 0 */<br/><br/>&#160;&#160;&#160;&#160;perms = (argc &lt;= optind + 1) ? (S_IRUSR | S_IWUSR) :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;getInt(argv[optind + 1], GN_BASE_8, "octal-perms");<br/>&#160;&#160;&#160;&#160;value = (argc &lt;= optind + 2) ? 0 : getInt(argv[optind + 2], 0, "value");<br/><br/>&#160;&#160;&#160;&#160;sem = sem_open(argv[optind], flags, perms, value);<br/>&#160;&#160;&#160;&#160;if (sem == SEM_FAILED)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sem_open");<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_______________________________________________________ <span class="codestrong">psem/psem_create.c</span></p>
<h4 class="h4" id="ch53lev2sec02"><span epub:type="pagebreak" id="page_1093"/><strong>53.2.2 Closing a Semaphore</strong></h4>
<p class="noindenta">When a process opens a named semaphore, the system records the association between the process and the semaphore. The <em>sem_close()</em> function terminates this association (i.e., closes the semaphore), releases any resources that the system has associated with the semaphore for this process, and decreases the count of processes referencing the semaphore.</p>
<div class="box">
<p class="programsa">#include &lt;semaphore.h&gt;<br/><br/>int <span class="codestrong">sem_close</span>(sem_t *<span class="font1">sem</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">Open named semaphores are also automatically closed on process termination or if the process performs an <em>exec()</em>.</p>
<p class="indent">Closing a semaphore does not delete it. For that purpose, we need to use <em>sem_unlink()</em>.</p>
<h4 class="h4" id="ch53lev2sec03"><strong>53.2.3 Removing a Named Semaphore</strong></h4>
<p class="noindenta">The <em>sem_unlink()</em> function removes the semaphore identified by <em>name</em> and marks the semaphore to be destroyed once all processes cease using it (this may mean immediately, if all processes that had the semaphore open have already closed it).</p>
<div class="box">
<p class="programsa">#include &lt;semaphore.h&gt;<br/><br/>int <span class="codestrong">sem_unlink</span>(const char *<span class="font1">name</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent"><a href="ch53.xhtml#ch53ex2">Listing 53-2</a> demonstrates the use of <em>sem_unlink()</em>.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1094"/><a id="ch53ex2"/><strong>Listing 53-2:</strong> Using <em>sem_unlink()</em> to unlink a POSIX named semaphore</p>
<p class="programsli">_______________________________________________________ <span class="codestrong">psem/psem_unlink.c</span><br/><br/>#include &lt;semaphore.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s sem-name\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;if (sem_unlink(argv[1]) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sem_unlink");<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_______________________________________________________ <span class="codestrong">psem/psem_unlink.c</span></p>
<h3 class="h3" id="ch53lev1sec03"><strong>53.3 Semaphore Operations</strong></h3>
<p class="noindentab">As with a System V semaphore, a POSIX semaphore is an integer that the system never allows to go below 0. However, POSIX semaphore operations differ from their System V counterparts in the following respects:</p>
<p class="bull">&#8226; The functions for changing a semaphore&#8217;s value&#8212;<em>sem_post()</em> and <em>sem_wait()</em>&#8212;operate on just one semaphore at a time. By contrast, the System V <em>semop()</em> system call can operate on multiple semaphores in a set.</p>
<p class="bull">&#8226; The <em>sem_post()</em> and <em>sem_wait()</em> functions increment and decrement a semaphore&#8217;s value by exactly one. By contrast, <em>semop()</em> can add and subtract arbitrary values.</p>
<p class="bull">&#8226; There is no equivalent of the wait-for-zero operation provided by System V semaphores (a <em>semop()</em> call where the <em>sops.sem_op</em> field is specified as 0).</p>
<p class="noindentt">From this list, it may seem that POSIX semaphores are less powerful than System V semaphores. However, this is not the case&#8212;anything that we can do with System V semaphores can also be done with POSIX semaphores. In a few cases, a bit more programming effort may be required, but, for typical scenarios, using POSIX semaphores actually requires less programming effort. (The System V semaphore API is rather more complicated than is required for most applications.)</p>
<h4 class="h4" id="ch53lev2sec04"><strong>53.3.1 Waiting on a Semaphore</strong></h4>
<p class="noindenta">The <em>sem_wait()</em> function decrements (decreases by 1) the value of the semaphore referred to by <em>sem</em>.</p>
<div class="box">
<p class="programsa">#include &lt;semaphore.h&gt;<br/><br/>int <span class="codestrong">sem_wait</span>(sem_t *<span class="font1">sem</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_1095"/>If the semaphore currently has a value greater than 0, <em>sem_wait()</em> returns immediately. If the value of the semaphore is currently 0, <em>sem_wait()</em> blocks until the semaphore value rises above 0; at that time, the semaphore is then decremented and <em>sem_wait()</em> returns.</p>
<p class="indent">If a blocked <em>sem_wait()</em> call is interrupted by a signal handler, then it fails with the error <span class="literal">EINTR</span>, regardless of whether the <span class="literal">SA_RESTART</span> flag was used when establishing the signal handler with <em>sigaction()</em>. (On some other UNIX implementations, <span class="literal">SA_RESTART</span> does cause <em>sem_wait()</em> to automatically restart.)</p>
<p class="indent">The program in <a href="ch53.xhtml#ch53ex3">Listing 53-3</a> provides a command-line interface to the <em>sem_wait()</em> function. We demonstrate the use of this program shortly.</p>
<p class="examplet"><a id="ch53ex3"/><strong>Listing 53-3:</strong> Using <em>sem_wait()</em> to decrement a POSIX semaphore</p>
<p class="programsli">_________________________________________________________ <span class="codestrong">psem/psem_wait.c</span><br/><br/>#include &lt;semaphore.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;sem_t *sem;<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s sem-name\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;sem = sem_open(argv[1], 0);<br/>&#160;&#160;&#160;&#160;if (sem == SEM_FAILED)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sem_open");<br/><br/>&#160;&#160;&#160;&#160;if (sem_wait(sem) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sem_wait");<br/><br/>&#160;&#160;&#160;&#160;printf("%ld sem_wait() succeeded\n", (long) getpid());<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________________ <span class="codestrong">psem/psem_wait.c</span></p>
<p class="noindent">The <em>sem_trywait()</em> function is a nonblocking version of <em>sem_wait()</em>.</p>
<div class="box">
<p class="programsa">#include &lt;semaphore.h&gt;<br/><br/>int <span class="codestrong">sem_trywait</span>(sem_t *<span class="font1">sem</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">If the decrement operation can&#8217;t be performed immediately, <em>sem_trywait()</em> fails with the error <span class="literal">EAGAIN</span>.</p>
<p class="indent">The <em>sem_timedwait()</em> function is another variation on <em>sem_wait()</em>. It allows the caller to specify a limit on the time for which the call will block.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_1096"/>#include &lt;semaphore.h&gt;<br/><br/>int <span class="codestrong">sem_timedwait</span>(sem_t *<span class="font1">sem</span>, const struct timespec *<span class="font1">abs_timeout</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">If a <em>sem_timedwait()</em> call times out without being able to decrement the semaphore, then the call fails with the error <span class="literal">ETIMEDOUT</span>.</p>
<p class="indent">The <em>abs_timeout</em> argument is a <em>timespec</em> structure (<a href="ch23.xhtml#ch23lev2sec02">Section 23.4.2</a>) that specifies the timeout as an absolute value in seconds and nanoseconds since the Epoch. If we want to perform a relative timeout, then we must fetch the current value of the <span class="literal">CLOCK_REALTIME</span> clock using <em>clock_gettime()</em> and add the required amount to that value to produce a <em>timespec</em> structure suitable for use with <em>sem_timedwait()</em>.</p>
<p class="indent">The <em>sem_timedwait()</em> function was originally specified in POSIX.1d (1999) and is not available on all UNIX implementations.</p>
<h4 class="h4" id="ch53lev2sec05"><strong>53.3.2 Posting a Semaphore</strong></h4>
<p class="noindenta">The <em>sem_post()</em> function increments (increases by 1) the value of the semaphore referred to by <em>sem</em>.</p>
<div class="box">
<p class="programsa">#include &lt;semaphore.h&gt;<br/><br/>int <span class="codestrong">sem_post</span>(sem_t *<span class="font1">sem</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">If the value of the semaphore was 0 before the <em>sem_post()</em> call, and some other process (or thread) is blocked waiting to decrement the semaphore, then that process is awoken, and its <em>sem_wait()</em> call proceeds to decrement the semaphore. If multiple processes (or threads) are blocked in <em>sem_wait()</em>, then, if the processes are being scheduled under the default round-robin time-sharing policy, it is indeterminate which one will be awoken and allowed to decrement the semaphore. (Like their System V counterparts, POSIX semaphores are only a synchronization mechanism, not a queuing mechanism.)</p>
<div class="block">
<p class="noindent">SUSv3 specifies that if processes or threads are being executed under a real-time scheduling policy, then the process or thread that will be awoken is the one with the highest priority that has been waiting the longest.</p>
</div>
<p class="noindent">As with System V semaphores, incrementing a POSIX semaphore corresponds to releasing some shared resource for use by another process or thread.</p>
<p class="indent">The program in <a href="ch53.xhtml#ch53ex4">Listing 53-4</a> provides a command-line interface to the <em>sem_post()</em> function. We demonstrate the use of this program shortly.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1097"/><a id="ch53ex4"/><strong>Listing 53-4:</strong> Using <em>sem_post()</em> to increment a POSIX semaphore</p>
<p class="programsli">_________________________________________________________ <span class="codestrong">psem/psem_post.c</span><br/><br/>#include &lt;semaphore.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;sem_t *sem;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 2)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s sem-name\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;sem = sem_open(argv[1], 0);<br/>&#160;&#160;&#160;&#160;if (sem == SEM_FAILED)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sem_open");<br/><br/>&#160;&#160;&#160;&#160;if (sem_post(sem) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sem_post");<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________________ <span class="codestrong">psem/psem_post.c</span></p>
<h4 class="h4" id="ch53lev2sec06"><strong>53.3.3 Retrieving the Current Value of a Semaphore</strong></h4>
<p class="noindenta">The <em>sem_getvalue()</em> function returns the current value of the semaphore referred to by <em>sem</em> in the <em>int</em> pointed to by <em>sval</em>.</p>
<div class="box">
<p class="programsa">#include &lt;semaphore.h&gt;<br/><br/>int <span class="codestrong">sem_getvalue</span>(sem_t *<span class="font1">sem</span>, int *<span class="font1">sval</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">If one or more processes (or threads) are currently blocked waiting to decrement the semaphore&#8217;s value, then the value returned in <em>sval</em> depends on the implementation. SUSv3 permits two possibilities: 0 or a negative number whose absolute value is the number of waiters blocked in <em>sem_wait()</em>. Linux and several other implementations adopt the former behavior; a few other implementations adopt the latter behavior.</p>
<div class="block">
<p class="noindent">Although returning a negative <em>sval</em> if there are blocked waiters can be useful, especially for debugging purposes, SUSv3 doesn&#8217;t require this behavior because the techniques that some systems use to efficiently implement POSIX semaphores don&#8217;t (in fact, can&#8217;t) record counts of blocked waiters.</p>
</div>
<p class="noindent">Note that by the time <em>sem_getvalue()</em> returns, the value returned in <em>sval</em> may already be out of date. A program that depends on the information returned by <em>sem_getvalue()</em> being unchanged by the time of a subsequent operation will be subject to time-of-check, time-of-use race conditions (<a href="ch38.xhtml#ch38lev1sec06">Section 38.6</a>).</p>
<p class="indent"><span epub:type="pagebreak" id="page_1098"/>The program in <a href="ch53.xhtml#ch53ex5">Listing 53-5</a> uses <em>sem_getvalue()</em> to retrieve the value of the semaphore named in its command-line argument, and then displays that value on standard output.</p>
<p class="examplet"><a id="ch53ex5"/><strong>Listing 53-5:</strong> Using <em>sem_getvalue()</em> to retrieve the value of a POSIX semaphore</p>
<p class="programsli">______________________________________________________ <span class="codestrong">psem/psem_getvalue.c</span><br/><br/>#include &lt;semaphore.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int value;<br/>&#160;&#160;&#160;&#160;sem_t *sem;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 2)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s sem-name\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;sem = sem_open(argv[1], 0);<br/>&#160;&#160;&#160;&#160;if (sem == SEM_FAILED)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sem_open");<br/><br/>&#160;&#160;&#160;&#160;if (sem_getvalue(sem, &#38;value) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sem_getvalue");<br/><br/>&#160;&#160;&#160;&#160;printf("%d\n", value);<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>______________________________________________________ <span class="codestrong">psem/psem_getvalue.c</span></p>
<h5 class="h5" id="ch53lev3sec02"><strong>Example</strong></h5>
<p class="noindenta">The following shell session log demonstrates the use of the programs we have shown so far in this chapter. We begin by creating a semaphore whose initial value is zero, and then start a program in the background that attempts to decrement the semaphore:</p>
<p class="programs">$ <span class="codestrong">./psem_create -c /demo 600 0</span><br/>$ <span class="codestrong">./psem_wait /demo &#38;</span><br/>[1] 31208</p>
<p class="noindent">The background command blocks, because the semaphore value is currently 0 and therefore can&#8217;t be decreased.</p>
<p class="indent">We then retrieve the semaphore value:</p>
<p class="programs">$ <span class="codestrong">./psem_getvalue /demo</span><br/>0</p>
<p class="noindent">We see the value 0 above. On some other implementations, we might see the value &#8211;1, indicating that one process is waiting on the semaphore.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1099"/>We then execute a command that increments the semaphore. This causes the blocked <em>sem_wait()</em> in the background program to complete:</p>
<p class="programs">$ <span class="codestrong">./psem_post /demo</span><br/>$ 31208 sem_wait() succeeded</p>
<p class="noindent">(The last line of output above shows the shell prompt mixed with the output of the background job.)</p>
<p class="indent">We press <em>Enter</em> to see the next shell prompt, which also causes the shell to report on the terminated background job, and then perform further operations on the semaphore:</p>
<p class="programs"><span class="font1">Press Enter</span><br/>[1]-&#160;&#160;Done&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;./psem_wait /demo<br/>$ <span class="codestrong">./psem_post /demo</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Increment semaphore</span><br/>$ <span class="codestrong">./psem_getvalue /demo</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Retrieve semaphore value</span><br/>1<br/>$ <span class="codestrong">./psem_unlink /demo</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">We're done with this semaphore</span></p>
<h3 class="h3" id="ch53lev1sec04"><strong>53.4 Unnamed Semaphores</strong></h3>
<p class="noindenta">Unnamed semaphores (also known as <em>memory-based semaphores</em>) are variables of type <em>sem_t</em> that are stored in memory allocated by the application. The semaphore is made available to the processes or threads that use it by placing it in an area of memory that they share.</p>
<p class="indentb">Operations on unnamed semaphores use the same functions (<em>sem_wait()</em>, <em>sem_post()</em>, <em>sem_getvalue()</em>, and so on) that are used to operate on named semaphores. In addition, two further functions are required:</p>
<p class="bull">&#8226; The <em>sem_init()</em> function initializes a semaphore and informs the system of whether the semaphore will be shared between processes or between the threads of a single process.</p>
<p class="bull">&#8226; The <em>sem_destroy()</em> function destroys a semaphore.</p>
<p class="noindentt">These functions should not be used with named semaphores.</p>
<h5 class="h5" id="ch53lev3sec03"><strong>Unnamed versus named semaphores</strong></h5>
<p class="noindentab">Using an unnamed semaphore allows us to avoid the work of creating a name for a semaphore. This can be useful in the following cases:</p>
<p class="bull">&#8226; A semaphore that is shared between threads doesn&#8217;t need a name. Making an unnamed semaphore a shared (global or heap) variable automatically makes it accessible to all threads.</p>
<p class="bull">&#8226; A semaphore that is being shared between related processes doesn&#8217;t need a name. If a parent process allocates an unnamed semaphore in a region of shared memory (e.g., a shared anonymous mapping), then a child automatically inherits the mapping and thus the semaphore as part of the operation of <em>fork()</em>.</p>
<p class="bull"><span epub:type="pagebreak" id="page_1100"/>&#8226; If we are building a dynamic data structure (e.g., a binary tree), each of whose items requires an associated semaphore, then the simplest approach is to allocate an unnamed semaphore within each item. Opening a named semaphore for each item would require us to design a convention for generating a (unique) semaphore name for each item and to manage those names (e.g., unlinking them when they are no longer required).</p>
<h4 class="h4" id="ch53lev2sec07"><strong>53.4.1 Initializing an Unnamed Semaphore</strong></h4>
<p class="noindenta">The <em>sem_init()</em> function initializes the unnamed semaphore pointed to by <em>sem</em> to the value specified by <em>value</em>.</p>
<div class="box">
<p class="programsa">#include &lt;semaphore.h&gt;<br/><br/>int <span class="codestrong">sem_init</span>(sem_t *<span class="font1">sem</span>, int <span class="font1">pshared</span>, unsigned int <span class="font1">value</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb">The <em>pshared</em> argument indicates whether the semaphore is to be shared between threads or between processes.</p>
<p class="bull">&#8226; If <em>pshared</em> is 0, then the semaphore is to be shared between the threads of the calling process. In this case, <em>sem</em> is typically specified as the address of either a global variable or a variable allocated on the heap. A thread-shared semaphore has process persistence; it is destroyed when the process terminates.</p>
<p class="bull">&#8226; If <em>pshared</em> is nonzero, then the semaphore is to be shared between processes. In this case, <em>sem</em> must be the address of a location in a region of shared memory (a POSIX shared memory object, a shared mapping created using <em>mmap()</em>, or a System V shared memory segment). The semaphore persists as long as the shared memory in which it resides. (The shared memory regions created by most of these techniques have kernel persistence. The exception is shared anonymous mappings, which persist only as long as at least one process maintains the mapping.) Since a child produced via <em>fork()</em> inherits its parent&#8217;s memory mappings, process-shared semaphores are inherited by the child of a <em>fork()</em>, and the parent and child can use these semaphores to synchronize their actions.</p>
<p class="noindenttb">The <em>pshared</em> argument is necessary for the following reasons:</p>
<p class="bull">&#8226; Some implementations don&#8217;t support process-shared semaphores. On these systems, specifying a nonzero value for <em>pshared</em> causes <em>sem_init()</em> to return an error. Linux did not support unnamed process-shared semaphores until kernel 2.6 and the advent of the NPTL threading implementation. (The older LinuxThreads implementation of <em>sem_init()</em> fails with the error <span class="literal">ENOSYS</span> if a nonzero value is specified for <em>pshared</em>.)</p>
<p class="bull">&#8226; On implementations that support both process-shared and thread-shared semaphores, specifying which kind of sharing is required may be necessary because the system must take special actions to support the requested sharing. Providing this information may also permit the system to perform optimizations depending on the type of sharing.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_1101"/>The initial NPTL <em>sem_init()</em> implementation ignored <em>pshared</em>. However, since glibc version 2.7, this argument must be set appropriately so that the implementation provides correct behavior.</p>
<div class="block">
<p class="noindent">The SUSv3 specification for <em>sem_init()</em> defines a failure return of &#8211;1, but makes no statement about the return value on success. Nevertheless, the manual pages on most modern UNIX implementations document a 0 return on success. (One notable exception is Solaris, where the description of the return value is similar to the SUSv3 specification. However, inspecting the OpenSolaris source code shows that, on that implementation, <em>sem_init()</em> does return 0 on success.) SUSv4 rectifies the situation, specifying that <em>sem_init()</em> shall return 0 on success.</p>
</div>
<p class="noindent">There are no permission settings associated with an unnamed semaphore (i.e., <em>sem_init()</em> has no analog of the <em>mode</em> argument of <em>sem_open()</em>). Access to an unnamed semaphore is governed by the permissions that are granted to the process for the underlying shared memory region.</p>
<p class="indent">SUSv3 specifies that initializing an already initialized unnamed semaphore results in undefined behavior. In other words, we must design our applications so that just one process or thread calls <em>sem_init()</em> to initialize a semaphore.</p>
<p class="indent">As with named semaphores, SUSv3 says that the results are undefined if we attempt to perform operations on a <em>copy</em> of the <em>sem_t</em> variable whose address is passed as the <em>sem</em> argument of <em>sem_init()</em>. Operations should always be performed only on the &#8220;original&#8221; semaphore.</p>
<h5 class="h5" id="ch53lev3sec04"><strong>Example program</strong></h5>
<p class="noindenta">In <a href="ch30.xhtml#ch30lev2sec02">Section 30.1.2</a>, we presented a program (<a href="ch30.xhtml#ch30ex2">Listing 30-2</a>) that used mutexes to protect a critical section in which two threads accessed the same global variable. The program in <a href="ch53.xhtml#ch53ex6">Listing 53-6</a> solves the same problem using an unnamed thread-shared semaphore.</p>
<p class="examplet"><a id="ch53ex6"/><strong>Listing 53-6:</strong> Using a POSIX unnamed semaphore to protect access to a global variable</p>
<p class="programsli">___________________________________________________ <span class="codestrong">psem/thread_incr_psem.c</span><br/><br/>#include &lt;semaphore.h&gt;<br/>#include &lt;pthread.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static int glob = 0;<br/>static sem_t sem;<br/><br/>static void *&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Loop 'arg' times incrementing 'glob' */<br/>threadFunc(void *arg)<br/>{<br/>&#160;&#160;&#160;&#160;int loops = *((int *) arg);<br/>&#160;&#160;&#160;&#160;int loc, j;<br/><br/>&#160;&#160;&#160;&#160;for (j = 0; j &lt; loops; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sem_wait(&#38;sem) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sem_wait");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;loc = glob;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;loc++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;glob = loc;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sem_post(&#38;sem) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sem_post");<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;return NULL;<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;pthread_t t1, t2;<br/>&#160;&#160;&#160;&#160;int loops, s;<br/><br/>&#160;&#160;&#160;&#160;loops = (argc &gt; 1) ? getInt(argv[1], GN_GT_0, "num-loops") : 10000000;<br/><br/>&#160;&#160;&#160;&#160;/* Initialize a semaphore with the value 1 */<br/><br/>&#160;&#160;&#160;&#160;if (sem_init(&#38;sem, 0, 1) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sem_init");<br/><br/>&#160;&#160;&#160;&#160;/* Create two threads that increment 'glob' */<br/><br/>&#160;&#160;&#160;&#160;s = pthread_create(&#38;t1, NULL, threadFunc, &#38;loops);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_create");<br/>&#160;&#160;&#160;&#160;s = pthread_create(&#38;t2, NULL, threadFunc, &#38;loops);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_create");<br/><br/>&#160;&#160;&#160;&#160;/* Wait for threads to terminate */<br/><br/>&#160;&#160;&#160;&#160;s = pthread_join(t1, NULL);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_join");<br/>&#160;&#160;&#160;&#160;s = pthread_join(t2, NULL);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_join");<br/><br/>&#160;&#160;&#160;&#160;printf("glob = %d\n", glob);<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>___________________________________________________ <span class="codestrong">psem/thread_incr_psem.c</span></p>
<h4 class="h4" id="ch53lev2sec08"><span epub:type="pagebreak" id="page_1102"/><strong>53.4.2 Destroying an Unnamed Semaphore</strong></h4>
<p class="noindenta">The <em>sem_destroy()</em> function destroys the semaphore <em>sem</em>, which must be an unnamed semaphore that was previously initialized using <em>sem_init()</em>. It is safe to destroy a semaphore only if no processes or threads are waiting on it.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_1103"/>#include &lt;semaphore.h&gt;<br/><br/>int <span class="codestrong">sem_destroy</span>(sem_t *<span class="font1">sem</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">After an unnamed semaphore segment has been destroyed with <em>sem_destroy()</em>, it can be reinitialized with <em>sem_init()</em>.</p>
<p class="indent">An unnamed semaphore should be destroyed before its underlying memory is deallocated. For example, if the semaphore is an automatically allocated variable, it should be destroyed before its host function returns. If the semaphore resides in a POSIX shared memory region, then it should be destroyed after all processes have ceased using the semaphore and before the last process unmaps the region.</p>
<p class="indent">On some implementations, omitting calls to <em>sem_destroy()</em> doesn&#8217;t cause problems. However, on other implementations, failing to call <em>sem_destroy()</em> can result in resource leaks. Portable applications should call <em>sem_destroy()</em> to avoid such problems.</p>
<h3 class="h3" id="ch53lev1sec05"><strong>53.5 Comparisons with Other Synchronization Techniques</strong></h3>
<p class="noindenta">In this section, we compare POSIX semaphores with two other synchronization techniques: System V semaphores and mutexes.</p>
<h5 class="h5" id="ch53lev3sec05"><strong>POSIX semaphores versus System V semaphores</strong></h5>
<p class="noindenta">POSIX semaphores and System V semaphores can both be used to synchronize the actions of processes. <a href="ch51.xhtml#ch51lev1sec02">Section 51.2</a> listed various advantages of POSIX IPC over System V IPC: the POSIX IPC interface is simpler and more consistent with the traditional UNIX file model, and POSIX IPC objects are reference counted, which simplifies the task of determining when to delete an IPC object. These general advantages also apply to the specific case of POSIX (named) semaphores versus System V semaphores.</p>
<p class="indentb">POSIX semaphores have the following further advantages over System V semaphores:</p>
<p class="bull">&#8226; The POSIX semaphore interface is much simpler than the System V semaphore interface. This simplicity is achieved without loss of functional power.</p>
<p class="bull">&#8226; POSIX named semaphores eliminate the initialization problem associated with System V semaphores (<a href="ch47.xhtml#ch47lev1sec05">Section 47.5</a>).</p>
<p class="bull">&#8226; It is easier to associate a POSIX unnamed semaphore with a dynamically allocated memory object: the semaphore can simply be embedded inside the object.</p>
<p class="bull">&#8226; In scenarios where there is a high degree of contention for a semaphore (i.e., operations on the semaphore are frequently blocked because another process has set the semaphore to a value that prevents the operation proceeding immediately), then the performance of POSIX semaphores and System V semaphores is similar. However, in cases where there is low contention for a semaphore (i.e., the semaphore&#8217;s value is such that operations can normally proceed without blocking), then POSIX semaphores perform considerably better <span epub:type="pagebreak" id="page_1104"/>than System V semaphores. (On the systems tested by the author, the difference in performance is more than an order of magnitude; see <a href="ch53.xhtml#ch53exe4">Exercise 53-4</a>.) POSIX semaphores perform so much better in this case because the way in which they are implemented only requires a system call when contention occurs, whereas System V semaphore operations always require a system call, regardless of contention.</p>
<p class="noindenttb">However, POSIX semaphores also have the following disadvantages compared to System V semaphores:</p>
<p class="bull">&#8226; POSIX semaphores are somewhat less portable. (On Linux, named semaphores have been supported only since kernel 2.6.)</p>
<p class="bull">&#8226; POSIX semaphores don&#8217;t provide an equivalent of the System V semaphore undo feature. (However, as we noted in <a href="ch47.xhtml#ch47lev1sec08">Section 47.8</a>, this feature may not be useful in some circumstances.)</p>
<h5 class="h5" id="ch53lev3sec06"><strong>POSIX semaphores versus Pthreads mutexes</strong></h5>
<p class="noindenta">POSIX semaphores and Pthreads mutexes can both be used to synchronize the actions of threads within the same process, and their performance is similar. However, mutexes are usually preferable, because the ownership property of mutexes enforces good structuring of code (only the thread that locks a mutex can unlock it). By contrast, one thread can increment a semaphore that was decremented by another thread. This flexibility can lead to poorly structured synchronization designs. (For this reason, semaphores are sometimes referred to as the &#8220;gotos&#8221; of concurrent programming.)</p>
<p class="indent">There is one circumstance in which mutexes can&#8217;t be used in a multithreaded application and semaphores may therefore be preferable. Because it is async-signal-safe (see <a href="ch21.xhtml#ch21table1">Table 21-1</a>, on <a href="ch21.xhtml#page_426">page 426</a>), the <em>sem_post()</em> function can be used from within a signal handler to synchronize with another thread. This is not possible with mutexes, because the Pthreads functions for operating on mutexes are not async-signal-safe. However, because it is usually preferable to deal with asynchronous signals by accepting them using <em>sigwaitinfo()</em> (or similar), rather than using signal handlers (see <a href="ch33.xhtml#ch33lev2sec04">Section 33.2.4</a>), this advantage of semaphores over mutexes is seldom required.</p>
<h3 class="h3" id="ch53lev1sec06"><strong>53.6 Semaphore Limits</strong></h3>
<p class="noindentab">SUSv3 defines two limits applying to semaphores:</p>
<p class="term"><span class="literal">SEM_NSEMS_MAX</span></p>
<p class="termlist">This is the maximum number of POSIX semaphores that a process may have. SUSv3 requires that this limit be at least 256. On Linux, the number of POSIX semaphores is effectively limited only by available memory.</p>
<p class="term"><span epub:type="pagebreak" id="page_1105"/><span class="literal">SEM_VALUE_MAX</span></p>
<p class="termlist">This is the maximum value that a POSIX semaphore may reach. Semaphores may assume any value from 0 up to this limit. SUSv3 requires this limit to be at least 32,767; the Linux implementation allows values up to <span class="literal">INT_MAX</span> (2,147,483,647).</p>
<h3 class="h3" id="ch53lev1sec07"><strong>53.7 Summary</strong></h3>
<p class="noindenta">POSIX semaphores allow processes or threads to synchronize their actions. POSIX semaphores come in two types: named and unnamed. A named semaphore is identified by a name, and can be shared by any processes that have permission to open the semaphore. An unnamed semaphore has no name, but processes or threads can share the same semaphore by placing it in a region of memory that they share (e.g., in a POSIX shared memory object for process sharing, or in a global variable for thread sharing).</p>
<p class="indent">The POSIX semaphore interface is simpler than the System V semaphore interface. Semaphores are allocated and operated on individually, and the wait and post operations adjust a semaphore&#8217;s value by one.</p>
<p class="indent">POSIX semaphores have a number of advantages over System V semaphores, but they are somewhat less portable. For synchronization within multithreaded applications, mutexes are generally preferred over semaphores.</p>
<h5 class="h5" id="ch53lev3sec07"><strong>Further information</strong></h5>
<p class="noindenta">[<a href="bib.xhtml#bib90">Stevens, 1999</a>] provides an alternative presentation of POSIX semaphores and shows user-space implementations using various other IPC mechanisms (FIFOs, memory-mapped files, and System V semaphores). [<a href="bib.xhtml#bib10">Butenhof, 1996</a>] describes the use of POSIX semaphores in multithreaded applications.</p>
<h3 class="h3" id="ch53lev1sec08"><strong>53.8 Exercises</strong></h3>
<p class="exer"><a id="ch53exe1"/><strong>53-1.</strong>&#160;&#160;&#160;Rewrite the programs in <a href="ch48.xhtml#ch48ex2">Listing 48-2</a> and <a href="ch48.xhtml#ch48ex3">Listing 48-3</a> (<a href="ch48.xhtml#ch48lev1sec04">Section 48.4</a>) as a threaded application, with the two threads passing data to each other via a global buffer, and using POSIX semaphores for synchronization.</p>
<p class="exer"><a id="ch53exe2"/><strong>53-2.</strong>&#160;&#160;&#160;Modify the program in <a href="ch53.xhtml#ch53ex3">Listing 53-3</a> (<span class="literal">psem_wait.c</span>) to use <em>sem_timedwait()</em> instead of <em>sem_wait()</em>. The program should take an additional command-line argument that specifies a (relative) number of seconds to be used as the timeout for the <em>sem_timedwait()</em> call.</p>
<p class="exer"><a id="ch53exe3"/><strong>53-3.</strong>&#160;&#160;&#160;Devise an implementation of POSIX semaphores using System V semaphores.</p>
<p class="exer"><a id="ch53exe4"/><strong>53-4.</strong>&#160;&#160;&#160;In <a href="ch53.xhtml#ch53lev1sec05">Section 53.5</a>, we noted that POSIX semaphores perform much better than System V semaphores in the case where the semaphore is uncontended. Write two programs (one for each semaphore type) to verify this. Each program should simply increment and decrement a semaphore a specified number of times. Compare the times required for the two programs.<span epub:type="pagebreak" id="page_1106"/></p>
</body>
</html>
