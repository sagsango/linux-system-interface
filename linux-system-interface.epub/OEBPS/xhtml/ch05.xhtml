<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_89"/><strong><span class="big">5</span></strong><br/><strong>FILE I/O: FURTHER DETAILS</strong></h2>
<p class="noindenta">In this chapter, we extend the discussion of file I/O that we started in the previous chapter.</p>
<p class="indent">In continuing the discussion of the <em>open()</em> system call, we explain the concept of <em>atomicity</em>&#8212;the notion that the actions performed by a system call are executed as a single uninterruptible step. This is a necessary requirement for the correct operation of many system calls.</p>
<p class="indent">We introduce another file-related system call, the multipurpose <em>fcntl()</em>, and show one of its uses: fetching and setting open file status flags.</p>
<p class="indent">Next, we look at the kernel data structures used to represent file descriptors and open files. Understanding the relationship between these structures clarifies some of the subtleties of file I/O discussed in subsequent chapters. Building on this model, we then explain how to duplicate file descriptors.</p>
<p class="indent">We then consider some system calls that provide extended read and write functionality. These system calls allow us to perform I/O at a specific location in a file without changing the file offset, and to transfer data to and from multiple buffers in a program.</p>
<p class="indent">We briefly introduce the concept of nonblocking I/O, and describe some extensions provided to support I/O on very large files.</p>
<p class="indent">Since temporary files are used by many system programs, we&#8217;ll also look at some library functions that allow us to create and use temporary files with randomly generated unique names.</p>
<h3 class="h3" id="ch05lev1sec01"><span epub:type="pagebreak" id="page_90"/><strong>5.1 Atomicity and Race Conditions</strong></h3>
<p class="noindenta">Atomicity is a concept that we&#8217;ll encounter repeatedly when discussing the operation of system calls. Various system call operations are executed atomically. By this, we mean that the kernel guarantees that all of the steps in the operation are completed without being interrupted by another process or thread.</p>
<p class="indent">Atomicity is essential to the successful completion of some operations. In particular, it allows us to avoid <em>race conditions</em> (sometimes known as <em>race hazards</em>). A race condition is a situation where the result produced by two processes (or threads) operating on shared resources depends in an unexpected way on the relative order in which the processes gain access to the CPU(s).</p>
<p class="indent">In the next few pages, we look at two situations involving file I/O where race conditions occur, and show how these conditions are eliminated through the use of <em>open()</em> flags that guarantee the atomicity of the relevant file operations.</p>
<p class="indent">We revisit the topic of race conditions when we describe <em>sigsuspend()</em> in <a href="ch22.xhtml#ch22lev1sec09">Section 22.9</a> and <em>fork()</em> in <a href="ch24.xhtml#ch24lev1sec04">Section 24.4</a>.</p>
<h5 class="h5" id="ch05lev3sec01"><strong>Creating a file exclusively</strong></h5>
<p class="noindenta">In <a href="ch04.xhtml#ch04lev2sec01">Section 4.3.1</a>, we noted that specifying <span class="literal">O_EXCL</span> in conjunction with <span class="literal">O_CREAT</span> causes <em>open()</em> to return an error if the file already exists. This provides a way for a process to ensure that it is the creator of a file. The check on the prior existence of the file and the creation of the file are performed atomically. To see why this is important, consider the code shown in <a href="ch05.xhtml#ch5ex1">Listing 5-1</a>, which we might resort to in the absence of the <span class="literal">O_EXCL</span> flag. (In this code, we display the process ID returned by the <em>getpid()</em> system call, which enables us to distinguish the output of two different runs of this program.)</p>
<p class="examplet"><a id="ch5ex1"/><strong>Listing 5-1:</strong> Incorrect code to exclusively open a file</p>
<p class="programsli">____________________________________________ <span class="font1">from</span> <span class="codestrong">fileio/bad_exclusive_open.c</span><br/><br/>&#160;&#160;&#160;&#160;fd = open(argv[1], O_WRONLY);&#160;&#160;&#160;/* Open 1: check if file exists */<br/>&#160;&#160;&#160;&#160;if (fd != -1) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Open succeeded */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("[PID %ld] File \"%s\" already exists\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) getpid(), argv[1]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;close(fd);<br/>&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno != ENOENT) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Failed for unexpected reason */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* WINDOW FOR FAILURE */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fd = open(argv[1], O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("[PID %ld] Created file \"%s\" exclusively\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) getpid(), argv[1]);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* MAY NOT BE TRUE! */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>___________________________________________ <span class="font1">from</span> <span class="codestrong">fileio/bad_exclusive_open.c</span></p>
<p class="noindent">Aside from the long-winded use of two calls to <em>open()</em>, the code in <a href="ch05.xhtml#ch5ex1">Listing 5-1</a> also contains a bug. Suppose that when our process first called <em>open()</em>, the file did not <span epub:type="pagebreak" id="page_91"/>exist, but by the time of the second <em>open()</em>, some other process had created the file. This could happen if the kernel scheduler decided that the process&#8217;s time slice had expired and gave control to another process, as shown in <a href="ch05.xhtml#ch5fig1">Figure 5-1</a>, or if the two processes were running at the same time on a multiprocessor system. <a href="ch05.xhtml#ch5fig1">Figure 5-1</a> portrays the case where two processes are both executing the code shown in <a href="ch05.xhtml#ch5ex1">Listing 5-1</a>. In this scenario, process A would wrongly conclude that it had created the file, since the second <em>open()</em> succeeds whether or not the file exists.</p>
<p class="indent">While the chance of the process wrongly believing it was the creator of the file is relatively small, the possibility that it may occur nevertheless renders this code unreliable. The fact that the outcome of these operations depends on the order of scheduling of the two processes means that this is a race condition.</p>
<div class="image"><img src="../images/f05-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch5fig1"/><strong>Figure 5-1:</strong> Failing to exclusively create a file</p>
<p class="noindent">To demonstrate that there is indeed a problem with this code, we could replace the commented line <span class="literal">WINDOW FOR FAILURE</span> in <a href="ch05.xhtml#ch5ex1">Listing 5-1</a> with a piece of code that creates an artificially long delay between the check for file existence and the creation of the file:</p>
<p class="programs">printf("[PID %ld] File \"%s\" doesn't exist yet\n", (long) getpid(), argv[1]);<br/>if (argc &gt; 2) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Delay between check and create */<br/>&#160;&#160;&#160;&#160;sleep(5);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Suspend execution for 5 seconds */<br/>&#160;&#160;&#160;&#160;printf("[PID %ld] Done sleeping\n", (long) getpid());<br/>}</p>
<div class="block">
<p class="noindent">The <em>sleep()</em> library function suspends the execution of a process for a specified number of seconds. We discuss this function in <a href="ch23.xhtml#ch23lev1sec04">Section 23.4</a>.</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_92"/>If we run two simultaneous instances of the program in <a href="ch05.xhtml#ch5ex1">Listing 5-1</a>, we see that they both claim to have exclusively created the file:</p>
<p class="programs">$ <span class="codestrong">./bad_exclusive_open tfile sleep &#38;</span><br/>[PID 3317] File "tfile" doesn't exist yet<br/>[1] 3317<br/>$ <span class="codestrong">./bad_exclusive_open tfile</span><br/>[PID 3318] File "tfile" doesn't exist yet<br/>[PID 3318] Created file "tfile" exclusively<br/>$ [PID 3317] Done sleeping<br/>[PID 3317] Created file "tfile" exclusively&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Not true</span></p>
<div class="block">
<p class="noindent">In the penultimate line of the above output, we see the shell prompt mixed with output from the first instance of the test program.</p>
</div>
<p class="noindent">Both processes claim to have created the file because the code of the first process was interrupted between the existence check and the creation of the file. Using a single <em>open()</em> call that specifies the <span class="literal">O_CREAT</span> and <span class="literal">O_EXCL</span> flags prevents this possibility by guaranteeing that the check and creation steps are carried out as a single atomic (i.e., uninterruptible) operation.</p>
<h5 class="h5" id="ch05lev3sec02"><strong>Appending data to a file</strong></h5>
<p class="noindenta">A second example of the need for atomicity is when we have multiple processes appending data to the same file (e.g., a global log file). For this purpose, we might consider using a piece of code such as the following in each of our writers:</p>
<p class="programs">if (lseek(fd, 0, SEEK_END) == -1)<br/>&#160;&#160;&#160;&#160;errExit("lseek");<br/>if (write(fd, buf, len) != len)<br/>&#160;&#160;&#160;&#160;fatal("Partial/failed write");</p>
<p class="noindent">However, this code suffers the same defect as the previous example. If the first process executing the code is interrupted between the <em>lseek()</em> and <em>write()</em> calls by a second process doing the same thing, then both processes will set their file offset to the same location before writing, and when the first process is rescheduled, it will overwrite the data already written by the second process. Again, this is a race condition because the results depend on the order of scheduling of the two processes.</p>
<p class="indent">Avoiding this problem requires that the seek to the next byte past the end of the file and the write operation happen atomically. This is what opening a file with the <span class="literal">O_APPEND</span> flag guarantees.</p>
<div class="block">
<p class="noindent">Some file systems (e.g., NFS) don&#8217;t support <span class="literal">O_APPEND</span>. In this case, the kernel reverts to the nonatomic sequence of calls shown above, with the consequent possibility of file corruption as just described.</p>
</div>
<h3 class="h3" id="ch05lev1sec02"><strong>5.2 File Control Operations: <em>fcntl()</em></strong></h3>
<p class="noindenta">The <em>fcntl()</em> system call performs a range of control operations on an open file descriptor.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_93"/>#include &lt;fcntl.h&gt;<br/><br/>int <span class="codestrong">fcntl</span>(int <span class="font1">fd</span>, int <span class="font1">cmd</span>, ...);</p>
<p class="right">Return value on success depends on <em>cmd</em>; returns &#8211;1 on error</p>
</div>
<p class="noindent">The <em>cmd</em> argument can specify a wide range of operations. We examine some of them in the following sections, and delay examination of others until later chapters.</p>
<p class="indent">As indicated by the ellipsis, the third argument to <em>fcntl()</em> can be of different types, or it can be omitted. The kernel uses the value of the <em>cmd</em> argument to determine the data type (if any) to expect for this argument.</p>
<h3 class="h3" id="ch05lev1sec03"><strong>5.3 Open File Status Flags</strong></h3>
<p class="noindenta">One use of <em>fcntl()</em> is to retrieve or modify the access mode and open file status flags of an open file. (These are the values set by the <em>flags</em> argument specified in the call to <em>open()</em>.) To retrieve these settings, we specify <em>cmd</em> as <span class="literal">F_GETFL</span>:</p>
<p class="programs">int flags, accessMode;<br/><br/>flags = fcntl(fd, F_GETFL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Third argument is not required */<br/>if (flags == -1)<br/>&#160;&#160;&#160;&#160;errExit("fcntl");</p>
<p class="noindent">After the above piece of code, we could test if the file was opened for synchronized writes as follows:</p>
<p class="programs">if (flags &#38; O_SYNC)<br/>&#160;&#160;&#160;&#160;printf("writes are synchronized\n");</p>
<div class="block">
<p class="noindent">SUSv3 requires that only status flags that were specified during an <em>open()</em> or a later <em>fcntl()</em> <span class="literal">F_SETFL</span> should be set on an open file. However, Linux deviates from this in one respect: if an application was compiled using one of the techniques described in <a href="ch05.xhtml#ch05lev1sec10">Section 5.10</a> for opening large files, then <span class="literal">O_LARGEFILE</span> will always be set in the flags retrieved by <span class="literal">F_GETFL</span>.</p>
</div>
<p class="noindent">Checking the access mode of the file is slightly more complex, since the <span class="literal">O_RDONLY</span> (0), <span class="literal">O_WRONLY</span> (1), and <span class="literal">O_RDWR</span> (2) constants don&#8217;t correspond to single bits in the open file status flags. Therefore, to make this check, we mask the <em>flags</em> value with the constant <span class="literal">O_ACCMODE</span>, and then test for equality with one of the constants:</p>
<p class="programs">accessMode = flags &#38; O_ACCMODE;<br/>if (accessMode == O_WRONLY || accessMode == O_RDWR)<br/>&#160;&#160;&#160;&#160;printf("file is writable\n");</p>
<p class="noindent">We can use the <em>fcntl()</em> <span class="literal">F_SETFL</span> command to modify some of the open file status flags. The flags that can be modified are <span class="literal">O_APPEND</span>, <span class="literal">O_NONBLOCK</span>, <span class="literal">O_NOATIME</span>, <span class="literal">O_ASYNC</span>, and <span class="literal">O_DIRECT</span>. Attempts to modify other flags are ignored. (Some other UNIX implementations allow <em>fcntl()</em> to modify other flags, such as <span class="literal">O_SYNC</span>.)</p>
<p class="indentb"><span epub:type="pagebreak" id="page_94"/>Using <em>fcntl()</em> to modify open file status flags is particularly useful in the following cases:</p>
<p class="bull">&#8226; The file was not opened by the calling program, so that it had no control over the flags used in the <em>open()</em> call (e.g., the file may be one of the three standard descriptors that are opened before the program is started).</p>
<p class="bull">&#8226; The file descriptor was obtained from a system call other than <em>open()</em>. Examples of such system calls are <em>pipe()</em>, which creates a pipe and returns two file descriptors referring to either end of the pipe, and <em>socket()</em>, which creates a socket and returns a file descriptor referring to the socket.</p>
<p class="noindentt">To modify the open file status flags, we use <em>fcntl()</em> to retrieve a copy of the existing flags, then modify the bits we wish to change, and finally make a further call to <em>fcntl()</em> to update the flags. Thus, to enable the <span class="literal">O_APPEND</span> flag, we would write the following:</p>
<p class="programs">int flags;<br/><br/>flags = fcntl(fd, F_GETFL);<br/>if (flags == -1)<br/>&#160;&#160;&#160;&#160;errExit("fcntl");<br/>flags |= O_APPEND;<br/>if (fcntl(fd, F_SETFL, flags) == -1)<br/>&#160;&#160;&#160;&#160;errExit("fcntl");</p>
<h3 class="h3" id="ch05lev1sec04"><strong>5.4 Relationship Between File Descriptors and Open Files</strong></h3>
<p class="noindenta">Up until now, it may have appeared that there is a one-to-one correspondence between a file descriptor and an open file. However, this is not the case. It is possible&#8212;and useful&#8212;to have multiple descriptors referring to the same open file. These file descriptors may be open in the same process or in different processes.</p>
<p class="indentb">To understand what is going on, we need to examine three data structures maintained by the kernel:</p>
<p class="bull">&#8226; the per-process file descriptor table;</p>
<p class="bull">&#8226; the system-wide table of open file descriptions; and</p>
<p class="bull">&#8226; the file system i-node table.</p>
<p class="noindenttb">For each process, the kernel maintains a table of <em>open file descriptors</em>. Each entry in this table records information about a single file descriptor, including:</p>
<p class="bull">&#8226; a set of flags controlling the operation of the file descriptor (there is just one such flag, the close-on-exec flag, which we describe in <a href="ch27.xhtml#ch27lev1sec04">Section 27.4</a>); and</p>
<p class="bull">&#8226; a reference to the open file description.</p>
<p class="noindenttb">The kernel maintains a system-wide table of all <em>open file descriptions</em>. (This table is sometimes referred to as the <em>open file table</em>, and its entries are sometimes called <em>open file handles</em>.) An open file description stores all information relating to an open file, including:</p>
<p class="bull">&#8226; the current file offset (as updated by <em>read()</em> and <em>write()</em>, or explicitly modified using <em>lseek()</em>);</p>
<p class="bull"><span epub:type="pagebreak" id="page_95"/>&#8226; status flags specified when opening the file (i.e., the <em>flags</em> argument to <em>open()</em>);</p>
<p class="bull">&#8226; the file access mode (read-only, write-only, or read-write, as specified in <em>open()</em>);</p>
<p class="bull">&#8226; settings relating to signal-driven I/O (<a href="ch63.xhtml#ch63lev1sec03">Section 63.3</a>); and</p>
<p class="bull">&#8226; a reference to the <em>i-node</em> object for this file.</p>
<p class="noindenttb">Each file system has a table of <em>i-nodes</em> for all files residing in the file system. The i-node structure, and file systems in general, are discussed in more detail in <a href="ch14.xhtml#ch14">Chapter 14</a>. For now, we note that the i-node for each file includes the following information:</p>
<p class="bull">&#8226; file type (e.g., regular file, socket, or FIFO) and permissions;</p>
<p class="bull">&#8226; a pointer to a list of locks held on this file; and</p>
<p class="bull">&#8226; various properties of the file, including its size and timestamps relating to different types of file operations.</p>
<div class="block">
<p class="noindent">Here, we are overlooking the distinction between on-disk and in-memory representations of an i-node. The on-disk i-node records the persistent attributes of a file, such as its type, permissions, and timestamps. When a file is accessed, an in-memory copy of the i-node is created, and this version of the i-node records a count of the open file descriptions referring to the i-node and the major and minor IDs of the device from which the i-node was copied. The in-memory i-node also records various ephemeral attributes that are associated with a file while it is open, such as file locks.</p>
</div>
<p class="noindent"><a href="ch05.xhtml#ch5fig2">Figure 5-2</a> illustrates the relationship between file descriptors, open file descriptions, and i-nodes. In this diagram, two processes have a number of open file descriptors.</p>
<div class="image"><img src="../images/f05-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch5fig2"/><strong>Figure 5-2:</strong> Relationship between file descriptors, open file descriptions, and i-nodes</p>
<p class="noindent"><span epub:type="pagebreak" id="page_96"/>In process A, descriptors 1 and 20 both refer to the same open file description (labeled 23). This situation may arise as a result of a call to <em>dup()</em>, <em>dup2()</em>, or <em>fcntl()</em> (see <a href="ch05.xhtml#ch05lev1sec05">Section 5.5</a>).</p>
<p class="indent">Descriptor 2 of process A and descriptor 2 of process B refer to a single open file description (73). This scenario could occur after a call to <em>fork()</em> (i.e., process A is the parent of process B, or vice versa), or if one process passed an open descriptor to another process using a UNIX domain socket (<a href="ch61.xhtml#ch61lev2sec10">Section 61.13.3</a>).</p>
<p class="indent">Finally, we see that descriptor 0 of process A and descriptor 3 of process B refer to different open file descriptions, but that these descriptions refer to the same i-node table entry (1976)&#8212;in other words, to the same file. This occurs because each process independently called <em>open()</em> for the same file. A similar situation could occur if a single process opened the same file twice.</p>
<p class="indentb">We can draw a number of implications from the preceding discussion:</p>
<p class="bull">&#8226; Two different file descriptors that refer to the same open file description share a file offset value. Therefore, if the file offset is changed via one file descriptor (as a consequence of calls to <em>read()</em>, <em>write()</em>, or <em>lseek()</em>), this change is visible through the other file descriptor. This applies both when the two file descriptors belong to the same process and when they belong to different processes.</p>
<p class="bull">&#8226; Similar scope rules apply when retrieving and changing the open file status flags (e.g., <span class="literal">O_APPEND</span>, <span class="literal">O_NONBLOCK</span>, and <span class="literal">O_ASYNC</span>) using the <em>fcntl()</em> <span class="literal">F_GETFL</span> and <span class="literal">F_SETFL</span> operations.</p>
<p class="bull">&#8226; By contrast, the file descriptor flags (i.e., the close-on-exec flag) are private to the process and file descriptor. Modifying these flags does not affect other file descriptors in the same process or a different process.</p>
<h3 class="h3" id="ch05lev1sec05"><strong>5.5 Duplicating File Descriptors</strong></h3>
<p class="noindenta">Using the (Bourne shell) I/O redirection syntax <span class="literal">2&gt;&#38;1</span> informs the shell that we wish to have standard error (file descriptor 2) redirected to the same place to which standard output (file descriptor 1) is being sent. Thus, the following command would (since the shell evaluates I/O directions from left to right) send both standard output and standard error to the file <span class="literal">results.log</span>:</p>
<p class="programs">$ <span class="codestrong">./myscript &gt; results.log 2&gt;&#38;1</span></p>
<p class="noindent">The shell redirects standard error by making file descriptor 2 a duplicate of file descriptor 1, so that it refers to the same open file description (in the same way that descriptors 1 and 20 of process A refer to the same open file description in <a href="ch05.xhtml#ch5fig2">Figure 5-2</a>). This effect can be achieved using the <em>dup()</em> and <em>dup2()</em> system calls.</p>
<p class="indent">Note that it is not sufficient for the shell simply to open the <span class="literal">results.log</span> file twice: once on descriptor 1 and once on descriptor 2. One reason for this is that the two file descriptors would not share a file offset pointer, and hence could end up overwriting each other&#8217;s output. Another reason is that the file may not be a disk file. Consider the following command, which sends standard error down the same pipe as standard output:</p>
<p class="programs">$ <span class="codestrong">./myscript 2&gt;&#38;1 | less</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_97"/>The <em>dup()</em> call takes <em>oldfd</em>, an open file descriptor, and returns a new descriptor that refers to the same open file description. The new descriptor is guaranteed to be the lowest unused file descriptor.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">dup2</span>(int <span class="font1">oldfd</span>, int <span class="font1">newfd</span>);</p>
<p class="right">Returns (new) file descriptor on success, or &#8211;1 on error</p>
</div>
<p class="noindent">Suppose we make the following call:</p>
<p class="programs">newfd = dup(1);</p>
<p class="noindent">Assuming the normal situation where the shell has opened file descriptors 0, 1, and 2 on the program&#8217;s behalf, and no other descriptors are in use, <em>dup()</em> will create the duplicate of descriptor 1 using descriptor 3.</p>
<p class="indent">If we wanted the duplicate to be descriptor 2, we could use the following technique:</p>
<p class="programs">close(2);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Frees file descriptor 2 */<br/>newfd = dup(1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Should reuse file descriptor 2 */</p>
<p class="noindent">This code works only if descriptor 0 was open. To make the above code simpler, and to ensure we always get the file descriptor we want, we can use <em>dup2()</em>.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">dup</span>(int <span class="font1">oldfd</span>);</p>
<p class="right">Returns (new) file descriptor on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>dup2()</em> system call makes a duplicate of the file descriptor given in <em>oldfd</em> using the descriptor number supplied in <em>newfd</em>. If the file descriptor specified in <em>newfd</em> is already open, <em>dup2()</em> closes it first. (Any error that occurs during this close is silently ignored.) The closing and reuse of <em>newfd</em> are performed atomically, which avoids the possibility that <em>newfd</em> is reused between the two steps in a signal handler or a parallel thread that allocates a file descriptor.</p>
<p class="indent">We could simplify the preceding calls to <em>close()</em> and <em>dup()</em> to the following:</p>
<p class="programs">dup2(1, 2);</p>
<p class="noindent">A successful <em>dup2()</em> call returns the number of the duplicate descriptor (i.e., the value passed in <em>newfd</em>).</p>
<p class="indent">If <em>oldfd</em> is not a valid file descriptor, then <em>dup2()</em> fails with the error <span class="literal">EBADF</span> and <em>newfd</em> is not closed. If <em>oldfd</em> is a valid file descriptor, and <em>oldfd</em> and <em>newfd</em> have the same value, then <em>dup2()</em> does nothing&#8212;<em>newfd</em> is not closed, and <em>dup2()</em> returns the <em>newfd</em> as its function result.</p>
<p class="indent">A further interface that provides some extra flexibility for duplicating file descriptors is the <em>fcntl()</em> <span class="literal">F_DUPFD</span> operation:</p>
<p class="programsf">newfd = fcntl(oldfd, F_DUPFD, startfd);</p>
<p class="noindent"><span epub:type="pagebreak" id="page_98"/>This call makes a duplicate of <em>oldfd</em> by using the lowest unused file descriptor greater than or equal to <em>startfd</em>. This is useful if we want a guarantee that the new descriptor (<em>newfd</em>) falls in a certain range of values. Calls to <em>dup()</em> and <em>dup2()</em> can always be recoded as calls to <em>close()</em> and <em>fcntl()</em>, although the former calls are more concise. (Note also that some of the <em>errno</em> error codes returned by <em>dup2()</em> and <em>fcntl()</em> differ, as described in the manual pages.)</p>
<p class="indent">From <a href="ch05.xhtml#ch5fig2">Figure 5-2</a>, we can see that duplicate file descriptors share the same file offset value and status flags in their shared open file description. However, the new file descriptor has its own set of file descriptor flags, and its close-on-exec flag (<span class="literal">FD_CLOEXEC</span>) is always turned off. The interfaces that we describe next allow explicit control of the new file descriptor&#8217;s close-on-exec flag.</p>
<p class="indent">The <em>dup3()</em> system call performs the same task as <em>dup2()</em>, but adds an additional argument, <em>flags</em>, that is a bit mask that modifies the behavior of the system call.</p>
<div class="box">
<p class="programsa">#define _GNU_SOURCE<br/>#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">dup3</span>(int <span class="font1">oldfd</span>, int <span class="font1">newfd</span>, int <span class="font1">flags</span>);</p>
<p class="right">Returns (new) file descriptor on success, or &#8211;1 on error</p>
</div>
<p class="noindent">Currently, <em>dup3()</em> supports one flag, <span class="literal">O_CLOEXEC</span>, which causes the kernel to enable the close-on-exec flag (<span class="literal">FD_CLOEXEC</span>) for the new file descriptor. This flag is useful for the same reasons as the <em>open()</em> <span class="literal">O_CLOEXEC</span> flag described in <a href="ch04.xhtml#ch04lev2sec01">Section 4.3.1</a>.</p>
<p class="indent">The <em>dup3()</em> system call is new in Linux 2.6.27, and is Linux-specific.</p>
<p class="indent">Since Linux 2.6.24, Linux also supports an additional <em>fcntl()</em> operation for duplicating file descriptors: <span class="literal">F_DUPFD_CLOEXEC</span>. This flag does the same thing as <span class="literal">F_DUPFD</span>, but additionally sets the close-on-exec flag (<span class="literal">FD_CLOEXEC</span>) for the new file descriptor. Again, this operation is useful for the same reasons as the <em>open()</em> <span class="literal">O_CLOEXEC</span> flag. <span class="literal">F_DUPFD_CLOEXEC</span> is not specified in SUSv3, but is specified in SUSv4.</p>
<h3 class="h3" id="ch05lev1sec06"><strong>5.6 File I/O at a Specified Offset: <em>pread()</em> and <em>pwrite()</em></strong></h3>
<p class="noindenta">The <em>pread()</em> and <em>pwrite()</em> system calls operate just like <em>read()</em> and <em>write()</em>, except that the file I/O is performed at the location specified by <em>offset</em>, rather than at the current file offset. The file offset is left unchanged by these calls.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>ssize_t <span class="codestrong">pread</span>(int <span class="font1">fd</span>, void *<span class="font1">buf</span>, size_t <span class="font1">count</span>, off_t <span class="font1">offset</span>);</p>
<p class="right">Returns number of bytes read, 0 on EOF, or &#8211;1 on error</p>
<p class="programsat">ssize_t <span class="codestrong">pwrite</span>(int <span class="font1">fd</span>, const void *<span class="font1">buf</span>, size_t <span class="font1">count</span>, off_t <span class="font1">offset</span>);</p>
<p class="right">Returns number of bytes written, or &#8211;1 on error</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_99"/>Calling <em>pread()</em> is equivalent to <em>atomically</em> performing the following calls:</p>
<p class="programs">off_t orig;<br/><br/>orig = lseek(fd, 0, SEEK_CUR);&#160;&#160;&#160;&#160;/* Save current offset */<br/>lseek(fd, offset, SEEK_SET);<br/>s = read(fd, buf, len);<br/>lseek(fd, orig, SEEK_SET);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Restore original file offset */</p>
<p class="noindent">For both <em>pread()</em> and <em>pwrite()</em>, the file referred to by <em>fd</em> must be seekable (i.e., a file descriptor on which it is permissible to call <em>lseek()</em>).</p>
<p class="indent">These system calls can be particularly useful in multithreaded applications. As we&#8217;ll see in <a href="ch29.xhtml#ch29">Chapter 29</a>, all of the threads in a process share the same file descriptor table. This means that the file offset for each open file is global to all threads. Using <em>pread()</em> or <em>pwrite()</em>, multiple threads can simultaneously perform I/O on the same file descriptor without being affected by changes made to the file offset by other threads. If we attempted to use <em>lseek()</em> plus <em>read()</em> (or <em>write()</em>) instead, then we would create a race condition similar to the one that we described when discussing the <span class="literal">O_APPEND</span> flag in <a href="ch05.xhtml#ch05lev1sec01">Section 5.1</a>. (The <em>pread()</em> and <em>pwrite()</em> system calls can similarly be useful for avoiding race conditions in applications where multiple processes have file descriptors referring to the same open file description.)</p>
<div class="block">
<p class="noindent">If we are repeatedly performing <em>lseek()</em> calls followed by file I/O, then the <em>pread()</em> and <em>pwrite()</em> system calls can also offer a performance advantage in some cases. This is because the cost of a single <em>pread()</em> (or <em>pwrite()</em>) system call is less than the cost of two system calls: <em>lseek()</em> and <em>read()</em> (or <em>write()</em>). However, the cost of system calls is usually dwarfed by the time required to actually perform I/O.</p>
</div>
<h3 class="h3" id="ch05lev1sec07"><strong>5.7 Scatter-Gather I/O: <em>readv()</em> and <em>writev()</em></strong></h3>
<p class="noindenta">The <em>readv()</em> and <em>writev()</em> system calls perform scatter-gather I/O.</p>
<div class="box">
<p class="programsa">#include &lt;sys/uio.h&gt;<br/><br/>ssize_t <span class="codestrong">readv</span>(int <span class="font1">fd</span>, const struct iovec *<span class="font1">iov</span>, int <span class="font1">iovcnt</span>);</p>
<p class="right">Returns number of bytes read, 0 on EOF, or &#8211;1 on error</p>
<p class="programsat">ssize_t <span class="codestrong">writev</span>(int <span class="font1">fd</span>, const struct iovec *<span class="font1">iov</span>, int <span class="font1">iovcnt</span>);</p>
<p class="right">Returns number of bytes written, or &#8211;1 on error</p>
</div>
<p class="noindent">Instead of accepting a single buffer of data to be read or written, these functions transfer multiple buffers of data in a single system call. The set of buffers to be transferred is defined by the array <em>iov</em>. The integer <em>iovcnt</em> specifies the number of elements in <em>iov</em>. Each element of <em>iov</em> is a structure of the following form:</p>
<p class="programs">struct iovec {<br/>&#160;&#160;&#160;&#160;void *iov_base;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Start address of buffer */<br/>&#160;&#160;&#160;&#160;size_t iov_len;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of bytes to transfer to/from buffer */<br/>};</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_100"/>SUSv3 allows an implementation to place a limit on the number of elements in <em>iov</em>. An implementation can advertise its limit by defining <span class="literal">IOV_MAX</span> in <span class="literal">&lt;limits.h&gt;</span> or at run time via the return from the call <em>sysconf(_SC_IOV_MAX)</em>. (We describe <em>sysconf()</em> in <a href="ch11.xhtml#ch11lev1sec02">Section 11.2</a>.) SUSv3 requires that this limit be at least 16. On Linux, <span class="literal">IOV_MAX</span> is defined as 1024, which corresponds to the kernel&#8217;s limit on the size of this vector (defined by the kernel constant <span class="literal">UIO_MAXIOV</span>).</p>
<p class="indent">However, the <em>glibc</em> wrapper functions for <em>readv()</em> and <em>writev()</em> silently do some extra work. If the system call fails because <em>iovcnt</em> is too large, then the wrapper function temporarily allocates a single buffer large enough to hold all of the items described by <em>iov</em> and performs a <em>read()</em> or <em>write()</em> call (see the discussion below of how <em>writev()</em> could be implemented in terms of <em>write()</em>).</p>
</div>
<p class="noindent"><a href="ch05.xhtml#ch5fig3">Figure 5-3</a> shows an example of the relationship between the <em>iov</em> and <em>iovcnt</em> arguments, and the buffers to which they refer.</p>
<div class="image"><img src="../images/f05-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch5fig3"/><strong>Figure 5-3:</strong> Example of an <em>iovec</em> array and associated buffers</p>
<h5 class="h5" id="ch05lev3sec03"><strong>Scatter input</strong></h5>
<p class="noindenta">The <em>readv()</em> system call performs <em>scatter input</em>: it reads a contiguous sequence of bytes from the file referred to by the file descriptor <em>fd</em> and places (&#8220;scatters&#8221;) these bytes into the buffers specified by <em>iov</em>. Each of the buffers, starting with the one defined by <em>iov[0]</em>, is completely filled before <em>readv()</em> proceeds to the next buffer.</p>
<p class="indent">An important property of <em>readv()</em> is that it completes atomically; that is, from the point of view of the calling process, the kernel performs a single data transfer between the file referred to by <em>fd</em> and user memory. This means, for example, that when reading from a file, we can be sure that the range of bytes read is contiguous, even if another process (or thread) sharing the same file offset attempts to manipulate the offset at the same time as the <em>readv()</em> call.</p>
<p class="indent">On successful completion, <em>readv()</em> returns the number of bytes read, or 0 if end-of-file was encountered. The caller must examine this count to verify whether all requested bytes were read. If insufficient data was available, then only some of the buffers may have been filled, and the last of these may be only partially filled.</p>
<p class="indent"><a href="ch05.xhtml#ch5ex2">Listing 5-2</a> demonstrates the use of <em>readv()</em>.</p>
<div class="block">
<p class="noindent">Using the prefix <span class="literal">t_</span> followed by a function name as the name of an example program (e.g., <span class="literal">t_readv.c</span> in <a href="ch05.xhtml#ch5ex2">Listing 5-2</a>) is our way of indicating that the program primarily demonstrates the use of a single system call or library function.</p>
</div>
<p class="examplet"><span epub:type="pagebreak" id="page_101"/><a id="ch5ex2"/><strong>Listing 5-2:</strong> Performing scatter input with <em>readv()</em></p>
<p class="programsli">________________________________________________________ <span class="codestrong">fileio/t_readv.c</span><br/><br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;sys/uio.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int fd;<br/>&#160;&#160;&#160;&#160;struct iovec iov[3];<br/>&#160;&#160;&#160;&#160;struct stat myStruct;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* First buffer */<br/>&#160;&#160;&#160;&#160;int x;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Second buffer */<br/>#define STR_SIZE 100<br/>&#160;&#160;&#160;&#160;char str[STR_SIZE];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Third buffer */<br/>&#160;&#160;&#160;&#160;ssize_t numRead, totRequired;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s file\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;fd = open(argv[1], O_RDONLY);<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open");<br/><br/>&#160;&#160;&#160;&#160;totRequired = 0;<br/><br/>&#160;&#160;&#160;&#160;iov[0].iov_base = &#38;myStruct;<br/>&#160;&#160;&#160;&#160;iov[0].iov_len = sizeof(struct stat);<br/>&#160;&#160;&#160;&#160;totRequired += iov[0].iov_len;<br/><br/>&#160;&#160;&#160;&#160;iov[1].iov_base = &#38;x;<br/>&#160;&#160;&#160;&#160;iov[1].iov_len = sizeof(x);<br/>&#160;&#160;&#160;&#160;totRequired += iov[1].iov_len;<br/><br/>&#160;&#160;&#160;&#160;iov[2].iov_base = str;<br/>&#160;&#160;&#160;&#160;iov[2].iov_len = STR_SIZE;<br/>&#160;&#160;&#160;&#160;totRequired += iov[2].iov_len;<br/><br/>&#160;&#160;&#160;&#160;numRead = readv(fd, iov, 3);<br/>&#160;&#160;&#160;&#160;if (numRead == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("readv");<br/><br/>&#160;&#160;&#160;&#160;if (numRead &lt; totRequired)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Read fewer bytes than requested\n");<br/><br/>&#160;&#160;&#160;&#160;printf("total bytes requested: %ld; bytes read: %ld\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) totRequired, (long) numRead);<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>________________________________________________________ <span class="codestrong">fileio/t_readv.c</span></p>
<h5 class="h5" id="ch05lev3sec04"><span epub:type="pagebreak" id="page_102"/><strong>Gather output</strong></h5>
<p class="noindenta">The <em>writev()</em> system call performs <em>gather output</em>. It concatenates (&#8220;gathers&#8221;) data from all of the buffers specified by <em>iov</em> and writes them as a sequence of contiguous bytes to the file referred to by the file descriptor <em>fd</em>. The buffers are gathered in array order, starting with the buffer defined by <em>iov[0]</em>.</p>
<p class="indent">Like <em>readv()</em>, <em>writev()</em> completes atomically, with all data being transferred in a single operation from user memory to the file referred to by <em>fd</em>. Thus, when writing to a regular file, we can be sure that all of the requested data is written contiguously to the file, rather than being interspersed with writes by other processes (or threads).</p>
<p class="indent">As with <em>write()</em>, a partial write is possible. Therefore, we must check the return value from <em>writev()</em> to see if all requested bytes were written.</p>
<p class="indentb">The primary advantages of <em>readv()</em> and <em>writev()</em> are convenience and speed. For example, we could replace a call to <em>writev()</em> by either:</p>
<p class="bull">&#8226; code that allocates a single large buffer, copies the data to be written from other locations in the process&#8217;s address space into that buffer, and then calls <em>write()</em> to output the buffer; or</p>
<p class="bull">&#8226; a series of <em>write()</em> calls that output the buffers individually.</p>
<p class="noindentt">The first of these options, while semantically equivalent to using <em>writev()</em>, leaves us with the inconvenience (and inefficiency) of allocating buffers and copying data in user space.</p>
<p class="indent">The second option is not semantically equivalent to a single call to <em>writev()</em>, since the <em>write()</em> calls are not performed atomically. Furthermore, performing a single <em>writev()</em> system call is cheaper than performing multiple <em>write()</em> calls (refer to the discussion of system calls in <a href="ch03.xhtml#ch03lev1sec01">Section 3.1</a>).</p>
<h5 class="h5" id="ch05lev3sec05"><strong>Performing scatter-gather I/O at a specified offset</strong></h5>
<p class="noindenta">Linux 2.6.30 adds two new system calls that combine scatter-gather I/O functionality with the ability to perform the I/O at a specified offset: <em>preadv()</em> and <em>pwritev()</em>. These system calls are nonstandard, but are also available on the modern BSDs.</p>
<div class="box">
<p class="programsa">#define _BSD_SOURCE<br/>#include &lt;sys/uio.h&gt;<br/><br/>ssize_t <span class="codestrong">preadv</span>(int <span class="font1">fd</span>, const struct iovec *<span class="font1">iov</span>, int <span class="font1">iovcnt</span>, off_t <span class="font1">offset</span>);</p>
<p class="right">Returns number of bytes read, 0 on EOF, or &#8211;1 on error</p>
<p class="programsat">ssize_t <span class="codestrong">pwritev</span>(int <span class="font1">fd</span>, const struct iovec *<span class="font1">iov</span>, int <span class="font1">iovcnt</span>, off_t <span class="font1">offset</span>);</p>
<p class="right">Returns number of bytes written, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>preadv()</em> and <em>pwritev()</em> system calls perform the same task as <em>readv()</em> and <em>writev()</em>, but perform the I/O at the file location specified by <em>offset</em> (like <em>pread()</em> and <em>pwrite()</em>). These system calls don&#8217;t change the file offset.</p>
<p class="indent">These system calls are useful for applications (e.g., multithreaded applications) that want to combine the benefits of scatter-gather I/O with the ability to perform I/O at a location that is independent of the current file offset.</p>
<h3 class="h3" id="ch05lev1sec08"><span epub:type="pagebreak" id="page_103"/><strong>5.8 Truncating a File: <em>truncate()</em> and <em>ftruncate()</em></strong></h3>
<p class="noindenta">The <em>truncate()</em> and <em>ftruncate()</em> system calls set the size of a file to the value specified by <em>length</em>.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">truncate</span>(const char *<span class="font1">pathname</span>, off_t <span class="font1">length</span>);<br/>int <span class="codestrong">ftruncate</span>(int <span class="font1">fd</span>, off_t <span class="font1">length</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">If the file is longer than <em>length</em>, the excess data is lost. If the file is currently shorter than <em>length</em>, it is extended by padding with a sequence of null bytes or a hole.</p>
<p class="indent">The difference between the two system calls lies in how the file is specified. With <em>truncate()</em>, the file, which must be accessible and writable, is specified as a pathname string. If <em>pathname</em> is a symbolic link, it is dereferenced. The <em>ftruncate()</em> system call takes a descriptor for a file that has been opened for writing. It doesn&#8217;t change the file offset for the file.</p>
<p class="indent">If the <em>length</em> argument to <em>ftruncate()</em> exceeds the current file size, SUSv3 allows two possible behaviors: either the file is extended (as on Linux) or the system call returns an error. XSI-conformant systems must adopt the former behavior. SUSv3 requires that <em>truncate()</em> always extend the file if <em>length</em> is greater than the current file size.</p>
<div class="block">
<p class="noindent">The <em>truncate()</em> system call is unique in being the only system call that can change the contents of a file without first obtaining a descriptor for the file via <em>open()</em> (or by some other means).</p>
</div>
<h3 class="h3" id="ch05lev1sec09"><strong>5.9 Nonblocking I/O</strong></h3>
<p class="noindentab">Specifying the <span class="literal">O_NONBLOCK</span> flag when opening a file serves two purposes:</p>
<p class="bull">&#8226; If the file can&#8217;t be opened immediately, then <em>open()</em> returns an error instead of blocking. One case where <em>open()</em> can block is with FIFOs (<a href="ch44.xhtml#ch44lev1sec07">Section 44.7</a>).</p>
<p class="bull">&#8226; After a successful <em>open()</em>, subsequent I/O operations are also nonblocking. If an I/O system call can&#8217;t complete immediately, then either a partial data transfer is performed or the system call fails with one of the errors <span class="literal">EAGAIN</span> or <span class="literal">EWOULDBLOCK</span>. Which error is returned depends on the system call. On Linux, as on many UNIX implementations, these two error constants are synonymous.</p>
<p class="noindent">Nonblocking mode can be used with devices (e.g., terminals and pseudoterminals), pipes, FIFOs, and sockets. (Because file descriptors for pipes and sockets are not obtained using <em>open()</em>, we must enable this flag using the <em>fcntl()</em> <span class="literal">F_SETFL</span> operation described in <a href="ch05.xhtml#ch05lev1sec03">Section 5.3</a>.)</p>
<p class="indent"><span class="literal">O_NONBLOCK</span> is generally ignored for regular files, because the kernel buffer cache ensures that I/O on regular files does not block, as described in <a href="ch13.xhtml#ch13lev1sec01">Section 13.1</a>. However, <span class="literal">O_NONBLOCK</span> does have an effect for regular files when mandatory file locking is employed (<a href="ch55.xhtml#ch55lev1sec04">Section 55.4</a>).</p>
<p class="noindent"><span epub:type="pagebreak" id="page_104"/>We say more about nonblocking I/O in <a href="ch44.xhtml#ch44lev1sec09">Section 44.9</a> and in <a href="ch63.xhtml#ch63">Chapter 63</a>.</p>
<div class="block">
<p class="noindent">Historically, System V&#8211;derived implementations provided the <span class="literal">O_NDELAY</span> flag, with similar semantics to <span class="literal">O_NONBLOCK</span>. The main difference was that a nonblocking <em>write()</em> on System V returned 0 if a <em>write()</em> could not be completed and a nonblocking <em>read()</em> returned 0 if no input was available. This behavior was problematic for <em>read()</em> because it was indistinguishable from an end-of-file condition, and so the first POSIX.1 standard introduced <span class="literal">O_NONBLOCK</span>. Some UNIX implementations continue to provide the <span class="literal">O_NDELAY</span> flag with the old semantics. On Linux, the <span class="literal">O_NDELAY</span> constant is defined, but it is synonymous with <span class="literal">O_NONBLOCK</span>.</p>
</div>
<h3 class="h3" id="ch05lev1sec10"><strong>5.10 I/O on Large Files</strong></h3>
<p class="noindenta">The <em>off_t</em> data type used to hold a file offset is typically implemented as a signed long integer. (A signed data type is required because the value &#8211;1 is used for representing error conditions.) On 32-bit architectures (such as x86-32) this would limit the size of files to 2<sup>31</sup>&#8211;1 bytes (i.e., 2 GB).</p>
<p class="indent">However, the capacity of disk drives long ago exceeded this limit, and thus the need arose for 32-bit UNIX implementations to handle files larger than this size. Since this is a problem common to many implementations, a consortium of UNIX vendors cooperated on the <em>Large File Summit</em> (LFS), to enhance the SUSv2 specification with the extra functionality required to access large files. We outline the LFS enhancements in this section. (The complete LFS specification, finalized in 1996, can be found at <em><a href="http://opengroup.org/platform/lfs.html">http://opengroup.org/platform/lfs.html</a></em>.)</p>
<p class="indent">Linux has provided LFS support on 32-bit systems since kernel 2.4 (<em>glibc</em> 2.2 or later is also required). In addition, the corresponding file system must also support large files. Most native Linux file systems provide this support, but some nonnative file systems do not (notable examples are Microsoft&#8217;s VFAT and NFSv2, both of which impose hard limits of 2 GB, regardless of whether the LFS extensions are employed).</p>
<div class="block">
<p class="noindent">Because long integers use 64 bits on 64-bit architectures (e.g., x86-64, Alpha, and IA-64), these architectures generally don&#8217;t suffer the limitations that the LFS enhancements were designed to address. Nevertheless, the implementation details of some native Linux file systems mean that the theoretical maximum size of a file may be less than 2<sup>63</sup>&#8211;1, even on 64-bit systems. In most cases, these limits are much higher than current disk sizes, so they don&#8217;t impose a practical limitation on file sizes.</p>
</div>
<p class="noindentb">We can write applications requiring LFS functionality in one of two ways:</p>
<p class="bull">&#8226; Use an alternative API that supports large files. This API was designed by the LFS as a &#8220;transitional extension&#8221; to the Single UNIX Specification. Thus, this API is not required to be present on systems conforming to SUSv2 or SUSv3, but many conforming systems do provide it. This approach is now obsolete.</p>
<p class="bull">&#8226; Define the <span class="literal">_FILE_OFFSET_BITS</span> macro with the value 64 when compiling our programs. This is the preferred approach, because it allows conforming applications to obtain LFS functionality without making any source code changes.</p>
<h5 class="h5" id="ch05lev3sec06"><span epub:type="pagebreak" id="page_105"/><strong>The transitional LFS API</strong></h5>
<p class="noindenta">To use the transitional LFS API, we must define the <span class="literal">_LARGEFILE64_SOURCE</span> feature test macro when compiling our program, either on the command line, or within the source file before including any header files. This API provides functions capable of handling 64-bit file sizes and offsets. These functions have the same names as their 32-bit counterparts, but have the suffix <em>64</em> appended to the function name. Among these functions are <em>fopen64()</em>, <em>open64()</em>, <em>lseek64()</em>, <em>truncate64()</em>, <em>stat64()</em>, <em>mmap64()</em>, and <em>setrlimit64()</em>. (We&#8217;ve already described some of the 32-bit counterparts of these functions; others are described in later chapters.)</p>
<p class="indent">In order to access a large file, we simply use the 64-bit version of the function. For example, to open a large file, we could write the following:</p>
<p class="programs">fd = open64(name, O_CREAT | O_RDWR, mode);<br/>if (fd == -1)<br/>&#160;&#160;&#160;&#160;errExit("open");</p>
<div class="block">
<p class="noindent">Calling <em>open64()</em> is equivalent to specifying the <span class="literal">O_LARGEFILE</span> flag when calling <em>open()</em>. Attempts to open a file larger than 2 GB by calling <em>open()</em> without this flag return an error.</p>
</div>
<p class="noindentb">In addition to the aforementioned functions, the transitional LFS API adds some new data types, including:</p>
<p class="bull">&#8226; <em>struct stat64</em>: an analog of the <em>stat</em> structure (<a href="ch15.xhtml#ch15lev1sec01">Section 15.1</a>) allowing for large file sizes.</p>
<p class="bull">&#8226; <em>off64_t</em>: a 64-bit type for representing file offsets.</p>
<p class="noindentt">The <em>off64_t</em> data type is used with (among others) the <em>lseek64()</em> function, as shown in <a href="ch05.xhtml#ch5ex3">Listing 5-3</a>. This program takes two command-line arguments: the name of a file to be opened and an integer value specifying a file offset. The program opens the specified file, seeks to the given file offset, and then writes a string. The following shell session demonstrates the use of the program to seek to a very large offset in the file (greater than 10 GB) and then write some bytes:</p>
<p class="programs">$ <span class="codestrong">./large_file x 10111222333</span><br/>$ <span class="codestrong">ls -l x</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Check size of resulting file</span><br/>-rw-------&#160;&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;10111222337 Mar&#160;&#160;&#160;4 13:34 x</p>
<p class="examplet"><a id="ch5ex3"/><strong>Listing 5-3:</strong> Accessing large files</p>
<p class="programsli">______________________________________________________ <span class="codestrong">fileio/large_file.c</span><br/><br/>#define _LARGEFILE64_SOURCE<br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int fd;<br/>&#160;&#160;&#160;&#160;off64_t off;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 3 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s pathname offset\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;fd = open64(argv[1], O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open64");<br/><br/>&#160;&#160;&#160;&#160;off = atoll(argv[2]);<br/>&#160;&#160;&#160;&#160;if (lseek64(fd, off, SEEK_SET) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("lseek64");<br/><br/>&#160;&#160;&#160;&#160;if (write(fd, "test", 4) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("write");<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_______________________________________________________ <span class="codestrong">fileio/large_file.c</span></p>
<h5 class="h5" id="ch05lev3sec07"><span epub:type="pagebreak" id="page_106"/><strong>The</strong> <span class="literal"><span class="codestrong">_FILE_OFFSET_BITS</span></span> <strong>macro</strong></h5>
<p class="noindenta">The recommended method of obtaining LFS functionality is to define the macro <span class="literal">_FILE_OFFSET_BITS</span> with the value 64 when compiling a program. One way to do this is via a command-line option to the C compiler:</p>
<p class="programs">$ <span class="codestrong">cc -D_FILE_OFFSET_BITS=64 prog.c</span></p>
<p class="noindent">Alternatively, we can define this macro in the C source before including any header files:</p>
<p class="programs">#define _FILE_OFFSET_BITS 64</p>
<p class="noindent">This automatically converts all of the relevant 32-bit functions and data types into their 64-bit counterparts. Thus, for example, calls to <em>open()</em> are actually converted into calls to <em>open64()</em>, and the <em>off_t</em> data type is defined to be 64 bits long. In other words, we can recompile an existing program to handle large files without needing to make any changes to the source code.</p>
<p class="indent">Using <span class="literal">_FILE_OFFSET_BITS</span> is clearly simpler than using the transitional LFS API, but this approach relies on applications being cleanly written (e.g., correctly using <em>off_t</em> to declare variables holding file offsets, rather than using a native C integer type).</p>
<p class="indent">The <span class="literal">_FILE_OFFSET_BITS</span> macro is not required by the LFS specification, which merely mentions this macro as an optional method of specifying the size of the <em>off_t</em> data type. Some UNIX implementations use a different feature test macro to obtain this functionality.</p>
<div class="block">
<p class="noindent">If we attempt to access a large file using 32-bit functions (i.e., from a program compiled without setting <span class="literal">_FILE_OFFSET_BITS</span> to 64), then we may encounter the error <span class="literal">EOVERFLOW</span>. For example, this error can occur if we attempt to use the 32-bit version of <em>stat()</em> (<a href="ch15.xhtml#ch15lev1sec01">Section 15.1</a>) to retrieve information about a file whose size exceeds 2 GB.</p>
</div>
<h5 class="h5" id="ch05lev3sec08"><span epub:type="pagebreak" id="page_107"/><strong>Passing <em>off_t</em> values to <em>printf()</em></strong></h5>
<p class="noindenta">One problem that the LFS extensions don&#8217;t solve for us is how to pass <em>off_t</em> values to <em>printf()</em> calls. In <a href="ch03.xhtml#ch03lev2sec04">Section 3.6.2</a>, we noted that the portable method of displaying values of one of the predefined system data types (e.g., <em>pid_t</em> or <em>uid_t</em>) was to cast that value to <em>long</em>, and use the <span class="literal">%ld</span> <em>printf()</em> specifier. However, if we are employing the LFS extensions, then this is often not sufficient for the <em>off_t</em> data type, because it may be defined as a type larger than <em>long</em>, typically <em>long long</em>. Therefore, to display a value of type <em>off_t</em>, we cast it to <em>long long</em> and use the <span class="literal">%lld</span> <em>printf()</em> specifier, as in the following:</p>
<p class="programs">#define _FILE_OFFSET_BITS 64<br/><br/>off_t offset;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Will be 64 bits, the size of 'long long' */<br/><br/>/* Other code assigning a value to 'offset' */<br/><br/>printf("offset=%lld\n", (long long) offset);</p>
<p class="noindent">Similar remarks also apply for the related <em>blkcnt_t</em> data type, which is employed in the <em>stat</em> structure (described in <a href="ch15.xhtml#ch15lev1sec01">Section 15.1</a>).</p>
<div class="block">
<p class="noindent">If we are passing function arguments of the types <em>off_t</em> or <em>stat</em> between separately compiled modules, then we need to ensure that both modules use the same sizes for these types (i.e., either both were compiled with <span class="literal">_FILE_OFFSET_BITS</span> set to 64 or both were compiled without this setting).</p>
</div>
<h3 class="h3" id="ch05lev1sec11"><strong>5.11 The</strong> <span class="literal"><span class="codestrong">/dev/fd</span></span> <strong>Directory</strong></h3>
<p class="noindenta">For each process, the kernel provides the special virtual directory <span class="literal">/dev/fd</span>. This directory contains filenames of the form <span class="literal">/dev/fd/</span><em>n</em>, where <em>n</em> is a number corresponding to one of the open file descriptors for the process. Thus, for example, <span class="literal">/dev/fd/0</span> is standard input for the process. (The <span class="literal">/dev/fd</span> feature is not specified by SUSv3, but several other UNIX implementations provide this feature.)</p>
<p class="indent">On some systems (but not Linux), opening one of the files in the <span class="literal">/dev/fd</span> directory is equivalent to duplicating the corresponding file descriptor. Thus, the following statements are equivalent:</p>
<p class="programs">fd = open("/dev/fd/1", O_WRONLY);<br/>fd = dup(1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Duplicate standard output */</p>
<p class="noindent">The <em>flags</em> argument of the <em>open()</em> call <em>is</em> interpreted, so that we should take care to specify the same access mode as was used by the original descriptor. Specifying other flags, such as <span class="literal">O_CREAT</span>, is meaningless (and ignored) in this context.</p>
<p class="indent">On Linux, opening one of the files in <span class="literal">/dev/fd</span> is equivalent to reopening the original file; that is, the new file descriptor is associated with a new open file description (and thus has distinct file status flags and file offset).</p>
<div class="block">
<p class="noindent"><span class="literal">/dev/fd</span> is actually a symbolic link to the Linux-specific <span class="literal">/proc/self/fd</span> directory. The latter directory is a special case of the Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/fd</span> directories, each of which contains symbolic links corresponding to all of the files held open by a process.</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_108"/>The files in the <span class="literal">/dev/fd</span> directory are rarely used within programs. Their most common use is in the shell. Many user-level commands take filename arguments, and sometimes we would like to put them in a pipeline and have one of the arguments be standard input or output instead. For this purpose, some programs (e.g., <em>diff</em>, <em>ed</em>, <em>tar</em>, and <em>comm</em>) have evolved the hack of using an argument consisting of a single hyphen (<span class="literal">-</span>) to mean &#8220;use standard input or output (as appropriate) for this filename argument.&#8221; Thus, to compare a file list from <em>ls</em> against a previously built file list, we might write the following:</p>
<p class="programs">$ <span class="codestrong">ls | diff - oldfilelist</span></p>
<p class="noindent">This approach has various problems. First, it requires specific interpretation of the hyphen character on the part of each program, and many programs don&#8217;t perform such interpretation; they are written to work only with filename arguments, and they have no means of specifying standard input or output as the files with which they are to work. Second, some programs instead interpret a single hyphen as a delimiter marking the end of command-line options.</p>
<p class="indent">Using <span class="literal">/dev/fd</span> eliminates these difficulties, allowing the specification of standard input, output, and error as filename arguments to any program requiring them. Thus, we can write the previous shell command as follows:</p>
<p class="programs">$ <span class="codestrong">ls | diff /dev/fd/0 oldfilelist</span></p>
<p class="noindent">As a convenience, the names <span class="literal">/dev/stdin</span>, <span class="literal">/dev/stdout</span>, and <span class="literal">/dev/stderr</span> are provided as symbolic links to, respectively, <span class="literal">/dev/fd/0</span>, <span class="literal">/dev/fd/1</span>, and <span class="literal">/dev/fd/2</span>.</p>
<h3 class="h3" id="ch05lev1sec12"><strong>5.12 Creating Temporary Files</strong></h3>
<p class="noindenta">Some programs need to create temporary files that are used only while the program is running, and these files should be removed when the program terminates. For example, many compilers create temporary files during the compilation process. The GNU C library provides a range of library functions for this purpose. (The variety is, in part, a consequence of inheritance from various other UNIX implementations.) Here, we describe two of these functions: <em>mkstemp()</em> and <em>tmpfile()</em>.</p>
<p class="indent">The <em>mkstemp()</em> function generates a unique filename based on a template supplied by the caller and opens the file, returning a file descriptor that can be used with I/O system calls.</p>
<div class="box">
<p class="programsa">#include &lt;stdlib.h&gt;<br/><br/>int <span class="codestrong">mkstemp</span>(char *<span class="font1">template</span>);</p>
<p class="right">Returns file descriptor on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>template</em> argument takes the form of a pathname in which the last 6 characters must be <span class="literal">XXXXXX</span>. These 6 characters are replaced with a string that makes the filename unique, and this modified string is returned via the <em>template</em> argument. Because <span epub:type="pagebreak" id="page_109"/><em>template</em> is modified, it must be specified as a character array, rather than as a string constant.</p>
<p class="indent">The <em>mkstemp()</em> function creates the file with read and write permissions for the file owner (and no permissions for other users), and opens it with the <span class="literal">O_EXCL</span> flag, guaranteeing that the caller has exclusive access to the file.</p>
<p class="indent">Typically, a temporary file is unlinked (deleted) soon after it is opened, using the <em>unlink()</em> system call (<a href="ch18.xhtml#ch18lev1sec03">Section 18.3</a>). Thus, we could employ <em>mkstemp()</em> as follows:</p>
<p class="programs">int fd;<br/>char template[] = "/tmp/somestringXXXXXX";<br/><br/>fd = mkstemp(template);<br/>if (fd == -1)<br/>&#160;&#160;&#160;&#160;errExit("mkstemp");<br/>printf("Generated filename was: %s\n", template);<br/>unlink(template);&#160;&#160;&#160;&#160;&#160;/* Name disappears immediately, but the file<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;is removed only after close() */<br/><br/>/* Use file I/O system calls - read(), write(), and so on */<br/><br/>if (close(fd) == -1)<br/>&#160;&#160;&#160;&#160;errExit("close");</p>
<div class="block">
<p class="noindent">The <em>tmpnam()</em>, <em>tempnam()</em>, and <em>mktemp()</em> functions can also be used to generate unique filenames. However, these functions should be avoided because they can create security holes in an application. See the manual pages for further details on these functions.</p>
</div>
<p class="noindent">The <em>tmpfile()</em> function creates a uniquely named temporary file that is opened for reading and writing. (The file is opened with the <span class="literal">O_EXCL</span> flag to guard against the unlikely possibility that another process has already created a file with the same name.)</p>
<div class="box">
<p class="programsa">#include &lt;stdio.h&gt;<br/><br/>FILE *<span class="codestrong">tmpfile</span>(void);</p>
<p class="right">Returns file pointer on success, or <span class="literal">NULL</span> on error</p>
</div>
<p class="noindent">On success, <em>tmpfile()</em> returns a file stream that can be used with the <em>stdio</em> library functions. The temporary file is automatically deleted when it is closed. To do this, <em>tmpfile()</em> makes an internal call to <em>unlink()</em> to remove the filename immediately after opening the file.</p>
<h3 class="h3" id="ch05lev1sec13"><strong>5.13 Summary</strong></h3>
<p class="noindenta">In the course of this chapter, we introduced the concept of atomicity, which is crucial to the correct operation of some system calls. In particular, the <em>open()</em> <span class="literal">O_EXCL</span> flag allows the caller to ensure that it is the creator of a file, and the <em>open()</em> <span class="literal">O_APPEND</span> flag ensures that multiple processes appending data to the same file don&#8217;t overwrite each other&#8217;s output.</p>
<p class="indent"><span epub:type="pagebreak" id="page_110"/>The <em>fcntl()</em> system call performs a variety of file control operations, including changing open file status flags and duplicating file descriptors. Duplicating file descriptors is also possible using <em>dup()</em> and <em>dup2()</em>.</p>
<p class="indent">We looked at the relationship between file descriptors, open file descriptions, and file i-nodes, and noted that different information is associated with each of these three objects. Duplicate file descriptors refer to the same open file description, and thus share open file status flags and the file offset.</p>
<p class="indent">We described a number of system calls that extend the functionality of the conventional <em>read()</em> and <em>write()</em> system calls. The <em>pread()</em> and <em>pwrite()</em> system calls perform I/O at a specified file location without changing the file offset. The <em>readv()</em> and <em>writev()</em> calls perform scatter-gather I/O. The <em>preadv()</em> and <em>pwritev()</em> calls combine scatter-gather I/O functionality with the ability to perform I/O at a specified file location.</p>
<p class="indent">The <em>truncate()</em> and <em>ftruncate()</em> system calls can be used to decrease the size of a file, discarding the excess bytes, or to increase the size, padding with a zero-filled file hole.</p>
<p class="indent">We briefly introduced the concept of nonblocking I/O, and we&#8217;ll return to it in later chapters.</p>
<p class="indent">The LFS specification defines a set of extensions that allow processes running on 32-bit systems to perform operations on files whose size is too large to be represented in 32 bits.</p>
<p class="indent">The numbered files in the <span class="literal">/dev/fd</span> virtual directory allow a process to access its own open files via file descriptor numbers, which can be particularly useful in shell commands.</p>
<p class="indent">The <em>mkstemp()</em> and <em>tmpfile()</em> functions allow an application to create temporary files.</p>
<h3 class="h3" id="ch05lev1sec14"><strong>5.14 Exercises</strong></h3>
<p class="exer"><a id="ch5exe1"/><strong>5-1.</strong>&#160;&#160;&#160;&#160;&#160;If you have access to a 32-bit Linux system, modify the program in <a href="ch05.xhtml#ch5ex3">Listing 5-3</a> to use standard file I/O system calls (<em>open()</em> and <em>lseek()</em>) and the <em>off_t</em> data type. Compile the program with the <span class="literal">_FILE_OFFSET_BITS</span> macro set to 64, and test it to show that a large file can be successfully created.</p>
<p class="exer"><a id="ch5exe2"/><strong>5-2.</strong>&#160;&#160;&#160;&#160;&#160;Write a program that opens an existing file for writing with the <span class="literal">O_APPEND</span> flag, and then seeks to the beginning of the file before writing some data. Where does the data appear in the file? Why?</p>
<p class="exer"><a id="ch5exe3"/><strong>5-3.</strong>&#160;&#160;&#160;&#160;&#160;This exercise is designed to demonstrate why the atomicity guaranteed by opening a file with the <span class="literal">O_APPEND</span> flag is necessary. Write a program that takes up to three command-line arguments:</p>
<p class="programs1">$ <span class="codestrong">atomic_append <span class="codeitalic">filename num-bytes</span></span> [<span class="codestrong"><span class="codeitalic">x</span></span>]</p>
<p class="exerp">This program should open the specified filename (creating it if necessary) and append <em>num-bytes</em> bytes to the file by using <em>write()</em> to write a byte at a time. By default, the program should open the file with the <span class="literal">O_APPEND</span> flag, but if a third command-line argument (<em>x</em>) is supplied, then the <span class="literal">O_APPEND</span> flag should be omitted, and <span epub:type="pagebreak" id="page_111"/>instead the program should perform an <em>lseek(fd, 0, SEEK_END)</em> call before each <em>write()</em>. Run two instances of this program at the same time without the <em>x</em> argument to write 1 million bytes to the same file:</p>
<p class="programs1">$ <span class="codestrong">atomic_append f1 1000000 &#38; atomic_append f1 1000000</span></p>
<p class="exerp">Repeat the same steps, writing to a different file, but this time specifying the <em>x</em> argument:</p>
<p class="programs1">$ <span class="codestrong">atomic_append f2 1000000 x &#38; atomic_append f2 1000000 x</span></p>
<p class="exerp">List the sizes of the files <span class="literal">f1</span> and <span class="literal">f2</span> using <em>ls &#8211;l</em> and explain the difference.</p>
<p class="exer"><a id="ch5exe4"/><strong>5-4.</strong>&#160;&#160;&#160;&#160;&#160;Implement <em>dup()</em> and <em>dup2()</em> using <em>fcntl()</em> and, where necessary, <em>close()</em>. (You may ignore the fact that <em>dup2()</em> and <em>fcntl()</em> return different <em>errno</em> values for some error cases.) For <em>dup2()</em>, remember to handle the special case where <em>oldfd</em> equals <em>newfd</em>. In this case, you should check whether <em>oldfd</em> is valid, which can be done by, for example, checking if <em>fcntl(oldfd, F_GETFL)</em> succeeds. If <em>oldfd</em> is not valid, then the function should return &#8211;1 with <em>errno</em> set to <span class="literal">EBADF</span>.</p>
<p class="exer"><a id="ch5exe5"/><strong>5-5.</strong>&#160;&#160;&#160;&#160;&#160;Write a program to verify that duplicated file descriptors share a file offset value and open file status flags.</p>
<p class="exer"><a id="ch5exe6"/><strong>5-6.</strong>&#160;&#160;&#160;&#160;&#160;After each of the calls to <em>write()</em> in the following code, explain what the content of the output file would be, and why:</p>
<p class="programs1">fd1 = open(file, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);<br/>fd2 = dup(fd1);<br/>fd3 = open(file, O_RDWR);<br/>write(fd1, "Hello,", 6);<br/>write(fd2, " world", 6);<br/>lseek(fd2, 0, SEEK_SET);<br/>write(fd1, "HELLO,", 6);<br/>write(fd3, "Gidday", 6);</p>
<p class="exer"><a id="ch5exe7"/><strong>5-7.</strong>&#160;&#160;&#160;&#160;&#160;Implement <em>readv()</em> and <em>writev()</em> using <em>read()</em>, <em>write()</em>, and suitable functions from the <em>malloc</em> package (<a href="ch07.xhtml#ch07lev2sec02">Section 7.1.2</a>).<span epub:type="pagebreak" id="page_112"/></p>
</body>
</html>
