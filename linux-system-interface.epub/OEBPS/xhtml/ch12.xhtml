<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_223"/><strong><span class="big">12</span></strong><br/><strong>SYSTEM AND PROCESS INFORMATION</strong></h2>
<p class="noindenta">In this chapter, we look at ways of accessing a variety of system and process information. The primary focus of the chapter is a discussion of the <span class="literal">/proc</span> file system. We also describe the <em>uname()</em> system call, which is used to retrieve various system identifiers.</p>
<h3 class="h3" id="ch12lev1sec01"><strong>12.1 The</strong> <span class="literal"><span class="codestrong">/proc</span></span> <strong>File System</strong></h3>
<p class="noindentab">In older UNIX implementations, there was typically no easy way to introspectively analyze (or change) attributes of the kernel, to answer questions such as the following:</p>
<p class="bull">&#8226; How many processes are running on the system and who owns them?</p>
<p class="bull">&#8226; What files does a process have open?</p>
<p class="bull">&#8226; What files are currently locked, and which processes hold the locks?</p>
<p class="bull">&#8226; What sockets are being used on the system?</p>
<p class="noindentt">Some older UNIX implementations solved this problem by allowing privileged programs to delve into data structures in kernel memory. However, this approach suffered various problems. In particular, it required specialized knowledge of the kernel data structures, and these structures might change from one kernel version to the next, requiring programs that depended on them to be rewritten.</p>
<p class="indent"><span epub:type="pagebreak" id="page_224"/>In order to provide easier access to kernel information, many modern UNIX implementations provide a <span class="literal">/proc</span> virtual file system. This file system resides under the <span class="literal">/proc</span> directory and contains various files that expose kernel information, allowing processes to conveniently read that information, and change it in some cases, using normal file I/O system calls. The <span class="literal">/proc</span> file system is said to be virtual because the files and subdirectories that it contains don&#8217;t reside on a disk. Instead, the kernel creates them &#8220;on the fly&#8221; as processes access them.</p>
<p class="indent">In this section, we present an overview of the <span class="literal">/proc</span> file system. In later chapters, we describe specific <span class="literal">/proc</span> files, as they relate to the topics of each chapter. Although many UNIX implementations provide a <span class="literal">/proc</span> file system, SUSv3 doesn&#8217;t specify this file system; the details described in this book are Linux-specific.</p>
<h4 class="h4" id="ch12lev2sec01"><strong>12.1.1 Obtaining Information About a Process:</strong> <span class="literal"><span class="codestrong">/proc/</span></span><strong>PID</strong></h4>
<p class="noindenta">For each process on the system, the kernel provides a corresponding directory named <span class="literal">/proc/</span><em>PID</em>, where <em>PID</em> is the ID of the process. Within this directory are various files and subdirectories containing information about that process. For example, we can obtain information about the <em>init</em> process, which always has the process ID 1, by looking at files under the directory <span class="literal">/proc/1</span>.</p>
<p class="indent">Among the files in each <span class="literal">/proc/</span><em>PID</em> directory is one named <span class="literal">status</span>, which provides a range of information about the process:</p>
<p class="programs">$ <span class="codestrong">cat /proc/1/status</span><br/>Name:&#160;&#160;&#160;init&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Name of command run by this process</span><br/>State:&#160;&#160;S (sleeping)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">State of this process</span><br/>Tgid:&#160;&#160;&#160;1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Thread group ID (traditional PID, getpid())</span><br/>Pid:&#160;&#160;&#160;&#160;1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Actually, thread ID (gettid())</span><br/>PPid:&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Parent process ID</span><br/>TracerPid:&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">PID of tracing process (0 if not traced)</span><br/>Uid:&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Real, effective, saved set, and FS UIDs</span><br/>Gid:&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Real, effective, saved set, and FS GIDs</span><br/>FDSize: 256&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1"># of file descriptor slots currently allocated</span><br/>Groups:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Supplementary group IDs</span><br/>VmPeak:&#160;&#160;&#160;&#160;&#160;&#160;852 kB&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Peak virtual memory size</span><br/>VmSize:&#160;&#160;&#160;&#160;&#160;&#160;724 kB&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Current virtual memory size</span><br/>VmLck:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0 kB&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Locked memory</span><br/>VmHWM:&#160;&#160;&#160;&#160;&#160;&#160;&#160;288 kB&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Peak resident set size</span><br/>VmRSS:&#160;&#160;&#160;&#160;&#160;&#160;&#160;288 kB&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Current resident set size</span><br/>VmData:&#160;&#160;&#160;&#160;&#160;&#160;148 kB&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Data segment size</span><br/>VmStk:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;88 kB&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Stack size</span><br/>VmExe:&#160;&#160;&#160;&#160;&#160;&#160;&#160;484 kB&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Text (executable code) size</span><br/>VmLib:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0 kB&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Shared library code size</span><br/>VmPTE:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;12 kB&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Size of page table (since 2.6.10)</span><br/>Threads:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1"># of threads in this thread's thread group</span><br/>SigQ:&#160;&#160;&#160;0/3067&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Current/max. queued signals (since 2.6.12)</span><br/>SigPnd: 0000000000000000&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Signals pending for thread</span><br/>ShdPnd: 0000000000000000&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Signals pending for process (since 2.6)</span><br/>SigBlk: 0000000000000000&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Blocked signals</span><br/>SigIgn: fffffffe5770d8fc&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Ignored signals</span><br/>SigCgt: 00000000280b2603&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Caught signals</span><br/>CapInh: 0000000000000000&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Inheritable capabilities</span><br/>CapPrm: 00000000ffffffff&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Permitted capabilities</span><br/>CapEff: 00000000fffffeff&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Effective capabilities</span><br/>CapBnd: 00000000ffffffff&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Capability bounding set (since 2.6.26)</span><br/>Cpus_allowed:&#160;&#160;&#160;1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">CPUs allowed, mask (since 2.6.24)</span><br/>Cpus_allowed_list:&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Same as above, list format (since 2.6.26)</span><br/>Mems_allowed:&#160;&#160;&#160;&#160;1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Memory nodes allowed, mask (since 2.6.24)</span><br/>Mems_allowed_list:&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Same as above, list format (since 2.6.26)</span><br/>voluntary_ctxt_switches:&#160;&#160;&#160;&#160;&#160;6998&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Voluntary context switches (since 2.6.23)</span><br/>nonvoluntary_ctxt_switches:&#160;&#160;107&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Involuntary context switches (since 2.6.23)</span><br/>Stack usage:&#160;&#160;&#160;&#160;8 kB&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Stack usage high-water mark (since 2.6.32)</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_225"/>The above output is taken from kernel 2.6.32. As indicated by the <em>since</em> comments accompanying the file output, the format of this file has evolved over time, with new fields added (and in a few cases, removed) in various kernel versions. (Aside from the Linux 2.6 changes noted above, Linux 2.4 added the <em>Tgid</em>, <em>TracerPid</em>, <em>FDSize</em>, and <em>Threads</em> fields.)</p>
<p class="indent">The fact that the contents of this file have changed over time raises a general point about the use of <span class="literal">/proc</span> files: when these files consist of multiple entries, we should parse them defensively&#8212;in this case, looking for a match on a line containing a particular string (e.g., <em>PPid:</em>), rather than processing the file by (logical) line number.</p>
<p class="indent"><a href="ch12.xhtml#ch12table1">Table 12-1</a> lists some of the other files found in each <span class="literal">/proc/</span><em>PID</em> directory.</p>
<p class="tablecap"><a id="ch12table1"/><strong>Table 12-1:</strong> Selected files in each <span class="literal">/proc/</span><em>PID</em> directory</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>File</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description (process attribute)</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">cmdline</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Command-line arguments delimited by <span class="literal">\0</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">cwd</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Symbolic link to current working directory</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">environ</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Environment list <em>NAME=value</em> pairs, delimited by <span class="literal">\0</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">exe</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Symbolic link to file being executed</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">fd</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Directory containing symbolic links to files opened by this process</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">maps</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Memory mappings</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">mem</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Process virtual memory (must <em>lseek()</em> to valid offset before I/O)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">mounts</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Mount points for this process</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">root</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Symbolic link to root directory</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">status</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Various information (e.g., process IDs, credentials, memory usage, signals)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">task</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Contains one subdirectory for each thread in process (Linux 2.6)</p></td>
</tr>
</tbody>
</table>
<h5 class="h5" id="ch12lev3sec01"><strong>The</strong> <span class="literal"><span class="codestrong">/proc/</span></span><strong>PID</strong><span class="literal"><span class="codestrong">/fd</span></span> <strong>directory</strong></h5>
<p class="noindenta">The <span class="literal">/proc/</span><em>PID</em><span class="literal">/fd</span> directory contains one symbolic link for each file descriptor that the process has open. Each of these symbolic links has a name that matches the descriptor number; for example, <span class="literal">/proc/1968/fd/1</span> is a symbolic link to the standard output of process 1968. Refer to <a href="ch05.xhtml#ch05lev1sec11">Section 5.11</a> for further information.</p>
<p class="indent">As a convenience, any process can access its own <span class="literal">/proc/</span><em>PID</em> directory using the symbolic link <span class="literal">/proc/self</span>.</p>
<h5 class="h5" id="ch12lev3sec02"><strong>Threads: the</strong> <span class="literal"><span class="codestrong">/proc/</span></span><strong>PID</strong><span class="literal"><span class="codestrong">/task</span></span> <strong>directory</strong></h5>
<p class="noindenta">Linux 2.4 added the notion of thread groups to properly support the POSIX threading model. Since some attributes are distinct for the threads in a thread group, Linux 2.4 added a <span class="literal">task</span> subdirectory under the <span class="literal">/proc/</span><em>PID</em> directory. For each thread in this process, the kernel provides a subdirectory named <span class="literal">/proc/</span><em>PID</em><span class="literal">/task/</span><em>TID</em>, <span epub:type="pagebreak" id="page_226"/>where <em>TID</em> is the thread ID of the thread. (This is the same number as would be returned by a call to <em>gettid()</em> in the thread.)</p>
<p class="indent">Under each <span class="literal">/proc/</span><em>PID</em><span class="literal">/task/</span><em>TID</em> subdirectory is a set of files and directories exactly like those that are found under <span class="literal">/proc/</span><em>PID</em>. Since threads share many attributes, much of the information in these files is the same for each of the threads in the process. However, where it makes sense, these files show distinct information for each thread. For example, in the <span class="literal">/proc/</span><em>PID</em><span class="literal">/task/</span><em>TID</em><span class="literal">/status</span> files for a thread group, <em>State</em>, <em>Pid</em>, <em>SigPnd</em>, <em>SigBlk</em>, <em>CapInh</em>, <em>CapPrm</em>, <em>CapEff</em>, and <em>CapBnd</em> are some of the fields that may be distinct for each thread.</p>
<h4 class="h4" id="ch12lev2sec02"><strong>12.1.2 System Information Under</strong> <span class="literal"><span class="codestrong">/proc</span></span></h4>
<p class="noindenta">Various files and subdirectories under <span class="literal">/proc</span> provide access to system-wide information. A few of these are shown in <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>.</p>
<p class="indent">Many of the files shown in <a href="ch12.xhtml#ch12fig1">Figure 12-1</a> are described elsewhere in this book. <a href="ch12.xhtml#ch12table2">Table 12-2</a> summarizes the general purpose of the <span class="literal">/proc</span> subdirectories shown in <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>.</p>
<p class="tablecap"><a id="ch12table2"/><strong>Table 12-2:</strong> Purpose of selected <span class="literal">/proc</span> subdirectories</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Directory</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Information exposed by files in this directory</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">/proc</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Various system information</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">/proc/net</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Status information about networking and sockets</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">/proc/sys/fs</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Settings related to file systems</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">/proc/sys/kernel</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Various general kernel settings</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">/proc/sys/net</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Networking and sockets settings</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">/proc/sys/vm</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Memory-management settings</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">/proc/sysvipc</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Information about System V IPC objects</p></td>
</tr>
</tbody>
</table>
<h4 class="h4" id="ch12lev2sec03"><strong>12.1.3 Accessing</strong> <span class="literal"><span class="codestrong">/proc</span></span> <strong>Files</strong></h4>
<p class="noindenta">Files under <span class="literal">/proc</span> are often accessed using shell scripts (most <span class="literal">/proc</span> files that contain multiple values can be easily parsed with a scripting language such as Python or Perl). For example, we can modify and view the contents of a <span class="literal">/proc</span> file using shell commands as follows:</p>
<p class="programs"># <span class="codestrong">echo 100000 &gt; /proc/sys/kernel/pid_max</span><br/># <span class="codestrong">cat /proc/sys/kernel/pid_max</span><br/>100000</p>
<p class="noindentb"><span class="literal">/proc</span> files can also be accessed from a program using normal file I/O system calls. Some restrictions apply when accessing these files:</p>
<p class="bull">&#8226; Some <span class="literal">/proc</span> files are read-only; that is, they exist only to display kernel information and can&#8217;t be used to modify that information. This applies to most files under the <span class="literal">/proc/</span><em>PID</em> directories.</p>
<p class="bull">&#8226; Some <span class="literal">/proc</span> files can be read only by the file owner (or by a privileged process). For example, all files under <span class="literal">/proc/</span><em>PID</em> are owned by the user who owns the corresponding process, and on some of these files (e.g., <span class="literal">/proc/</span><em>PID</em><span class="literal">/environ</span>), read permission is granted only to the file owner.</p>
<p class="bull"><span epub:type="pagebreak" id="page_227"/>&#8226; Other than the files in the <span class="literal">/proc/</span><em>PID</em> subdirectories, most files under <span class="literal">/proc</span> are owned by <em>root</em>, and the files that are modifiable can be modified only by <em>root</em>.</p>
<div class="image"><img src="../images/f12-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch12fig1"/><strong>Figure 12-1:</strong> Selected files and subdirectories under <span class="literal">/proc</span></p>
<h5 class="h5" id="ch12lev3sec03"><strong>Accessing files in</strong> <span class="literal"><span class="codestrong">/proc/</span></span><strong>PID</strong></h5>
<p class="noindenta">The <span class="literal">/proc/</span><em>PID</em> directories are volatile. Each of these directories comes into existence when a process with the corresponding process ID is created and disappears when that process terminates. This means that if we determine that a particular <span class="literal">/proc/</span><em>PID</em> directory exists, then we need to cleanly handle the possibility that the process has terminated, and the corresponding <span class="literal">/proc/</span><em>PID</em> directory has been deleted, by the time we try to open a file in that directory.</p>
<h5 class="h5" id="ch12lev3sec04"><span epub:type="pagebreak" id="page_228"/><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch12.xhtml#ch12ex1">Listing 12-1</a> demonstrates how to read and modify a <span class="literal">/proc</span> file. This program reads and displays the contents of <span class="literal">/proc/sys/kernel/pid_max</span>. If a command-line argument is supplied, the program updates the file using that value. This file (which is new in Linux 2.6) specifies an upper limit for process IDs (<a href="ch06.xhtml#ch06lev1sec02">Section 6.2</a>). Here is an example of the use of this program:</p>
<p class="programs">$ <span class="codestrong">su</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Privilege is required to update</span> pid_max <span class="font1">file</span><br/>Password:<br/># <span class="codestrong">./procfs_pidmax 10000</span><br/>Old value: 32768<br/>/proc/sys/kernel/pid_max now contains 10000</p>
<p class="examplet"><a id="ch12ex1"/><strong>Listing 12-1:</strong> Accessing <span class="literal">/proc/sys/kernel/pid_max</span></p>
<p class="programsli">____________________________________________________ <span class="codestrong">sysinfo/procfs_pidmax.c</span><br/><br/>#include &lt;fcntl.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>#define MAX_LINE 100<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int fd;<br/>&#160;&#160;&#160;&#160;char line[MAX_LINE];<br/>&#160;&#160;&#160;&#160;ssize_t n;<br/><br/>&#160;&#160;&#160;&#160;fd = open("/proc/sys/kernel/pid_max", (argc &gt; 1) ? O_RDWR : O_RDONLY);<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open");<br/><br/>&#160;&#160;&#160;&#160;n = read(fd, line, MAX_LINE);<br/>&#160;&#160;&#160;&#160;if (n == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("read");<br/><br/>&#160;&#160;&#160;&#160;if (argc &gt; 1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Old value: ");<br/>&#160;&#160;&#160;&#160;printf("%.*s", (int) n, line);<br/><br/>&#160;&#160;&#160;&#160;if (argc &gt; 1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (lseek (fd, 0, SEEK_SET) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("lseek");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (write(fd, argv[1], strlen(argv[1])) != strlen(argv[1]))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("write() failed");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;system("echo /proc/sys/kernel/pid_max now contains "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"`cat /proc/sys/kernel/pid_max`");<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>____________________________________________________ <span class="codestrong">sysinfo/procfs_pidmax.c</span></p>
<h3 class="h3" id="ch12lev1sec02"><span epub:type="pagebreak" id="page_229"/><strong>12.2 System Identification: <em>uname()</em></strong></h3>
<p class="noindenta">The <em>uname()</em> system call returns a range of identifying information about the host system on which an application is running, in the structure pointed to by <em>utsbuf</em>.</p>
<div class="box">
<p class="programsa">#include &lt;sys/utsname.h&gt;<br/><br/>int <span class="codestrong">uname</span>(struct utsname *<span class="font1">utsbuf</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>utsbuf</em> argument is a pointer to a <em>utsname</em> structure, which is defined as follows:</p>
<p class="programs">#define _UTSNAME_LENGTH 65<br/><br/>struct utsname {<br/>&#160;&#160;&#160;&#160;char sysname[_UTSNAME_LENGTH];&#160;&#160;&#160;&#160;&#160;&#160;/* Implementation name */<br/>&#160;&#160;&#160;&#160;char nodename[_UTSNAME_LENGTH];&#160;&#160;&#160;&#160;&#160;/* Node name on network */<br/>&#160;&#160;&#160;&#160;char release[_UTSNAME_LENGTH];&#160;&#160;&#160;&#160;&#160;&#160;/* Implementation release level */<br/>&#160;&#160;&#160;&#160;char version[_UTSNAME_LENGTH];&#160;&#160;&#160;&#160;&#160;&#160;/* Release version level */<br/>&#160;&#160;&#160;&#160;char machine[_UTSNAME_LENGTH];&#160;&#160;&#160;&#160;&#160;&#160;/* Hardware on which system<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;is running */<br/>#ifdef _GNU_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Following is Linux-specific */<br/>&#160;&#160;&#160;&#160;char domainname[_UTSNAME_LENGTH];&#160;&#160;&#160;/* NIS domain name of host */<br/>#endif<br/>};</p>
<p class="noindent">SUSv3 specifies <em>uname()</em>, but leaves the lengths of the various fields of the <em>utsname</em> structure undefined, requiring only that the strings be terminated by a null byte. On Linux, these fields are each 65 bytes long, including space for the terminating null byte. On some UNIX implementations, these fields are shorter; on others (e.g., Solaris), they range up to 257 bytes.</p>
<p class="indent">The <em>sysname</em>, <em>release</em>, <em>version</em>, and <em>machine</em> fields of the <em>utsname</em> structure are automatically set by the kernel.</p>
<div class="block">
<p class="noindent">On Linux, three files in the directory <span class="literal">/proc/sys/kernel</span> provide access to the same information as is returned in the <em>sysname</em>, <em>release</em>, and <em>version</em> fields of the <em>utsname</em> structure. These read-only files are, respectively, <span class="literal">ostype</span>, <span class="literal">osrelease</span>, and <span class="literal">version</span>. Another file, <span class="literal">/proc/version</span>, includes the same information as in these files, and also includes information about the kernel compilation step (i.e., the name of the user that performed the compilation, the name of host on which the compilation was performed, and the <em>gcc</em> version used).</p>
</div>
<p class="noindent">The <em>nodename</em> field returns the value that was set using the <em>sethostname()</em> system call (see the manual page for details of this system call). Often, this name is something like the hostname prefix from the system&#8217;s DNS domain name.</p>
<p class="indent">The <em>domainname</em> field returns the value that was set using the <em>setdomainname()</em> system call (see the manual page for details of this system call). This is the Network Information Services (NIS) domain name of the host (which is not the same thing as the host&#8217;s DNS domain name).</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_230"/>The <em>gethostname()</em> system call, which is the converse of <em>sethostname()</em>, retrieves the system hostname. The system hostname is also viewable and settable using the <em>hostname(1)</em> command and the Linux-specific <span class="literal">/proc/sys/kernel/domainname</span> file.</p>
<p class="indent">The <em>getdomainname()</em> system call, which is the converse of <em>setdomainname()</em>, retrieves the NIS domain name. The NIS domain name is also viewable and settable using the <em>domainname(1)</em> command and the Linux-specific <span class="literal">/proc/sys/kernel/domainname</span> file.</p>
<p class="indent">The <em>sethostname()</em> and <em>setdomainname()</em> system calls are rarely used in application programs. Normally, the hostname and NIS domain name are established at boot time by startup scripts.</p>
</div>
<p class="noindent">The program in <a href="ch12.xhtml#ch12ex2">Listing 12-2</a> displays the information returned by <em>uname()</em>. Here&#8217;s an example of the output we might see when running this program:</p>
<p class="programs">$ <span class="codestrong">./t_uname</span><br/>Node name:&#160;&#160;&#160;tekapo<br/>System name: Linux<br/>Release:&#160;&#160;&#160;&#160;&#160;2.6.30-default<br/>Version:&#160;&#160;&#160;&#160;&#160;#3 SMP Fri Jul 17 10:25:00 CEST 2009<br/>Machine:&#160;&#160;&#160;&#160;&#160;i686<br/>Domain name:</p>
<p class="examplet"><a id="ch12ex2"/><strong>Listing 12-2:</strong> Using <em>uname()</em></p>
<p class="programsli">________________________________________________________ <span class="codestrong">sysinfo/t_uname.c</span><br/><br/>#ifdef __linux__<br/>#define _GNU_SOURCE<br/>#endif<br/>#include &lt;sys/utsname.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct utsname uts;<br/><br/>&#160;&#160;&#160;&#160;if (uname(&#38;uts) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("uname");<br/><br/>&#160;&#160;&#160;&#160;printf("Node name:&#160;&#160;&#160;%s\n", uts.nodename);<br/>&#160;&#160;&#160;&#160;printf("System name: %s\n", uts.sysname);<br/>&#160;&#160;&#160;&#160;printf("Release:&#160;&#160;&#160;&#160;&#160;%s\n", uts.release);<br/>&#160;&#160;&#160;&#160;printf("Version:&#160;&#160;&#160;&#160;&#160;%s\n", uts.version);<br/>&#160;&#160;&#160;&#160;printf("Machine:&#160;&#160;&#160;&#160;&#160;%s\n", uts.machine);<br/>#ifdef _GNU_SOURCE<br/>&#160;&#160;&#160;&#160;printf("Domain name: %s\n", uts.domainname);<br/>#endif<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>________________________________________________________ <span class="codestrong">sysinfo/t_uname.c</span></p>
<h3 class="h3" id="ch12lev1sec03"><span epub:type="pagebreak" id="page_231"/><strong>12.3 Summary</strong></h3>
<p class="noindenta">The <span class="literal">/proc</span> file system exposes a range of kernel information to application programs. Each <span class="literal">/proc/</span><em>PID</em> subdirectory contains files and subdirectories that provide information about the process whose ID matches <em>PID</em>. Various other files and directories under <span class="literal">/proc</span> expose system-wide information that programs can read and, in some cases, modify.</p>
<p class="indent">The <em>uname()</em> system call allows us to discover the UNIX implementation and the type of machine on which an application is running.</p>
<h5 class="h5" id="ch12lev3sec05"><strong>Further information</strong></h5>
<p class="noindenta">Further information about the <span class="literal">/proc</span> file system can be found in the <em>proc(5)</em> manual page, in the kernel source file <span class="literal">Documentation/filesystems/proc.txt</span>, and in various files in the <span class="literal">Documentation/sysctl</span> directory.</p>
<h3 class="h3" id="ch12lev1sec04"><strong>12.4 Exercises</strong></h3>
<p class="exer"><a id="ch12exe1"/><strong>12-1.</strong>&#160;&#160;&#160;Write a program that lists the process ID and command name for all processes being run by the user named in the program&#8217;s command-line argument. (You may find the <em>userIdFromName()</em> function from <a href="ch08.xhtml#ch8ex1">Listing 8-1</a>, on <a href="ch08.xhtml#page_159">page 159</a>, useful.) This can be done by inspecting the <em>Name:</em> and <em>Uid:</em> lines of all of the <span class="literal">/proc/</span><em>PID</em><span class="literal">/status</span> files on the system. Walking through all of the <span class="literal">/proc/</span><em>PID</em> directories on the system requires the use of <em>readdir(3)</em>, which is described in <a href="ch18.xhtml#ch18lev1sec08">Section 18.8</a>. Make sure your program correctly handles the possibility that a <span class="literal">/proc/</span><em>PID</em> directory disappears between the time that the program determines that the directory exists and the time that it tries to open the corresponding <span class="literal">/proc/</span><em>PID</em><span class="literal">/status</span> file.</p>
<p class="exer"><a id="ch12exe2"/><strong>12-2.</strong>&#160;&#160;&#160;Write a program that draws a tree showing the hierarchical parent-child relationships of all processes on the system, going all the way back to <em>init</em>. For each process, the program should display the process ID and the command being executed. The output of the program should be similar to that produced by <em>pstree(1)</em>, although it does need not to be as sophisticated. The parent of each process on the system can be found by inspecting the <em>PPid:</em> line of all of the <span class="literal">/proc/</span><em>PID</em><span class="literal">/status</span> files on the system. Be careful to handle the possibility that a process&#8217;s parent (and thus its <span class="literal">/proc/</span><em>PID</em> directory) disappears during the scan of all <span class="literal">/proc/</span><em>PID</em> directories.</p>
<p class="exer"><a id="ch12exe3"/><strong>12-3.</strong>&#160;&#160;&#160;Write a program that lists all processes that have a particular file pathname open. This can be achieved by inspecting the contents of all of the <span class="literal">/proc/</span><em>PID</em><span class="literal">/fd/*</span> symbolic links. This will require nested loops employing <em>readdir(3)</em> to scan all <span class="literal">/proc/</span><em>PID</em> directories, and then the contents of all <span class="literal">/proc/</span><em>PID</em><span class="literal">/fd</span> entries within each <span class="literal">/proc/</span><em>PID</em> directory. To read the contents of a <span class="literal">/proc/</span><em>PID</em><span class="literal">/fd/</span><em>n</em> symbolic link requires the use of <em>readlink()</em>, described in <a href="ch18.xhtml#ch18lev1sec05">Section 18.5</a>.<span epub:type="pagebreak" id="page_232"/></p>
</body>
</html>
