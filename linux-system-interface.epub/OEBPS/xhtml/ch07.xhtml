<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_139"/><strong><span class="big">7</span></strong><br/><strong>MEMORY ALLOCATION</strong></h2>
<p class="noindenta">Many system programs need to be able to allocate extra memory for dynamic data structures (e.g., linked lists and binary trees), whose size depends on information that is available only at run time. This chapter describes the functions that are used to allocate memory on the heap or the stack.</p>
<h3 class="h3" id="ch07lev1sec01"><strong>7.1 Allocating Memory on the Heap</strong></h3>
<p class="noindenta">A process can allocate memory by increasing the size of the heap, a variablesize segment of contiguous virtual memory that begins just after the uninitialized data segment of a process and grows and shrinks as memory is allocated and freed (see <a href="ch06.xhtml#ch6fig1">Figure 6-1</a> on <a href="ch06.xhtml#page_119">page 119</a>). The current limit of the heap is referred to as the <em>program break</em>.</p>
<p class="indent">To allocate memory, C programs normally use the <em>malloc</em> family of functions, which we describe shortly. However, we begin with a description of <em>brk()</em> and <em>sbrk()</em>, upon which the <em>malloc</em> functions are based.</p>
<h4 class="h4" id="ch07lev2sec01"><strong>7.1.1 Adjusting the Program Break: <em>brk()</em> and <em>sbrk()</em></strong></h4>
<p class="noindenta">Resizing the heap (i.e., allocating or deallocating memory) is actually as simple as telling the kernel to adjust its idea of where the process&#8217;s program break is. Initially, the program break lies just past the end of the uninitialized data segment (i.e., the same location as <em>&#38;end</em>, shown in <a href="ch06.xhtml#ch6fig1">Figure 6-1</a>).</p>
<p class="indent"><span epub:type="pagebreak" id="page_140"/>After the program break is increased, the program may access any address in the newly allocated area, but no physical memory pages are allocated yet. The kernel automatically allocates new physical pages on the first attempt by the process to access addresses in those pages.</p>
<p class="indent">Traditionally, the UNIX system has provided two system calls for manipulating the program break, and these are both available on Linux: <em>brk()</em> and <em>sbrk()</em>. Although these system calls are seldom used directly in programs, understanding them helps clarify how memory allocation works.</p>
<div class="box">
<p class="programsa">#define _BSD_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Or: #define _SVID_SOURCE */<br/>#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">brk</span>(void *<span class="font1">end_data_segment</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
<p class="programsat">void *<span class="codestrong">sbrk</span>(intptr_t <span class="font1">increment</span>);</p>
<p class="right">Returns previous program break on success, or <em>(void *)</em> &#8211;1 on error</p>
</div>
<p class="noindent">The <em>brk()</em> system call sets the program break to the location specified by <em>end_data_segment</em>. Since virtual memory is allocated in units of pages, <em>end_data_segment</em> is effectively rounded up to the next page boundary.</p>
<p class="indent">Attempts to set the program break below its initial value (i.e., below <em>&#38;end</em>) are likely to result in unexpected behavior, such as a segmentation fault (the <span class="literal">SIGSEGV</span> signal, described in <a href="ch20.xhtml#ch20lev1sec02">Section 20.2</a>) when trying to access data in now nonexistent parts of the initialized or uninitialized data segments. The precise upper limit on where the program break can be set depends on a range of factors, including: the process resource limit for the size of the data segment (<span class="literal">RLIMIT_DATA</span>, described in <a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a>); and the location of memory mappings, shared memory segments, and shared libraries.</p>
<p class="indent">A call to <em>sbrk()</em> adjusts the program break by adding <em>increment</em> to it. (On Linux, <em>sbrk()</em> is a library function implemented on top of <em>brk()</em>.) The <em>intptr_t</em> type used to declare <em>increment</em> is an integer data type. On success, <em>sbrk()</em> returns the previous address of the program break. In other words, if we have increased the program break, the return value points to the start of the newly allocated block of memory.</p>
<p class="indent">The call <em>sbrk(0)</em> returns the current setting of the program break without changing it. This can be useful if we want to track the size of the heap, perhaps in order to monitor the behavior of a memory allocation package.</p>
<div class="block">
<p class="noindent">SUSv2 specified <em>brk()</em> and <em>sbrk()</em> (marking them LEGACY). SUSv3 removed their specifications.</p>
</div>
<h4 class="h4" id="ch07lev2sec02"><strong>7.1.2 Allocating Memory on the Heap: <em>malloc()</em> and <em>free()</em></strong></h4>
<p class="noindentab">In general, C programs use the <em>malloc</em> family of functions to allocate and deallocate memory on the heap. These functions offer several advantages over <em>brk()</em> and <em>sbrk()</em>. In particular, they:</p>
<p class="bull">&#8226; are standardized as part of the C language;</p>
<p class="bull">&#8226; are easier to use in threaded programs;</p>
<p class="bull"><span epub:type="pagebreak" id="page_141"/>&#8226; provide a simple interface that allows memory to be allocated in small units; and</p>
<p class="bull">&#8226; allow us to arbitrarily deallocate blocks of memory, which are maintained on a free list and recycled in future calls to allocate memory.</p>
<p class="noindent">The <em>malloc()</em> function allocates <em>size</em> bytes from the heap and returns a pointer to the start of the newly allocated block of memory. The allocated memory is not initialized.</p>
<div class="box">
<p class="programsa">#include &lt;stdlib.h&gt;<br/><br/>void *<span class="codestrong">malloc</span>(size_t <span class="font1">size</span>);</p>
<p class="right">Returns pointer to allocated memory on success, or <span class="literal">NULL</span> on error</p>
</div>
<p class="noindent">Because <em>malloc()</em> returns <em>void *</em>, we can assign it to any type of C pointer. The block of memory returned by <em>malloc()</em> is always aligned on a byte boundary suitable for efficient access to any type of C data structure. In practice, this means that it is allocated on an 8-byte or 16-byte boundary on most architectures.</p>
<div class="block">
<p class="noindent">SUSv3 specifies that the call <em>malloc(0)</em> may return either <span class="literal">NULL</span> or a pointer to a small piece of memory that can (and should) be freed with <em>free()</em>. On Linux, <em>malloc(0)</em> follows the latter behavior.</p>
</div>
<p class="noindent">If memory could not be allocated (perhaps because we reached the limit to which the program break could be raised), then <em>malloc()</em> returns <span class="literal">NULL</span> and sets <em>errno</em> to indicate the error. Although the possibility of failure in allocating memory is small, all calls to <em>malloc()</em>, and the related functions that we describe later, should check for this error return.</p>
<p class="indent">The <em>free()</em> function deallocates the block of memory pointed to by its <em>ptr</em> argument, which should be an address previously returned by <em>malloc()</em> or one of the other heap memory allocation functions that we describe later in this chapter.</p>
<div class="box">
<p class="programsa">#include &lt;stdlib.h&gt;<br/><br/>void <span class="codestrong">free</span>(void *<span class="font1">ptr</span>);</p>
</div>
<p class="noindentb">In general, <em>free()</em> doesn&#8217;t lower the program break, but instead adds the block of memory to a list of free blocks that are recycled by future calls to <em>malloc()</em>. This is done for several reasons:</p>
<p class="bull">&#8226; The block of memory being freed is typically somewhere in the middle of the heap, rather than at the end, so that lowering the program break is not possible.</p>
<p class="bull">&#8226; It minimizes the number of <em>sbrk()</em> calls that the program must perform. (As noted in <a href="ch03.xhtml#ch03lev1sec01">Section 3.1</a>, system calls have a small but significant overhead.)</p>
<p class="bull">&#8226; In many cases, lowering the break would not help programs that allocate large amounts of memory, since they typically tend to hold on to allocated memory or repeatedly release and reallocate memory, rather than release it all and then continue to run for an extended period of time.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_142"/>If the argument given to <em>free()</em> is a <span class="literal">NULL</span> pointer, then the call does nothing. (In other words, it is not an error to give a <span class="literal">NULL</span> pointer to <em>free()</em>.)</p>
<p class="indent">Making any use of <em>ptr</em> after the call to <em>free()</em>&#8212;for example, passing it to <em>free()</em> a second time&#8212;is an error that can lead to unpredictable results.</p>
<h5 class="h5" id="ch07lev3sec01"><strong>Example program</strong></h5>
<p class="noindenta">The program in <a href="ch07.xhtml#ch7ex1">Listing 7-1</a> can be used to illustrate the effect of <em>free()</em> on the program break. This program allocates multiple blocks of memory and then frees some or all of them, depending on its (optional) command-line arguments.</p>
<p class="indent">The first two command-line arguments specify the number and size of blocks to allocate. The third command-line argument specifies the loop step unit to be used when freeing memory blocks. If we specify 1 here (which is also the default if this argument is omitted), then the program frees every memory block; if 2, then every second allocated block; and so on. The fourth and fifth command-line arguments specify the range of blocks that we wish to free. If these arguments are omitted, then all allocated blocks (in steps given by the third command-line argument) are freed.</p>
<p class="examplet"><a id="ch7ex1"/><strong>Listing 7-1:</strong> Demonstrate what happens to the program break when memory is freed</p>
<p class="programsli">___________________________________________________ <span class="codestrong">memalloc/free_and_sbrk.c</span><br/><br/>#define _BSD_SOURCE<br/>#include "tlpi_hdr.h"<br/><br/>#define MAX_ALLOCS 1000000<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;char *ptr[MAX_ALLOCS];<br/>&#160;&#160;&#160;&#160;int freeStep, freeMin, freeMax, blockSize, numAllocs, j;<br/><br/>&#160;&#160;&#160;&#160;printf("\n");<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 3 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s num-allocs block-size [step [min [max]]]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;numAllocs = getInt(argv[1], GN_GT_0, "num-allocs");<br/>&#160;&#160;&#160;&#160;if (numAllocs &gt; MAX_ALLOCS)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cmdLineErr("num-allocs &gt; %d\n", MAX_ALLOCS);<br/><br/>&#160;&#160;&#160;&#160;blockSize = getInt(argv[2], GN_GT_0 | GN_ANY_BASE, "block-size");<br/><br/>&#160;&#160;&#160;&#160;freeStep = (argc &gt; 3) ? getInt(argv[3], GN_GT_0, "step") : 1;<br/>&#160;&#160;&#160;&#160;freeMin =&#160;&#160;(argc &gt; 4) ? getInt(argv[4], GN_GT_0, "min") : 1;<br/>&#160;&#160;&#160;&#160;freeMax =&#160;&#160;(argc &gt; 5) ? getInt(argv[5], GN_GT_0, "max") : numAllocs;<br/><br/>&#160;&#160;&#160;&#160;if (freeMax &gt; numAllocs)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cmdLineErr("free-max &gt; num-allocs\n");<br/><br/>&#160;&#160;&#160;&#160;printf("Initial program break:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;%10p\n", sbrk(0));<br/><br/>&#160;&#160;&#160;&#160;printf("Allocating %d*%d bytes\n", numAllocs, blockSize);<br/><br/>&#160;&#160;&#160;&#160;for (j = 0; j &lt; numAllocs; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ptr[j] = malloc(blockSize);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (ptr[j] == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("malloc");<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;printf("Program break is now:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;%10p\n", sbrk(0));<br/><br/>&#160;&#160;&#160;&#160;printf("Freeing blocks from %d to %d in steps of %d\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;freeMin, freeMax, freeStep);<br/>&#160;&#160;&#160;&#160;for (j = freeMin - 1; j &lt; freeMax; j += freeStep)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;free(ptr[j]);<br/><br/>&#160;&#160;&#160;&#160;printf("After free(), program break is: %10p\n", sbrk(0));<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>___________________________________________________ <span class="codestrong">memalloc/free_and_sbrk.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_143"/>Running the program in <a href="ch07.xhtml#ch7ex1">Listing 7-1</a> with the following command line causes the program to allocate 1000 blocks of memory and then free every second block:</p>
<p class="programs">$ <span class="codestrong">./free_and_sbrk 1000 10240 2</span></p>
<p class="noindent">The output shows that after these blocks have been freed, the program break is left unchanged from the level it reached when all memory blocks were allocated:</p>
<p class="programs">Initial program break:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0x804a6bc<br/>Allocating 1000*10240 bytes<br/>Program break is now:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0x8a13000<br/>Freeing blocks from 1 to 1000 in steps of 2<br/>After free(), program break is:&#160;&#160;0x8a13000</p>
<p class="noindent">The following command line specifies that all but the last of the allocated blocks should be freed. Again, the program break remains at its &#8220;high-water mark.&#8221;</p>
<p class="programs">$ <span class="codestrong">./free_and_sbrk 1000 10240 1 1 999</span><br/>Initial program break:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0x804a6bc<br/>Allocating 1000*10240 bytes<br/>Program break is now:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0x8a13000<br/>Freeing blocks from 1 to 999 in steps of 1<br/>After free(), program break is:&#160;&#160;0x8a13000</p>
<p class="noindent">If, however, we free a complete set of blocks at the top end of the heap, we see that the program break decreases from its peak value, indicating that <em>free()</em> has used <em>sbrk()</em> to lower the program break. Here, we free the last 500 blocks of allocated memory:</p>
<p class="programs">$ <span class="codestrong">./free_and_sbrk 1000 10240 1 500 1000</span><br/>Initial program break:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0x804a6bc<br/>Allocating 1000*10240 bytes<br/>Program break is now:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0x8a13000<br/>Freeing blocks from 500 to 1000 in steps of 1<br/>After free(), program break is:&#160;&#160;0x852b000</p>
<p class="noindent"><span epub:type="pagebreak" id="page_144"/>In this case, the (<em>glibc</em>) <em>free()</em> function is able to recognize that an entire region at the top end of the heap is free, since, when releasing blocks, it coalesces neighboring free blocks into a single larger block. (Such coalescing is done to avoid having a large number of small fragments on the free list, all of which may be too small to satisfy subsequent <em>malloc()</em> requests.)</p>
<div class="block">
<p class="noindent">The <em>glibc free()</em> function calls <em>sbrk()</em> to lower the program break only when the free block at the top end is &#8220;sufficiently&#8221; large, where &#8220;sufficient&#8221; is determined by parameters controlling the operation of the <em>malloc</em> package (128 kB is a typical value). This reduces the number of <em>sbrk()</em> calls (i.e., the number of <em>brk()</em> system calls) that must be made.</p>
</div>
<h5 class="h5" id="ch07lev3sec02"><strong>To <em>free()</em> or not to <em>free()</em>?</strong></h5>
<p class="noindenta">When a process terminates, all of its memory is returned to the system, including heap memory allocated by functions in the <em>malloc</em> package. In programs that allocate memory and continue using it until program termination, it is common to omit calls to <em>free()</em>, relying on this behavior to automatically free the memory. This can be especially useful in programs that allocate many blocks of memory, since adding multiple calls to <em>free()</em> could be expensive in terms of CPU time, as well as perhaps being complicated to code.</p>
<p class="indentb">Although relying on process termination to automatically free memory is acceptable for many programs, there are a couple of reasons why it can be desirable to explicitly free all allocated memory:</p>
<p class="bull">&#8226; Explicitly calling <em>free()</em> may make the program more readable and maintainable in the face of future modifications.</p>
<p class="bull">&#8226; If we are using a <em>malloc</em> debugging library (described below) to find memory leaks in a program, then any memory that is not explicitly freed will be reported as a memory leak. This can complicate the task of finding real memory leaks.</p>
<h4 class="h4" id="ch07lev2sec03"><strong>7.1.3 Implementation of <em>malloc()</em> and <em>free()</em></strong></h4>
<p class="noindenta">Although <em>malloc()</em> and <em>free()</em> provide an interface for allocating memory that is much easier to use than <em>brk()</em> and <em>sbrk()</em>, it is still possible to make various programming errors when using them. Understanding how <em>malloc()</em> and <em>free()</em> are implemented provides us with insights into the causes of these errors and how we can avoid them.</p>
<p class="indent">The implementation of <em>malloc()</em> is straightforward. It first scans the list of memory blocks previously released by <em>free()</em> in order to find one whose size is larger than or equal to its requirements. (Different strategies may be employed for this scan, depending on the implementation; for example, <em>first-fit</em> or <em>best-fit</em>.) If the block is exactly the right size, then it is returned to the caller. If it is larger, then it is split, so that a block of the correct size is returned to the caller and a smaller free block is left on the free list.</p>
<p class="indent">If no block on the free list is large enough, then <em>malloc()</em> calls <em>sbrk()</em> to allocate more memory. To reduce the number of calls to <em>sbrk()</em>, rather than allocating exactly the number of bytes required, <em>malloc()</em> increases the program break in larger units (some multiple of the virtual memory page size), putting the excess memory onto the free list.</p>
<p class="indent"><span epub:type="pagebreak" id="page_145"/>Looking at the implementation of <em>free()</em>, things start to become more interesting. When <em>free()</em> places a block of memory onto the free list, how does it know what size that block is? This is done via a trick. When <em>malloc()</em> allocates the block, it allocates extra bytes to hold an integer containing the size of the block. This integer is located at the beginning of the block; the address actually returned to the caller points to the location just past this length value, as shown in <a href="ch07.xhtml#ch7fig1">Figure 7-1</a>.</p>
<div class="image"><img src="../images/f07-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch7fig1"/><strong>Figure 7-1:</strong> Memory block returned by <em>malloc()</em></p>
<p class="noindent">When a block is placed on the (doubly linked) free list, <em>free()</em> uses the bytes of the block itself in order to add the block to the list, as shown in <a href="ch07.xhtml#ch7fig2">Figure 7-2</a>.</p>
<div class="image"><img src="../images/f07-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch7fig2"/><strong>Figure 7-2:</strong> A block on the free list</p>
<p class="noindent">As blocks are deallocated and reallocated over time, the blocks of the free list will become intermingled with blocks of allocated, in-use memory, as shown in <a href="ch07.xhtml#ch7fig3">Figure 7-3</a>.</p>
<div class="image"><img src="../images/f07-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch7fig3"/><strong>Figure 7-3:</strong> Heap containing allocated blocks and a free list</p>
<p class="noindent">Now consider the fact that C allows us to create pointers to any location in the heap, and modify the locations they point to, including the <em>length</em>, <em>previous free block</em>, and <em>next free block</em> pointers maintained by <em>free()</em> and <em>malloc()</em>. Add this to the preceding description, and we have a fairly combustible mix when it comes to creating obscure programming bugs. For example, if, via a misdirected pointer, we accidentally increase one of the length values preceding an allocated block of memory, and subsequently deallocate that block, then <em>free()</em> will record the wrong size block of memory on the free list. Subsequently, <em>malloc()</em> may reallocate this block, leading to a scenario where the program has pointers to two blocks of allocated memory that it understands to be distinct, but which actually overlap. Numerous other pictures of what could go wrong can be drawn.</p>
<p class="noindenttb"><span epub:type="pagebreak" id="page_146"/>To avoid these types of errors, we should observe the following rules:</p>
<p class="bull">&#8226; After we allocate a block of memory, we should be careful not to touch any bytes outside the range of that block. This could occur, for example, as a result of faulty pointer arithmetic or off-by-one errors in loops updating the contents of a block.</p>
<p class="bull">&#8226; It is an error to free the same piece of allocated memory more than once. With <em>glibc</em> on Linux, we often get a segmentation violation (<span class="literal">SIGSEGV</span> signal). This is good, because it alerts us that we&#8217;ve made a programming error. However, more generally, freeing the same memory twice leads to unpredictable behavior.</p>
<p class="bull">&#8226; We should never call <em>free()</em> with a pointer value that wasn&#8217;t obtained by a call to one of the functions in the <em>malloc</em> package.</p>
<p class="bull">&#8226; If we are writing a long-running program (e.g., a shell or a network daemon process) that repeatedly allocates memory for various purposes, then we should ensure that we deallocate any memory after we have finished using it. Failure to do so means that the heap will steadily grow until we reach the limits of available virtual memory, at which point further attempts to allocate memory fail. Such a condition is known as a <em>memory leak</em>.</p>
<h5 class="h5" id="ch07lev3sec03"><strong>Tools and libraries for <em>malloc</em> debugging</strong></h5>
<p class="noindenta">Failure to observe the rules listed above can lead to the creation of bugs that are obscure and difficult to reproduce. The task of finding such bugs can be eased considerably by using the <em>malloc</em> debugging tools provided by <em>glibc</em> or one of a number of <em>malloc</em> debugging libraries that are designed for this purpose.</p>
<p class="indentb">Among the <em>malloc</em> debugging tools provided by <em>glibc</em> are the following:</p>
<p class="bull">&#8226; The <em>mtrace()</em> and <em>muntrace()</em> functions allow a program to turn tracing of memory allocation calls on and off. These functions are used in conjunction with the <span class="literal">MALLOC_TRACE</span> environment variable, which should be defined to contain the name of a file to which tracing information should be written. When <em>mtrace()</em> is called, it checks to see whether this file is defined and can be opened for writing; if so, then all calls to functions in the <em>malloc</em> package are traced and recorded in the file. Since the resulting file is not easily human-readable, a script&#8212;also called <em>mtrace</em>&#8212;is provided to analyze the file and produce a readable summary. For security reasons, calls to <em>mtrace()</em> are ignored by set-user-ID and set-group-ID programs.</p>
<p class="bull">&#8226; The <em>mcheck()</em> and <em>mprobe()</em> functions allow a program to perform consistency checks on blocks of allocated memory; for example, catching errors such as attempting to write to a location past the end of a block of allocated memory. These functions provide functionality that somewhat overlaps with the <em>malloc</em> debugging libraries described below. Programs that employ these functions must be linked with the <em>mcheck</em> library using the <em>cc &#8211;lmcheck</em> option.</p>
<p class="bull">&#8226; The <span class="literal">MALLOC_CHECK_</span> environment variable (note the trailing underscore) serves a similar purpose to <em>mcheck()</em> and <em>mprobe()</em>. (One notable difference between the two techniques is that using <span class="literal">MALLOC_CHECK_</span> doesn&#8217;t require modification and recompilation of the program.) By setting this variable to different integer values, we can control how a program responds to memory allocation errors. Possible <span epub:type="pagebreak" id="page_147"/>settings are: 0, meaning ignore errors; 1, meaning print diagnostic errors on <em>stderr</em>; and 2, meaning call <em>abort()</em> to terminate the program. Not all memory allocation and deallocation errors are detected via the use of <span class="literal">MALLOC_CHECK_</span>; it finds just the common ones. However, this technique is fast, easy to use, and has low run-time overhead compared with the use of <em>malloc</em> debugging libraries. For security reasons, the setting of <span class="literal">MALLOC_CHECK_</span> is ignored by set-user-ID and set-group-ID programs.</p>
<p class="noindentt">Further information about all of the above features can be found in the <em>glibc</em> manual.</p>
<p class="indent">A <em>malloc</em> debugging library offers the same API as the standard <em>malloc</em> package, but does extra work to catch memory allocation bugs. In order to use such a library, we link our application against that library instead of the <em>malloc</em> package in the standard C library. Because these libraries typically operate at the cost of slower run-time operation, increased memory consumption, or both, we should use them only for debugging purposes, and then return to linking with the standard <em>malloc</em> package for the production version of an application. Among such libraries are <em>Electric Fence</em> (<em><a href="http://www.perens.com/FreeSoftware/">http://www.perens.com/FreeSoftware/</a></em>), <em>dmalloc</em> (<em><a href="http://dmalloc.com/">http://dmalloc.com/</a></em>), <em>Valgrind</em> (<em><a href="http://valgrind.org/">http://valgrind.org/</a></em>), and <em>Insure++</em> (<em><a href="http://www.parasoft.com/">http://www.parasoft.com/</a></em>).</p>
<div class="block">
<p class="noindent">Both <em>Valgrind</em> and <em>Insure++</em> are capable of detecting many other kinds of bugs aside from those associated with heap allocation. See their respective web sites for details.</p>
</div>
<h5 class="h5" id="ch07lev3sec04"><strong>Controlling and monitoring the <em>malloc</em> package</strong></h5>
<p class="noindentab">The <em>glibc</em> manual describes a range of nonstandard functions that can be used to monitor and control the allocation of memory by functions in the <em>malloc</em> package, including the following:</p>
<p class="bull">&#8226; The <em>mallopt()</em> function modifies various parameters that control the algorithm used by <em>malloc()</em>. For example, one such parameter specifies the minimum amount of releasable space that must exist at the end of the free list before <em>sbrk()</em> is used to shrink the heap. Another parameter specifies an upper limit for the size of blocks that will be allocated from the heap; blocks larger than this are allocated using the <em>mmap()</em> system call (refer to <a href="ch49.xhtml#ch49lev1sec07">Section 49.7</a>).</p>
<p class="bull">&#8226; The <em>mallinfo()</em> function returns a structure containing various statistics about the memory allocated by <em>malloc()</em>.</p>
<p class="noindentt">Many UNIX implementations provide versions of <em>mallopt()</em> and <em>mallinfo()</em>. However, the interfaces offered by these functions vary across implementations, so they are not portable.</p>
<h4 class="h4" id="ch07lev2sec04"><strong>7.1.4 Other Methods of Allocating Memory on the Heap</strong></h4>
<p class="noindenta">As well as <em>malloc()</em>, the C library provides a range of other functions for allocating memory on the heap, and we describe those functions here.</p>
<h5 class="h5" id="ch07lev3sec05"><strong>Allocating memory with <em>calloc()</em> and <em>realloc()</em></strong></h5>
<p class="noindenta">The <em>calloc()</em> function allocates memory for an array of identical items.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_148"/>#include &lt;stdlib.h&gt;<br/><br/>void *<span class="codestrong">calloc</span>(size_t <span class="font1">numitems</span>, size_t <span class="font1">size</span>);</p>
<p class="right">Returns pointer to allocated memory on success, or <span class="literal">NULL</span> on error</p>
</div>
<p class="noindent">The <em>numitems</em> argument specifies how many items to allocate, and <em>size</em> specifies their size. After allocating a block of memory of the appropriate size, <em>calloc()</em> returns a pointer to the start of the block (or <span class="literal">NULL</span> if the memory could not be allocated). Unlike <em>malloc()</em>, <em>calloc()</em> initializes the allocated memory to 0.</p>
<p class="indent">Here is an example of the use of <em>calloc()</em>:</p>
<p class="programs">struct myStruct { /* Some field definitions */ };<br/>struct myStruct *p;<br/><br/>p = calloc(1000, sizeof(struct myStruct));<br/>if (p == NULL)<br/>&#160;&#160;&#160;&#160;errExit("calloc");</p>
<p class="noindent">The <em>realloc()</em> function is used to resize (usually enlarge) a block of memory previously allocated by one of the functions in the <em>malloc</em> package.</p>
<div class="box">
<p class="programsa">#include &lt;stdlib.h&gt;<br/><br/>void *<span class="codestrong">realloc</span>(void *<span class="font1">ptr</span>, size_t <span class="font1">size</span>);</p>
<p class="right">Returns pointer to allocated memory on success, or <span class="literal">NULL</span> on error</p>
</div>
<p class="noindent">The <em>ptr</em> argument is a pointer to the block of memory that is to be resized. The <em>size</em> argument specifies the desired new size of the block.</p>
<p class="indent">On success, <em>realloc()</em> returns a pointer to the location of the resized block. This may be different from its location before the call. On error, <em>realloc()</em> returns <span class="literal">NULL</span> and leaves the block pointed to by <em>ptr</em> untouched (SUSv3 requires this).</p>
<p class="indent">When <em>realloc()</em> increases the size of a block of allocated memory, it doesn&#8217;t initialize the additionally allocated bytes.</p>
<p class="indent">Memory allocated using <em>calloc()</em> or <em>realloc()</em> should be deallocated with <em>free()</em>.</p>
<div class="block">
<p class="noindent">The call <em>realloc(ptr, 0)</em> is equivalent to calling <em>free(ptr)</em> followed by <em>malloc(0)</em>. If <em>ptr</em> is specified as <span class="literal">NULL</span>, then <em>realloc()</em> is equivalent to calling <em>malloc(size)</em>.</p>
</div>
<p class="noindent">For the usual case, where we are increasing the size of the block of memory, <em>realloc()</em> attempts to coalesce the block with an immediately following block of memory on the free list, if one exists and is large enough. If the block lies at the end of the heap, then <em>realloc()</em> expands the heap. If the block of memory lies in the middle of the heap, and there is insufficient free space immediately following it, <em>realloc()</em> allocates a new block of memory and copies all existing data from the old block to the new block. This last case is common and CPU-intensive. In general, it is advisable to minimize the use of <em>realloc()</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_149"/>Since <em>realloc()</em> may relocate the block of memory, we must use the returned pointer from <em>realloc()</em> for future references to the memory block. We can employ <em>realloc()</em> to reallocate a block pointed to by the variable <em>ptr</em> as follows:</p>
<p class="programs">nptr = realloc(ptr, newsize);<br/>if (nptr == NULL) {<br/>&#160;&#160;&#160;&#160;/* Handle error */<br/>} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* realloc() succeeded */<br/>&#160;&#160;&#160;&#160;ptr = nptr;<br/>}</p>
<p class="noindent">In this example, we didn&#8217;t assign the return value of <em>realloc()</em> directly to <em>ptr</em> because, if <em>realloc()</em> had failed, then <em>ptr</em> would have been set to <span class="literal">NULL</span>, making the existing block inaccessible.</p>
<p class="indent">Because <em>realloc()</em> may move the block of memory, any pointers that referred to locations inside the block before the <em>realloc()</em> call may no longer be valid after the call. The only type of reference to a location within the block that is guaranteed to remain valid is one formed by adding an offset to the pointer to the start of the block. We discuss this point in more detail in <a href="ch48.xhtml#ch48lev1sec06">Section 48.6</a>.</p>
<h5 class="h5" id="ch07lev3sec06"><strong>Allocating aligned memory: <em>memalign()</em> and <em>posix_memalign()</em></strong></h5>
<p class="noindenta">The <em>memalign()</em> and <em>posix_memalign()</em> functions are designed to allocate memory starting at an address aligned at a specified power-of-two boundary, a feature that is useful for some applications (see, for example, <a href="ch13.xhtml#ch13ex1">Listing 13-1</a>, on <a href="ch13.xhtml#page_247">page 247</a>).</p>
<div class="box">
<p class="programsa">#include &lt;malloc.h&gt;<br/><br/>void *<span class="codestrong">memalign</span>(size_t <span class="font1">boundary</span>, size_t <span class="font1">size</span>);</p>
<p class="right">Returns pointer to allocated memory on success, or <span class="literal">NULL</span> on error</p>
</div>
<p class="noindent">The <em>memalign()</em> function allocates <em>size</em> bytes starting at an address aligned to a multiple of <em>boundary</em>, which must be a power of two. The address of the allocated memory is returned as the function result.</p>
<p class="indent">The <em>memalign()</em> function is not present on all UNIX implementations. Most other UNIX implementations that provide <em>memalign()</em> require the inclusion of <span class="literal">&lt;stdlib.h&gt;</span> instead of <span class="literal">&lt;malloc.h&gt;</span> in order to obtain the function declaration.</p>
<p class="indent">SUSv3 doesn&#8217;t specify <em>memalign()</em>, but instead specifies a similar function, named <em>posix_memalign()</em>. This function is a recent creation of the standards committees, and appears on only a few UNIX implementations.</p>
<div class="box">
<p class="programsa">#include &lt;stdlib.h&gt;<br/><br/>int <span class="codestrong">posix_memalign</span>(void **<span class="font1">memptr</span>, size_t <span class="font1">alignment</span>, size_t <span class="font1">size</span>);</p>
<p class="right">Returns 0 on success, or a positive error number on error</p>
</div>
<p class="noindentb"><span epub:type="pagebreak" id="page_150"/>The <em>posix_memalign()</em> function differs from <em>memalign()</em> in two respects:</p>
<p class="bull">&#8226; The address of the allocated memory is returned in <em>memptr</em>.</p>
<p class="bull">&#8226; The memory is aligned to a multiple of <em>alignment</em>, which must be a power-oftwo multiple of <em>sizeof(void *)</em> (4 or 8 bytes on most hardware architectures).</p>
<p class="noindentt">Note also the unusual return value of this function&#8212;rather than returning &#8211;1 on error, it returns an error number (i.e., a positive integer of the type normally returned in <em>errno</em>).</p>
<p class="indent">If <em>sizeof(void *)</em> is 4, then we can use <em>posix_memalign()</em> to allocate 65,536 bytes of memory aligned on a 4096-byte boundary as follows:</p>
<p class="programs">int s;<br/>void *memptr;<br/><br/>s = posix_memalign(&#38;memptr, 1024 * sizeof(void *), 65536);<br/>if (s != 0)<br/>&#160;&#160;&#160;&#160;/* Handle error */</p>
<p class="noindent">Blocks of memory allocated using <em>memalign()</em> or <em>posix_memalign()</em> should be deallocated with <em>free()</em>.</p>
<div class="block">
<p class="noindent">On some UNIX implementations, it is not possible to call <em>free()</em> on a block of memory allocated via <em>memalign()</em>, because the <em>memalign()</em> implementation uses <em>malloc()</em> to allocate a block of memory, and then returns a pointer to an address with a suitable alignment in that block. The <em>glibc</em> implementation of <em>memalign()</em> doesn&#8217;t suffer this limitation.</p>
</div>
<h3 class="h3" id="ch07lev1sec02"><strong>7.2 Allocating Memory on the Stack: <em>alloca()</em></strong></h3>
<p class="noindenta">Like the functions in the <em>malloc</em> package, <em>alloca()</em> allocates memory dynamically. However, instead of obtaining memory from the heap, <em>alloca()</em> obtains memory from the stack by increasing the size of the stack frame. This is possible because the calling function is the one whose stack frame is, by definition, on the top of the stack. Therefore, there is space above the frame for expansion, which can be accomplished by simply modifying the value of the stack pointer.</p>
<div class="box">
<p class="programsa">#include &lt;alloca.h&gt;<br/><br/>void *<span class="codestrong">alloca</span>(size_t <span class="font1">size</span>);</p>
<p class="right">Returns pointer to allocated block of memory</p>
</div>
<p class="noindent">The <em>size</em> argument specifies the number of bytes to allocate on the stack. The <em>alloca()</em> function returns a pointer to the allocated memory as its function result.</p>
<p class="indent">We need not&#8212;indeed, must not&#8212;call <em>free()</em> to deallocate memory allocated with <em>alloca()</em>. Likewise, it is not possible to use <em>realloc()</em> to resize a block of memory allocated by <em>alloca()</em>.</p>
<p class="indent">Although <em>alloca()</em> is not part of SUSv3, it is provided on most UNIX implementations and is thus reasonably portable.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_151"/>Older versions of <em>glibc</em>, and some other UNIX implementations (mainly BSD derivatives), require the inclusion of <span class="literal">&lt;stdlib.h&gt;</span> instead of <span class="literal">&lt;alloca.h&gt;</span> to obtain the declaration of <em>alloca()</em>.</p>
</div>
<p class="noindent">If the stack overflows as a consequence of calling <em>alloca()</em>, then program behavior is unpredictable. In particular, we don&#8217;t get a <span class="literal">NULL</span> return to inform us of the error. (In fact, in this circumstance, we may receive a <span class="literal">SIGSEGV</span> signal. Refer to <a href="ch21.xhtml#ch21lev1sec03">Section 21.3</a> for further details.)</p>
<p class="indent">Note that we can&#8217;t use <em>alloca()</em> within a function argument list, as in this example:</p>
<p class="programs">func(x, alloca(size), z);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* WRONG! */</p>
<p class="noindent">This is because the stack space allocated by <em>alloca()</em> would appear in the middle of the space for the function arguments (which are placed at fixed locations within the stack frame). Instead, we must use code such as this:</p>
<p class="programs">void *y;<br/><br/>y = alloca(size);<br/>func(x, y, z);</p>
<p class="noindent">Using <em>alloca()</em> to allocate memory has a few advantages over <em>malloc()</em>. One of these is that allocating blocks of memory is faster with <em>alloca()</em> than with <em>malloc()</em>, because <em>alloca()</em> is implemented by the compiler as inline code that directly adjusts the stack pointer. Furthermore, <em>alloca()</em> doesn&#8217;t need to maintain a list of free blocks.</p>
<p class="indent">Another advantage of <em>alloca()</em> is that the memory that it allocates is automatically freed when the stack frame is removed; that is, when the function that called <em>alloca()</em> returns. This is so because the code executed during function return resets the value of the stack pointer register to the end of the previous frame (i.e., assuming a downwardly growing stack, to the address just above the start of the current frame). Since we don&#8217;t need to do the work of ensuring that allocated memory is freed on all return paths from a function, coding of some functions becomes much simpler.</p>
<p class="indent">Using <em>alloca()</em> can be especially useful if we employ <em>longjmp()</em> (<a href="ch06.xhtml#ch06lev1sec08">Section 6.8</a>) or <em>siglongjmp()</em> (<a href="ch21.xhtml#ch21lev2sec04">Section 21.2.1</a>) to perform a nonlocal goto from a signal handler. In this case, it is difficult or even impossible to avoid memory leaks if we allocated memory in the jumped-over functions using <em>malloc()</em>. By contrast, <em>alloca()</em> avoids this problem completely, since, as the stack is unwound by these calls, the allocated memory is automatically freed.</p>
<h3 class="h3" id="ch07lev1sec03"><strong>7.3 Summary</strong></h3>
<p class="noindenta">Using the <em>malloc</em> family of functions, a process can dynamically allocate and release memory on the heap. In considering the implementation of these functions, we saw that various things can go wrong in a program that mishandles the blocks of allocated memory, and we noted that a number of debugging tools are available to help locate the source of such errors.</p>
<p class="indent">The <em>alloca()</em> function allocates memory on the stack. This memory is automatically deallocated when the function that calls <em>alloca()</em> returns.</p>
<h3 class="h3" id="ch07lev1sec04"><span epub:type="pagebreak" id="page_152"/><strong>7.4 Exercises</strong></h3>
<p class="exer"><a id="ch7exe1"/><strong>7-1.</strong>&#160;&#160;&#160;&#160;&#160;Modify the program in <a href="ch07.xhtml#ch7ex1">Listing 7-1</a> (<span class="literal">free_and_sbrk.c</span>) to print out the current value of the program break after each execution of <em>malloc()</em>. Run the program specifying a small allocation block size. This will demonstrate that <em>malloc()</em> doesn&#8217;t employ <em>sbrk()</em> to adjust the program break on each call, but instead periodically allocates larger chunks of memory from which it passes back small pieces to the caller.</p>
<p class="exer"><a id="ch7exe2"/><strong>7-2.</strong>&#160;&#160;&#160;&#160;&#160;(Advanced) Implement <em>malloc()</em> and <em>free()</em>.</p>
</body>
</html>
