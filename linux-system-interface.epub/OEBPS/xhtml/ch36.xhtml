<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch36"><span epub:type="pagebreak" id="page_753"/><strong><span class="big">36</span></strong><br/><strong>PROCESS RESOURCES</strong></h2>
<p class="noindenta">Each process consumes system resources such as memory and CPU time. This chapter looks at resource-related system calls. We begin with the <em>getrusage()</em> system call, which allows a process to monitor the resources that it has used or that its children have used. We then look at the <em>setrlimit()</em> and <em>getrlimit()</em> system calls, which can be used to change and retrieve limits on the calling process&#8217;s consumption of various resources.</p>
<h3 class="h3" id="ch36lev1sec01"><strong>36.1 Process Resource Usage</strong></h3>
<p class="noindenta">The <em>getrusage()</em> system call retrieves statistics about various system resources used by the calling process or by all of its children.</p>
<div class="box">
<p class="programsa">#include &lt;sys/resource.h&gt;<br/><br/>int <span class="codestrong">getrusage</span>(int <span class="font1">who</span>, struct rusage *<span class="font1">res_usage</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb"><span epub:type="pagebreak" id="page_754"/>The <em>who</em> argument specifies the process(es) for which resource usage information is to be retrieved. It has one of the following values:</p>
<p class="term"><span class="literal">RUSAGE_SELF</span></p>
<p class="termlist">Return information about the calling process.</p>
<p class="term"><span class="literal">RUSAGE_CHILDREN</span></p>
<p class="termlist">Return information about all children of the calling process that have terminated and been waited for.</p>
<p class="term"><span class="literal">RUSAGE_THREAD</span> (since Linux 2.6.26)</p>
<p class="termlist">Return information about the calling thread. This value is Linux-specific.</p>
<p class="noindentt">The <em>res_usage</em> argument is a pointer to a structure of type <em>rusage</em>, defined as shown in <a href="ch36.xhtml#ch36ex1">Listing 36-1</a>.</p>
<p class="examplet"><a id="ch36ex1"/><strong>Listing 36-1:</strong> Definition of the <em>rusage</em> structure</p>
<p class="programsli">______________________________________________________________________<br/><br/>struct rusage {<br/>&#160;&#160;&#160;&#160;struct timeval ru_utime;&#160;&#160;&#160;&#160;&#160;&#160;/* User CPU time used */<br/>&#160;&#160;&#160;&#160;struct timeval ru_stime;&#160;&#160;&#160;&#160;&#160;&#160;/* System CPU time used */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ru_maxrss;&#160;&#160;&#160;&#160;&#160;/* Maximum size of resident set (kilobytes)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[used since Linux 2.6.32] */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ru_ixrss;&#160;&#160;&#160;&#160;&#160;&#160;/* Integral (shared) text memory size<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(kilobyte-seconds) [unused] */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ru_idrss;&#160;&#160;&#160;&#160;&#160;&#160;/* Integral (unshared) data memory used<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(kilobyte-seconds) [unused] */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ru_isrss;&#160;&#160;&#160;&#160;&#160;&#160;/* Integral (unshared) stack memory used<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(kilobyte-seconds) [unused] */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ru_minflt;&#160;&#160;&#160;&#160;&#160;/* Soft page faults (I/O not required) */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ru_majflt;&#160;&#160;&#160;&#160;&#160;/* Hard page faults (I/O required) */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ru_nswap;&#160;&#160;&#160;&#160;&#160;&#160;/* Swaps out of physical memory [unused] */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ru_inblock;&#160;&#160;&#160;&#160;/* Block input operations via file<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;system [used since Linux 2.6.22] */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ru_oublock;&#160;&#160;&#160;&#160;/* Block output operations via file<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;system [used since Linux 2.6.22] */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ru_msgsnd;&#160;&#160;&#160;&#160;&#160;/* IPC messages sent [unused] */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ru_msgrcv;&#160;&#160;&#160;&#160;&#160;/* IPC messages received [unused] */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ru_nsignals;&#160;&#160;&#160;/* Signals received [unused] */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ru_nvcsw;&#160;&#160;&#160;&#160;&#160;&#160;/* Voluntary context switches (process<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;relinquished CPU before its time slice<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;expired) [used since Linux 2.6] */<br/>&#160;&#160;&#160;&#160;long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ru_nivcsw;&#160;&#160;&#160;&#160;&#160;/* Involuntary context switches (higher<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;priority process became runnable or time<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slice ran out) [used since Linux 2.6] */<br/>};<br/>______________________________________________________________________</p>
<p class="noindent">As indicated in the comments in <a href="ch36.xhtml#ch36ex1">Listing 36-1</a>, on Linux, many of the fields in the <em>rusage</em> structure are not filled in by <em>getrusage()</em> (or <em>wait3()</em> and <em>wait4()</em>), or they are filled in only by more recent kernel versions. Some of the fields that are unused on Linux are used on other UNIX implementations. These fields are provided on Linux so that, if they are implemented at a future date, the <em>rusage</em> structure does not need to undergo a change that would break existing application binaries.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_755"/>Although <em>getrusage()</em> appears on most UNIX implementations, it is only weakly specified in SUSv3 (which specifies only the fields <em>ru_utime</em> and <em>ru_stime</em>). In part, this is because the meaning of much of the information in the <em>rusage</em> structure is implementation-dependent.</p>
</div>
<p class="noindent">The <em>ru_utime</em> and <em>ru_stime</em> fields are structures of type <em>timeval</em> (<a href="ch10.xhtml#ch10lev1sec01">Section 10.1</a>), which return the number of seconds and microseconds of CPU time consumed by a process in user mode and kernel mode, respectively. (Similar information is retrieved by the <em>times()</em> system call described in <a href="ch10.xhtml#ch10lev1sec07">Section 10.7</a>.)</p>
<div class="block">
<p class="noindent">The Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/stat</span> files expose some resource usage information (CPU time and page faults) about all processes on the system. See the <em>proc(5)</em> manual page for further details.</p>
</div>
<p class="noindent">The <em>rusage</em> structure returned by the <em>getrusage()</em> <span class="literal">RUSAGE_CHILDREN</span> operation includes the resource usage statistics of all of the descendants of the calling process. For example, if we have three processes related as parent, child, and grandchild, then, when the child does a <em>wait()</em> on the grandchild, the resource usage values of the grandchild are added to the child&#8217;s <span class="literal">RUSAGE_CHILDREN</span> values; when the parent performs a <em>wait()</em> for the child, the resource usage values of both the child and the grandchild are added to the parent&#8217;s <span class="literal">RUSAGE_CHILDREN</span> values. Conversely, if the child does not <em>wait()</em> on the grandchild, then the grandchild&#8217;s resource usages are not recorded in the <span class="literal">RUSAGE_CHILDREN</span> values of the parent.</p>
<p class="indent">For the <span class="literal">RUSAGE_CHILDREN</span> operation, the <em>ru_maxrss</em> field returns the maximum resident set size among all of the descendants of the calling process (rather than a sum for all descendants).</p>
<div class="block">
<p class="noindent">SUSv3 specifies that if <span class="literal">SIGCHLD</span> is being ignored (so that children are not turned into zombies that can be waited on), then the child statistics should not be added to the values returned by <span class="literal">RUSAGE_CHILDREN</span>. However, as noted in <a href="ch26.xhtml#ch26lev2sec09">Section 26.3.3</a>, in kernels before 2.6.9, Linux deviates from this requirement&#8212;if <span class="literal">SIGCHLD</span> is ignored, then the resource usage values for dead children <em>are</em> included in the values returned for <span class="literal">RUSAGE_CHILDREN</span>.</p>
</div>
<h3 class="h3" id="ch36lev1sec02"><strong>36.2 Process Resource Limits</strong></h3>
<p class="noindenta">Each process has a set of resource limits that can be used to restrict the amounts of various system resources that the process may consume. For example, we may want to set resource limits on a process before execing an arbitrary program, if we are concerned that it may consume excessive resources. We can set the resource limits of the shell using the <em>ulimit</em> built-in command (<em>limit</em> in the C shell). These limits are inherited by the processes that the shell creates to execute user commands.</p>
<div class="block">
<p class="noindent">Since kernel 2.6.24, the Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/limits</span> file can be used to view all of the resource limits of any process. This file is owned by the real user ID of the corresponding process and its permissions allow reading only by that user ID (or by a privileged process).</p>
</div>
<p class="noindent">The <em>getrlimit()</em> and <em>setrlimit()</em> system calls allow a process to fetch and modify its resource limits.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_756"/>#include &lt;sys/resource.h&gt;<br/><br/>int <span class="codestrong">getrlimit</span>(int <span class="font1">resource</span>, struct rlimit *<span class="font1">rlim</span>);<br/>int <span class="codestrong">setrlimit</span>(int <span class="font1">resource</span>, const struct rlimit *<span class="font1">rlim</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>resource</em> argument identifies the resource limit to be retrieved or changed. The <em>rlim</em> argument is used to return resource limit values (<em>getrlimit()</em>) or to specify new resource limit values (<em>setrlimit()</em>), and is a pointer to a structure containing two fields:</p>
<p class="programs">struct rlimit {<br/>&#160;&#160;&#160;&#160;rlim_t rlim_cur;&#160;&#160;&#160;&#160;&#160;&#160;/* Soft limit (actual process limit) */<br/>&#160;&#160;&#160;&#160;rlim_t rlim_max;&#160;&#160;&#160;&#160;&#160;&#160;/* Hard limit (ceiling for rlim_cur) */<br/>};</p>
<p class="noindent">These fields correspond to the two associated limits for a resource: the <em>soft</em> (<em>rlim_cur</em>) and <em>hard</em> (<em>rlim_max</em>) limits. (The <em>rlim_t</em> data type is an integer type.) The soft limit governs the amount of the resource that may be consumed by the process. A process can adjust the soft limit to any value from 0 up to the hard limit. For most resources, the sole purpose of the hard limit is to provide this ceiling for the soft limit. A privileged (<span class="literal">CAP_SYS_RESOURCE</span>) process can adjust the hard limit in either direction (as long as its value remains greater than the soft limit), but an unprivileged process can adjust the hard limit only to a lower value (irreversibly). The value <span class="literal">RLIM_INFINITY</span> in <em>rlim_cur</em> or <em>rlim_max</em> means infinity (no limit on the resource), both when retrieved via <em>getrlimit()</em> and when set via <em>setrlimit()</em>.</p>
<p class="indent">In most cases, resource limits are enforced for both privileged and unprivileged processes. They are inherited by child processes created via <em>fork()</em> and are preserved across an <em>exec()</em>.</p>
<p class="indent">The values that can be specified for the <em>resource</em> argument of <em>getrlimit()</em> and <em>setrlimit()</em> are summarized in <a href="ch36.xhtml#ch36table1">Table 36-1</a> and detailed in <a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a>.</p>
<p class="indent">Although a resource limit is a per-process attribute, in some cases, the limit is measured against not just that process&#8217;s consumption of the corresponding resource, but also against the sum of resources consumed by all processes with the same real user ID. The <span class="literal">RLIMIT_NPROC</span> limit, which places a limit on the number of processes that can be created, is a good example of the rationale for this approach. Applying this limit against only the number of children that the process itself created would be ineffective, since each child that the process created would also be able to create further children, which could create more children, and so on. Instead, the limit is measured against the count of all processes that have the same real user ID. Note, however, that the resource limit is checked only in the processes where it has been set (i.e., the process itself and its descendants, which inherit the limit). If another process owned by the same real user ID has not set the limit (i.e., the limit is infinite) or has set a different limit, then that process&#8217;s capacity to create children will be checked according to the limit that it has set.</p>
<p class="indent">As we describe each resource limit below, we note those limits that are measured against the resources consumed by all processes with the same real user ID. If not otherwise specified, then a resource limit is measured only against the process&#8217;s own consumption of the resource.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_757"/>Be aware that, in many cases, the shell commands for getting and setting resource limits (<em>ulimit</em> in <em>bash</em> and the Korn shell, and <em>limit</em> in the C shell) use different units from those used in <em>getrlimit()</em> and <em>setrlimit()</em>. For example, the shell commands typically express the limits on the size of various memory segments in kilobytes.</p>
</div>
<p class="tablecap"><a id="ch36table1"/><strong>Table 36-1:</strong> Resource values for <em>getrlimit()</em> and <em>setrlimit()</em></p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><em>resource</em></strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Limit on</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="tablec"><strong>SUSv3</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">RLIMIT_AS</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Process virtual memory size (bytes)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">RLIMIT_CORE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Core file size (bytes)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">RLIMIT_CPU</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">CPU time (seconds)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">RLIMIT_DATA</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Process data segment (bytes)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">RLIMIT_FSIZE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">File size (bytes)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">RLIMIT_MEMLOCK</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Locked memory (bytes)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">RLIMIT_MSGQUEUE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Bytes allocated for POSIX message queues for real user ID (since Linux 2.6.8)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">RLIMIT_NICE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Nice value (since Linux 2.6.12)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">RLIMIT_NOFILE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Maximum file descriptor number plus one</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">RLIMIT_NPROC</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Number of processes for real user ID</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">RLIMIT_RSS</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Resident set size (bytes; not implemented)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">RLIMIT_RTPRIO</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Realtime scheduling priority (since Linux 2.6.12)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">RLIMIT_RTTIME</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Realtime CPU time (microseconds; since Linux 2.6.25)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">RLIMIT_SIGPENDING</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Number of queued signals for real user ID (since Linux 2.6.8)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">RLIMIT_STACK</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">Size of stack segment (bytes)</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="tablec">&#8226;</p></td>
</tr>
</tbody>
</table>
<h5 class="h5" id="ch36lev3sec01"><strong>Example program</strong></h5>
<p class="noindenta">Before going into the specifics of each resource limit, we look at a simple example of the use of resource limits. <a href="ch36.xhtml#ch36ex2">Listing 36-2</a> defines the function <em>printRlimit()</em>, which displays a message, along with the soft and hard limits for a specified resource.</p>
<div class="block">
<p class="noindent">The <em>rlim_t</em> data type is typically represented in the same way as <em>off_t</em>, to handle the representation of <span class="literal">RLIMIT_FSIZE</span>, the file size resource limit. For this reason, when printing <em>rlim_t</em> values (as in <a href="ch36.xhtml#ch36ex2">Listing 36-2</a>), we cast them to <em>long long</em> and use the <span class="literal">%lld</span> <em>printf()</em> specifier, as explained in <a href="ch05.xhtml#ch05lev1sec10">Section 5.10</a>.</p>
</div>
<p class="noindent">The program in <a href="ch36.xhtml#ch36ex3">Listing 36-3</a> calls <em>setrlimit()</em> to set the soft and hard limits on the number of processes that a user may create (<span class="literal">RLIMIT_NPROC</span>), uses the <em>printRlimit()</em> function of <a href="ch36.xhtml#ch36ex2">Listing 36-2</a> to display the limits before and after the change, and then creates as many processes as possible. When we run this program, setting the soft limit to 30 and the hard limit to 100, we see the following:</p>
<p class="programs">$ <span class="codestrong">./rlimit_nproc 30 100</span><br/>Initial maximum process limits:&#160;&#160;soft=1024; hard=1024<br/>New maximum process limits:&#160;&#160;&#160;&#160;&#160;&#160;soft=30; hard=100<br/>Child 1 (PID=15674) started<br/>Child 2 (PID=15675) started<br/>Child 3 (PID=15676) started<br/>Child 4 (PID=15677) started<br/>ERROR [EAGAIN Resource temporarily unavailable] fork</p>
<p class="noindent"><span epub:type="pagebreak" id="page_758"/>In this example, the program managed to create only 4 new processes, because 26 processes were already running for this user.</p>
<p class="examplet"><a id="ch36ex2"/><strong>Listing 36-2:</strong> Displaying process resource limits</p>
<p class="programsli">____________________________________________________ <span class="codestrong">procres/print_rlimit.c</span><br/><br/>#include &lt;sys/resource.h&gt;<br/>#include "print_rlimit.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declares function defined here */<br/>#include "tlpi_hdr.h"<br/><br/>int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Print 'msg' followed by limits for 'resource' */<br/>printRlimit(const char *msg, int resource)<br/>{<br/>&#160;&#160;&#160;&#160;struct rlimit rlim;<br/><br/>&#160;&#160;&#160;&#160;if (getrlimit(resource, &#38;rlim) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/>&#160;&#160;&#160;&#160;printf("%s soft=", msg);<br/>&#160;&#160;&#160;&#160;if (rlim.rlim_cur == RLIM_INFINITY)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("infinite");<br/>#ifdef RLIM_SAVED_CUR&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Not defined on some implementations */<br/>&#160;&#160;&#160;&#160;else if (rlim.rlim_cur == RLIM_SAVED_CUR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("unrepresentable");<br/>#endif<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%lld", (long long) rlim.rlim_cur);<br/><br/>&#160;&#160;&#160;&#160;printf("; hard=");<br/>&#160;&#160;&#160;&#160;if (rlim.rlim_max == RLIM_INFINITY)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("infinite\n");<br/>#ifdef RLIM_SAVED_MAX&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Not defined on some implementations */<br/>&#160;&#160;&#160;&#160;else if (rlim.rlim_max == RLIM_SAVED_MAX)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("unrepresentable");<br/>#endif<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%lld\n", (long long) rlim.rlim_max);<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/>____________________________________________________ <span class="codestrong">procres/print_rlimit.c</span></p>
<p class="examplet"><a id="ch36ex3"/><strong>Listing 36-3:</strong> Setting the <span class="literal">RLIMIT_NPROC</span> resource limit</p>
<p class="programsli">____________________________________________________ <span class="codestrong">procres/rlimit_nproc.c</span><br/><br/>#include &lt;sys/resource.h&gt;<br/>#include "print_rlimit.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declaration of printRlimit() */<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct rlimit rl;<br/>&#160;&#160;&#160;&#160;int j;<br/>&#160;&#160;&#160;&#160;pid_t childPid;<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 2 || argc &gt; 3 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s soft-limit [hard-limit]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;printRlimit("Initial maximum process limits: ", RLIMIT_NPROC);<br/><br/>&#160;&#160;&#160;&#160;/* Set new process limits (hard == soft if not specified) */<br/><br/>&#160;&#160;&#160;&#160;rl.rlim_cur = (argv[1][0] == 'i') ? RLIM_INFINITY :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;getInt(argv[1], 0, "soft-limit");<br/>&#160;&#160;&#160;&#160;rl.rlim_max = (argc == 2) ? rl.rlim_cur :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(argv[2][0] == 'i') ? RLIM_INFINITY :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;getInt(argv[2], 0, "hard-limit");<br/>&#160;&#160;&#160;&#160;if (setrlimit(RLIMIT_NPROC, &#38;rl) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("setrlimit");<br/><br/>&#160;&#160;&#160;&#160;printRlimit("New maximum process limits:&#160;&#160;&#160;&#160;&#160;", RLIMIT_NPROC);<br/><br/>&#160;&#160;&#160;&#160;/* Create as many children as possible */<br/><br/>&#160;&#160;&#160;&#160;for (j = 1; ; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (childPid = fork()) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case -1: errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 0: _exit(EXIT_SUCCESS);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent: display message about each new child<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;and let the resulting zombies accumulate */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Child %d (PID=%ld) started\n", j, (long) childPid);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>____________________________________________________ <span class="codestrong">procres/rlimit_nproc.c</span></p>
<h5 class="h5" id="ch36lev3sec02"><span epub:type="pagebreak" id="page_759"/><strong>Unrepresentable limit values</strong></h5>
<p class="noindenta">In some programming environments, the <em>rlim_t</em> data type may not be able to represent the full range of values that could be maintained for a particular resource limit. This may be the case on a system that offers multiple programming environments in which the size of the <em>rlim_t</em> data type differs. Such systems can arise if a large-file compilation environment with a 64-bit <em>off_t</em> is added to a system on which <em>off_t</em> was traditionally 32 bits. (In each environment, <em>rlim_t</em> would be the same size as <em>off_t</em>.) This leads to the situation where a program with a small <em>rlim_t</em> can, after being execed by a program with a 64-bit <em>off_t</em>, inherit a resource limit (e.g., the file size limit) that is greater than the maximum <em>rlim_t</em> value.</p>
<p class="indent">To assist portable applications in handling the possibility that a resource limit may be unrepresentable, SUSv3 specifies two constants to indicate unrepresentable limit values: <span class="literal">RLIM_SAVED_CUR</span> and <span class="literal">RLIM_SAVED_MAX</span>. If a soft resource limit can&#8217;t be represented in <em>rlim_t</em>, then <em>getrlimit()</em> will return <span class="literal">RLIM_SAVED_CUR</span> in the <em>rlim_cur</em> field. <span class="literal">RLIM_SAVED_MAX</span> performs an analogous function for an unrepresentable hard limit returned in the <em>rlim_max</em> field.</p>
<p class="indent"><span epub:type="pagebreak" id="page_760"/>If all possible resource limit values can be represented in <em>rlim_t</em>, then SUSv3 permits an implementation to define <span class="literal">RLIM_SAVED_CUR</span> and <span class="literal">RLIM_SAVED_MAX</span> to be the same as <span class="literal">RLIM_INFINITY</span>. This is how these constants are defined on Linux, implying that all possible resource limit values can be represented in <em>rlim_t</em>. However, this is not the case on 32-bit architectures such as x86-32. On those architectures, in a large-file compilation environment (i.e., setting the <span class="literal">_FILE_OFFSET_BITS</span> feature test macro to 64 as described in <a href="ch05.xhtml#ch05lev1sec10">Section 5.10</a>), the <em>glibc</em> definition of <em>rlim_t</em> is 64 bits wide, but the kernel data type for representing a resource limit is <em>unsigned long</em>, which is only 32 bits wide. Current versions of <em>glibc</em> deal with this situation as follows: if a program compiled with <span class="literal">_FILE_OFFSET_BITS=64</span> tries to set a resource limit to a value larger than can be represented in a 32-bit <em>unsigned long</em>, then the <em>glibc</em> wrapper for <em>setrlimit()</em> silently converts the value to <span class="literal">RLIM_INFINITY</span>. In other words, the requested setting of the resource limit is not honored.</p>
<div class="block">
<p class="noindent">Because utilities that handle files are normally compiled with <span class="literal">_FILE_OFFSET_BITS=64</span> in many x86-32 distributions, the failure to honor resource limits larger than the value that can be represented in 32 bits is a problem that can affect not only application programmers, but also end users.</p>
<p class="indent">One could argue that it might be better for the <em>glibc setrlimit()</em> wrapper to give an error if the requested resource limit exceeds the capacity of a 32-bit <em>unsigned long</em>. However, the fundamental problem is a kernel limitation, and the behavior described in the main text is the approach that the <em>glibc</em> developers have taken to dealing with it.</p>
</div>
<h3 class="h3" id="ch36lev1sec03"><strong>36.3 Details of Specific Resource Limits</strong></h3>
<p class="noindentab">In this section, we provide details on each of the resource limits available on Linux, noting those that are Linux-specific.</p>
<h5 class="h5" id="ch36lev3sec03"><span class="literal"><span class="codestrong">RLIMIT_AS</span></span></h5>
<p class="noindenta">The <span class="literal">RLIMIT_AS</span> limit specifies the maximum size for the process&#8217;s virtual memory (address space), in bytes. Attempts (<em>brk()</em>, <em>sbrk()</em>, <em>mmap()</em>, <em>mremap()</em>, and <em>shmat()</em>) to exceed this limit fail with the error <span class="literal">ENOMEM</span>. In practice, the most common place where a program may hit this limit is in calls to functions in the <em>malloc</em> package, which make use of <em>sbrk()</em> and <em>mmap()</em>. Upon encountering this limit, stack growth can also fail with the consequences listed below for <span class="literal">RLIMIT_STACK</span>.</p>
<h5 class="h5" id="ch36lev3sec04"><span class="literal"><span class="codestrong">RLIMIT_CORE</span></span></h5>
<p class="noindenta">The <span class="literal">RLIMIT_CORE</span> limit specifies the maximum size, in bytes, for core dump files produced when a process is terminated by certain signals (<a href="ch22.xhtml#ch22lev1sec01">Section 22.1</a>). Production of a core dump file will stop at this limit. Specifying a limit of 0 prevents creation of core dump files, which is sometimes useful because core dump files can be very large, and end users usually don&#8217;t know what to do with them. Another reason for disabling core dumps is security&#8212;to prevent the contents of a program&#8217;s memory from being dumped to disk. If the <span class="literal">RLIMIT_FSIZE</span> limit is lower than this limit, core dump files are limited to <span class="literal">RLIMIT_FSIZE</span> bytes.</p>
<h5 class="h5" id="ch36lev3sec05"><span epub:type="pagebreak" id="page_761"/><span class="literal"><span class="codestrong">RLIMIT_CPU</span></span></h5>
<p class="noindenta">The <span class="literal">RLIMIT_CPU</span> limit specifies the maximum number of seconds of CPU time (in both system and user mode) that can be used by the process. SUSv3 requires that the <span class="literal">SIGXCPU</span> signal be sent to the process when the soft limit is reached, but leaves other details unspecified. (The default action for <span class="literal">SIGXCPU</span> is to terminate a process with a core dump.) It is possible to establish a handler for <span class="literal">SIGXCPU</span> that does whatever processing is desired and then returns control to the main program. Thereafter, (on Linux) <span class="literal">SIGXCPU</span> is sent once per second of consumed CPU time. If the process continues executing until the hard CPU limit is reached, then the kernel sends it a <span class="literal">SIGKILL</span> signal, which always terminates the process.</p>
<p class="indent">UNIX implementations vary in the details of how they deal with processes that continue consuming CPU time after handling a <span class="literal">SIGXCPU</span> signal. Most continue to deliver <span class="literal">SIGXCPU</span> at regular intervals. If aiming for portable use of this signal, we should code an application so that, on first receipt of this signal, it does whatever cleanup is required and terminates. (Alternatively, the program could change the resource limit after receiving the signal.)</p>
<h5 class="h5" id="ch36lev3sec06"><span class="literal"><span class="codestrong">RLIMIT_DATA</span></span></h5>
<p class="noindenta">The <span class="literal">RLIMIT_DATA</span> limit specifies the maximum size, in bytes, of the process&#8217;s data segment (the sum of the initialized data, uninitialized data, and heap segments described in <a href="ch06.xhtml#ch06lev1sec03">Section 6.3</a>). Attempts (<em>sbrk()</em> and <em>brk()</em>) to extend the data segment (program break) beyond this limit fail with the error <span class="literal">ENOMEM</span>. As with <span class="literal">RLIMIT_AS</span>, the most common place where a program may hit this limit is in calls to functions in the <em>malloc</em> package.</p>
<h5 class="h5" id="ch36lev3sec07"><span class="literal"><span class="codestrong">RLIMIT_FSIZE</span></span></h5>
<p class="noindenta">The <span class="literal">RLIMIT_FSIZE</span> limit specifies the maximum size of files that the process may create, in bytes. If a process attempts to extend a file beyond the soft limit, it is sent a <span class="literal">SIGXFSZ</span> signal, and the system call (e.g., <em>write()</em> or <em>truncate()</em>) fails with the error <span class="literal">EFBIG</span>. The default action for <span class="literal">SIGXFSZ</span> is to terminate a process and produce a core dump. It is possible to instead catch this signal and return control to the main program. However, any further attempt to extend the file will yield the same signal and error.</p>
<h5 class="h5" id="ch36lev3sec08"><span class="literal"><span class="codestrong">RLIMIT_MEMLOCK</span></span></h5>
<p class="noindenta">The <span class="literal">RLIMIT_MEMLOCK</span> limit (BSD-derived; absent from SUSv3 and available only on Linux and the BSDs) specifies the maximum number of bytes of virtual memory that a process may lock into physical memory, to prevent the memory from being swapped out. This limit affects the <em>mlock()</em> and <em>mlockall()</em> system calls, and the locking options for the <em>mmap()</em> and <em>shmctl()</em> system calls. We describe the details in <a href="ch50.xhtml#ch50lev1sec02">Section 50.2</a>.</p>
<p class="indent">If the <span class="literal">MCL_FUTURE</span> flag is specified when calling <em>mlockall()</em>, then the <span class="literal">RLIMIT_MEMLOCK</span> limit may also cause later calls to <em>brk()</em>, <em>sbrk()</em>, <em>mmap()</em>, or <em>mremap()</em> to fail.</p>
<h5 class="h5" id="ch36lev3sec09"><span class="literal"><span class="codestrong">RLIMIT_MSGQUEUE</span></span></h5>
<p class="noindenta">The <span class="literal">RLIMIT_MSGQUEUE</span> limit (Linux-specific; since Linux 2.6.8) specifies the maximum number of bytes that can be allocated for POSIX message queues for the real user <span epub:type="pagebreak" id="page_762"/>ID of the calling process. When a POSIX message queue is created using <em>mq_open()</em>, bytes are deducted against this limit according to the following formula:</p>
<p class="programs">bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;attr.mq_maxmsg * attr.mq_msgsize;</p>
<p class="noindent">In this formula, <em>attr</em> is the <em>mq_attr</em> structure that is passed as the fourth argument to <em>mq_open()</em>. The addend that includes <em>sizeof(struct msg_msg *)</em> ensures that the user can&#8217;t queue an unlimited number of zero-length messages. (The <em>msg_msg</em> structure is a data type used internally by the kernel.) This is necessary because, although zero-length messages contain no data, they do consume some system memory for bookkeeping overhead.</p>
<p class="indent">The <span class="literal">RLIMIT_MSGQUEUE</span> limit affects only the calling process. Other processes belonging to this user are not affected unless they also set this limit or inherit it.</p>
<h5 class="h5" id="ch36lev3sec10"><span class="literal"><span class="codestrong">RLIMIT_NICE</span></span></h5>
<p class="noindenta">The <span class="literal">RLIMIT_NICE</span> limit (Linux-specific; since Linux 2.6.12) specifies a ceiling on the nice value that may be set for this process using <em>sched_setscheduler()</em> and <em>nice()</em>. The ceiling is calculated as <em>20 &#8211; rlim_cur</em>, where <em>rlim_cur</em> is the current <span class="literal">RLIMIT_NICE</span> soft resource limit. Refer to <a href="ch35.xhtml#ch35lev1sec01">Section 35.1</a> for further details.</p>
<h5 class="h5" id="ch36lev3sec11"><span class="literal"><span class="codestrong">RLIMIT_NOFILE</span></span></h5>
<p class="noindenta">The <span class="literal">RLIMIT_NOFILE</span> limit specifies a number one greater than the maximum file descriptor number that a process may allocate. Attempts (e.g., <em>open()</em>, <em>pipe()</em>, <em>socket()</em>, <em>accept()</em>, <em>shm_open()</em>, <em>dup()</em>, <em>dup2()</em>, <em>fcntl(F_DUPFD)</em>, and <em>epoll_create()</em>) to allocate descriptors beyond this limit fail. In most cases, the error is <span class="literal">EMFILE</span>, but for <em>dup2(fd, newfd)</em> it is <span class="literal">EBADF</span>, and for <em>fcntl(fd, F_DUPFD, newfd)</em> with <em>newfd</em> is greater than or equal to the limit, it is <span class="literal">EINVAL</span>.</p>
<p class="indent">Changes to the <span class="literal">RLIMIT_NOFILE</span> limit are reflected in the value returned by <em>sysconf(_SC_OPEN_MAX)</em>. SUSv3 permits, but doesn&#8217;t require, an implementation to return different values for a call to <em>sysconf(_SC_OPEN_MAX)</em> before and after changing the <span class="literal">RLIMIT_NOFILE</span> limit; other implementations may not behave the same as Linux on this point.</p>
<div class="block">
<p class="noindent">SUSv3 states that if an application sets the soft or hard <span class="literal">RLIMIT_NOFILE</span> limit to a value less than or equal to the number of the highest file descriptor that the process currently has open, unexpected behavior may occur.</p>
<p class="indent">On Linux, we can check which file descriptors a process currently has open by using <em>readdir()</em> to scan the contents of the <span class="literal">/proc/</span><em>PID</em><span class="literal">/fd</span> directory, which contains symbolic links for each of the file descriptors currently opened by the process.</p>
</div>
<p class="noindent">The kernel imposes a ceiling on the value to which the <span class="literal">RLIMIT_NOFILE</span> limit may be raised. In kernels before 2.6.25, this ceiling is a hard-coded value defined by the kernel constant <span class="literal">NR_OPEN</span>, whose value is 1,048,576. (A kernel rebuild is required to raise this ceiling.) Since kernel 2.6.25, the limit is defined by the value in the Linux-specific <span class="literal">/proc/sys/fs/nr_open</span> file. The default value in this file is 1,048,576; this can be modified by the superuser. Attempts to set the soft or hard <span class="literal">RLIMIT_NOFILE</span> limit higher than the ceiling value yield the error <span class="literal">EPERM</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_763"/>There is also a system-wide limit on the total number of files that may be opened by all processes. This limit can be retrieved and modified via the Linux-specific <span class="literal">/proc/sys/fs/file-max</span> file. (Referring to <a href="ch05.xhtml#ch05lev1sec04">Section 5.4</a>, we can define <span class="literal">file-max</span> more precisely as a system-wide limit on the number of open file descriptions.) Only privileged (<span class="literal">CAP_SYS_ADMIN</span>) processes can exceed the <span class="literal">file-max</span> limit. In an unprivileged process, a system call that encounters the <span class="literal">file-max</span> limit fails with the error <span class="literal">ENFILE</span>.</p>
<h5 class="h5" id="ch36lev3sec12"><span class="literal"><span class="codestrong">RLIMIT_NPROC</span></span></h5>
<p class="noindenta">The <span class="literal">RLIMIT_NPROC</span> limit (BSD-derived; absent from SUSv3 and available only on Linux and the BSDs) specifies the maximum number of processes that may be created for the real user ID of the calling process. Attempts (<em>fork()</em>, <em>vfork()</em>, and <em>clone()</em>) to exceed this limit fail with the error <span class="literal">EAGAIN</span>.</p>
<p class="indent">The <span class="literal">RLIMIT_NPROC</span> limit affects only the calling process. Other processes belonging to this user are not affected unless they also set or inherit this limit. This limit is not enforced for privileged (<span class="literal">CAP_SYS_ADMIN</span> or <span class="literal">CAP_SYS_RESOURCE</span>) processes.</p>
<div class="block">
<p class="noindent">Linux also imposes a system-wide limit on the number of processes that can be created by all users. On Linux 2.4 and later, the Linux-specific <span class="literal">/proc/sys/kernel/threads-max</span> file can be used to retrieve and modify this limit.</p>
<p class="indent">To be precise, the <span class="literal">RLIMIT_NPROC</span> resource limit and the <span class="literal">threads-max</span> file are actually limits on the numbers of threads that can be created, rather than the number of processes.</p>
</div>
<p class="noindent">The manner in which the default value for the <span class="literal">RLIMIT_NPROC</span> resource limit is set has varied across kernel versions. In Linux 2.2, it was calculated according to a fixed formula. In Linux 2.4 and later, it is calculated using a formula based on the amount of available physical memory.</p>
<div class="block">
<p class="noindent">SUSv3 doesn&#8217;t specify the <span class="literal">RLIMIT_NPROC</span> resource limit. The SUSv3-mandated method for retrieving (but not changing) the maximum number of processes permitted to a user ID is via the call <em>sysconf(_SC_CHILD_MAX)</em>. This <em>sysconf()</em> call is supported on Linux, but in kernel versions before 2.6.23, the call does not return accurate information&#8212;it always returns the value 999. Since Linux 2.6.23 (and with <em>glibc</em> 2.4 and later), this call correctly reports the limit (by checking the value of the <span class="literal">RLIMIT_NPROC</span> resource limit).</p>
<p class="indent">There is no portable way of discovering how many processes have already been created for a specific user ID. On Linux, we can try scanning all of the <span class="literal">/proc/</span><em>PID</em><span class="literal">/status</span> files on the system and examining the information under the <span class="literal">Uid</span> entry (which lists the four process user IDs in the order: real, effective, saved set, and file system) in order to estimate the number of processes currently owned by a user. Be aware, however, that by the time we have completed such a scan, this information may already have changed.</p>
</div>
<h5 class="h5" id="ch36lev3sec13"><span class="literal"><span class="codestrong">RLIMIT_RSS</span></span></h5>
<p class="noindenta">The <span class="literal">RLIMIT_RSS</span> limit (BSD-derived; absent from SUSv3, but widely available) specifies the maximum number of pages in the process&#8217;s resident set; that is, the total number of virtual memory pages currently in physical memory. This limit is provided on Linux, but it currently has no effect.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_764"/>In older Linux 2.4 kernels (up to and including 2.4.29), <span class="literal">RLIMIT_RSS</span> did have an effect on the behavior of the <em>madvise()</em> <span class="literal">MADV_WILLNEED</span> operation (<a href="ch50.xhtml#ch50lev1sec04">Section 50.4</a>). If this operation could not be performed as a result of encountering the <span class="literal">RLIMIT_RSS</span> limit, the error <span class="literal">EIO</span> was returned in <em>errno</em>.</p>
</div>
<h5 class="h5" id="ch36lev3sec14"><span class="literal"><span class="codestrong">RLIMIT_RTPRIO</span></span></h5>
<p class="noindenta">The <span class="literal">RLIMIT_RTPRIO</span> limit (Linux-specific; since Linux 2.6.12) specifies a ceiling on the realtime priority that may be set for this process using <em>sched_setscheduler()</em> and <em>sched_setparam()</em>. Refer to <a href="ch35.xhtml#ch35lev2sec05">Section 35.3.2</a> for further details.</p>
<h5 class="h5" id="ch36lev3sec15"><span class="literal"><span class="codestrong">RLIMIT_RTTIME</span></span></h5>
<p class="noindenta">The <span class="literal">RLIMIT_RTTIME</span> limit (Linux-specific; since Linux 2.6.25) specifies the maximum amount of CPU time in microseconds that a process running under a realtime scheduling policy may consume without sleeping (i.e., performing a blocking system call). The behavior if this limit is reached is the same as for <span class="literal">RLIMIT_CPU</span>: if the process reaches the soft limit, then a <span class="literal">SIGXCPU</span> signal is sent to the process, and further <span class="literal">SIGXCPU</span> signals are sent for each additional second of CPU time consumed. On reaching the hard limit, a <span class="literal">SIGKILL</span> signal is sent. Refer to <a href="ch35.xhtml#ch35lev2sec05">Section 35.3.2</a> for further details.</p>
<h5 class="h5" id="ch36lev3sec16"><span class="literal"><span class="codestrong">RLIMIT_SIGPENDING</span></span></h5>
<p class="noindenta">The <span class="literal">RLIMIT_SIGPENDING</span> limit (Linux-specific; since Linux 2.6.8) specifies the maximum number of signals that may be queued for the real user ID of the calling process. Attempts (<em>sigqueue()</em>) to exceed this limit fail with the error <span class="literal">EAGAIN</span>.</p>
<p class="indent">The <span class="literal">RLIMIT_SIGPENDING</span> limit affects only the calling process. Other processes belonging to this user are not affected unless they also set or inherit this limit.</p>
<p class="indent">As initially implemented, the default value for the <span class="literal">RLIMIT_SIGPENDING</span> limit was 1024. Since kernel 2.6.12, the default value has been changed to be the same as the default value for <span class="literal">RLIMIT_NPROC</span>.</p>
<p class="indent">For the purposes of checking the <span class="literal">RLIMIT_SIGPENDING</span> limit, the count of queued signals includes both realtime and standard signals. (Standard signals can be queued only once to a process.) However, this limit is enforced only for <em>sigqueue()</em>. Even if the number of signals specified by this limit has already been queued to processes belonging to this real user ID, it is still possible to use <em>kill()</em> to queue one instance of each of the signals (including realtime signals) that are not already queued to a process.</p>
<p class="indent">From kernel 2.6.12 onward, the <span class="literal">SigQ</span> field of the Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/status</span> file displays the current and maximum number of queued signals for the real user ID of the process.</p>
<h5 class="h5" id="ch36lev3sec17"><span class="literal"><span class="codestrong">RLIMIT_STACK</span></span></h5>
<p class="noindenta">The <span class="literal">RLIMIT_STACK</span> limit specifies the maximum size of the process stack, in bytes. Attempts to grow the stack beyond this limit result in the generation of a <span class="literal">SIGSEGV</span> signal for the process. Since the stack is exhausted, the only way to catch this signal is by establishing an alternate signal stack, as described in <a href="ch21.xhtml#ch21lev1sec03">Section 21.3</a>.</p>
<div class="block">
<p class="noindent">Since Linux 2.6.23, the <span class="literal">RLIMIT_STACK</span> limit also determines the amount of space available for holding the process&#8217;s command-line arguments and environment variables. See the <em>execve(2)</em> manual page for details.</p>
</div>
<h3 class="h3" id="ch36lev1sec04"><span epub:type="pagebreak" id="page_765"/><strong>36.4 Summary</strong></h3>
<p class="noindenta">Processes consume various system resources. The <em>getrusage()</em> system call allows a process to monitor certain of the resources consumed by itself and by its children.</p>
<p class="indent">The <em>setrlimit()</em> and <em>getrlimit()</em> system calls allow a process to set and retrieve limits on its consumption of various resources. Each resource limit has two components: a soft limit, which is what the kernel enforces when checking a process&#8217;s resource consumption, and a hard limit, which acts as a ceiling on the value of the soft limit. An unprivileged process can set the soft limit for a resource to any value in the range from 0 up to the hard limit, but can only lower the hard limit. A privileged process can make any changes to either limit value, as long as the soft limit is less than or equal to the hard limit. If a process encounters a soft limit, it is typically informed of the fact either by receiving a signal or via failure of the system call that attempts to exceed the limit.</p>
<h3 class="h3" id="ch36lev1sec05"><strong>36.5 Exercises</strong></h3>
<p class="exer"><a id="ch36exe1"/><strong>36-1.</strong>&#160;&#160;&#160;Write a program that shows that the <em>getrusage()</em> <span class="literal">RUSAGE_CHILDREN</span> flag retrieves information about only the children for which a <em>wait()</em> call has been performed. (Have the program create a child process that consumes some CPU time, and then have the parent call <em>getrusage()</em> before and after calling <em>wait()</em>.)</p>
<p class="exer"><a id="ch36exe2"/><strong>36-2.</strong>&#160;&#160;&#160;Write a program that executes a command and then displays its resource usage. This is analogous to what the <em>time(1)</em> command does. Thus, we would use this program as follows:</p>
<p class="programs1">$ <span class="codestrong">./rusage <span class="codeitalic">command arg...</span></span></p>
<p class="exer"><a id="ch36exe3"/><strong>36-3.</strong>&#160;&#160;&#160;Write programs to determine what happens if a process&#8217;s consumption of various resources already exceeds the soft limit specified in a call to <em>setrlimit()</em>.<span epub:type="pagebreak" id="page_766"/></p>
</body>
</html>
