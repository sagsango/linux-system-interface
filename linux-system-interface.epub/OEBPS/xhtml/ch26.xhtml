<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch26"><span epub:type="pagebreak" id="page_541"/><strong><span class="big">26</span></strong><br/><strong>MONITORING CHILD PROCESSES</strong></h2>
<p class="noindenta">In many application designs, a parent process needs to know when one of its child processes changes state&#8212;when the child terminates or is stopped by a signal. This chapter describes two techniques used to monitor child processes: the <em>wait()</em> system call (and its variants) and the use of the <span class="literal">SIGCHLD</span> signal.</p>
<h3 class="h3" id="ch26lev1sec01"><strong>26.1 Waiting on a Child Process</strong></h3>
<p class="noindenta">In many applications where a parent creates child processes, it is useful for the parent to be able to monitor the children to find out when and how they terminate. This facility is provided by <em>wait()</em> and a number of related system calls.</p>
<h4 class="h4" id="ch26lev2sec01"><strong>26.1.1 The <em>wait()</em> System Call</strong></h4>
<p class="noindenta">The <em>wait()</em> system call waits for one of the children of the calling process to terminate and returns the termination status of that child in the buffer pointed to by <em>status</em>.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_542"/>#include &lt;sys/wait.h&gt;<br/><br/>pid_t <span class="codestrong">wait</span>(int *<span class="font1">status</span>);</p>
<p class="right">Returns process ID of terminated child, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>wait()</em> system call does the following:</p>
<ol>
<li class="order"><p class="orderp">If no (previously unwaited-for) child of the calling process has yet terminated, the call blocks until one of the children terminates. If a child has already terminated by the time of the call, <em>wait()</em> returns immediately.</p></li>
<li class="order"><p class="orderp">If <em>status</em> is not <span class="literal">NULL</span>, information about how the child terminated is returned in the integer to which <em>status</em> points. We describe the information returned in <em>status</em> in <a href="ch26.xhtml#ch26lev2sec03">Section 26.1.3</a>.</p></li>
<li class="order"><p class="orderp">The kernel adds the process CPU times (<a href="ch10.xhtml#ch10lev1sec07">Section 10.7</a>) and resource usage statistics (<a href="ch36.xhtml#ch36lev1sec01">Section 36.1</a>) to running totals for all children of this parent process.</p></li>
<li class="order"><p class="orderp">As its function result, <em>wait()</em> returns the process ID of the child that has terminated.</p></li>
</ol>
<p class="noindent">On error, <em>wait()</em> returns &#8211;1. One possible error is that the calling process has no (previously unwaited-for) children, which is indicated by the <em>errno</em> value <span class="literal">ECHILD</span>. This means that we can use the following loop to wait for all children of the calling process to terminate:</p>
<p class="programs">while ((childPid = wait(NULL)) != -1)<br/>&#160;&#160;&#160;&#160;continue;<br/>if (errno != ECHILD)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* An unexpected error... */<br/>&#160;&#160;&#160;&#160;errExit("wait");</p>
<p class="noindent"><a href="ch26.xhtml#ch26ex1">Listing 26-1</a> demonstrates the use of <em>wait()</em>. This program creates multiple child processes, one per (integer) command-line argument. Each child sleeps for the number of seconds specified in the corresponding command-line argument and then exits. In the meantime, after all children have been created, the parent process repeatedly calls <em>wait()</em> to monitor the termination of its children. This loop continues until <em>wait()</em> returns &#8211;1. (This is not the only approach: we could alternatively exit the loop when the number of terminated children, <em>numDead</em>, matches the number of children created.) The following shell session log shows what happens when we use the program to create three children:</p>
<p class="programs">$ <span class="codestrong">./multi_wait 7 1 4</span><br/>[13:41:00] child 1 started with PID 21835, sleeping 7 seconds<br/>[13:41:00] child 2 started with PID 21836, sleeping 1 seconds<br/>[13:41:00] child 3 started with PID 21837, sleeping 4 seconds<br/>[13:41:01] wait() returned child PID 21836 (numDead=1)<br/>[13:41:04] wait() returned child PID 21837 (numDead=2)<br/>[13:41:07] wait() returned child PID 21835 (numDead=3)<br/>No more children - bye!</p>
<div class="block">
<p class="noindent">If there are multiple terminated children at a particular moment, SUSv3 leaves unspecified the order in which these children will be reaped by a sequence of <em>wait()</em> calls; that is, the order depends on the implementation. Even across versions of the Linux kernel, the behavior varies.</p>
</div>
<p class="examplet"><span epub:type="pagebreak" id="page_543"/><a id="ch26ex1"/><strong>Listing 26-1:</strong> Creating and waiting for multiple children</p>
<p class="programsli">_____________________________________________________ <span class="codestrong">procexec/multi_wait.c</span><br/><br/>#include &lt;sys/wait.h&gt;<br/>#include &lt;time.h&gt;<br/>#include "curr_time.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declaration of currTime() */<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int numDead;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of children so far waited for */<br/>&#160;&#160;&#160;&#160;pid_t childPid;&#160;&#160;&#160;&#160;/* PID of waited for child */<br/>&#160;&#160;&#160;&#160;int j;<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s sleep-time...\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;setbuf(stdout, NULL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Disable buffering of stdout */<br/><br/>&#160;&#160;&#160;&#160;for (j = 1; j &lt; argc; j++) {&#160;&#160;&#160;&#160;/* Create one child for each argument */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (fork()) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case -1:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child sleeps for a while then exits */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("[%s] child %d started with PID %ld, sleeping %s "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"seconds\n", currTime("%T"), j, (long) getpid(), argv[j]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep(getInt(argv[j], GN_NONNEG, "sleep-time"));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_exit(EXIT_SUCCESS);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent just continues around loop */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;numDead = 0;<br/>&#160;&#160;&#160;&#160;for (;;) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent waits for each child to exit */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;childPid = wait(NULL);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (childPid == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno == ECHILD) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("No more children - bye!\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Some other (unexpected) error */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("wait");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numDead++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("[%s] wait() returned child PID %ld (numDead=%d)\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;currTime("%T"), (long) childPid, numDead);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>_____________________________________________________ <span class="codestrong">procexec/multi_wait.c</span></p>
<h4 class="h4" id="ch26lev2sec02"><span epub:type="pagebreak" id="page_544"/><strong>26.1.2 The <em>waitpid()</em> System Call</strong></h4>
<p class="noindentab">The <em>wait()</em> system call has a number of limitations, which <em>waitpid()</em> was designed to address:</p>
<p class="bull">&#8226; If a parent process has created multiple children, it is not possible to <em>wait()</em> for the completion of a specific child; we can only wait for the next child that terminates.</p>
<p class="bull">&#8226; If no child has yet terminated, <em>wait()</em> always blocks. Sometimes, it would be preferable to perform a nonblocking wait so that if no child has yet terminated, we obtain an immediate indication of this fact.</p>
<p class="bull">&#8226; Using <em>wait()</em>, we can find out only about children that have terminated. It is not possible to be notified when a child is stopped by a signal (such as <span class="literal">SIGSTOP</span> or <span class="literal">SIGTTIN</span>) or when a stopped child is resumed by delivery of a <span class="literal">SIGCONT</span> signal.</p>
<div class="box">
<p class="programsa">#include &lt;sys/wait.h&gt;<br/><br/>pid_t <span class="codestrong">waitpid</span>(pid_t <span class="font1">pid</span>, int *<span class="font1">status</span>, int <span class="font1">options</span>);</p>
<p class="right">Returns process ID of child, 0 (see text), or &#8211;1 on error</p>
</div>
<p class="noindentb">The return value and <em>status</em> arguments of <em>waitpid()</em> are the same as for <em>wait()</em>. (See <a href="ch26.xhtml#ch26lev2sec03">Section 26.1.3</a> for an explanation of the value returned in <em>status</em>.) The <em>pid</em> argument enables the selection of the child to be waited for, as follows:</p>
<p class="bull">&#8226; If <em>pid</em> is greater than 0, wait for the child whose <em>process ID</em> equals <em>pid</em>.</p>
<p class="bull">&#8226; If <em>pid</em> equals 0, wait for any child in the <em>same process group as the caller</em> (parent). We describe process groups in <a href="ch34.xhtml#ch34lev1sec02">Section 34.2</a>.</p>
<p class="bull">&#8226; If <em>pid</em> is less than &#8211;1, wait for any child whose <em>process group</em> identifier equals the absolute value of <em>pid</em>.</p>
<p class="bull">&#8226; If <em>pid</em> equals &#8211;1, wait for <em>any</em> child. The call <em>wait(&#38;status)</em> is equivalent to the call <em>waitpid(&#8211;1, &#38;status, 0)</em>.</p>
<p class="noindenttb">The <em>options</em> argument is a bit mask that can include (OR) zero or more of the following flags (all of which are specified in SUSv3):</p>
<p class="term"><span class="literal">WUNTRACED</span></p>
<p class="termlist">In addition to returning information about terminated children, also return information when a child is <em>stopped</em> by a signal.</p>
<p class="term"><span class="literal">WCONTINUED</span> (since Linux 2.6.10)</p>
<p class="termlist">Also return status information about stopped children that have been resumed by delivery of a <span class="literal">SIGCONT</span> signal.</p>
<p class="term"><span class="literal">WNOHANG</span></p>
<p class="termlist">If no child specified by <em>pid</em> has yet changed state, then return immediately, instead of blocking (i.e., perform a &#8220;poll&#8221;). In this case, the return value of <em>waitpid()</em> is 0. If the calling process has no children that match the specification in <em>pid</em>, <em>waitpid()</em> fails with the error <span class="literal">ECHILD</span>.</p>
<p class="noindentt">We demonstrate the use of <em>waitpid()</em> in <a href="ch26.xhtml#ch26ex3">Listing 26-3</a>.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_545"/>In its rationale for <em>waitpid()</em>, SUSv3 notes that the name <span class="literal">WUNTRACED</span> is a historical artifact of this flag&#8217;s origin in BSD, where a process could be stopped in one of two ways: as a consequence of being traced by the <em>ptrace()</em> system call, or by being stopped by a signal (i.e., not being traced). When a child is being traced by <em>ptrace()</em>, then delivery of <em>any</em> signal (other than <span class="literal">SIGKILL</span>) causes the child to be stopped, and a <span class="literal">SIGCHLD</span> signal is consequently sent to the parent. This behavior occurs even if the child is ignoring the signal. However, if the child is blocking the signal, then it is not stopped (unless the signal is <span class="literal">SIGSTOP</span>, which can&#8217;t be blocked).</p>
</div>
<h4 class="h4" id="ch26lev2sec03"><strong>26.1.3 The Wait Status Value</strong></h4>
<p class="noindentab">The <em>status</em> value returned by <em>wait()</em> and <em>waitpid()</em> allows us to distinguish the following events for the child:</p>
<p class="bull">&#8226; The child terminated by calling <em>_exit()</em> (or <em>exit()</em>), specifying an integer <em>exit status</em>.</p>
<p class="bull">&#8226; The child was terminated by the delivery of an unhandled signal.</p>
<p class="bull">&#8226; The child was stopped by a signal, and <em>waitpid()</em> was called with the <span class="literal">WUNTRACED</span> flag.</p>
<p class="bull">&#8226; The child was resumed by a <span class="literal">SIGCONT</span> signal, and <em>waitpid()</em> was called with the <span class="literal">WCONTINUED</span> flag.</p>
<p class="noindentt">We use the term <em>wait status</em> to encompass all of the above cases. The designation <em>termination status</em> is used to refer to the first two cases. (In the shell, we can obtain the termination status of the last command executed by examining the contents of the variable <em>$?</em>.)</p>
<p class="indent">Although defined as an <em>int</em>, only the bottom 2 bytes of the value pointed to by <em>status</em> are actually used. The way in which these 2 bytes are filled depends on which of the above events occurred for the child, as depicted in <a href="ch26.xhtml#ch26fig1">Figure 26-1</a>.</p>
<div class="block">
<p class="noindent"><a href="ch26.xhtml#ch26fig1">Figure 26-1</a> shows the layout of the wait status value for Linux/x86-32. The details vary across implementations. SUSv3 doesn&#8217;t specify any particular layout for this information, or even require that it is contained in the bottom 2 bytes of the value pointed to by <em>status</em>. Portable applications should always use the macros described in this section to inspect this value, rather than directly inspecting its bit-mask components.</p>
</div>
<div class="image"><img src="../images/f26-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch26fig1"/><strong>Figure 26-1:</strong> Value returned in the <em>status</em> argument of <em>wait()</em> and <em>waitpid()</em></p>
<p class="noindentb"><span epub:type="pagebreak" id="page_546"/>The <span class="literal">&lt;sys/wait.h&gt;</span> header file defines a standard set of macros that can be used to dissect a wait status value. When applied to a <em>status</em> value returned by <em>wait()</em> or <em>waitpid()</em>, only one of the macros in the list below will return true. Additional macros are provided to further dissect the <em>status</em> value, as noted in the list.</p>
<p class="term"><span class="literal">WIFEXITED(status)</span></p>
<p class="termlist">This macro returns true if the child process exited normally. In this case, the macro <span class="literal">WEXITSTATUS(status)</span> returns the exit status of the child process. (As noted in <a href="ch25.xhtml#ch25lev1sec01">Section 25.1</a>, only the least significant byte of the child&#8217;s exit status is available to the parent.)</p>
<p class="term"><span class="literal">WIFSIGNALED(status)</span></p>
<p class="termlist">This macro returns true if the child process was killed by a signal. In this case, the macro <span class="literal">WTERMSIG(status)</span> returns the number of the signal that caused the process to terminate, and the macro <span class="literal">WCOREDUMP(status)</span> returns true if the child process produced a core dump file. The <span class="literal">WCOREDUMP()</span> macro is not specified by SUSv3, but is available on most UNIX implementations.</p>
<p class="term"><span class="literal">WIFSTOPPED(status)</span></p>
<p class="termlist">This macro returns true if the child process was stopped by a signal. In this case, the macro <span class="literal">WSTOPSIG(status)</span> returns the number of the signal that stopped the process.</p>
<p class="term"><span class="literal">WIFCONTINUED(status)</span></p>
<p class="termlist">This macro returns true if the child was resumed by delivery of <span class="literal">SIGCONT</span>. This macro is available since Linux 2.6.10.</p>
<p class="noindentt">Note that although the name <em>status</em> is also used for the argument of the above macros, they expect a plain integer, rather than a pointer to an integer as required by <em>wait()</em> and <em>waitpid()</em>.</p>
<h5 class="h5" id="ch26lev3sec01"><strong>Example program</strong></h5>
<p class="noindenta">The <em>printWaitStatus()</em> function of <a href="ch26.xhtml#ch26ex2">Listing 26-2</a> uses all of the macros described above. This function dissects and prints the contents of a wait status value.</p>
<p class="examplet"><a id="ch26ex2"/><strong>Listing 26-2:</strong> Displaying the status value returned by <em>wait()</em> and related calls</p>
<p class="programsli">_______________________________________________ <span class="codestrong">procexec/print_wait_status.c</span><br/><br/>#define _GNU_SOURCE&#160;&#160;&#160;&#160;&#160;/* Get strsignal() declaration from &lt;string.h&gt; */<br/>#include &lt;string.h&gt;<br/>#include &lt;sys/wait.h&gt;<br/>#include "print_wait_status.h" /* Declaration of printWaitStatus() */<br/>#include "tlpi_hdr.h"<br/><br/>/* NOTE: The following function employs printf(), which is not<br/>&#160;&#160;&#160;async-signal-safe (see <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>). As such, this function is<br/>&#160;&#160;&#160;also not async-signal-safe (i.e., beware of calling it from a<br/>&#160;&#160;&#160;SIGCHLD handler). */<br/><br/>void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Examine a wait() status using the W* macros */<br/>printWaitStatus(const char *msg, int status)<br/>{<br/>&#160;&#160;&#160;&#160;if (msg != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s", msg);<br/><br/>&#160;&#160;&#160;&#160;if (WIFEXITED(status)) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("child exited, status=%d\n", WEXITSTATUS(status));<br/><br/>&#160;&#160;&#160;&#160;} else if (WIFSIGNALED(status)) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("child killed by signal %d (%s)",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;WTERMSIG(status), strsignal(WTERMSIG(status)));<br/>#ifdef WCOREDUMP&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Not in SUSv3, may be absent on some systems */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (WCOREDUMP(status))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf(" (core dumped)");<br/>#endif<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("\n");<br/><br/>&#160;&#160;&#160;&#160;} else if (WIFSTOPPED(status)) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("child stopped by signal %d (%s)\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;WSTOPSIG(status), strsignal(WSTOPSIG(status)));<br/><br/>#ifdef WIFCONTINUED&#160;&#160;&#160;&#160;&#160;/* SUSv3 has this, but older Linux versions and<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;some other UNIX implementations don't */<br/>&#160;&#160;&#160;&#160;} else if (WIFCONTINUED(status)) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("child continued\n");<br/>#endif<br/><br/>&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Should never happen */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("what happened to this child? (status=%x)\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(unsigned int) status);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>_______________________________________________ <span class="codestrong">procexec/print_wait_status.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_547"/>The <em>printWaitStatus()</em> function is used in <a href="ch26.xhtml#ch26ex3">Listing 26-3</a>. This program creates a child process that either loops continuously calling <em>pause()</em> (during which time signals can be sent to the child) or, if an integer command-line argument was supplied, exits immediately using this integer as the exit status. In the meantime, the parent monitors the child via <em>waitpid()</em>, printing the returned status value and passing this value to <em>printWaitStatus()</em>. The parent exits when it detects that the child has either exited normally or been terminated by a signal.</p>
<p class="indent">The following shell session shows a few example runs of the program in <a href="ch26.xhtml#ch26ex3">Listing 26-3</a>. We begin by creating a child that immediately exits with a status of 23:</p>
<p class="programs">$ <span class="codestrong">./child_status 23</span><br/>Child started with PID = 15807<br/>waitpid() returned: PID=15807; status=0x1700 (23,0)<br/>child exited, status=23</p>
<p class="noindent">In the next run, we start the program in the background, and then send <span class="literal">SIGSTOP</span> and <span class="literal">SIGCONT</span> signals to the child:</p>
<p class="programs">$ <span class="codestrong">./child_status &#38;</span><br/>[1] 15870<br/>$ Child started with PID = 15871<br/><span class="codestrong">kill -STOP 15871</span><br/>$ waitpid() returned: PID=15871; status=0x137f (19,127)<br/>child stopped by signal 19 (Stopped (signal))<br/><span class="codestrong">kill -CONT 15871</span><br/>$ waitpid() returned: PID=15871; status=0xffff (255,255)<br/>child continued</p>
<p class="noindent"><span epub:type="pagebreak" id="page_548"/>The last two lines of output will appear only on Linux 2.6.10 and later, since earlier kernels don&#8217;t support the <em>waitpid()</em> <span class="literal">WCONTINUED</span> option. (This shell session is made slightly hard to read by the fact that output from the program executing in the background is in some cases intermingled with the prompt produced by the shell.)</p>
<p class="indent">We continue the shell session by sending a <span class="literal">SIGABRT</span> signal to terminate the child:</p>
<p class="programs"><span class="codestrong">kill -ABRT 15871</span><br/>$ waitpid() returned: PID=15871; status=0x0006 (0,6)<br/>child killed by signal 6 (Aborted)<br/><span class="font1">Press Enter, in order to see shell notification that background job has terminated</span><br/>[1]+&#160;&#160;Done&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;./child_status<br/>$ <span class="codestrong">ls -l core</span><br/>ls: core: No such file or directory<br/>$ <span class="codestrong">ulimit -c</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Display</span> RLIMIT_CORE <span class="font1">limit</span><br/>0</p>
<p class="noindent">Although the default action of <span class="literal">SIGABRT</span> is to produce a core dump file and terminate the process, no core file was produced. This is because core dumps were disabled&#8212;the <span class="literal">RLIMIT_CORE</span> soft resource limit (<a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a>), which specifies the maximum size of a core file, was set to 0, as shown by the <em>ulimit</em> command above.</p>
<p class="indent">We repeat the same experiment, but this time enabling core dumps before sending <span class="literal">SIGABRT</span> to the child:</p>
<p class="programs">$ <span class="codestrong">ulimit -c unlimited</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Allow core dumps</span><br/>$ <span class="codestrong">./child_status &#38;</span><br/>[1] 15902<br/>$ Child started with PID = 15903<br/><span class="codestrong">kill -ABRT 15903</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Send</span> SIGABRT <span class="font1">to child</span><br/>$ waitpid() returned: PID=15903; status=0x0086 (0,134)<br/>child killed by signal 6 (Aborted) (core dumped)<br/><span class="font1">Press Enter, in order to see shell notification that background job has terminated</span><br/>[1]+&#160;&#160;Done&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;./child_status<br/>$ <span class="codestrong">ls -l core</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">This time we get a core dump</span><br/>-rw-------&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;&#160;&#160;65536 May&#160;&#160;6 21:01 core</p>
<p class="examplet"><a id="ch26ex3"/><strong>Listing 26-3:</strong> Using <em>waitpid()</em> to retrieve the status of a child process</p>
<p class="programsli">___________________________________________________ <span class="codestrong">procexec/child_status.c</span><br/><br/>#include &lt;sys/wait.h&gt;<br/>#include "print_wait_status.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declares printWaitStatus() */<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int status;<br/>&#160;&#160;&#160;&#160;pid_t childPid;<br/><br/>&#160;&#160;&#160;&#160;if (argc &gt; 1 &#38;&#38; strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s [exit-status]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;switch (fork()) {<br/>&#160;&#160;&#160;&#160;case -1: errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;case 0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child: either exits immediately with given<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;status or loops waiting for signals */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Child started with PID = %ld\n", (long) getpid());<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc &gt; 1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Status supplied on command line? */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(getInt(argv[1], 0, "exit-status"));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Otherwise, wait for signals */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (;;)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pause();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Not reached, but good practice */<br/><br/>&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent: repeatedly wait on child until it<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;either exits or is terminated by a signal */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (;;) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;childPid = waitpid(-1, &#38;status, WUNTRACED<br/>#ifdef WCONTINUED&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Not present on older versions of Linux */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| WCONTINUED<br/>#endif<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (childPid == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("waitpid");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Print status in hex, and as separate decimal bytes */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("waitpid() returned: PID=%ld; status=0x%04x (%d,%d)\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) childPid,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(unsigned int) status, status &gt;&gt; 8, status &#38; 0xff);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printWaitStatus(NULL, status);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (WIFEXITED(status) || WIFSIGNALED(status))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>___________________________________________________ <span class="codestrong">procexec/child_status.c</span></p>
<h4 class="h4" id="ch26lev2sec04"><span epub:type="pagebreak" id="page_549"/><strong>26.1.4 Process Termination from a Signal Handler</strong></h4>
<p class="noindenta">As shown in <a href="ch20.xhtml#ch20table1">Table 20-1</a> (on <a href="ch20.xhtml#page_396">page 396</a>), some signals terminate a process by default. In some circumstances, we may wish to have certain cleanup steps performed before a process terminates. For this purpose, we can arrange to have a handler catch such signals, perform the cleanup steps, and then terminate the process. If we do this, we should bear in mind that the termination status of a process is available to its parent via <em>wait()</em> or <em>waitpid()</em>. For example, calling <em>_exit(EXIT_SUCCESS)</em> from the signal handler will make it appear to the parent process that the child terminated successfully.</p>
<p class="indent">If the child needs to inform the parent that it terminated because of a signal, then the child&#8217;s signal handler should first disestablish itself, and then raise the <span epub:type="pagebreak" id="page_550"/>same signal once more, which this time will terminate the process. The signal handler would contain code such as the following:</p>
<p class="programs">void<br/>handler(int sig)<br/>{<br/>&#160;&#160;&#160;&#160;/* Perform cleanup steps */<br/><br/>&#160;&#160;&#160;&#160;signal(sig, SIG_DFL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Disestablish handler */<br/>&#160;&#160;&#160;&#160;raise(sig);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Raise signal again */<br/>}</p>
<h4 class="h4" id="ch26lev2sec05"><strong>26.1.5 The <em>waitid()</em> System Call</strong></h4>
<p class="noindenta">Like <em>waitpid()</em>, <em>waitid()</em> returns the status of child processes. However, <em>waitid()</em> provides extra functionality that is unavailable with <em>waitpid()</em>. This system call derives from System V, but is now specified in SUSv3. It was added to Linux in kernel 2.6.9.</p>
<div class="block">
<p class="noindent">Before Linux 2.6.9, a version of <em>waitid()</em> was provided via an implementation in <em>glibc</em>. However, because a full implementation of this interface requires kernel support, the <em>glibc</em> implementation provided no more functionality than was available using <em>waitpid()</em>.</p>
</div>
<div class="box">
<p class="programsa">#include &lt;sys/wait.h&gt;<br/><br/>int <span class="codestrong">waitid</span>(idtype_t <span class="font1">idtype</span>, id_t <span class="font1">id</span>, siginfo_t *<span class="font1">infop</span>, int <span class="font1">options</span>);</p>
<p class="right">Returns 0 on success or if <span class="literal">WNOHANG</span> was specified and there were no children to wait for, or &#8211;1 on error</p>
</div>
<p class="noindentb">The <em>idtype</em> and <em>id</em> arguments specify which child(ren) to wait for, as follows:</p>
<p class="bull">&#8226; If <em>idtype</em> is <span class="literal">P_ALL</span>, wait for any child; <em>id</em> is ignored.</p>
<p class="bull">&#8226; If <em>idtype</em> is <span class="literal">P_PID</span>, wait for the child whose process ID equals <em>id</em>.</p>
<p class="bull">&#8226; If <em>idtype</em> is <span class="literal">P_PGID</span>, wait for any child whose process group ID equals <em>id</em>.</p>
<div class="block">
<p class="noindent">Note that unlike <em>waitpid()</em>, it is not possible to specify 0 in <em>id</em> to mean any process in the same process group as the caller. Instead, we must explicitly specify the caller&#8217;s process group ID using the value returned by <em>getpgrp()</em>.</p>
</div>
<p class="noindentb">The most significant difference between <em>waitpid()</em> and <em>waitid()</em> is that <em>waitid()</em> provides more precise control of the child events that should be waited for. We control this by ORing one or more of the following flags in <em>options</em>:</p>
<p class="term"><span class="literal">WEXITED</span></p>
<p class="termlist">Wait for children that have terminated, either normally or abnormally.</p>
<p class="term"><span class="literal">WSTOPPED</span></p>
<p class="termlist">Wait for children that have been stopped by a signal.</p>
<p class="term"><span class="literal">WCONTINUED</span></p>
<p class="termlist">Wait for children that have been resumed by a <span class="literal">SIGCONT</span> signal.</p>
<p class="noindenttb"><span epub:type="pagebreak" id="page_551"/>The following additional flags may be ORed in <em>options</em>:</p>
<p class="term"><span class="literal">WNOHANG</span></p>
<p class="termlist">This flag has the same meaning as for <em>waitpid()</em>. If none of the children matching the specification in <em>id</em> has status information to return, then return immediately (a poll). In this case, the return value of <em>waitid()</em> is 0. If the calling process has no children that match the specification in <em>id</em>, <em>waitid()</em> instead fails with the error <span class="literal">ECHILD</span>.</p>
<p class="term"><span class="literal">WNOWAIT</span></p>
<p class="termlist">Normally, once a child has been waited for using <em>waitid()</em>, then that &#8220;status event&#8221; is consumed. However, if <span class="literal">WNOWAIT</span> is specified, then the child status is returned, but the child remains in a waitable state, and we can later wait for it again to retrieve the same information.</p>
<p class="noindenttb">On success, <em>waitid()</em> returns 0, and the <em>siginfo_t</em> structure (<a href="ch21.xhtml#ch21lev1sec04">Section 21.4</a>) pointed to by <em>infop</em> is updated to contain information about the child. The following fields are filled in the <em>siginfo_t</em> structure:</p>
<p class="term"><em>si_code</em></p>
<p class="termlist">This field contains one of the following values: <span class="literal">CLD_EXITED</span>, indicating that the child terminated by calling <em>_exit()</em>; <span class="literal">CLD_KILLED</span>, indicating that the child was killed by a signal; <span class="literal">CLD_STOPPED</span>, indicating that the child was stopped by a signal; or <span class="literal">CLD_CONTINUED</span>, indicating that the (previously stopped) child resumed execution as a consequence of receiving a (<span class="literal">SIGCONT</span>) signal.</p>
<p class="term"><em>si_pid</em></p>
<p class="termlist">This field contains the process ID of the child whose state has changed.</p>
<p class="term"><em>si_signo</em></p>
<p class="termlist">This field is always set to <span class="literal">SIGCHLD</span>.</p>
<p class="term"><em>si_status</em></p>
<p class="termlist">This field contains either the exit status of the child, as passed to <em>_exit()</em>, or the signal that caused the child to stop, continue, or terminate. We can determine which type of information is in this field by examining the <em>si_code</em> field.</p>
<p class="term"><em>si_uid</em></p>
<p class="termlist">This field contains the real user ID of the child. Most other UNIX implementations don&#8217;t set this field.</p>
<div class="block">
<p class="noindent">On Solaris, two additional fields are filled in: <em>si_stime</em> and <em>si_utime</em>. These contain the system and user CPU time used by the child, respectively. SUSv3 doesn&#8217;t require these fields to be set by <em>waitid()</em>.</p>
</div>
<p class="noindent">One detail of the operation of <em>waitid()</em> needs further clarification. If <span class="literal">WNOHANG</span> is specified in <em>options</em>, then a 0 return value from <em>waitid()</em> can mean one of two things: a child had already changed state at the time of the call (and information about the child is returned in the <em>siginfo_t</em> structure pointed to by <em>infop</em>), or there was no child whose state has changed. For the case where no child has changed state, some UNIX implementations (including Linux), zero out the returned <em>siginfo_t</em> structure. This provides a method of distinguishing the two possibilities: we can check whether the <span epub:type="pagebreak" id="page_552"/>value in <em>si_pid</em> is 0 or nonzero. Unfortunately, this behavior is not required by SUSv3, and some UNIX implementations leave the <em>siginfo_t</em> structure unchanged in this case. (A future corrigendum to SUSv4 is likely to add a requirement that <em>si_pid</em> and <em>si_signo</em> are zeroed in this case.) The only portable way to distinguish these two cases is to zero out the <em>siginfo_t</em> structure before calling <em>waitid()</em>, as in the following code:</p>
<p class="programs">siginfo_t info;<br/>...<br/>memset(&#38;info, 0, sizeof(siginfo_t));<br/>if (waitid(idtype, id, &#38;info, options | WNOHANG) == -1)<br/>&#160;&#160;&#160;&#160;errExit("waitid");<br/>if (info.si_pid == 0) {<br/>&#160;&#160;&#160;&#160;/* No children changed state */<br/>} else {<br/>&#160;&#160;&#160;&#160;/* A child changed state; details are provided in 'info' */<br/>}</p>
<h4 class="h4" id="ch26lev2sec06"><strong>26.1.6 The <em>wait3()</em> and <em>wait4()</em> System Calls</strong></h4>
<p class="noindenta">The <em>wait3()</em> and <em>wait4()</em> system calls perform a similar task to <em>waitpid()</em>. The principal semantic difference is that <em>wait3()</em> and <em>wait4()</em> return <em>resource usage</em> information about the terminated child in the structure pointed to by the <em>rusage</em> argument. This information includes the amount of CPU time used by the process and memory-management statistics. We defer detailed discussion of the <em>rusage</em> structure until <a href="ch36.xhtml#ch36lev1sec01">Section 36.1</a>, where we describe the <em>getrusage()</em> system call.</p>
<div class="box">
<p class="programsa">#define _BSD_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Or #define _XOPEN_SOURCE 500 for wait3() */<br/>#include &lt;sys/resource.h&gt;<br/>#include &lt;sys/wait.h&gt;<br/><br/>pid_t <span class="codestrong">wait3</span>(int *<span class="font1">status</span>, int <span class="font1">options</span>, struct rusage *<span class="font1">rusage</span>);<br/>pid_t <span class="codestrong">wait4</span>(pid_t <span class="font1">pid</span>, int *<span class="font1">status</span>, int <span class="font1">options</span>, struct rusage *<span class="font1">rusage</span>);</p>
<p class="right">Both return process ID of child, or &#8211;1 on error</p>
</div>
<p class="noindent">Excluding the use of the <em>rusage</em> argument, a call to <em>wait3()</em> is equivalent to the following <em>waitpid()</em> call:</p>
<p class="programs">waitpid(-1, &#38;status, options);</p>
<p class="noindent">Similarly, <em>wait4()</em> is equivalent to the following:</p>
<p class="programs">waitpid(pid, &#38;status, options);</p>
<p class="noindent">In other words, <em>wait3()</em> waits for any child, while <em>wait4()</em> can be used to select a specific child or children upon which to wait.</p>
<p class="indent">On some UNIX implementations, <em>wait3()</em> and <em>wait4()</em> return resource usage information only for terminated children. On Linux, resource usage information can also be retrieved for stopped children if the <span class="literal">WUNTRACED</span> flag is specified in <em>options</em>.</p>
<p class="indent">The names for these two system calls refer to the number of arguments they each take. Both system calls originated in BSD, but are now available on most <span epub:type="pagebreak" id="page_553"/>UNIX implementations. Neither is standardized in SUSv3. (SUSv2 did specify <em>wait3()</em>, but marked it LEGACY.)</p>
<p class="indent">We usually avoid the use of <em>wait3()</em> and <em>wait4()</em> in this book. Typically, we don&#8217;t need the extra information returned by these calls. Also, lack of standardization limits their portability.</p>
<h3 class="h3" id="ch26lev1sec02"><strong>26.2 Orphans and Zombies</strong></h3>
<p class="noindentab">The lifetimes of parent and child processes are usually not the same&#8212;either the parent outlives the child or vice versa. This raises two questions:</p>
<p class="bull">&#8226; Who becomes the parent of an <em>orphaned</em> child? The orphaned child is adopted by <em>init</em>, the ancestor of all processes, whose process ID is 1. In other words, after a child&#8217;s parent terminates, a call to <em>getppid()</em> will return the value 1. This can be used as a way of determining if a child&#8217;s true parent is still alive (this assumes a child that was created by a process other than <em>init</em>).</p>
<div class="block">
<p class="noindent">Using the <span class="literal">PR_SET_PDEATHSIG</span> operation of the Linux-specific <em>prctl()</em> system call, it is possible to arrange that a process receives a specified signal when it becomes an orphan.</p>
</div>
<p class="bull">&#8226; What happens to a child that terminates before its parent has had a chance to perform a <em>wait()</em>? The point here is that, although the child has finished its work, the parent should still be permitted to perform a <em>wait()</em> at some later time to determine how the child terminated. The kernel deals with this situation by turning the child into a <em>zombie</em>. This means that most of the resources held by the child are released back to the system to be reused by other processes. The only part of the process that remains is an entry in the kernel&#8217;s process table recording (among other things) the child&#8217;s process ID, termination status, and resource usage statistics (<a href="ch36.xhtml#ch36lev1sec01">Section 36.1</a>).</p>
<p class="noindentt">Regarding zombies, UNIX systems imitate the movies&#8212;a zombie process can&#8217;t be killed by a signal, not even the (silver bullet) <span class="literal">SIGKILL</span>. This ensures that the parent can always eventually perform a <em>wait()</em>.</p>
<p class="indent">When the parent does perform a <em>wait()</em>, the kernel removes the zombie, since the last remaining information about the child is no longer required. On the other hand, if the parent terminates without doing a <em>wait()</em>, then the <em>init</em> process adopts the child and automatically performs a <em>wait()</em>, thus removing the zombie process from the system.</p>
<p class="indent">If a parent creates a child, but fails to perform a <em>wait()</em>, then an entry for the zombie child will be maintained indefinitely in the kernel&#8217;s process table. If a large number of such zombie children are created, they will eventually fill the kernel process table, preventing the creation of new processes. Since the zombies can&#8217;t be killed by a signal, the only way to remove them from the system is to kill their parent (or wait for it to exit), at which time the zombies are adopted and waited on by <em>init</em>, and consequently removed from the system.</p>
<p class="indent">These semantics have important implications for the design of long-lived parent processes, such as network servers and shells, that create numerous children. To put things another way, in such applications, a parent process should perform <span epub:type="pagebreak" id="page_554"/><em>wait()</em> calls in order to ensure that dead children are always removed from the system, rather than becoming long-lived zombies. The parent may perform such <em>wait()</em> calls either synchronously, or asynchronously, in response to delivery of the <span class="literal">SIGCHLD</span> signal, as described in <a href="ch26.xhtml#ch26lev2sec07">Section 26.3.1</a>.</p>
<p class="indent"><a href="ch26.xhtml#ch26ex4">Listing 26-4</a> demonstrates the creation of a zombie and that a zombie can&#8217;t be killed by <span class="literal">SIGKILL</span>. When we run this program, we see the following output:</p>
<p class="programs">$ <span class="codestrong">./make_zombie</span><br/>Parent PID=1013<br/>Child (PID=1014) exiting<br/>&#160;1013 pts/4&#160;&#160;&#160;&#160;00:00:00 make_zombie&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Output from ps(1)</span><br/>&#160;1014 pts/4&#160;&#160;&#160;&#160;00:00:00 make_zombie &lt;defunct&gt;<br/>After sending SIGKILL to make_zombie (PID=1014):<br/>&#160;1013 pts/4&#160;&#160;&#160;&#160;00:00:00 make_zombie&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Output from ps(1)</span><br/>&#160;1014 pts/4&#160;&#160;&#160;&#160;00:00:00 make_zombie &lt;defunct&gt;</p>
<p class="noindent">In the above output, we see that <em>ps(1)</em> displays the string <span class="literal">&lt;defunct&gt;</span> to indicate a process in the zombie state.</p>
<div class="block">
<p class="noindent">The program in <a href="ch26.xhtml#ch26ex4">Listing 26-4</a> uses the <em>system()</em> function to execute the shell command given in its character-string argument. We describe <em>system()</em> in detail in <a href="ch27.xhtml#ch27lev1sec06">Section 27.6</a>.</p>
</div>
<p class="examplet"><a id="ch26ex4"/><strong>Listing 26-4:</strong> Creating a zombie child process</p>
<p class="programsli">____________________________________________________ <span class="codestrong">procexec/make_zombie.c</span><br/><br/>#include &lt;signal.h&gt;<br/>#include &lt;libgen.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* For basename() declaration */<br/>#include "tlpi_hdr.h"<br/><br/>#define CMD_SIZE 200<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;char cmd[CMD_SIZE];<br/>&#160;&#160;&#160;&#160;pid_t childPid;<br/><br/>&#160;&#160;&#160;&#160;setbuf(stdout, NULL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Disable buffering of stdout */<br/><br/>&#160;&#160;&#160;&#160;printf("Parent PID=%ld\n", (long) getpid());<br/><br/>&#160;&#160;&#160;&#160;switch (childPid = fork()) {<br/>&#160;&#160;&#160;&#160;case -1:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;case 0:&#160;&#160;&#160;&#160;&#160;/* Child: immediately exits to become zombie */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Child (PID=%ld) exiting\n", (long) getpid());<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_exit(EXIT_SUCCESS);<br/><br/>&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;/* Parent */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep(3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Give child a chance to start and exit */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;snprintf(cmd, CMD_SIZE, "ps | grep %s", basename(argv[0]));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;system(cmd);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* View zombie child */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Now send the "sure kill" signal to the zombie */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (kill(childPid, SIGKILL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("kill");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep(3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Give child a chance to react to signal */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("After sending SIGKILL to zombie (PID=%ld):\n", (long) childPid);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;system(cmd);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* View zombie child again */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>____________________________________________________ <span class="codestrong">procexec/make_zombie.c</span></p>
<h3 class="h3" id="ch26lev1sec03"><span epub:type="pagebreak" id="page_555"/><strong>26.3 The</strong> <span class="literal"><span class="codestrong">SIGCHLD</span></span> <strong>Signal</strong></h3>
<p class="noindentab">The termination of a child process is an event that occurs asynchronously. A parent can&#8217;t predict when one of its children will terminate. (Even if the parent sends a <span class="literal">SIGKILL</span> signal to a child, the exact time of termination is still dependent on when the child is next scheduled for use of a CPU.) We have already seen that the parent should use <em>wait()</em> (or similar) in order to prevent the accumulation of zombie children, and have looked at two ways in which this can be done:</p>
<p class="bull">&#8226; The parent can call <em>wait()</em>, or <em>waitpid()</em> without specifying the <span class="literal">WNOHANG</span> flag, in which case the call will block if a child has not already terminated.</p>
<p class="bull">&#8226; The parent can periodically perform a nonblocking check (a poll) for dead children via a call to <em>waitpid()</em> specifying the <span class="literal">WNOHANG</span> flag.</p>
<p class="noindentt">Both of these approaches can be inconvenient. On the one hand, we may not want the parent to be blocked waiting for a child to terminate. On the other hand, making repeated nonblocking <em>waitpid()</em> calls wastes CPU time and adds complexity to an application design. To get around these problems, we can employ a handler for the <span class="literal">SIGCHLD</span> signal.</p>
<h4 class="h4" id="ch26lev2sec07"><strong>26.3.1 Establishing a Handler for</strong> <span class="literal"><span class="codestrong">SIGCHLD</span></span></h4>
<p class="noindenta">The <span class="literal">SIGCHLD</span> signal is sent to a parent process whenever one of its children terminates. By default, this signal is ignored, but we can catch it by installing a signal handler. Within the signal handler, we can use <em>wait()</em> (or similar) to reap the zombie child. However, there is a subtlety to consider in this approach.</p>
<p class="indent">In <a href="ch20.xhtml#ch20lev1sec10">Sections 20.10</a> and <a href="ch20.xhtml#ch20lev1sec12">20.12</a>, we observed that when a signal handler is called, the signal that caused its invocation is temporarily blocked (unless the <em>sigaction()</em> <span class="literal">SA_NODEFER</span> flag was specified), and also that standard signals, of which <span class="literal">SIGCHLD</span> is one, are not queued. Consequently, if a second and third child terminate in quick <span epub:type="pagebreak" id="page_556"/>succession while a <span class="literal">SIGCHLD</span> handler is executing for an already terminated child, then, although <span class="literal">SIGCHLD</span> is generated twice, it is queued only once to the parent. As a result, if the parent&#8217;s <span class="literal">SIGCHLD</span> handler called <em>wait()</em> only once each time it was invoked, the handler might fail to reap some zombie children.</p>
<p class="indent">The solution is to loop inside the <span class="literal">SIGCHLD</span> handler, repeatedly calling <em>waitpid()</em> with the <span class="literal">WNOHANG</span> flag until there are no more dead children to be reaped. Often, the body of a <span class="literal">SIGCHLD</span> handler simply consists of the following code, which reaps any dead children without checking their status:</p>
<p class="programs">while (waitpid(-1, NULL, WNOHANG) &gt; 0)<br/>&#160;&#160;&#160;&#160;continue;</p>
<p class="noindent">The above loop continues until <em>waitpid()</em> returns either 0, indicating no more zombie children, or &#8211;1, indicating an error (probably <span class="literal">ECHILD</span>, meaning that there are no more children).</p>
<h5 class="h5" id="ch26lev3sec02"><strong>Design issues for</strong> <span class="literal"><span class="codestrong">SIGCHLD</span></span> <strong>handlers</strong></h5>
<p class="noindenta">Suppose that, at the time we establish a handler for <span class="literal">SIGCHLD</span>, there is already a terminated child for this process. Does the kernel then immediately generate a <span class="literal">SIGCHLD</span> signal for the parent? SUSv3 leaves this point unspecified. Some System V&#8211;derived implementations do generate a <span class="literal">SIGCHLD</span> in these circumstances; other implementations, including Linux, do not. A portable application can make this difference invisible by establishing the <span class="literal">SIGCHLD</span> handler before creating any children. (This is usually the natural way of doing things, of course.)</p>
<p class="indent">A further point to consider is the issue of reentrancy. In <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>, we noted that using a system call (e.g., <em>waitpid()</em>) from within a signal handler may change the value of the global variable <em>errno</em>. Such a change could interfere with attempts by the main program to explicitly set <em>errno</em> (see, for example, the discussion of <em>getpriority()</em> in <a href="ch35.xhtml#ch35lev1sec01">Section 35.1</a>) or check its value after a failed system call. For this reason, it is sometimes necessary to code a <span class="literal">SIGCHLD</span> handler to save <em>errno</em> in a local variable on entry to the handler, and then restore the <em>errno</em> value just prior to returning. An example of this is shown in <a href="ch26.xhtml#ch26ex5">Listing 26-5</a>.</p>
<h5 class="h5" id="ch26lev3sec03"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch26.xhtml#ch26ex5">Listing 26-5</a> provides an example of a more complex <span class="literal">SIGCHLD</span> handler. This handler displays the process ID and wait status of each reaped child <span class="ent">&#x2460;</span>. In order to see that multiple <span class="literal">SIGCHLD</span> signals are not queued while the handler is already invoked, execution of the handler is artificially lengthened by a call to <em>sleep()</em> <span class="ent">&#x2461;</span>. The main program creates one child process for each (integer) command-line argument <span class="ent">&#x2463;</span>. Each of these children sleeps for the number of seconds specified in the corresponding command-line argument and then exits <span class="ent">&#x2464;</span>. In the following example of the execution of this program, we see that even though three children terminate, <span class="literal">SIGCHLD</span> is only queued twice to the parent:</p>
<p class="programs">$ <span class="codestrong">./multi_SIGCHLD 1 2 4</span><br/>16:45:18 Child 1 (PID=17767) exiting<br/>16:45:18 handler: Caught SIGCHLD&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">First invocation of handler</span><br/>16:45:18 handler: Reaped child 17767 - child exited, status=0<br/>16:45:19 Child 2 (PID=17768) exiting&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">These children terminate during&#8230;</span><br/>16:45:21 Child 3 (PID=17769) exiting&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">first invocation of handler</span><br/>16:45:23 handler: returning&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">End of first invocation of handler</span><br/>16:45:23 handler: Caught SIGCHLD&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Second invocation of handler</span><br/>16:45:23 handler: Reaped child 17768 - child exited, status=0<br/>16:45:23 handler: Reaped child 17769 - child exited, status=0<br/>16:45:28 handler: returning<br/>16:45:28 All 3 children have terminated; SIGCHLD was caught 2 times</p>
<p class="noindent"><span epub:type="pagebreak" id="page_557"/>Note the use of <em>sigprocmask()</em> to block the <span class="literal">SIGCHLD</span> signal before any children are created in <a href="ch26.xhtml#ch26ex5">Listing 26-5</a> <span class="ent">&#x2462;</span>. This is done to ensure correct operation of the <em>sigsuspend()</em> loop in the parent. If we failed to block <span class="literal">SIGCHLD</span> in this way, and a child terminated between the test of the value of <em>numLiveChildren</em> and the execution of the <em>sigsuspend()</em> call (or alternatively a <em>pause()</em> call), then the <em>sigsuspend()</em> call would block forever waiting for a signal that has already been caught <span class="ent">&#x2465;</span>. The requirement for dealing with this type of race condition was detailed in <a href="ch22.xhtml#ch22lev1sec09">Section 22.9</a>.</p>
<p class="examplet"><a id="ch26ex5"/><strong>Listing 26-5:</strong> Reaping dead children via a handler for <span class="literal">SIGCHLD</span></p>
<p class="programsli">__________________________________________________ <span class="codestrong">procexec/multi_SIGCHLD.c</span><br/><br/>&#160;&#160;&#160;#include &lt;signal.h&gt;<br/>&#160;&#160;&#160;#include &lt;sys/wait.h&gt;<br/>&#160;&#160;&#160;#include "print_wait_status.h"<br/>&#160;&#160;&#160;#include "curr_time.h"<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;static volatile int numLiveChildren = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of children started but not yet waited on */<br/><br/>&#160;&#160;&#160;static void<br/>&#160;&#160;&#160;sigchldHandler(int sig)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int status, savedErrno;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;pid_t childPid;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* UNSAFE: This handler uses non-async-signal-safe functions<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(printf(), printWaitStatus(), currTime(); see <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>) */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;savedErrno = errno;&#160;&#160;&#160;&#160;&#160;/* In case we modify 'errno' */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s handler: Caught SIGCHLD\n", currTime("%T"));<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;while ((childPid = waitpid(-1, &#38;status, WNOHANG)) &gt; 0) {<br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s handler: Reaped child %ld - ", currTime("%T"),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) childPid);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printWaitStatus(NULL, status);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numLiveChildren--;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (childPid == -1 &#38;&#38; errno != ECHILD)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("waitpid");<br/><span epub:type="pagebreak" id="page_558"/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;sleep(5);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Artificially lengthen execution of handler */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s handler: returning\n", currTime("%T"));<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;errno = savedErrno;<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int j, sigCnt;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigset_t blockMask, emptyMask;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sigaction sa;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s child-sleep-time...\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;setbuf(stdout, NULL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Disable buffering of stdout */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigCnt = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;numLiveChildren = argc - 1;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_flags = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_handler = sigchldHandler;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGCHLD, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Block SIGCHLD to prevent its delivery if a child terminates<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;before the parent commences the sigsuspend() loop below */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;blockMask);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigaddset(&#38;blockMask, SIGCHLD);<br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;if (sigprocmask(SIG_SETMASK, &#38;blockMask, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask");<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;for (j = 1; j &lt; argc; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (fork()) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case -1:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child - sleeps and then exits */<br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep(getInt(argv[j], GN_NONNEG, "child-sleep-time"));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s Child %d (PID=%ld) exiting\n", currTime("%T"),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;j, (long) getpid());<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_exit(EXIT_SUCCESS);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent - loops to create next child */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent comes here: wait for SIGCHLD until all children are dead */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;emptyMask);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (numLiveChildren &gt; 0) {<br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigsuspend(&#38;emptyMask) == -1 &#38;&#38; errno != EINTR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigsuspend");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigCnt++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s All %d children have terminated; SIGCHLD was caught "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"%d times\n", currTime("%T"), argc - 1, sigCnt);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;}<br/>__________________________________________________ <span class="codestrong">procexec/multi_SIGCHLD.c</span></p>
<h4 class="h4" id="ch26lev2sec08"><span epub:type="pagebreak" id="page_559"/><strong>26.3.2 Delivery of</strong> <span class="literal"><span class="codestrong">SIGCHLD</span></span> <strong>for Stopped Children</strong></h4>
<p class="noindenta">Just as <em>waitpid()</em> can be used to monitor stopped children, so is it possible for a parent process to receive the <span class="literal">SIGCHLD</span> signal when one of its children is stopped by a signal. This behavior is controlled by the <span class="literal">SA_NOCLDSTOP</span> flag when using <em>sigaction()</em> to establish a handler for the <span class="literal">SIGCHLD</span> signal. If this flag is omitted, a <span class="literal">SIGCHLD</span> signal is delivered to the parent when one of its children stops; if the flag is present, <span class="literal">SIGCHLD</span> is not delivered for stopped children. (The implementation of <em>signal()</em> given in <a href="ch22.xhtml#ch22lev1sec07">Section 22.7</a> doesn&#8217;t specify <span class="literal">SA_NOCLDSTOP</span>.)</p>
<div class="block">
<p class="noindent">Since <span class="literal">SIGCHLD</span> is ignored by default, the <span class="literal">SA_NOCLDSTOP</span> flag has a meaning only if we are establishing a handler for <span class="literal">SIGCHLD</span>. Furthermore, <span class="literal">SIGCHLD</span> is the only signal for which the <span class="literal">SA_NOCLDSTOP</span> flag has an effect.</p>
</div>
<p class="noindent">SUSv3 also allows for a parent to be sent a <span class="literal">SIGCHLD</span> signal if one of its stopped children is resumed by being sent a <span class="literal">SIGCONT</span> signal. (This corresponds to the <span class="literal">WCONTINUED</span> flag for <em>waitpid()</em>.) This feature is implemented in Linux since kernel 2.6.9.</p>
<h4 class="h4" id="ch26lev2sec09"><strong>26.3.3 Ignoring Dead Child Processes</strong></h4>
<p class="noindenta">There is a further possibility for dealing with dead child processes. Explicitly setting the disposition of <span class="literal">SIGCHLD</span> to <span class="literal">SIG_IGN</span> causes any child process that subsequently terminates to be immediately removed from the system instead of being converted into a zombie. In this case, since the status of the child process is simply discarded, a subsequent call to <em>wait()</em> (or similar) can&#8217;t return any information for the terminated child.</p>
<div class="block">
<p class="noindent">Note that even though the default disposition for <span class="literal">SIGCHLD</span> is to be ignored, explicitly setting the disposition to <span class="literal">SIG_IGN</span> causes the different behavior described here. In this respect, <span class="literal">SIGCHLD</span> is treated uniquely among signals.</p>
</div>
<p class="noindent">On Linux, as on many UNIX implementations, setting the disposition of <span class="literal">SIGCHLD</span> to <span class="literal">SIG_IGN</span> doesn&#8217;t affect the status of any existing zombie children, which must still be waited upon in the usual way. On some other UNIX implementations (e.g., Solaris 8), setting the disposition of <span class="literal">SIGCHLD</span> to <span class="literal">SIG_IGN</span> <em>does</em> remove existing zombie children.</p>
<p class="indent"><span epub:type="pagebreak" id="page_560"/>The <span class="literal">SIG_IGN</span> semantics for <span class="literal">SIGCHLD</span> have a long history, deriving from System V. SUSv3 specifies the behavior described here, but these semantics were left unspecified in the original POSIX.1 standard. Thus, on some older UNIX implementations, ignoring <span class="literal">SIGCHLD</span> has no effect on the creation of zombies. The only completely portable way of preventing the creation of zombies is to call <em>wait()</em> or <em>waitpid()</em>, possibly from within a handler established for <span class="literal">SIGCHLD</span>.</p>
<h5 class="h5" id="ch26lev3sec04"><strong>Deviations from SUSv3 in older Linux kernels</strong></h5>
<p class="noindenta">SUSv3 specifies that if the disposition of <span class="literal">SIGCHLD</span> is set to <span class="literal">SIG_IGN</span>, the resource usage information for the child should be discarded and not included in the totals returned when the parent makes a call to <em>getrusage()</em> specifying the <span class="literal">RUSAGE_CHILDREN</span> flag (<a href="ch36.xhtml#ch36lev1sec01">Section 36.1</a>). However, on Linux versions before kernel 2.6.9, the CPU times and resources used by the child <em>are</em> recorded and are visible in calls to <em>getrusage()</em>. This nonconformance is fixed in Linux 2.6.9 and later.</p>
<div class="block">
<p class="noindent">Setting the disposition of <span class="literal">SIGCHLD</span> to <span class="literal">SIG_IGN</span> should also prevent the child CPU times from being included in the structure returned by <em>times()</em> (<a href="ch10.xhtml#ch10lev1sec07">Section 10.7</a>). However, on Linux kernels before 2.6.9, a similar nonconformance applies for the information returned by <em>times()</em>.</p>
</div>
<p class="noindent">SUSv3 specifies that if the disposition of <span class="literal">SIGCHLD</span> is set to <span class="literal">SIG_IGN</span>, and the parent has no terminated children that have been transformed into zombies and have not yet been waited for, then a call to <em>wait()</em> (or <em>waitpid()</em>) should block until <em>all</em> of the parent&#8217;s children have terminated, at which point the call should terminate with the error <span class="literal">ECHILD</span>. Linux 2.6 conforms to this requirement. However, in Linux 2.4 and earlier, <em>wait()</em> blocks only until the <em>next</em> child terminates, and then returns the process ID and status of that child (i.e., the behavior is the same as if the disposition of <span class="literal">SIGCHLD</span> had not been set to <span class="literal">SIG_IGN</span>).</p>
<h5 class="h5" id="ch26lev3sec05"><strong>The <em>sigaction()</em></strong> <span class="literal"><span class="codestrong">SA_NOCLDWAIT</span></span> <strong>flag</strong></h5>
<p class="noindenta">SUSv3 specifies the <span class="literal">SA_NOCLDWAIT</span> flag, which can be used when setting the disposition of the <span class="literal">SIGCHLD</span> signal using <em>sigaction()</em>. This flag produces behavior similar to that when the disposition of <span class="literal">SIGCHLD</span> is set to <span class="literal">SIG_IGN</span>. This flag was not implemented in Linux 2.4 and earlier, but is implemented in Linux 2.6.</p>
<p class="indent">The principal difference between setting the disposition of <span class="literal">SIGCHLD</span> to <span class="literal">SIG_IGN</span> and employing <span class="literal">SA_NOCLDWAIT</span> is that, when establishing a handler with <span class="literal">SA_NOCLDWAIT</span>, SUSv3 leaves it unspecified whether or not a <span class="literal">SIGCHLD</span> signal is sent to the parent when a child terminates. In other words, an implementation is permitted to deliver <span class="literal">SIGCHLD</span> when <span class="literal">SA_NOCLDWAIT</span> is specified, and an application could catch this signal (although the <span class="literal">SIGCHLD</span> handler would not be able to reap the child status using <em>wait()</em>, since the kernel has already discarded the zombie). On some UNIX implementations, including Linux, the kernel does generate a <span class="literal">SIGCHLD</span> signal for the parent process. On other UNIX implementations, <span class="literal">SIGCHLD</span> is not generated.</p>
<div class="block">
<p class="noindent">When setting the <span class="literal">SA_NOCLDWAIT</span> flag for the <span class="literal">SIGCHLD</span> signal, older Linux kernels demonstrate the same details of nonconformance to SUSv3 as were described above for setting the disposition of <span class="literal">SIGCHLD</span> to <span class="literal">SIG_IGN</span>.</p>
</div>
<h5 class="h5" id="ch26lev3sec06"><span epub:type="pagebreak" id="page_561"/><strong>The System V</strong> <span class="literal"><span class="codestrong">SIGCLD</span></span> <strong>signal</strong></h5>
<p class="noindenta">On Linux, the name <span class="literal">SIGCLD</span> is provided as a synonym for the <span class="literal">SIGCHLD</span> signal. The reason for the existence of both names is historical. The <span class="literal">SIGCHLD</span> signal originated on BSD, and this name was adopted by POSIX, which largely standardized on the BSD signal model. System V provided the corresponding <span class="literal">SIGCLD</span> signal, with slightly different semantics.</p>
<p class="indentb">The key difference between BSD <span class="literal">SIGCHLD</span> and System V <span class="literal">SIGCLD</span> lies in what happens when the disposition of the signal was set to <span class="literal">SIG_IGN</span>:</p>
<p class="bull">&#8226; On historical (and some contemporary) BSD implementations, the system continues to generate zombies for unwaited-for children, even when <span class="literal">SIGCHLD</span> is ignored.</p>
<p class="bull">&#8226; On System V, using <em>signal()</em> (but not <em>sigaction()</em>) to ignore <span class="literal">SIGCLD</span> has the result that zombies are not generated when children died.</p>
<p class="noindentt">As already noted, the original POSIX.1 standard left the result of ignoring <span class="literal">SIGCHLD</span> unspecified, thus permitting the System V behavior. Nowadays, this System V behavior is specified as part of SUSv3 (which nevertheless holds to the name <span class="literal">SIGCHLD</span>). Modern System V derivatives use the standard name <span class="literal">SIGCHLD</span> for this signal, but continue to provide the synonym <span class="literal">SIGCLD</span>. Further details on <span class="literal">SIGCLD</span> can be found in [<a href="bib.xhtml#bib94">Stevens &#38; Rago, 2005</a>].</p>
<h3 class="h3" id="ch26lev1sec04"><strong>26.4 Summary</strong></h3>
<p class="noindenta">Using <em>wait()</em> and <em>waitpid()</em> (and other related functions), a parent process can obtain the status of its terminated and stopped children. This status indicates whether a child process terminated normally (with an exit status indicating either success or failure), terminated abnormally, was stopped by a signal, or was resumed by a <span class="literal">SIGCONT</span> signal.</p>
<p class="indent">If a child&#8217;s parent terminates, the child becomes an orphan and is adopted by the <em>init</em> process, whose process ID is 1.</p>
<p class="indent">When a child process terminates, it becomes a zombie, and is removed from the system only when its parent calls <em>wait()</em> (or similar) to retrieve the child&#8217;s status. Long-running programs such as shells and daemons should be designed so that they always reap the status of the child processes they create, since a process in the zombie state can&#8217;t be killed, and unreaped zombies will eventually clog the kernel process table.</p>
<p class="indent">A common way of reaping dead child processes is to establish a handler for the <span class="literal">SIGCHLD</span> signal. This signal is delivered to a parent process whenever one of its children terminates, and optionally when a child is stopped by a signal. Alternatively, but somewhat less portably, a process may elect to set the disposition of <span class="literal">SIGCHLD</span> to <span class="literal">SIG_IGN</span>, in which case the status of terminated children is immediately discarded (and thus can&#8217;t later be retrieved by the parent), and the children don&#8217;t become zombies.</p>
<h5 class="h5" id="ch26lev3sec07"><strong>Further information</strong></h5>
<p class="noindenta">Refer to the sources of further information listed in <a href="ch24.xhtml#ch24lev1sec06">Section 24.6</a>.</p>
<h3 class="h3" id="ch26lev1sec05"><span epub:type="pagebreak" id="page_562"/><strong>26.5 Exercises</strong></h3>
<p class="exer"><a id="ch26exe1"/><strong>26-1.</strong>&#160;&#160;&#160;Write a program to verify that when a child&#8217;s parent terminates, a call to <em>getppid()</em> returns 1 (the process ID of <em>init</em>).</p>
<p class="exer"><a id="ch26exe2"/><strong>26-2.</strong>&#160;&#160;&#160;Suppose that we have three processes related as grandparent, parent, and child, and that the grandparent doesn&#8217;t immediately perform a <em>wait()</em> after the parent exits, so that the parent becomes a zombie. When do you expect the grandchild to be adopted by <em>init</em> (so that <em>getppid()</em> in the grandchild returns 1): after the parent terminates or after the grandparent does a <em>wait()</em>? Write a program to verify your answer.</p>
<p class="exer"><a id="ch26exe3"/><strong>26-3.</strong>&#160;&#160;&#160;Replace the use of <em>waitpid()</em> with <em>waitid()</em> in <a href="ch26.xhtml#ch26ex3">Listing 26-3</a> (<span class="literal">child_status.c</span>). The call to <em>printWaitStatus()</em> will need to be replaced by code that prints relevant fields from the <em>siginfo_t</em> structure returned by <em>waitid()</em>.</p>
<p class="exer"><a id="ch26exe4"/><strong>26-4.</strong>&#160;&#160;&#160;<a href="ch26.xhtml#ch26ex4">Listing 26-4</a> (<span class="literal">make_zombie.c</span>) uses a call to <em>sleep()</em> to allow the child process a chance to execute and terminate before the parent executes <em>system()</em>. This approach produces a theoretical race condition. Modify the program to eliminate the race condition by using signals to synchronize the parent and child.</p>
</body>
</html>
