<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch28"><span epub:type="pagebreak" id="page_591"/><strong><span class="big">28</span></strong><br/><strong>PROCESS CREATION AND PROGRAM EXECUTION IN MORE DETAIL</strong></h2>
<p class="noindenta">This chapter extends the material presented in <a href="ch24.xhtml#ch24">Chapters 24</a> to <a href="ch27.xhtml#ch27">27</a> by covering a variety of topics related to process creation and program execution. We describe process accounting, a kernel feature that writes an accounting record for each process on the system as it terminates. We then look at the Linux-specific <em>clone()</em> system call, which is the low-level API that is used to create threads on Linux. We follow this with some comparisons of the performance of <em>fork()</em>, <em>vfork()</em>, and <em>clone()</em>. We conclude with a summary of the effects of <em>fork()</em> and <em>exec()</em> on the attributes of a process.</p>
<h3 class="h3" id="ch28lev1sec01"><strong>28.1 Process Accounting</strong></h3>
<p class="noindenta">When process accounting is enabled, the kernel writes an accounting record to the system-wide process accounting file as each process terminates. This accounting record contains various information maintained by the kernel about the process, including its termination status and how much CPU time it consumed. The accounting file can be analyzed by standard tools (<em>sa(8)</em> summarizes information from the accounting file, and <em>lastcomm(1)</em> lists information about previously executed commands) or by tailored applications.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_592"/>In kernels before 2.6.10, a separate process accounting record was written for each thread created using the NPTL threading implementation. Since kernel 2.6.10, a single accounting record is written for the entire process when the last thread terminates. Under the older LinuxThreads threading implementation, a single process accounting record is always written for each thread.</p>
</div>
<p class="noindent">Historically, the primary use of process accounting was to charge users for consumption of system resources on multiuser UNIX systems. However, process accounting can also be useful for obtaining information about a process that was not otherwise monitored and reported on by its parent.</p>
<p class="indent">Although available on most UNIX implementations, process accounting is not specified in SUSv3. The format of the accounting records, as well as the location of the accounting file, vary somewhat across implementations. We describe the details for Linux in this section, noting some variations from other UNIX implementations along the way.</p>
<div class="block">
<p class="noindent">On Linux, process accounting is an optional kernel component that is configured via the option <span class="literal">CONFIG_BSD_PROCESS_ACCT</span>.</p>
</div>
<h5 class="h5" id="ch28lev3sec01"><strong>Enabling and disabling process accounting</strong></h5>
<p class="noindenta">The <em>acct()</em> system call is used by a privileged (<span class="literal">CAP_SYS_PACCT</span>) process to enable and disable process accounting. This system call is rarely used in application programs. Normally, process accounting is enabled at each system restart by placing appropriate commands in the system boot scripts.</p>
<div class="box">
<p class="programsa">#define _BSD_SOURCE<br/>#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">acct</span>(const char *<span class="font1">acctfile</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">To enable process accounting, we supply the pathname of an <em>existing</em> regular file in <em>acctfile</em>. A typical pathname for the accounting file is <span class="literal">/var/log/pacct</span> or <span class="literal">/usr/account/pacct</span>. To disable process accounting, we specify <em>acctfile</em> as <span class="literal">NULL</span>.</p>
<p class="indent">The program in <a href="ch28.xhtml#ch28ex1">Listing 28-1</a> uses <em>acct()</em> to switch process accounting on and off. The functionality of this program is similar to the shell <em>accton(8)</em> command.</p>
<p class="examplet"><a id="ch28ex1"/><strong>Listing 28-1:</strong> Turning process accounting on and off</p>
<p class="programsli">_______________________________________________________ <span class="codestrong">procexec/acct_on.c</span><br/><br/>#define _BSD_SOURCE<br/>#include &lt;unistd.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;if (argc &gt; 2 || (argc &gt; 1 &#38;&#38; strcmp(argv[1], "--help") == 0))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s [file]\n", argv[0]);<br/>&#160;&#160;&#160;&#160;if (acct(argv[1]) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("acct");<br/><br/>&#160;&#160;&#160;&#160;printf("Process accounting %s\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(argv[1] == NULL) ? "disabled" : "enabled");<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_______________________________________________________ <span class="codestrong">procexec/acct_on.c</span></p>
<h5 class="h5" id="ch28lev3sec02"><span epub:type="pagebreak" id="page_593"/><strong>Process accounting records</strong></h5>
<p class="noindenta">Once process accounting is enabled, an <em>acct</em> record is written to the accounting file as each process terminates. The <em>acct</em> structure is defined in <span class="literal">&lt;sys/acct.h&gt;</span> as follows:</p>
<p class="programs">typedef u_int16_t comp_t;&#160;&#160;/* See text */<br/><br/>struct acct {<br/>&#160;&#160;&#160;&#160;char&#160;&#160;&#160;&#160;&#160;&#160;ac_flag;&#160;&#160;&#160;&#160;&#160;/* Accounting flags (see text) */<br/>&#160;&#160;&#160;&#160;u_int16_t ac_uid;&#160;&#160;&#160;&#160;&#160;&#160;/* User ID of process */<br/>&#160;&#160;&#160;&#160;u_int16_t ac_gid;&#160;&#160;&#160;&#160;&#160;&#160;/* Group ID of process */<br/>&#160;&#160;&#160;&#160;u_int16_t ac_tty;&#160;&#160;&#160;&#160;&#160;&#160;/* Controlling terminal for process (may be<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0 if none, e.g., for a daemon) */<br/>&#160;&#160;&#160;&#160;u_int32_t ac_btime;&#160;&#160;&#160;&#160;/* Start time (time_t; seconds since the Epoch) */<br/>&#160;&#160;&#160;&#160;comp_t&#160;&#160;&#160;&#160;ac_utime;&#160;&#160;&#160;&#160;/* User CPU time (clock ticks) */<br/>&#160;&#160;&#160;&#160;comp_t&#160;&#160;&#160;&#160;ac_stime;&#160;&#160;&#160;&#160;/* System CPU time (clock ticks) */<br/>&#160;&#160;&#160;&#160;comp_t&#160;&#160;&#160;&#160;ac_etime;&#160;&#160;&#160;&#160;/* Elapsed (real) time (clock ticks) */<br/>&#160;&#160;&#160;&#160;comp_t&#160;&#160;&#160;&#160;ac_mem;&#160;&#160;&#160;&#160;&#160;&#160;/* Average memory usage (kilobytes) */<br/>&#160;&#160;&#160;&#160;comp_t&#160;&#160;&#160;&#160;ac_io;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Bytes transferred by read(2) and write(2)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(unused) */<br/>&#160;&#160;&#160;&#160;comp_t&#160;&#160;&#160;&#160;ac_rw;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Blocks read/written (unused) */<br/>&#160;&#160;&#160;&#160;comp_t&#160;&#160;&#160;&#160;ac_minflt;&#160;&#160;&#160;/* Minor page faults (Linux-specific) */<br/>&#160;&#160;&#160;&#160;comp_t&#160;&#160;&#160;&#160;ac_majflt;&#160;&#160;&#160;/* Major page faults (Linux-specific) */<br/>&#160;&#160;&#160;&#160;comp_t&#160;&#160;&#160;&#160;ac_swaps;&#160;&#160;&#160;&#160;/* Number of swaps (unused; Linux-specific) */<br/>&#160;&#160;&#160;&#160;u_int32_t ac_exitcode; /* Process termination status */<br/>#define ACCT_COMM 16<br/>&#160;&#160;&#160;&#160;char&#160;&#160;&#160;&#160;&#160;&#160;ac_comm[ACCT_COMM+1];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* (Null-terminated) command name<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(basename of last execed file) */<br/>&#160;&#160;&#160;&#160;char&#160;&#160;&#160;&#160;&#160;&#160;ac_pad[10];&#160;&#160;/* Padding (reserved for future use) */<br/>};</p>
<p class="noindentb">Note the following points regarding the <em>acct</em> structure:</p>
<p class="bull">&#8226; The <em>u_int16_t</em> and <em>u_int32_t</em> data types are 16-bit and 32-bit unsigned integers.</p>
<p class="bull">&#8226; The <em>ac_flag</em> field is a bit mask recording various events for the process. The bits that can appear in this field are shown in <a href="ch28.xhtml#ch28table1">Table 28-1</a>. As indicated in the table, some of these bits are not present on all UNIX implementations. A few other implementations provide additional bits in this field.</p>
<p class="bull">&#8226; The <em>ac_comm</em> field records the name of the last command (program file) executed by this process. The kernel records this value on each <em>execve()</em>. On some other UNIX implementations, this field is limited to 8 characters.</p>
<p class="bull"><span epub:type="pagebreak" id="page_594"/>&#8226; The <em>comp_t</em> type is a kind of floating-point number. Values of this type are sometimes called <em>compressed clock ticks</em>. The floating-point value consists of a 3-bit, base-8 exponent, followed by a 13-bit mantissa; the exponent can represent a factor in the range 8<sup>0</sup>=1 to 8<sup>7</sup> (2,097,152). For example, a mantissa of 125 and an exponent of 1 represent the value 1000. <a href="ch28.xhtml#ch28ex2">Listing 28-2</a> defines a function (<em>comptToLL()</em>) to convert this type to <em>long long</em>. We need to use the type <em>long long</em> because the 32 bits used to represent an <em>unsigned long</em> on x86-32 are insufficient to hold the largest value that can be represented in <em>comp_t</em>, which is (2<sup>13</sup> &#8211; 1) * 8<sup>7</sup>.</p>
<p class="bull">&#8226; The three time fields defined with the type <em>comp_t</em> represent time in system clock ticks. Therefore, we must divide these times by the value returned by <em>sysconf(_SC_CLK_TCK)</em> in order to convert them to seconds.</p>
<p class="bull">&#8226; The <em>ac_exitcode</em> field holds the termination status of the process (described in <a href="ch26.xhtml#ch26lev2sec03">Section 26.1.3</a>). Most other UNIX implementations instead provide a single-byte field named <em>ac_stat</em>, which records only the signal that killed the process (if it was killed by a signal) and a bit indicating whether that signal caused the process to dump core. BSD-derived implementations don&#8217;t provide either field.</p>
<p class="tablecap"><a id="ch28table1"/><strong>Table 28-1:</strong> Bit values for the <em>ac_flag</em> field of process accounting records</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Bit</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">AFORK</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Process was created by <em>fork()</em>, but did not <em>exec()</em> before terminating</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ASU</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Process made use of superuser privileges</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">AXSIG</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Process was terminated by a signal (not present on some implementations)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">ACORE</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Process produced a core dump (not present on some implementations)</p></td>
</tr>
</tbody>
</table>
<p class="noindent">Because accounting records are written only as processes terminate, they are ordered by termination time (a value not recorded in the record), rather than by process start time (<em>ac_btime</em>).</p>
<div class="block">
<p class="noindent">If the system crashes, no accounting record is written for any processes that are still executing.</p>
</div>
<p class="noindent">Since writing records to the accounting file can rapidly consume disk space, Linux provides the <span class="literal">/proc/sys/kernel/acct</span> virtual file for controlling the operation of process accounting. This file contains three numbers, defining (in order) the parameters <em>high-water</em>, <em>low-water</em>, and <em>frequency</em>. Typical defaults for these three parameters are 4, 2, and 30. If process accounting is enabled and the amount of free disk space falls below <em>low-water</em> percent, accounting is suspended. If the amount of free disk space later rises above <em>high-water</em> percent, then accounting is resumed. The <em>frequency</em> value specifies how often, in seconds, checks should be made on the percentage of free disk space.</p>
<h5 class="h5" id="ch28lev3sec03"><strong>Example program</strong></h5>
<p class="noindenta">The program in <a href="ch28.xhtml#ch28ex2">Listing 28-2</a> displays selected fields from the records in a process accounting file. The following shell session demonstrates the use of this program. We begin by creating a new, empty process accounting file and enabling process accounting:</p>
<p class="programs"><span epub:type="pagebreak" id="page_595"/>$ <span class="codestrong">su</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Need privilege to enable process accounting</span><br/>Password:<br/># <span class="codestrong">touch pacct</span><br/># <span class="codestrong">./acct_on pacct</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">This process will be first entry in accounting file</span><br/>Process accounting enabled<br/># <span class="codestrong">exit</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Cease being superuser</span></p>
<p class="noindent">At this point, three processes have already terminated since we enabled process accounting. These processes executed the <em>acct_on</em>, <em>su</em>, and <em>bash</em> programs. The <em>bash</em> process was started by <em>su</em> to run the privileged shell session.</p>
<p class="indent">Now we run a series of commands to add further records to the accounting file:</p>
<p class="programs">$ <span class="codestrong">sleep 15 &#38;</span><br/>[1] 18063<br/>$ <span class="codestrong">ulimit -c unlimited</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Allow core dumps (shell built-in)</span><br/>$ <span class="codestrong">cat</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create a process</span><br/><span class="font1">Type Control-\ (generates</span> SIGQUIT<span class="font1">, signal 3) to kill cat process</span><br/>Quit (core dumped)<br/>$<br/><span class="font1">Press Enter to see shell notification of completion of sleep before next shell prompt</span><br/>[1]+&#160;&#160;Done&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep 15<br/>$ <span class="codestrong">grep xxx badfile</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">grep fails with status of 2</span><br/>grep: badfile: No such file or directory<br/>$ <span class="codestrong">echo $?</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">The shell obtained status of grep (shell built-in)</span><br/>2</p>
<p class="noindent">The next two commands run programs that we presented in previous chapters (<a href="ch27.xhtml#ch27ex1">Listing 27-1</a>, on <a href="ch27.xhtml#page_566">page 566</a>, and <a href="ch24.xhtml#ch24ex1">Listing 24-1</a>, on <a href="ch24.xhtml#page_517">page 517</a>). The first command runs a program that execs the file <span class="literal">/bin/echo</span>; this results in an accounting record with the command name <em>echo</em>. The second command creates a child process that doesn&#8217;t perform an <em>exec()</em>.</p>
<p class="programs">$ <span class="codestrong">./t_execve /bin/echo</span><br/>hello world goodbye<br/>$ <span class="codestrong">./t_fork</span><br/>PID=18350 (child) idata=333 istack=666<br/>PID=18349 (parent) idata=111 istack=222</p>
<p class="noindent">Finally, we use the program in <a href="ch28.xhtml#ch28ex2">Listing 28-2</a> to view the contents of the accounting file:</p>
<p class="programs">$ <span class="codestrong">./acct_view pacct</span><br/>command&#160;&#160;flags&#160;&#160;&#160;term.&#160;&#160;user&#160;&#160;&#160;&#160;&#160;start time&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;CPU&#160;&#160;&#160;elapsed<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;status&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;time&#160;&#160;&#160;&#160;time<br/>acct_on&#160;&#160;&#160;-S--&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;root&#160;&#160;&#160;&#160;&#160;2010-07-23 17:19:05&#160;&#160;&#160;0.00&#160;&#160;&#160;&#160;0.00<br/>bash&#160;&#160;&#160;&#160;&#160;&#160;----&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;root&#160;&#160;&#160;&#160;&#160;2010-07-23 17:18:55&#160;&#160;&#160;0.02&#160;&#160;&#160;21.10<br/>su&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-S--&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;root&#160;&#160;&#160;&#160;&#160;2010-07-23 17:18:51&#160;&#160;&#160;0.01&#160;&#160;&#160;24.94<br/>cat&#160;&#160;&#160;&#160;&#160;&#160;&#160;--XC&#160;&#160;&#160;0x83&#160;&#160;&#160;mtk&#160;&#160;&#160;&#160;&#160;&#160;2010-07-23 17:19:55&#160;&#160;&#160;0.00&#160;&#160;&#160;&#160;1.72<br/>sleep&#160;&#160;&#160;&#160;&#160;----&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;mtk&#160;&#160;&#160;&#160;&#160;&#160;2010-07-23 17:19:42&#160;&#160;&#160;0.00&#160;&#160;&#160;15.01<br/>grep&#160;&#160;&#160;&#160;&#160;&#160;----&#160;&#160;0x200&#160;&#160;&#160;mtk&#160;&#160;&#160;&#160;&#160;&#160;2010-07-23 17:20:12&#160;&#160;&#160;0.00&#160;&#160;&#160;&#160;0.00<br/>echo&#160;&#160;&#160;&#160;&#160;&#160;----&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;mtk&#160;&#160;&#160;&#160;&#160;&#160;2010-07-23 17:21:15&#160;&#160;&#160;0.01&#160;&#160;&#160;&#160;0.01<br/>t_fork&#160;&#160;&#160;&#160;F---&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;mtk&#160;&#160;&#160;&#160;&#160;&#160;2010-07-23 17:21:36&#160;&#160;&#160;0.00&#160;&#160;&#160;&#160;0.00<br/>t_fork&#160;&#160;&#160;&#160;----&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;mtk&#160;&#160;&#160;&#160;&#160;&#160;2010-07-23 17:21:36&#160;&#160;&#160;0.00&#160;&#160;&#160;&#160;3.01</p>
<p class="noindent"><span epub:type="pagebreak" id="page_596"/>In the output, we see one line for each process that was created in the shell session. The <em>ulimit</em> and <em>echo</em> commands are shell built-in commands, so they don&#8217;t result in the creation of new processes. Note that the entry for <em>sleep</em> appeared in the accounting file after the <em>cat</em> entry because the <em>sleep</em> command terminated after the <em>cat</em> command.</p>
<p class="indent">Most of the output is self-explanatory. The <em>flags</em> column shows single letters indicating which of the <em>ac_flag</em> bits is set in each record (see <a href="ch28.xhtml#ch28table1">Table 28-1</a>). <a href="ch26.xhtml#ch26lev2sec03">Section 26.1.3</a> describes how to interpret the termination status values shown in the <em>term. status</em> column.</p>
<p class="examplet"><a id="ch28ex2"/><strong>Listing 28-2:</strong> Displaying data from a process accounting file</p>
<p class="programsli">______________________________________________________ <span class="codestrong">procexec/acct_view.c</span><br/><br/>#include &lt;fcntl.h&gt;<br/>#include &lt;time.h&gt;<br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;sys/acct.h&gt;<br/>#include &lt;limits.h&gt;<br/>#include "ugid_functions.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declaration of userNameFromId() */<br/>#include "tlpi_hdr.h"<br/><br/>#define TIME_BUF_SIZE 100<br/><br/>static long long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Convert comp_t value into long long */<br/>comptToLL(comp_t ct)<br/>{<br/>&#160;&#160;&#160;&#160;const int EXP_SIZE = 3;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* 3-bit, base-8 exponent */<br/>&#160;&#160;&#160;&#160;const int MANTISSA_SIZE = 13;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Followed by 13-bit mantissa */<br/>&#160;&#160;&#160;&#160;const int MANTISSA_MASK = (1 &lt;&lt; MANTISSA_SIZE) - 1;<br/>&#160;&#160;&#160;&#160;long long mantissa, exp;<br/><br/>&#160;&#160;&#160;&#160;mantissa = ct &#38; MANTISSA_MASK;<br/>&#160;&#160;&#160;&#160;exp = (ct &gt;&gt; MANTISSA_SIZE) &#38; ((1 &lt;&lt; EXP_SIZE) - 1);<br/>&#160;&#160;&#160;&#160;return mantissa &lt;&lt; (exp * 3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Power of 8 = left shift 3 bits */<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int acctFile;<br/>&#160;&#160;&#160;&#160;struct acct ac;<br/>&#160;&#160;&#160;&#160;ssize_t numRead;<br/>&#160;&#160;&#160;&#160;char *s;<br/>&#160;&#160;&#160;&#160;char timeBuf[TIME_BUF_SIZE];<br/>&#160;&#160;&#160;&#160;struct tm *loc;<br/>&#160;&#160;&#160;&#160;time_t t;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s file\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;acctFile = open(argv[1], O_RDONLY);<br/>&#160;&#160;&#160;&#160;if (acctFile == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open");<br/><br/>&#160;&#160;&#160;&#160;printf("command&#160;&#160;flags&#160;&#160;&#160;term.&#160;&#160;user&#160;&#160;&#160;&#160;&#160;"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"start time&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;CPU&#160;&#160;&#160;elapsed\n");<br/>&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;status&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;time&#160;&#160;&#160;&#160;time\n");<br/><br/>&#160;&#160;&#160;&#160;while ((numRead = read(acctFile, &#38;ac, sizeof(struct acct))) &gt; 0) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead != sizeof(struct acct))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("partial read");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%-8.8s ", ac.ac_comm);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%c", (ac.ac_flag &#38; AFORK) ? 'F' : '-') ;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%c", (ac.ac_flag &#38; ASU)&#160;&#160;&#160;? 'S' : '-') ;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%c", (ac.ac_flag &#38; AXSIG) ? 'X' : '-') ;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%c", (ac.ac_flag &#38; ACORE) ? 'C' : '-') ;<br/><br/>#ifdef __linux__<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf(" %#6lx&#160;&#160;&#160;", (unsigned long) ac.ac_exitcode);<br/>#else&#160;&#160;&#160;/* Many other implementations provide ac_stat instead */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf(" %#6lx&#160;&#160;&#160;", (unsigned long) ac.ac_stat);<br/>#endif<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = userNameFromId(ac.ac_uid);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%-8.8s ", (s == NULL) ? "???" : s);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t = ac.ac_btime;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;loc = localtime(&#38;t);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (loc == NULL) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("???Unknown time??? ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;strftime(timeBuf, TIME_BUF_SIZE, "%Y-%m-%d %T ", loc);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s ", timeBuf);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%5.2f %7.2f ", (double) (comptToLL(ac.ac_utime) +<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;comptToLL(ac.ac_stime)) / sysconf(_SC_CLK_TCK),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(double) comptToLL(ac.ac_etime) / sysconf(_SC_CLK_TCK));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("\n");<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (numRead == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("read");<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>______________________________________________________ <span class="codestrong">procexec/acct_view.c</span></p>
<h5 class="h5" id="ch28lev3sec04"><span epub:type="pagebreak" id="page_597"/><strong>Process accounting Version 3 file format</strong></h5>
<p class="noindenta">Starting with kernel 2.6.8, Linux introduced an optional alternative version of the process accounting file that addresses some limitations of the traditional accounting file. To use this alternative version, known as <em>Version 3</em>, the <span class="literal">CONFIG_BSD_PROCESS_ACCT_V3</span> kernel configuration option must be enabled before building the kernel.</p>
<p class="indent"><span epub:type="pagebreak" id="page_598"/>When using the Version 3 option, the only difference in the operation of process accounting is in the format of records written to the accounting file. The new format is defined as follows:</p>
<p class="programs">struct acct_v3 {<br/>&#160;&#160;&#160;&#160;char&#160;&#160;&#160;&#160;&#160;&#160;ac_flag;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Accounting flags */<br/>&#160;&#160;&#160;&#160;char&#160;&#160;&#160;&#160;&#160;&#160;ac_version;&#160;&#160;&#160;&#160;&#160;/* Accounting version (3) */<br/>&#160;&#160;&#160;&#160;u_int16_t ac_tty;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Controlling terminal for process */<br/>&#160;&#160;&#160;&#160;u_int32_t ac_exitcode;&#160;&#160;&#160;&#160;/* Process termination status */<br/>&#160;&#160;&#160;&#160;u_int32_t ac_uid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* 32-bit user ID of process */<br/>&#160;&#160;&#160;&#160;u_int32_t ac_gid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* 32-bit group ID of process */<br/>&#160;&#160;&#160;&#160;u_int32_t ac_pid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Process ID */<br/>&#160;&#160;&#160;&#160;u_int32_t ac_ppid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent process ID */<br/>&#160;&#160;&#160;&#160;u_int32_t ac_btime;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Start time (time_t) */<br/>&#160;&#160;&#160;&#160;float&#160;&#160;&#160;&#160;&#160;ac_etime;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Elapsed (real) time (clock ticks) */<br/>&#160;&#160;&#160;&#160;comp_t&#160;&#160;&#160;&#160;ac_utime;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* User CPU time (clock ticks) */<br/>&#160;&#160;&#160;&#160;comp_t&#160;&#160;&#160;&#160;ac_stime;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* System CPU time (clock ticks) */<br/>&#160;&#160;&#160;&#160;comp_t&#160;&#160;&#160;&#160;ac_mem;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Average memory usage (kilobytes) */<br/>&#160;&#160;&#160;&#160;comp_t&#160;&#160;&#160;&#160;ac_io;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Bytes read/written (unused) */<br/>&#160;&#160;&#160;&#160;comp_t&#160;&#160;&#160;&#160;ac_rw;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Blocks read/written (unused) */<br/>&#160;&#160;&#160;&#160;comp_t&#160;&#160;&#160;&#160;ac_minflt;&#160;&#160;&#160;&#160;&#160;&#160;/* Minor page faults */<br/>&#160;&#160;&#160;&#160;comp_t&#160;&#160;&#160;&#160;ac_majflt;&#160;&#160;&#160;&#160;&#160;&#160;/* Major page faults */<br/>&#160;&#160;&#160;&#160;comp_t&#160;&#160;&#160;&#160;ac_swaps;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of swaps (unused; Linux-specific) */<br/>#define ACCT_COMM 16<br/>&#160;&#160;&#160;&#160;char&#160;&#160;&#160;&#160;&#160;&#160;ac_comm[ACCT_COMM];&#160;&#160;&#160;/* Command name */<br/>};</p>
<p class="noindentb">The following are the main differences between the <em>acct_v3</em> structure and the traditional Linux <em>acct</em> structure:</p>
<p class="bull">&#8226; The <em>ac_version</em> field is added. This field contains the version number of this type of accounting record. This field is always 3 for an <em>acct_v3</em> record.</p>
<p class="bull">&#8226; The fields <em>ac_pid</em> and <em>ac_ppid</em>, containing the process ID and parent process ID of the terminated process, are added.</p>
<p class="bull">&#8226; The <em>ac_uid</em> and <em>ac_gid</em> fields are widened from 16 to 32 bits, to accommodate the 32-bit user and group IDs that were introduced in Linux 2.4. (Large user and group IDs can&#8217;t be correctly represented in the traditional <em>acct</em> file.)</p>
<p class="bull">&#8226; The type of the <em>ac_etime</em> field is changed from <em>comp_t</em> to <em>float</em>, to allow longer elapsed times to be recorded.</p>
<div class="block">
<p class="noindent">We provide a Version 3 analog of the program in <a href="ch28.xhtml#ch28ex2">Listing 28-2</a> in the file <span class="literal">procexec/acct_v3_view.c</span> in the source code distribution for this book.</p>
</div>
<h3 class="h3" id="ch28lev1sec02"><strong>28.2 The <em>clone()</em> System Call</strong></h3>
<p class="noindenta">Like <em>fork()</em> and <em>vfork()</em>, the Linux-specific <em>clone()</em> system call creates a new process. It differs from the other two calls in allowing finer control over the steps that occur during process creation. The main use of <em>clone()</em> is in the implementation of threading libraries. Because <em>clone()</em> is not portable, its direct use in application programs should normally be avoided. We describe it here because it is useful background for the discussion of POSIX threads in <a href="ch29.xhtml#ch29">Chapters 29</a> to <a href="ch33.xhtml#ch33">33</a>, and also because it further illuminates the operation of <em>fork()</em> and <em>vfork()</em>.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_599"/>#define _GNU_SOURCE<br/>#include &lt;sched.h&gt;<br/><br/>int <span class="codestrong">clone</span>(int (*<span class="font1">func</span>) (void *), void *<span class="font1">child_stack</span>, int <span class="font1">flags</span>, void *<span class="font1">func_arg</span>, ...<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* pid_t *<span class="font1">ptid</span>, struct user_desc *<span class="font1">tls</span>, pid_t *<span class="font1">ctid</span> */ );</p>
<p class="right">Returns process ID of child on success, or &#8211;1 on error</p>
</div>
<p class="noindent">Like <em>fork()</em>, a new process created with <em>clone()</em> is an almost exact duplicate of the parent.</p>
<p class="indent">Unlike <em>fork()</em>, the cloned child doesn&#8217;t continue from the point of the call, but instead commences by calling the function specified in the <em>func</em> argument; we&#8217;ll refer to this as the <em>child function</em>. When called, the child function is passed the value specified in <em>func_arg</em>. Using appropriate casting, the child function can freely interpret this argument; for example, as an <em>int</em> or as a pointer to a structure. (Interpreting it as a pointer is possible because the cloned child either obtains a copy of or shares the calling process&#8217;s memory.)</p>
<div class="block">
<p class="noindent">Within the kernel, <em>fork()</em>, <em>vfork()</em>, and <em>clone()</em> are ultimately implemented by the same function (<em>do_fork()</em> in <span class="literal">kernel/fork.c</span>). At this level, cloning is much closer to forking: <em>sys_clone()</em> doesn&#8217;t have the <em>func</em> and <em>func_arg</em> arguments, and after the call, <em>sys_clone()</em> returns in the child in the same manner as <em>fork()</em>. The main text describes the <em>clone()</em> wrapper function that <em>glibc</em> provides for <em>sys_clone()</em>. (This function is defined in architecture-specific <em>glibc</em> assembler sources, such as in <span class="literal">sysdeps/unix/sysv/linux/i386/clone.S</span>.) This wrapper function invokes <em>func</em> after <em>sys_clone()</em> returns in the child.</p>
</div>
<p class="noindent">The cloned child process terminates either when <em>func</em> returns (in which case its return value is the exit status of the process) or when the process makes a call to <em>exit()</em> (or <em>_exit()</em>). The parent process can wait for the cloned child in the usual manner using <em>wait()</em> or similar.</p>
<p class="indent">Since a cloned child may (like <em>vfork()</em>) share the parent&#8217;s memory, it can&#8217;t use the parent&#8217;s stack. Instead, the caller must allocate a suitably sized block of memory for use as the child&#8217;s stack and pass a pointer to that block in the argument <em>child_stack</em>. On most hardware architectures, the stack grows downward, so the <em>child_stack</em> argument should point to the high end of the allocated block.</p>
<div class="block">
<p class="noindent">The architecture-dependence on the direction of stack growth is a defect in the design of <em>clone()</em>. On the Intel IA-64 architecture, an improved clone API is provided, in the form of <em>clone2()</em>. This system call defines the range of the stack of the child in a way that doesn&#8217;t depend on the direction of stack growth, by supplying both the start address and size of the stack. See the manual page for details.</p>
</div>
<p class="noindent">The <em>clone() flags</em> argument serves two purposes. First, its lower byte specifies the child&#8217;s <em>termination signal</em>, which is the signal to be sent to the parent when the child terminates. (If a cloned child is <em>stopped</em> by a signal, the parent still receives <span class="literal">SIGCHLD</span>.) This byte may be 0, in which case no signal is generated. (Using the Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/stat</span> file, we can determine the termination signal of any process; see the <em>proc(5)</em> manual page for further details.)</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_600"/>With <em>fork()</em> and <em>vfork()</em>, we have no way to select the termination signal; it is always <span class="literal">SIGCHLD</span>.</p>
</div>
<p class="noindent">The remaining bytes of the <em>flags</em> argument hold a bit mask that controls the operation of <em>clone()</em>. We summarize these bit-mask values in <a href="ch28.xhtml#ch28table2">Table 28-2</a>, and describe them in more detail in <a href="ch28.xhtml#ch28lev2sec01">Section 28.2.1</a>.</p>
<p class="tablecap"><a id="ch28table2"/><strong>Table 28-2:</strong> The <em>clone() flags</em> bit-mask values</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Flag</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Effect if present</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_CHILD_CLEARTID</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Clear <em>ctid</em> when child calls <em>exec()</em> or <em>_exit()</em> (2.6 onward)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_CHILD_SETTID</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Write thread ID of child into <em>ctid</em> (2.6 onward)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_FILES</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Parent and child share table of open file descriptors</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_FS</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Parent and child share attributes related to file system</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_IO</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Child shares parent&#8217;s I/O context (2.6.25 onward)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_NEWIPC</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Child gets new System V IPC namespace (2.6.19 onward)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_NEWNET</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Child gets new network namespace (2.6.24 onward)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_NEWNS</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Child gets copy of parent&#8217;s mount namespace (2.4.19 onward)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_NEWPID</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Child gets new process-ID namespace (2.6.19 onward)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_NEWUSER</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Child gets new user-ID namespace (2.6.23 onward)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_NEWUTS</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Child gets new UTS (<em>uname()</em>) namespace (2.6.19 onward)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_PARENT</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Make child&#8217;s parent same as caller&#8217;s parent (2.4 onward)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_PARENT_SETTID</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Write thread ID of child into <em>ptid</em> (2.6 onward)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_PID</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Obsolete flag used only by system boot process (up to 2.4)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_PTRACE</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">If parent is being traced, then trace child also</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_SETTLS</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>tls</em> describes thread-local storage for child (2.6 onward)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_SIGHAND</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Parent and child share signal dispositions</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_SYSVSEM</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Parent and child share semaphore undo values (2.6 onward)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_THREAD</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Place child in same thread group as parent (2.4 onward)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_UNTRACED</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Can&#8217;t force <span class="literal">CLONE_PTRACE</span> on child (2.6 onward)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">CLONE_VFORK</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Parent is suspended until child calls <em>exec()</em> or <em>_exit()</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">CLONE_VM</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Parent and child share virtual memory</p></td>
</tr>
</tbody>
</table>
<p class="noindent">The remaining arguments to <em>clone()</em> are <em>ptid</em>, <em>tls</em>, and <em>ctid</em>. These arguments relate to the implementation of threads, in particular the use of thread IDs and thread-local storage. We cover the use of these arguments when describing the <em>flags</em> bit-mask values in <a href="ch28.xhtml#ch28lev2sec01">Section 28.2.1</a>. (In Linux 2.4 and earlier, these three arguments are not provided by <em>clone()</em>. They were specifically added in Linux 2.6 to support the NPTL POSIX threads implementation.)</p>
<h5 class="h5" id="ch28lev3sec05"><strong>Example program</strong></h5>
<p class="noindentab"><a href="ch28.xhtml#ch28ex3">Listing 28-3</a> shows a simple example of the use of <em>clone()</em> to create a child process. The main program does the following:</p>
<p class="bull">&#8226; Open a file descriptor (for <span class="literal">/dev/null</span>) that will be closed by the child <span class="ent">&#x2461;</span>.</p>
<p class="bull">&#8226; Set the value for the <em>clone() flags</em> argument to <span class="literal">CLONE_FILES</span> <span class="ent">&#x2462;</span> if a command-line argument was supplied, so that the parent and child will share a single file descriptor table. If no command-line argument was supplied, <em>flags</em> is set to 0.</p>
<p class="bull"><span epub:type="pagebreak" id="page_601"/>&#8226; Allocate a stack for use by the child <span class="ent">&#x2463;</span>.</p>
<p class="bull">&#8226; If <span class="literal">CHILD_SIG</span> is nonzero and is not equal to <span class="literal">SIGCHLD</span>, ignore it, in case it is a signal that would terminate the process <span class="ent">&#x2464;</span>. We don&#8217;t ignore <span class="literal">SIGCHLD</span>, because doing so would prevent waiting on the child to collect its status.</p>
<p class="bull">&#8226; Call <em>clone()</em> to create the child <span class="ent">&#x2465;</span>. The third (bit-mask) argument includes the termination signal. The fourth argument (<em>func_arg</em>) specifies the file descriptor opened earlier (at <span class="ent">&#x2461;</span>).</p>
<p class="bull">&#8226; Wait for the child to terminate <span class="ent">&#x2466;</span>.</p>
<p class="bull">&#8226; Check whether the file descriptor (opened at <span class="ent">&#x2461;</span>) is still open by trying to <em>write()</em> to it <span class="ent">&#x2467;</span>. The program reports whether the <em>write()</em> succeeds or fails.</p>
<p class="noindentt">Execution of the cloned child begins in <em>childFunc()</em>, which receives (in the argument <em>arg</em>) the file descriptor opened by the main program (at <span class="ent">&#x2461;</span>). The child closes this file descriptor and then terminates by performing a <span class="literal">return</span> <span class="ent">&#x2460;</span>.</p>
<p class="examplet"><a id="ch28ex3"/><strong>Listing 28-3:</strong> Using <em>clone()</em> to create a child process</p>
<p class="programsli">__________________________________________________ <span class="codestrong">procexec/t_clone.c</span><br/><br/>&#160;&#160;&#160;#define _GNU_SOURCE<br/>&#160;&#160;&#160;#include &lt;signal.h&gt;<br/>&#160;&#160;&#160;#include &lt;sys/wait.h&gt;<br/>&#160;&#160;&#160;#include &lt;fcntl.h&gt;<br/>&#160;&#160;&#160;#include &lt;sched.h&gt;<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;#ifndef CHILD_SIG<br/>&#160;&#160;&#160;#define CHILD_SIG SIGUSR1&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Signal to be generated on termination<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;of cloned child */<br/>&#160;&#160;&#160;#endif<br/><br/>&#160;&#160;&#160;static int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Startup function for cloned child */<br/>&#160;&#160;&#160;childFunc(void *arg)<br/>&#160;&#160;&#160;{<br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;if (close(*((int *) arg)) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;return 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child terminates now */<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;const int STACK_SIZE = 65536;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Stack size for cloned child */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char *stack;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Start of stack buffer */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char *stackTop;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* End of stack buffer */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int s, fd, flags;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;fd = open("/dev/null", O_RDWR);&#160;&#160;&#160;&#160;/* Child will close this fd */<br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If argc &gt; 1, child shares file descriptor table with parent */<br/><br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;flags = (argc &gt; 1) ? CLONE_FILES : 0;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allocate stack for child */<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;stack = malloc(STACK_SIZE);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (stack == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("malloc");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;stackTop = stack + STACK_SIZE;&#160;&#160;&#160;&#160;&#160;&#160;/* Assume stack grows downward */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Ignore CHILD_SIG, in case it is a signal whose default is to<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;terminate the process; but don't ignore SIGCHLD (which is ignored<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;by default), since that would prevent the creation of a zombie. */<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;if (CHILD_SIG != 0 &#38;&#38; CHILD_SIG != SIGCHLD)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (signal(CHILD_SIG, SIG_IGN) == SIG_ERR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("signal");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create child; child commences execution in childFunc() */<br/><br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;if (clone(childFunc, stackTop, flags | CHILD_SIG, (void *) &#38;fd) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("clone");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent falls through to here. Wait for child; __WCLONE is<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;needed for child notifying with signal other than SIGCHLD. */<br/><br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;if (waitpid(-1, NULL, (CHILD_SIG != SIGCHLD) ? __WCLONE : 0) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("waitpid");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("child has terminated\n");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Did close() of file descriptor in child affect parent? */<br/><br/><span class="ent">&#x2467;</span>&#160;&#160;&#160;&#160;&#160;s = write(fd, "x", 1);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s == -1 &#38;&#38; errno == EBADF)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("file descriptor %d has been closed\n", fd);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (s == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("write() on file descriptor %d failed "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"unexpectedly (%s)\n", fd, strerror(errno));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("write() on file descriptor %d succeeded\n", fd);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;}<br/>__________________________________________________ <span class="codestrong">procexec/t_clone.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_602"/>When we run the program in <a href="ch28.xhtml#ch28ex3">Listing 28-3</a> without a command-line argument, we see the following:</p>
<p class="programs">$ <span class="codestrong">./t_clone</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Doesn't use</span> CLONE_FILES<br/>child has terminated<br/>write() on file descriptor 3 succeeded&#160;&#160;&#160;&#160;<span class="font1">Child's close() did not affect parent</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_603"/>When we run the program with a command-line argument, we can see that the two processes share the file descriptor table:</p>
<p class="programs">$ <span class="codestrong">./t_clone x</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Uses</span> CLONE_FILES<br/>child has terminated<br/>file descriptor 3 has been closed&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Child's close() affected parent</span></p>
<div class="block">
<p class="noindent">We show a more complex example of the use of <em>clone()</em> in the file <span class="literal">procexec/demo_clone.c</span> in the source code distribution for this book.</p>
</div>
<h4 class="h4" id="ch28lev2sec01"><strong>28.2.1 The <em>clone() flags</em> Argument</strong></h4>
<p class="noindenta">The <em>clone() flags</em> argument is a combination (ORing) of the bit-mask values described in the following pages. Rather than presenting these flags in alphabetical order, we present them in an order that eases explanation, and begin with those flags that are used in the implementation of POSIX threads. From the point of view of implementing threads, many uses of the word <em>process</em> below can be replaced by <em>thread</em>.</p>
<p class="indent">At this point, it is worth remarking that, to some extent, we are playing with words when trying to draw a distinction between the terms <em>thread</em> and <em>process</em>. It helps a little to introduce the term <em>kernel scheduling entity</em> (KSE), which is used in some texts to refer to the objects that are dealt with by the kernel scheduler. Really, threads and processes are simply KSEs that provide for greater and lesser degrees of sharing of attributes (virtual memory, open file descriptors, signal dispositions, process ID, and so on) with other KSEs. The POSIX threads specification provides just one out of various possible definitions of which attributes should be shared between threads.</p>
<p class="indent">In the course of the following descriptions, we&#8217;ll sometimes mention the two main implementations of POSIX threads available on Linux: the older LinuxThreads implementation and the more recent NPTL implementation. Further information about these two implementations can be found in <a href="ch33.xhtml#ch33lev1sec05">Section 33.5</a>.</p>
<div class="block">
<p class="noindent">Starting in kernel 2.6.16, Linux provides a new system call, <em>unshare()</em>, which allows a child created using <em>clone()</em> (or <em>fork()</em> or <em>vfork()</em>) to undo some of the attribute sharing (i.e., reverse the effects of some of the <em>clone() flags</em> bits) that was established when the child was created. For details, see the <em>unshare(2)</em> manual page.</p>
</div>
<h5 class="h5" id="ch28lev3sec06"><strong>Sharing file descriptor tables:</strong> <span class="literal"><span class="codestrong">CLONE_FILES</span></span></h5>
<p class="noindenta">If the <span class="literal">CLONE_FILES</span> flag is specified, the parent and the child share the same table of open file descriptors. This means that file descriptor allocation or deallocation (<em>open()</em>, <em>close()</em>, <em>dup()</em>, <em>pipe()</em>, <em>socket()</em>, and so on) in either process will be visible in the other process. If the <span class="literal">CLONE_FILES</span> flag is not set, then the file descriptor table is not shared, and the child gets a copy of the parent&#8217;s table at the time of the <em>clone()</em> call. These copied descriptors refer to the same open file descriptions as the corresponding descriptors in the parent (as with <em>fork()</em> and <em>vfork()</em>).</p>
<p class="indent">The specification of POSIX threads requires that all of the threads in a process share the same open file descriptors.</p>
<h5 class="h5" id="ch28lev3sec07"><span epub:type="pagebreak" id="page_604"/><strong>Sharing file system&#8211;related information:</strong> <span class="literal"><span class="codestrong">CLONE_FS</span></span></h5>
<p class="noindenta">If the <span class="literal">CLONE_FS</span> flag is specified, then the parent and the child share file system&#8211;related information&#8212;umask, root directory, and current working directory. This means that calls to <em>umask()</em>, <em>chdir()</em>, or <em>chroot()</em> in either process will affect the other process. If the <span class="literal">CLONE_FS</span> flag is not set, then the parent and child have separate copies of this information (as with <em>fork()</em> and <em>vfork()</em>).</p>
<p class="indent">The attribute sharing provided by <span class="literal">CLONE_FS</span> is required by POSIX threads.</p>
<h5 class="h5" id="ch28lev3sec08"><strong>Sharing signal dispositions:</strong> <span class="literal"><span class="codestrong">CLONE_SIGHAND</span></span></h5>
<p class="noindenta">If the <span class="literal">CLONE_SIGHAND</span> flag is set, then the parent and child share the same table of signal dispositions. Using <em>sigaction()</em> or <em>signal()</em> to change a signal&#8217;s disposition in either process will affect that signal&#8217;s disposition in the other process. If the <span class="literal">CLONE_SIGHAND</span> flag is not set, then signal dispositions are not shared; instead, the child gets a copy of the parent&#8217;s signal disposition table (as with <em>fork()</em> and <em>vfork()</em>). The <span class="literal">CLONE_SIGHAND</span> flag doesn&#8217;t affect the process signal mask and the set of pending signals, which are always distinct for the two processes. From Linux 2.6 onward, <span class="literal">CLONE_VM</span> must also be included in <em>flags</em> if <span class="literal">CLONE_SIGHAND</span> is specified.</p>
<p class="indent">Sharing of signal dispositions is required by POSIX threads.</p>
<h5 class="h5" id="ch28lev3sec09"><strong>Sharing the parent&#8217;s virtual memory:</strong> <span class="literal"><span class="codestrong">CLONE_VM</span></span></h5>
<p class="noindenta">If the <span class="literal">CLONE_VM</span> flag is set, then the parent and child share the same virtual memory pages (as with <em>vfork()</em>). Updates to memory or calls to <em>mmap()</em> or <em>munmap()</em> by either process will be visible to the other process. If the <span class="literal">CLONE_VM</span> flag is not set, then the child receives a copy of the parent&#8217;s virtual memory (as with <em>fork()</em>).</p>
<p class="indent">Sharing the same virtual memory is one of the defining attributes of threads, and is required by POSIX threads.</p>
<h5 class="h5" id="ch28lev3sec10"><strong>Thread groups:</strong> <span class="literal"><span class="codestrong">CLONE_THREAD</span></span></h5>
<p class="noindenta">If the <span class="literal">CLONE_THREAD</span> flag is set, then the child is placed in the same thread group as the parent. If this flag is not set, the child is placed in its own new thread group.</p>
<p class="indent"><em>Thread groups</em> were introduced in Linux 2.4 to allow threading libraries to support the POSIX threads requirement that all of the threads in a process share a single process ID (i.e., <em>getpid()</em> in each of the threads should return the same value). A thread group is a group of KSEs that share the same <em>thread group identifier</em> (TGID), as shown in <a href="ch28.xhtml#ch28fig1">Figure 28-1</a>. For the remainder of the discussion of <span class="literal">CLONE_THREAD</span>, we&#8217;ll refer to these KSEs as <em>threads</em>.</p>
<p class="indent">Since Linux 2.4, <em>getpid()</em> returns the calling thread&#8217;s TGID. In other words, a TGID is the same thing as a process ID.</p>
<div class="block">
<p class="noindent">The <em>clone()</em> implementation in Linux 2.2 and earlier did not provide <span class="literal">CLONE_THREAD</span>. Instead, LinuxThreads implemented POSIX threads as processes that shared various attributes (e.g., virtual memory) but had distinct process IDs. For compatibility reasons, even on modern Linux kernels, the LinuxThreads implementation doesn&#8217;t use the <span class="literal">CLONE_THREAD</span> flag, so that threads in that implementation continue to have distinct process IDs.</p>
</div>
<div class="image"><span epub:type="pagebreak" id="page_605"/><img src="../images/f28-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch28fig1"/><strong>Figure 28-1:</strong> A thread group containing four threads</p>
<p class="noindent">Each thread within a thread group is distinguished by a unique <em>thread identifier</em> (TID). Linux 2.4 introduced a new system call, <em>gettid()</em>, to allow a thread to obtain its own thread ID (this is the same value as is returned to the thread that calls <em>clone()</em>). A thread ID is represented using the same data type that is used for a process ID, <em>pid_t</em>. Thread IDs are unique system-wide, and the kernel guarantees that no thread ID will be the same as any process ID on the system, except when a thread is the thread group leader for a process.</p>
<p class="indent">The first thread in a new thread group has a thread ID that is the same as its thread group ID. This thread is referred to as the <em>thread group leader</em>.</p>
<div class="block">
<p class="noindent">The thread IDs that we are discussing here are not the same as the thread IDs (the <em>pthread_t</em> data type) used by POSIX threads. The latter identifiers are generated and maintained internally (in user space) by a POSIX threads implementation.</p>
</div>
<p class="noindent">All of the threads in a thread group have the same parent process ID&#8212;that of the thread group leader. Only after all of the threads in a thread group have terminated is a <span class="literal">SIGCHLD</span> signal (or other termination signal) sent to that parent process. These semantics correspond to the requirements of POSIX threads.</p>
<p class="indent">When a <span class="literal">CLONE_THREAD</span> thread terminates, no signal is sent to the thread that created it using <em>clone()</em>. Correspondingly, it is not possible to use <em>wait()</em> (or similar) to wait for a thread created using <span class="literal">CLONE_THREAD</span>. This accords with POSIX requirements. A POSIX thread is not the same thing as a process, and can&#8217;t be waited for using <em>wait()</em>; instead, it must be joined using <em>pthread_join()</em>. To detect the termination of a thread created using <span class="literal">CLONE_THREAD</span>, a special synchronization primitive, called a <em>futex</em>, is used (see the discussion of the <span class="literal">CLONE_PARENT_SETTID</span> flag below).</p>
<p class="indent">If any of the threads in a thread group performs an <em>exec()</em>, then all threads other than the thread group leader are terminated (this behavior corresponds to the semantics required for POSIX threads), and the new program is execed in the thread group leader. In other words, in the new program, <em>gettid()</em> will return the thread ID of the thread group leader. During an <em>exec()</em>, the termination signal that this process should send to its parent is reset to <span class="literal">SIGCHLD</span>.</p>
<p class="indent">If one of the threads in a thread group creates a child using <em>fork()</em> or <em>vfork()</em>, then any thread in the group can monitor that child using <em>wait()</em> or similar.</p>
<p class="indent">From Linux 2.6 onward, <span class="literal">CLONE_SIGHAND</span> must also be included in <em>flags</em> if <span class="literal">CLONE_THREAD</span> is specified. This corresponds to further POSIX threads requirements; <span epub:type="pagebreak" id="page_606"/>for details, see the description of how POSIX threads and signals interact in <a href="ch33.xhtml#ch33lev1sec02">Section 33.2</a>. (The kernel handling of signals for <span class="literal">CLONE_THREAD</span> thread groups mirrors the POSIX requirements for how the threads in a process should react to signals.)</p>
<h5 class="h5" id="ch28lev3sec11"><strong>Threading library support:</strong> <span class="literal"><span class="codestrong">CLONE_PARENT_SETTID</span></span>, <span class="literal"><span class="codestrong">CLONE_CHILD_SETTID</span></span><strong>, and</strong> <span class="literal"><span class="codestrong">CLONE_CHILD_CLEARTID</span></span></h5>
<p class="noindenta">The <span class="literal">CLONE_PARENT_SETTID</span>, <span class="literal">CLONE_CHILD_SETTID</span>, and <span class="literal">CLONE_CHILD_CLEARTID</span> flags were added in Linux 2.6 to support the implementation of POSIX threads. These flags affect how <em>clone()</em> treats its <em>ptid</em> and <em>ctid</em> arguments. <span class="literal">CLONE_PARENT_SETTID</span> and <span class="literal">CLONE_CHILD_CLEARTID</span> are used in the NPTL threading implementation.</p>
<p class="indent">If the <span class="literal">CLONE_PARENT_SETTID</span> flag is set, then the kernel writes the thread ID of the child thread into the location pointed to by <em>ptid</em>. The thread ID is copied into <em>ptid</em> before the memory of the parent is duplicated. This means that, even if the <span class="literal">CLONE_VM</span> flag is not specified, both the parent and the child can see the child&#8217;s thread ID in this location. (As noted above, the <span class="literal">CLONE_VM</span> flag is specified when creating POSIX threads.)</p>
<p class="indent">The <span class="literal">CLONE_PARENT_SETTID</span> flag exists in order to provide a reliable means for a threading implementation to obtain the ID of the new thread. Note that it isn&#8217;t sufficient to obtain the thread ID of the new thread via the return value of <em>clone()</em>, like so:</p>
<p class="programs">tid = clone(...);</p>
<p class="noindent">The problem is that this code can lead to various race conditions, because the assignment occurs only after <em>clone()</em> returns. For example, suppose that the new thread terminates, and the handler for its termination signal is invoked before the assignment to <em>tid</em> completes. In this case, the handler can&#8217;t usefully access <em>tid</em>. (Within a threading library, <em>tid</em> might be an item in a global bookkeeping structure used to track the status of all threads.) Programs that invoke <em>clone()</em> directly often can be designed to work around this race condition. However, a threading library can&#8217;t control the actions of the program that calls it. Using <span class="literal">CLONE_PARENT_SETTID</span> to ensure that the new thread ID is placed in the location pointed to by <em>ptid</em> before <em>clone()</em> returns allows a threading library to avoid such race conditions.</p>
<p class="indent">If the <span class="literal">CLONE_CHILD_SETTID</span> flag is set, then <em>clone()</em> writes the thread ID of the child thread into the location pointed to by <em>ctid</em>. The setting of <em>ctid</em> is done only in the child&#8217;s memory, but this will affect the parent if <span class="literal">CLONE_VM</span> is also specified. Although NPTL doesn&#8217;t need <span class="literal">CLONE_CHILD_SETTID</span>, this flag is provided to allow flexibility for other possible threading library implementations.</p>
<p class="indent">If the <span class="literal">CLONE_CHILD_CLEARTID</span> flag is set, then <em>clone()</em> zeros the memory location pointed to by <em>ctid</em> when the child terminates.</p>
<p class="indent">The <em>ctid</em> argument is the mechanism (described in a moment) by which the NPTL threading implementation obtains notification of the termination of a thread. Such notification is required by the <em>pthread_join()</em> function, which is the POSIX threads mechanism by which one thread can wait for the termination of another thread.</p>
<p class="indent">When a thread is created using <em>pthread_create()</em>, NPTL makes a <em>clone()</em> call in which <em>ptid</em> and <em>ctid</em> point to the same location. (This is why <span class="literal">CLONE_CHILD_SETTID</span> is not required by NPTL.) The <span class="literal">CLONE_PARENT_SETTID</span> flag causes that location to be initialized <span epub:type="pagebreak" id="page_607"/>with the new thread&#8217;s ID. When the child terminates and <em>ctid</em> is cleared, that change is visible to all threads in the process (since the <span class="literal">CLONE_VM</span> flag is also specified).</p>
<p class="indent">The kernel treats the location pointed to by <em>ctid</em> as a <em>futex</em>, an efficient synchronization mechanism. (See the <em>futex(2)</em> manual page for further details of futexes.) Notification of thread termination can be obtained by performing a <em>futex()</em> system call that blocks waiting for a change in the value at the location pointed to by <em>ctid</em>. (Behind the scenes, this is what <em>pthread_join()</em> does.) At the same time that the kernel clears <em>ctid</em>, it also wakes up any kernel scheduling entity (i.e., thread) that is blocked performing a futex wait on that address. (At the POSIX threads level, this causes the <em>pthread_join()</em> call to unblock.)</p>
<h5 class="h5" id="ch28lev3sec12"><strong>Thread-local storage:</strong> <span class="literal"><span class="codestrong">CLONE_SETTLS</span></span></h5>
<p class="noindenta">If the <span class="literal">CLONE_SETTLS</span> flag is set, then the <em>tls</em> argument points to a <em>user_desc</em> structure describing the thread-local storage buffer to be used for this thread. This flag was added in Linux 2.6 to support the NPTL implementation of thread-local storage (<a href="ch31.xhtml#ch31lev1sec04">Section 31.4</a>). For details of the <em>user_desc</em> structure, see the definition and use of this structure in the 2.6 kernel sources and the <em>set_thread_area(2)</em> manual page.</p>
<h5 class="h5" id="ch28lev3sec13"><strong>Sharing System V semaphore undo values:</strong> <span class="literal"><span class="codestrong">CLONE_SYSVSEM</span></span></h5>
<p class="noindenta">If the <span class="literal">CLONE_SYSVSEM</span> flag is set, then the parent and child share a single list of System V semaphore undo values (<a href="ch47.xhtml#ch47lev1sec08">Section 47.8</a>). If this flag is not set, then the parent and child have separate undo lists, and the child&#8217;s undo list is initially empty.</p>
<p class="indent">The <span class="literal">CLONE_SYSVSEM</span> flag is available from kernel 2.6 onward, and provides the sharing semantics required by POSIX threads.</p>
<h5 class="h5" id="ch28lev3sec14"><strong>Per-process mount namespaces:</strong> <span class="literal"><span class="codestrong">CLONE_NEWNS</span></span></h5>
<p class="noindenta">From kernel 2.4.19 onward, Linux supports the notion of per-process <em>mount namespaces</em>. A mount namespace is the set of mount points maintained by calls to <em>mount()</em> and <em>umount()</em>. The mount namespace affects how pathnames are resolved to actual files, as well as the operation of system calls such as <em>chdir()</em> and <em>chroot()</em>.</p>
<p class="indent">By default, the parent and the child share a mount namespace, which means that changes to the namespace by one process using <em>mount()</em> and <em>umount()</em> are visible in the other process (as with <em>fork()</em> and <em>vfork()</em>). A privileged (<span class="literal">CAP_SYS_ADMIN</span>) process may specify the <span class="literal">CLONE_NEWNS</span> flag so that the child obtains a copy of the parent&#8217;s mount namespace. Thereafter, changes to the namespace by one process are not visible in the other process. (In earlier 2.4.<em>x</em> kernels, as well as in older kernels, we can consider all processes on the system as sharing a single system-wide mount namespace.)</p>
<p class="indent">Per-process mount namespaces can be used to create environments that are similar to <em>chroot()</em> jails, but which are more secure and flexible; for example, a jailed process can be provided with a mount point that is not visible to other processes on the system. Mount namespaces are also useful in setting up virtual server environments.</p>
<p class="indent">Specifying both <span class="literal">CLONE_NEWNS</span> and <span class="literal">CLONE_FS</span> in the same call to <em>clone()</em> is nonsensical and is not permitted.</p>
<h5 class="h5" id="ch28lev3sec15"><span epub:type="pagebreak" id="page_608"/><strong>Making the child&#8217;s parent the same as the caller&#8217;s:</strong> <span class="literal"><span class="codestrong">CLONE_PARENT</span></span></h5>
<p class="noindenta">By default, when we create a new process with <em>clone()</em>, the parent of that process (as returned by <em>getppid()</em>) is the process that calls <em>clone()</em> (as with <em>fork()</em> and <em>vfork()</em>). If the <span class="literal">CLONE_PARENT</span> flag is set, then the parent of the child will be the caller&#8217;s parent. In other words, <span class="literal">CLONE_PARENT</span> is the equivalent of setting <em>child.PPID = caller.PPID</em>. (In the default case, without <span class="literal">CLONE_PARENT</span>, it would be <em>child.PPID = caller.PID</em>.) The parent process (<em>child.PPID</em>) is the process that is signaled when the child terminates.</p>
<p class="indent">The <span class="literal">CLONE_PARENT</span> flag is available in Linux 2.4 and later. Originally, it was designed to be useful for POSIX threads implementations, but the 2.6 kernel pursued an approach to supporting threads (the use of <span class="literal">CLONE_THREAD</span>, described above) that removed the need for this flag.</p>
<h5 class="h5" id="ch28lev3sec16"><strong>Making the child&#8217;s PID the same as the parent&#8217;s PID:</strong> <span class="literal"><span class="codestrong">CLONE_PID</span></span> <strong>(obsolete)</strong></h5>
<p class="noindenta">If the <span class="literal">CLONE_PID</span> flag is set, then the child has the same process ID as the parent. If this flag is not set, then the parent and child have different process IDs (as with <em>fork()</em> and <em>vfork()</em>). Only the system boot process (process ID 0) may specify this flag; it is used when initializing a multiprocessor system.</p>
<p class="indent">The <span class="literal">CLONE_PID</span> flag is not intended for use in user applications. In Linux 2.6, it has been removed, and is superseded by <span class="literal">CLONE_IDLETASK</span>, which causes the process ID of the new process to be set to 0. <span class="literal">CLONE_IDLETASK</span> is available only for internal use within the kernel (if specified in the <em>flags</em> argument of <em>clone()</em>, it is ignored). It is used to create the invisible per-CPU <em>idle process</em>, of which multiple instances may exist on multiprocessor systems.</p>
<h5 class="h5" id="ch28lev3sec17"><strong>Process tracing:</strong> <span class="literal"><span class="codestrong">CLONE_PTRACE</span></span> <strong>and</strong> <span class="literal"><span class="codestrong">CLONE_UNTRACED</span></span></h5>
<p class="noindenta">If the <span class="literal">CLONE_PTRACE</span> flag is set and the calling process is being traced, then the child is also traced. For details on process tracing (used by debuggers and the <em>strace</em> command), refer to the <em>ptrace(2)</em> manual page.</p>
<p class="indent">From kernel 2.6 onward, the <span class="literal">CLONE_UNTRACED</span> flag can be set, meaning that a tracing process can&#8217;t force <span class="literal">CLONE_PTRACE</span> on this child. The <span class="literal">CLONE_UNTRACED</span> flag is used internally by the kernel in the creation of kernel threads.</p>
<h5 class="h5" id="ch28lev3sec18"><strong>Suspending the parent until the child exits or execs:</strong> <span class="literal"><span class="codestrong">CLONE_VFORK</span></span></h5>
<p class="noindenta">If the <span class="literal">CLONE_VFORK</span> flag is set, then the execution of the parent is suspended until the child releases its virtual memory resources via a call to <em>exec()</em> or <em>_exit()</em> (as with <em>vfork()</em>).</p>
<h5 class="h5" id="ch28lev3sec19"><strong>New <em>clone()</em> flags to support containers</strong></h5>
<p class="noindenta">A number of new <em>clone() flags</em> values were added in Linux 2.6.19 and later: <span class="literal">CLONE_IO</span>, <span class="literal">CLONE_NEWIPC</span>, <span class="literal">CLONE_NEWNET</span>, <span class="literal">CLONE_NEWPID</span>, <span class="literal">CLONE_NEWUSER</span>, and <span class="literal">CLONE_NEWUTS</span>. (See the <em>clone(2)</em> manual page for the details of these flags.)</p>
<p class="indent">Most of these flags are provided to support the implementation of <em>containers</em> ([<a href="bib.xhtml#bib05">Bhattiprolu et al., 2008</a>]). A container is a form of lightweight virtualization, whereby groups of processes running on the same kernel can be isolated from one another in environments that appear to be separate machines. Containers can also be nested, one inside the other. The containers approach contrasts with full virtualization, where each virtualized environment is running a distinct kernel.</p>
<p class="indent"><span epub:type="pagebreak" id="page_609"/>To implement containers, the kernel developers had to provide a layer of indirection within the kernel around each of the global system resources&#8212;such as process IDs, the networking stack, the identifiers returned by <em>uname()</em>, System V IPC objects, and user and group ID namespaces&#8212;so that each container can provide its own instance of these resources.</p>
<p class="indentb">There are various possible uses for containers, including the following:</p>
<p class="bull">&#8226; controlling allocation of resources on the system, such as network bandwidth or CPU time (e.g., one container might be granted 75% of the CPU time, while the other gets 25%);</p>
<p class="bull">&#8226; providing multiple lightweight virtual servers on a single host machine;</p>
<p class="bull">&#8226; freezing a container, so that execution of all processes in the container is suspended, later to be restarted, possibly after migrating to a different machine; and</p>
<p class="bull">&#8226; allowing an application&#8217;s state to be dumped (checkpointed) and then later restored (perhaps after an application crash, or a planned or unplanned system shutdown) to continue computation from the time of the checkpoint.</p>
<h5 class="h5" id="ch28lev3sec20"><strong>Use of <em>clone() flags</em></strong></h5>
<p class="noindentab">Roughly, we can say that a <em>fork()</em> corresponds to a <em>clone()</em> call with <em>flags</em> specified as just <span class="literal">SIGCHLD</span>, while a <em>vfork()</em> corresponds to a <em>clone()</em> call specifying <em>flags</em> as follows:</p>
<p class="programs">CLONE_VM | CLONE_VFORK | SIGCHLD</p>
<div class="block">
<p class="noindent">Since version 2.3.3, the <em>glibc</em> wrapper <em>fork()</em> provided as part of the NPTL threading implementation bypasses the kernel&#8217;s <em>fork()</em> system call and invokes <em>clone()</em>. This wrapper function invokes any fork handlers that have been established by the caller using <em>pthread_atfork()</em> (see <a href="ch33.xhtml#ch33lev1sec03">Section 33.3</a>).</p>
</div>
<p class="noindent">The LinuxThreads threading implementation uses <em>clone()</em> (with just the first four arguments) to create threads by specifying <em>flags</em> as follows:</p>
<p class="programs">CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND</p>
<p class="noindent">The NPTL threading implementation uses <em>clone()</em> (with all seven arguments) to create threads by specifying <em>flags</em> as follows:</p>
<p class="programs">CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND | CLONE_THREAD |<br/>CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_SYSVSEM</p>
<h4 class="h4" id="ch28lev2sec02"><strong>28.2.2 Extensions to <em>waitpid()</em> for Cloned Children</strong></h4>
<p class="noindentab">To wait for children produced by <em>clone()</em>, the following additional (Linux-specific) values can be included in the <em>options</em> bit-mask argument for <em>waitpid()</em>, <em>wait3()</em>, and <em>wait4()</em>:</p>
<p class="term"><span class="literal">__WCLONE</span></p>
<p class="termlist">If set, then wait for <em>clone</em> children only. If not set, then wait for <em>nonclone</em> children only. In this context, a <em>clone</em> child is one that delivers a signal other than <span class="literal">SIGCHLD</span> to its parent on termination. This bit is ignored if <span class="literal">__WALL</span> is also specified.</p>
<p class="term"><span epub:type="pagebreak" id="page_610"/><span class="literal">__WALL</span> (since Linux 2.4)</p>
<p class="termlist">Wait for all children, regardless of type (<em>clone</em> or <em>nonclone</em>).</p>
<p class="term"><span class="literal">__WNOTHREAD</span> (since Linux 2.4)</p>
<p class="termlist">By default, the wait calls wait not only for children of the calling process, but also for children of any other processes in the same thread group as the caller. Specifying the <span class="literal">__WNOTHREAD</span> flag limits the wait to children of the calling process.</p>
<p class="noindentt">These flags can&#8217;t be used with <em>waitid()</em>.</p>
<h3 class="h3" id="ch28lev1sec03"><strong>28.3 Speed of Process Creation</strong></h3>
<p class="noindenta"><a href="ch28.xhtml#ch28table3">Table 28-3</a> shows some speed comparisons for different methods of process creation. The results were obtained using a test program that executed a loop that repeatedly created a child process and then waited for it to terminate. The table compares the various methods using three different process memory sizes, as indicated by the <em>Total virtual memory</em> value. The differences in memory size were simulated by having the program <em>malloc()</em> additional memory on the heap prior to performing the timings.</p>
<div class="block">
<p class="noindent">Values for process size (<em>Total virtual memory</em>) in <a href="ch28.xhtml#ch28table3">Table 28-3</a> are taken from the <em>VSZ</em> value displayed by the command <em>ps &#8211;o &#8220;pid vsz cmd&#8221;</em>.</p>
</div>
<p class="tablecap"><a id="ch28table3"/><strong>Table 28-3:</strong> Time required to create 100,000 processes using <em>fork()</em>, <em>vfork()</em>, and <em>clone()</em></p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: middle;" class="table_th" rowspan="3"><p class="tablec"><strong>Method of process creation</strong></p></td>
<td style="vertical-align: top;" class="table_th1" colspan="6"><p class="tablec"><strong>Total Virtual Memory</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_th" colspan="2"><p class="tablec"><strong>1.70 MB</strong></p></td>
<td style="vertical-align: top;" class="table_th" colspan="2"><p class="tablec"><strong>2.70 MB</strong></p></td>
<td style="vertical-align: top;" class="table_th1" colspan="2"><p class="tablec"><strong>11.70 MB</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong>Time (secs)</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong>Rate</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong>Time (secs)</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong>Rate</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong>Time (secs)</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="tablec"><strong>Rate</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><em>fork()</em></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">22.27</span><br/><span class="literal">(7.99)</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">4544</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">26.38</span><br/><span class="literal">(8.98)</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">4135</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">126.93</span><br/><span class="literal">(52.55)</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="tablec"><span class="literal">1276</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><em>vfork()</em></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">3.52</span><br/><span class="literal">(2.49)</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">28955</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">3.55</span><br/><span class="literal">(2.50)</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">28621</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">3.53</span><br/><span class="literal">(2.51)</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="tablec"><span class="literal">28810</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><em>clone()</em></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">2.97</span><br/><span class="literal">(2.14)</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">34333</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">2.98</span><br/><span class="literal">(2.13)</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">34217</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">2.93</span><br/><span class="literal">(2.10)</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="tablec"><span class="literal">34688</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><em>fork() + exec()</em></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">135.72</span><br/><span class="literal">(12.39)</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">764</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">146.15</span><br/><span class="literal">(16.69)</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">719</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec"><span class="literal">260.34</span><br/><span class="literal">(61.86)</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="tablec"><span class="literal">435</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><em>vfork() + exec()</em></p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec"><span class="literal">107.36</span><br/><span class="literal">(6.27)</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec"><span class="literal">969</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec"><span class="literal">107.81</span><br/><span class="literal">(6.35)</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec"><span class="literal">964</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec"><span class="literal">107.97</span><br/><span class="literal">(6.38)</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="tablec"><span class="literal">960</span></p></td>
</tr>
</tbody>
</table>
<p class="noindentb">For each process size, two types of statistics are provided in <a href="ch28.xhtml#ch28table3">Table 28-3</a>:</p>
<p class="bull">&#8226; The first statistic consists of two time measurements. The main (larger) measurement is the total elapsed (real) time to perform 100,000 process creation operations. The second time, shown in parentheses, is the CPU time consumed by the parent process. Since these tests were run on an otherwise unloaded machine, the difference between the two time values represents the total time consumed by child processes created during the test.</p>
<p class="bull"><span epub:type="pagebreak" id="page_611"/>&#8226; The second statistic for each test shows the rate at which processes were created per (real) second.</p>
<p class="noindentt">Statistics shown are the average of 20 runs for each case, and were obtained using kernel 2.6.27 running on an x86-32 system.</p>
<p class="indent">The first three data rows show times for simple process creation (without execing a new program in the child). In each case, the child processes exit immediately after they are created, and the parent waits for each child to terminate before creating the next.</p>
<p class="indent">The first row contains values for the <em>fork()</em> system call. From the data, we can see that as a process gets larger, <em>fork()</em> takes longer. These time differences show the additional time required to duplicate increasingly large page tables for the child and mark all data, heap, and stack segment page entries as read-only. (No <em>pages</em> are copied, since the child doesn&#8217;t modify its data or stack segments.)</p>
<p class="indent">The second data row provides the same statistics for <em>vfork()</em>. We see that as the process size increases, the times remain the same&#8212;because no page tables or pages are copied during a <em>vfork()</em>, the virtual memory size of the calling process has no effect. The difference between the <em>fork()</em> and <em>vfork()</em> statistics represents the total time required for copying process page tables in each case.</p>
<div class="block">
<p class="noindent">Small variations in the <em>vfork()</em> and <em>clone()</em> values in <a href="ch28.xhtml#ch28table3">Table 28-3</a> are due to sampling errors and scheduling variations. Even when creating processes up to 300 MB in size, times for these two system calls remained constant.</p>
</div>
<p class="noindent">The third data row shows statistics for process creation using <em>clone()</em> with the following flags:</p>
<p class="programs">CLONE_VM | CLONE_VFORK | CLONE_FS | CLONE_SIGHAND | CLONE_FILES</p>
<p class="noindent">The first two of these flags emulate the behavior of <em>vfork()</em>. The remaining flags specify that the parent and child should share their file-system attributes (umask, root directory, and current working directory), table of signal dispositions, and table of open file descriptors. The difference between the <em>clone()</em> and <em>vfork()</em> data represents the small amount of additional work performed in <em>vfork()</em> to copy this information into the child process. The cost of copying file-system attributes and the table of signal dispositions is constant. However, the cost of copying the table of open file descriptors varies according to the number of descriptors. For example, opening 100 file descriptors in the parent process raised the <em>vfork()</em> real time (in the first column of the table) from 3.52 to 5.04 seconds, but left times for <em>clone()</em> unaffected.</p>
<div class="block">
<p class="noindent">The timings for <em>clone()</em> are for the <em>glibc clone()</em> wrapper function, rather than direct calls to <em>sys_clone()</em>. Other tests (not summarized here) revealed negligible timing differences between using <em>sys_clone()</em> and calling <em>clone()</em> with a child function that immediately exited.</p>
</div>
<p class="noindentb">The differences between <em>fork()</em> and <em>vfork()</em> are quite marked. However, the following points should be kept in mind:</p>
<p class="bull">&#8226; The final data column, where <em>vfork()</em> is more than 30 times faster than <em>fork()</em>, corresponds to a large process. Typical processes would lie somewhere closer to the first two columns of the table.</p>
<p class="bull"><span epub:type="pagebreak" id="page_612"/>&#8226; Because the times required for process creation are typically much smaller than those required for an <em>exec()</em>, the differences are much less marked if a <em>fork()</em> or <em>vfork()</em> is followed by an <em>exec()</em>. This is illustrated by the final pair of data rows in <a href="ch28.xhtml#ch28table3">Table 28-3</a>, where each child performs an <em>exec()</em>, rather than immediately exiting. The program execed was the <em>true</em> command (<span class="literal">/bin/true</span>, chosen because it produces no output). In this case, we see that the relative differences between <em>fork()</em> and <em>vfork()</em> are much lower.</p>
<div class="block">
<p class="noindent">In fact, the data shown in <a href="ch28.xhtml#ch28table3">Table 28-3</a> doesn&#8217;t reveal the full cost of an <em>exec()</em>, because the child execs the same program in each loop of the test. As a result, the cost of disk I/O to read the program into memory is essentially eliminated, because the program will be read into the kernel buffer cache on the first <em>exec()</em>, and then remain there. If each loop of the test execed a different program (e.g., a differently named copy of the same program), then we would observe a greater cost for an <em>exec()</em>.</p>
</div>
<h3 class="h3" id="ch28lev1sec04"><strong>28.4 Effect of <em>exec()</em> and <em>fork()</em> on Process Attributes</strong></h3>
<p class="noindentab">A process has numerous attributes, some of which we have already described in earlier chapters, and others that we explore in later chapters. Regarding these attributes, two questions arise:</p>
<p class="bull">&#8226; What happens to these attributes when a process performs an <em>exec()</em>?</p>
<p class="bull">&#8226; Which attributes are inherited by a child when a <em>fork()</em> is performed?</p>
<p class="noindentt"><a href="ch28.xhtml#ch28table4">Table 28-4</a> summarizes the answers to these questions. The <em>exec()</em> column indicates which attributes are preserved during an <em>exec()</em>. The <em>fork()</em> column indicates which attributes are inherited (or in some cases, shared) by a child after <em>fork()</em>. Other than the attributes indicated as being Linux-specific, all listed attributes appear in standard UNIX implementations, and their handling during <em>exec()</em> and <em>fork()</em> conforms to the requirements of SUSv3.</p>
<p class="tablecap"><a id="ch28table4"/><strong>Table 28-4:</strong> Effect of <em>exec()</em> and <em>fork()</em> on process attributes</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Process attribute</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><em>exec()</em></strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><em>fork()</em></strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Interfaces affecting attribute; additional notes</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_2b" colspan="4"><p class="table"><strong>Process address space</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Text segment</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Shared</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Child process shares text segment with parent.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Stack segment</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Function entry/exit; <em>alloca()</em>, <em>longjmp()</em>, <em>siglongjmp()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Data and heap segments</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>brk()</em>, <em>sbrk()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Environment variables</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">See notes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>putenv()</em>, <em>setenv()</em>; direct modification of <em>environ</em>. Overwritten by <em>execle()</em> and <em>execve()</em> and preserved by remaining <em>exec()</em> calls.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Memory mappings</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes; see notes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>mmap()</em>, <em>munmap()</em>. A mapping&#8217;s <span class="literal">MAP_NORESERVE</span> flag is inherited across <em>fork()</em>. Mappings that have been marked with <em>madvise(MADV_DONTFORK)</em> are not inherited across <em>fork()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">Memory locks</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table"><em>mlock()</em>, <em>munlock()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_2b" colspan="4"><p class="table"><span epub:type="pagebreak" id="page_613"/><strong>Process identifiers and credentials</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Process ID</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Parent process ID</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Process group ID</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>setpgid()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Session ID</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>setsid()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Real IDs</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>setuid()</em>, <em>setgid()</em>, and related calls.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Effective and saved set IDs</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">See notes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>setuid()</em>, <em>setgid()</em>, and related calls. <a href="ch09.xhtml#ch09">Chapter 9</a> explains how <em>exec()</em> affects these IDs.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">Supplementary group IDs</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table"><em>setgroups()</em>, <em>initgroups()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_2b" colspan="4"><p class="table"><strong>Files, file I/O, and directories</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Open file descriptors</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">See notes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>open()</em>, <em>close()</em>, <em>dup()</em>, <em>pipe()</em>, <em>socket()</em>, and so on. File descriptors are preserved across <em>exec()</em> unless marked close-on-exec. Descriptors in child and parent refer to same open file descriptions; see <a href="ch05.xhtml#ch05lev1sec04">Section 5.4</a>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Close-on-exec flag</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes (if off)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>fcntl(F_SETFD)</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">File offsets</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Shared</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>lseek()</em>, <em>read()</em>, <em>write()</em>, <em>readv()</em>, <em>writev()</em>. Child shares file offsets with parent.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Open file status flags</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Shared</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>open(), fcntl(F_SETFL)</em>. Child shares open file status flags with parent.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Asynchronous I/O operations</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">See notes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>aio_read()</em>, <em>aio_write()</em>, and related calls. Outstanding operations are canceled during an <em>exec()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">Directory streams</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Yes; see notes</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table"><em>opendir()</em>, <em>readdir()</em>. SUSv3 states that child gets a copy of parent&#8217;s directory streams, but these copies may or may not share the directory stream position. On Linux, the directory stream position is not shared.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_2b" colspan="4"><p class="table"><strong>File system</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Current working directory</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>chdir()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Root directory</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>chroot()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">File mode creation mask</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table"><em>umask()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_2b" colspan="4"><p class="table"><strong>Signals</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Signal dispositions</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">See notes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>signal()</em>, <em>sigaction()</em>. During an <em>exec()</em>, signals with dispositions set to default or ignore are unchanged; caught signals revert to their default dispositions. See <a href="ch27.xhtml#ch27lev1sec05">Section 27.5</a>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Signal mask</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Signal delivery, <em>sigprocmask()</em>, <em>sigaction()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Pending signal set</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Signal delivery; <em>raise()</em>, <em>kill()</em>, <em>sigqueue()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">Alternate signal stack</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table"><em>sigaltstack()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_2b" colspan="4"><p class="table"><span epub:type="pagebreak" id="page_614"/><strong>Timers</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Interval timers</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>setitimer()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Timers set by <em>alarm()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>alarm()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">POSIX timers</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table"><em>timer_create()</em> and related calls.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_2b" colspan="4"><p class="table"><strong>POSIX threads</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Threads</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">See notes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">During <em>fork()</em>, only calling thread is replicated in child.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Thread cancelability state and type</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">After an <em>exec()</em>, the cancelability type and state are reset to <span class="literal">PTHREAD_CANCEL_ENABLE</span> and <span class="literal">PTHREAD_CANCEL_DEFERRED</span>, respectively</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">Mutexes and condition variables</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">See <a href="ch33.xhtml#ch33lev1sec03">Section 33.3</a> for details of the treatment of mutexes and other thread resources during <em>fork()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_2b" colspan="4"><p class="table"><strong>Priority and scheduling</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Nice value</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>nice()</em>, <em>setpriority()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">Scheduling policy and priority</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table"><em>sched_setscheduler()</em>, <em>sched_setparam()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_2b" colspan="4"><p class="table"><strong>Resources and CPU time</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Resource limits</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>setrlimit()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Process and child CPU times</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">As returned by <em>times()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">Resource usages</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">As returned by <em>getrusage()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_2b" colspan="4"><p class="table"><strong>Interprocess communication</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">System V shared memory segments</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>shmat()</em>, <em>shmdt()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">POSIX shared memory</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>shm_open()</em> and related calls.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">POSIX message queues</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>mq_open()</em> and related calls. Descriptors in child and parent refer to same open message queue descriptions. A child doesn&#8217;t inherit its parent&#8217;s message notification registrations.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">POSIX named semaphores</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Shared</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>sem_open()</em> and related calls. Child shares references to same semaphores as parent.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">POSIX unnamed semaphores</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">See notes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>sem_init()</em> and related calls. If semaphores are in a shared memory region, then child shares semaphores with parent; otherwise, child has its own copy of the semaphores.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">System V semaphore adjustments</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>semop()</em>. See <a href="ch47.xhtml#ch47lev1sec08">Section 47.8</a>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">File locks</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">See notes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>flock()</em>. Child inherits a reference to the same lock as parent.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">Record locks</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">See notes</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table"><em>fcntl(F_SETLK)</em>. Locks are preserved across <em>exec()</em> unless a file descriptor referring to the file is marked close-on-exec; see <a href="ch55.xhtml#ch55lev2sec07">Section 55.3.5</a>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_2b" colspan="4"><p class="table"><span epub:type="pagebreak" id="page_615"/><strong>Miscellaneous</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Locale settings</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>setlocale()</em>. As part of C run-time initialization, the equivalent of <em>setlocale(LC_ALL, &#8220;C&#8221;)</em> is executed after a new program is execed.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Floating-point environment</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">When a new program is execed, the state of the floating-point environment is reset to the default; see <em>fenv(3)</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Controlling terminal</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">Exit handlers</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table"><em>atexit()</em>, <em>on_exit()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_2b" colspan="4"><p class="table"><strong>Linux-specific</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">File-system IDs</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">See notes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>setfsuid()</em>, <em>setfsgid()</em>. These IDs are also changed any time the corresponding effective IDs are changed.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>timerfd</em> timers</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">See notes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>timerfd_create()</em>; child inherits file descriptors referring to same timers as parent.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Capabilities</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">See notes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>capset()</em>. The handling of capabilities during an <em>exec()</em> is described in <a href="ch39.xhtml#ch39lev1sec05">Section 39.5</a>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Capability bounding set</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Capabilities <em>securebits</em> flags</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">See notes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">All <em>securebits</em> flags are preserved during an <em>exec()</em> except <span class="literal">SECBIT_KEEP_CAPS</span>, which is always cleared.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">CPU affinity</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>sched_setaffinity()</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SCHED_RESET_ON_FORK</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">See <a href="ch35.xhtml#ch35lev2sec05">Section 35.3.2</a>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Allowed CPUs</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">See <em>cpuset(7)</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Allowed memory nodes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">See <em>cpuset(7)</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Memory policy</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">See <em>set_mempolicy(2)</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">File leases</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">See notes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>fcntl(F_SETLEASE)</em>. Child inherits a reference to the same lease as parent.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Directory change notifications</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">The <em>dnotify</em> API, available via <em>fcntl(F_NOTIFY)</em>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>prctl(PR_SET_DUMPABLE)</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">See notes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">During an <em>exec()</em>, the <span class="literal">PR_SET_DUMPABLE</span> flag is set, unless execing a set-user-ID or set-group-ID program, in which case it is cleared.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>prctl(PR_SET_PDEATHSIG)</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>prctl(PR_SET_NAME)</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">oom_adj</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">See <a href="ch49.xhtml#ch49lev1sec09">Section 49.9</a>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">coredump_filter</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">See <a href="ch22.xhtml#ch22lev1sec01">Section 22.1</a>.</p></td>
</tr>
</tbody>
</table>
<h3 class="h3" id="ch28lev1sec05"><span epub:type="pagebreak" id="page_616"/><strong>28.5 Summary</strong></h3>
<p class="noindenta">When process accounting is enabled, the kernel writes an accounting record to a file for each process that terminates on the system. This record contains statistics on the resources used by the process.</p>
<p class="indent">Like <em>fork()</em>, the Linux-specific <em>clone()</em> system call creates a new process, but allows finer control over which attributes are shared between the parent and child. This system call is used primarily for implementing threading libraries.</p>
<p class="indent">We compared the speed of process creation using <em>fork()</em>, <em>vfork()</em>, and <em>clone()</em>. Although <em>vfork()</em> is faster than <em>fork()</em>, the time difference between these system calls is small by comparison with the time required for a child process to do a subsequent <em>exec()</em>.</p>
<p class="indent">When a child process is created via <em>fork()</em>, it inherits copies of (or in some cases shares) certain process attributes from its parent, while other process attributes are not inherited. For example, a child inherits copies of its parent&#8217;s file descriptor table and signal dispositions, but doesn&#8217;t inherit its parent&#8217;s interval timers, record locks, or set of pending signals. Correspondingly, when a process performs an <em>exec()</em>, certain process attributes remain unchanged, while others are reset to defaults. For example, the process ID remains the same, file descriptors remain open (unless marked close-on-exec), interval timers are preserved, and pending signals remain pending, but handled signals are reset to their default disposition and shared memory segments are detached.</p>
<h5 class="h5" id="ch28lev3sec21"><strong>Further information</strong></h5>
<p class="noindenta">Refer to the sources of further information listed in <a href="ch24.xhtml#ch24lev1sec06">Section 24.6</a>. <a href="ch17.xhtml#ch17">Chapter 17</a> of [<a href="bib.xhtml#bib27">Frisch, 2002</a>] describes the administration of process accounting, as well as some of the variations across UNIX implementations. [<a href="bib.xhtml#bib09">Bovet &#38; Cesati, 2005</a>] describes the implementation of the <em>clone()</em> system call.</p>
<h3 class="h3" id="ch28lev1sec06"><strong>28.6 Exercise</strong></h3>
<p class="exer"><a id="ch28exe1"/><strong>28-1.</strong>&#160;&#160;&#160;Write a program to see how fast the <em>fork()</em> and <em>vfork()</em> system calls are on your system. Each child process should immediately exit, and the parent should <em>wait()</em> on each child before creating the next. Compare the relative differences for these two system calls with those of <a href="ch28.xhtml#ch28table3">Table 28-3</a>. The shell built-in command <em>time</em> can be used to measure the execution time of a program.</p>
</body>
</html>
