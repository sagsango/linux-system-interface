<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch30"><span epub:type="pagebreak" id="page_631"/><strong><span class="big">30</span></strong><br/><strong>THREADS: THREAD SYNCHRONIZATION</strong></h2>
<p class="noindenta">In this chapter, we describe two tools that threads can use to synchronize their actions: mutexes and condition variables. Mutexes allow threads to synchronize their use of a shared resource, so that, for example, one thread doesn&#8217;t try to access a shared variable at the same time as another thread is modifying it. Condition variables perform a complementary task: they allow threads to inform each other that a shared variable (or other shared resource) has changed state.</p>
<h3 class="h3" id="ch30lev1sec01"><strong>30.1 Protecting Accesses to Shared Variables: Mutexes</strong></h3>
<p class="noindenta">One of the principal advantages of threads is that they can share information via global variables. However, this easy sharing comes at a cost: we must take care that multiple threads do not attempt to modify the same variable at the same time, or that one thread doesn&#8217;t try to read the value of a variable while another thread is modifying it. The term <em>critical section</em> is used to refer to a section of code that accesses a shared resource and whose execution should be <em>atomic</em>; that is, its execution should not be interrupted by another thread that simultaneously accesses the same shared resource.</p>
<p class="indent"><a href="ch30.xhtml#ch30ex1">Listing 30-1</a> provides a simple example of the kind of problems that can occur when shared resources are not accessed atomically. This program creates two threads, each of which executes the same function. The function executes a loop that repeatedly increments a global variable, <em>glob</em>, by copying <em>glob</em> into the local variable <span epub:type="pagebreak" id="page_632"/><em>loc</em>, incrementing <em>loc</em>, and copying <em>loc</em> back to <em>glob</em>. (Since <em>loc</em> is an automatic variable allocated on the per-thread stack, each thread has its own copy of this variable.) The number of iterations of the loop is determined by the command-line argument supplied to the program, or by a default value, if no argument is supplied.</p>
<p class="examplet"><a id="ch30ex1"/><strong>Listing 30-1:</strong> Incorrectly incrementing a global variable from two threads</p>
<p class="programsli">_____________________________________________________ <span class="codestrong">threads/thread_incr.c</span><br/><br/>#include &lt;pthread.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static volatile int glob = 0;&#160;&#160;&#160;/* "volatile" prevents compiler optimizations<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;of arithmetic operations on 'glob' */<br/><br/>static void *&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Loop 'arg' times incrementing 'glob' */<br/>threadFunc(void *arg)<br/>{<br/>&#160;&#160;&#160;&#160;int loops = *((int *) arg);<br/>&#160;&#160;&#160;&#160;int loc, j;<br/><br/>&#160;&#160;&#160;&#160;for (j = 0; j &lt; loops; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;loc = glob;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;loc++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;glob = loc;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;return NULL;<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;pthread_t t1, t2;<br/>&#160;&#160;&#160;&#160;int loops, s;<br/><br/>&#160;&#160;&#160;&#160;loops = (argc &gt; 1) ? getInt(argv[1], GN_GT_0, "num-loops") : 10000000;<br/><br/>&#160;&#160;&#160;&#160;s = pthread_create(&#38;t1, NULL, threadFunc, &#38;loops);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_create");<br/>&#160;&#160;&#160;&#160;s = pthread_create(&#38;t2, NULL, threadFunc, &#38;loops);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_create");<br/><br/>&#160;&#160;&#160;&#160;s = pthread_join(t1, NULL);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_join");<br/>&#160;&#160;&#160;&#160;s = pthread_join(t2, NULL);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_join");<br/><br/>&#160;&#160;&#160;&#160;printf("glob = %d\n", glob);<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_____________________________________________________ <span class="codestrong">threads/thread_incr.c</span></p>
<div class="image"><span epub:type="pagebreak" id="page_633"/><img src="../images/f30-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch30fig1"/><strong>Figure 30-1:</strong> Two threads incrementing a global variable without synchronization</p>
<p class="noindent">When we run the program in <a href="ch30.xhtml#ch30ex1">Listing 30-1</a> specifying that each thread should increment the variable 1000 times, all seems well:</p>
<p class="programs">$ <span class="codestrong">./thread_incr 1000</span><br/>glob = 2000</p>
<p class="noindent">However, what has probably happened here is that the first thread completed all of its work and terminated before the second thread even started. When we ask both threads to do a lot more work, we see a rather different result:</p>
<p class="programs">$ <span class="codestrong">./thread_incr 10000000</span><br/>glob = 16517656</p>
<p class="noindent">At the end of this sequence, the value of <em>glob</em> should have been 20 million. The problem here results from execution sequences such as the following (see also <a href="ch30.xhtml#ch30fig1">Figure 30-1</a>, above):</p>
<ol>
<li class="order"><p class="orderp">Thread 1 fetches the current value of <em>glob</em> into its local variable <em>loc</em>. Let&#8217;s assume that the current value of <em>glob</em> is 2000.</p></li>
<li class="order"><p class="orderp">The scheduler time slice for thread 1 expires, and thread 2 commences execution.</p></li>
<li class="order"><p class="orderp">Thread 2 performs multiple loops in which it fetches the current value of <em>glob</em> into its local variable <em>loc</em>, increments <em>loc</em>, and assigns the result to <em>glob</em>. In the first of these loops, the value fetched from <em>glob</em> will be 2000. Let&#8217;s suppose that by the time the time slice for thread 2 has expired, <em>glob</em> has been increased to 3000.</p></li>
<li class="order"><p class="orderp"><span epub:type="pagebreak" id="page_634"/>Thread 1 receives another time slice and resumes execution where it left off. Having previously (step 1) copied the value of <em>glob</em> (2000) into its <em>loc</em>, it now increments <em>loc</em> and assigns the result (2001) to <em>glob</em>. At this point, the effect of the increment operations performed by thread 2 is lost.</p></li>
</ol>
<p class="noindent">If we run the program in <a href="ch30.xhtml#ch30ex1">Listing 30-1</a> multiple times with the same command-line argument, we see that the printed value of <em>glob</em> fluctuates wildly:</p>
<p class="programs">$ <span class="codestrong">./thread_incr 10000000</span><br/>glob = 10880429<br/>$ <span class="codestrong">./thread_incr 10000000</span><br/>glob = 13493953</p>
<p class="noindent">This nondeterministic behavior is a consequence of the vagaries of the kernel&#8217;s CPU scheduling decisions. In complex programs, this nondeterministic behavior means that such errors may occur only rarely, be hard to reproduce, and therefore be difficult to find.</p>
<p class="indent">It might seem that we could eliminate the problem by replacing the three statements inside the <span class="literal">for</span> loop in the <em>threadFunc()</em> function in <a href="ch30.xhtml#ch30ex1">Listing 30-1</a> with a single statement:</p>
<p class="programs">glob++;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* or: ++glob; */</p>
<p class="noindent">However, on many hardware architectures (e.g., RISC architectures), the compiler would still need to convert this single statement into machine code whose steps are equivalent to the three statements inside the loop in <em>threadFunc()</em>. In other words, despite its simple appearance, even a C increment operator may not be atomic, and it might demonstrate the behavior that we described above.</p>
<p class="indent">To avoid the problems that can occur when threads try to update a shared variable, we must use a <em>mutex</em> (short for <em>mutual exclusion</em>) to ensure that only one thread at a time can access the variable. More generally, mutexes can be used to ensure atomic access to any shared resource, but protecting shared variables is the most common use.</p>
<p class="indent">A mutex has two states: <em>locked</em> and <em>unlocked</em>. At any moment, at most one thread may hold the lock on a mutex. Attempting to lock a mutex that is already locked either blocks or fails with an error, depending on the method used to place the lock.</p>
<p class="indent">When a thread locks a mutex, it becomes the owner of that mutex. Only the mutex owner can unlock the mutex. This property improves the structure of code that uses mutexes and also allows for some optimizations in the implementation of mutexes. Because of this ownership property, the terms <em>acquire</em> and <em>release</em> are sometimes used synonymously for lock and unlock.</p>
<p class="indentb">In general, we employ a different mutex for each shared resource (which may consist of multiple related variables), and each thread employs the following protocol for accessing a resource:</p>
<p class="bull">&#8226; lock the mutex for the shared resource;</p>
<p class="bull">&#8226; access the shared resource; and</p>
<p class="bull">&#8226; unlock the mutex.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_635"/>If multiple threads try to execute this block of code (a <em>critical section</em>), the fact that only one thread can hold the mutex (the others remain blocked) means that only one thread at a time can enter the block, as illustrated in <a href="ch30.xhtml#ch30fig2">Figure 30-2</a>.</p>
<div class="image"><img src="../images/f30-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch30fig2"/><strong>Figure 30-2:</strong> Using a mutex to protect a critical section</p>
<p class="noindent">Finally, note that mutex locking is advisory, rather than mandatory. By this, we mean that a thread is free to ignore the use of a mutex and simply access the corresponding shared variable(s). In order to safely handle shared variables, all threads must cooperate in their use of a mutex, abiding by its locking rules.</p>
<h4 class="h4" id="ch30lev2sec01"><strong>30.1.1 Statically Allocated Mutexes</strong></h4>
<p class="noindenta">A mutex can either be allocated as a static variable or be created dynamically at run time (for example, in a block of memory allocated via <em>malloc()</em>). Dynamic mutex creation is somewhat more complex, and we delay discussion of it until <a href="ch30.xhtml#ch30lev2sec05">Section 30.1.5</a>.</p>
<p class="indent">A mutex is a variable of the type <em>pthread_mutex_t</em>. Before it can be used, a mutex must always be initialized. For a statically allocated mutex, we can do this by assigning it the value <span class="literal">PTHREAD_MUTEX_INITIALIZER</span>, as in the following example:</p>
<p class="programs">pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;</p>
<div class="block">
<p class="noindent">According to SUSv3, applying the operations that we describe in the remainder of this section to a <em>copy</em> of a mutex yields results that are undefined. Mutex operations should always be performed only on the original mutex that has been statically initialized using <span class="literal">PTHREAD_MUTEX_INITIALIZER</span> or dynamically initialized using <em>pthread_mutex_init()</em> (described in <a href="ch30.xhtml#ch30lev2sec05">Section 30.1.5</a>).</p>
</div>
<h4 class="h4" id="ch30lev2sec02"><strong>30.1.2 Locking and Unlocking a Mutex</strong></h4>
<p class="noindenta">After initialization, a mutex is unlocked. To lock and unlock a mutex, we use the <em>pthread_mutex_lock()</em> and <em>pthread_mutex_unlock()</em> functions.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_636"/>#include &lt;pthread.h&gt;<br/><br/>int <span class="codestrong">pthread_mutex_lock</span>(pthread_mutex_t *<span class="font1">mutex</span>);<br/>int <span class="codestrong">pthread_mutex_unlock</span>(pthread_mutex_t *<span class="font1">mutex</span>);</p>
<p class="right">Both return 0 on success, or a positive error number on error</p>
</div>
<p class="noindent">To lock a mutex, we specify the mutex in a call to <em>pthread_mutex_lock()</em>. If the mutex is currently unlocked, this call locks the mutex and returns immediately. If the mutex is currently locked by another thread, then <em>pthread_mutex_lock()</em> blocks until the mutex is unlocked, at which point it locks the mutex and returns.</p>
<p class="indent">If the calling thread itself has already locked the mutex given to <em>pthread_mutex_lock()</em>, then, for the default type of mutex, one of two implementation-defined possibilities may result: the thread deadlocks, blocked trying to lock a mutex that it already owns, or the call fails, returning the error <span class="literal">EDEADLK</span>. On Linux, the thread deadlocks by default. (We describe some other possible behaviors when we look at mutex types in <a href="ch30.xhtml#ch30lev2sec07">Section 30.1.7</a>.)</p>
<p class="indent">The <em>pthread_mutex_unlock()</em> function unlocks a mutex previously locked by the calling thread. It is an error to unlock a mutex that is not currently locked, or to unlock a mutex that is locked by another thread.</p>
<p class="indent">If more than one other thread is waiting to acquire the mutex unlocked by a call to <em>pthread_mutex_unlock()</em>, it is indeterminate which thread will succeed in acquiring it.</p>
<h5 class="h5" id="ch30lev3sec01"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch30.xhtml#ch30ex2">Listing 30-2</a> is a modified version of the program in <a href="ch30.xhtml#ch30ex1">Listing 30-1</a>. It uses a mutex to protect access to the global variable <em>glob</em>. When we run this program with a similar command line to that used earlier, we see that <em>glob</em> is always reliably incremented:</p>
<p class="programs">$ <span class="codestrong">./thread_incr_mutex 10000000</span><br/>glob = 20000000</p>
<p class="examplet"><a id="ch30ex2"/><strong>Listing 30-2:</strong> Using a mutex to protect access to a global variable</p>
<p class="programsli">________________________________________________ <span class="codestrong">threads/thread_incr_mutex.c</span><br/><br/>#include &lt;pthread.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static volatile int glob = 0;<br/>static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;<br/><br/>static void *&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Loop 'arg' times incrementing 'glob' */<br/>threadFunc(void *arg)<br/>{<br/>&#160;&#160;&#160;&#160;int loops = *((int *) arg);<br/>&#160;&#160;&#160;&#160;int loc, j, s;<br/><br/>&#160;&#160;&#160;&#160;for (j = 0; j &lt; loops; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_mutex_lock(&#38;mtx);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_lock");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;loc = glob;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;loc++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;glob = loc;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_mutex_unlock(&#38;mtx);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_unlock");<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;return NULL;<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;pthread_t t1, t2;<br/>&#160;&#160;&#160;&#160;int loops, s;<br/><br/>&#160;&#160;&#160;&#160;loops = (argc &gt; 1) ? getInt(argv[1], GN_GT_0, "num-loops") : 10000000;<br/><br/>&#160;&#160;&#160;&#160;s = pthread_create(&#38;t1, NULL, threadFunc, &#38;loops);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_create");<br/>&#160;&#160;&#160;&#160;s = pthread_create(&#38;t2, NULL, threadFunc, &#38;loops);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_create");<br/><br/>&#160;&#160;&#160;&#160;s = pthread_join(t1, NULL);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_join");<br/>&#160;&#160;&#160;&#160;s = pthread_join(t2, NULL);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_join");<br/><br/>&#160;&#160;&#160;&#160;printf("glob = %d\n", glob);<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>________________________________________________ <span class="codestrong">threads/thread_incr_mutex.c</span></p>
<h5 class="h5" id="ch30lev3sec02"><span epub:type="pagebreak" id="page_637"/><strong><em>pthread_mutex_trylock()</em> and <em>pthread_mutex_timedlock()</em></strong></h5>
<p class="noindenta">The Pthreads API provides two variants of the <em>pthread_mutex_lock()</em> function: <em>pthread_mutex_trylock()</em> and <em>pthread_mutex_timedlock()</em>. (See the manual pages for prototypes of these functions.)</p>
<p class="indent">The <em>pthread_mutex_trylock()</em> function is the same as <em>pthread_mutex_lock()</em>, except that if the mutex is currently locked, <em>pthread_mutex_trylock()</em> fails, returning the error <span class="literal">EBUSY</span>.</p>
<p class="indent">The <em>pthread_mutex_timedlock()</em> function is the same as <em>pthread_mutex_lock()</em>, except that the caller can specify an additional argument, <em>abstime</em>, that places a limit on the time that the thread will sleep while waiting to acquire the mutex. If the time interval specified by its <em>abstime</em> argument expires without the caller becoming the owner of the mutex, <em>pthread_mutex_timedlock()</em> returns the error <span class="literal">ETIMEDOUT</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_638"/>The <em>pthread_mutex_trylock()</em> and <em>pthread_mutex_timedlock()</em> functions are much less frequently used than <em>pthread_mutex_lock()</em>. In most well-designed applications, a thread should hold a mutex for only a short time, so that other threads are not prevented from executing in parallel. This guarantees that other threads that are blocked on the mutex will soon be granted a lock on the mutex. A thread that uses <em>pthread_mutex_trylock()</em> to periodically poll the mutex to see if it can be locked risks being starved of access to the mutex while other queued threads are successively granted access to the mutex via <em>pthread_mutex_lock()</em>.</p>
<h4 class="h4" id="ch30lev2sec03"><strong>30.1.3 Performance of Mutexes</strong></h4>
<p class="noindenta">What is the cost of using a mutex? We have shown two different versions of a program that increments a shared variable: one without mutexes (<a href="ch30.xhtml#ch30ex1">Listing 30-1</a>) and one with mutexes (<a href="ch30.xhtml#ch30ex2">Listing 30-2</a>). When we run these two programs on an x86-32 system running Linux 2.6.31 (with NPTL), we find that the version without mutexes requires a total of 0.35 seconds to execute 10 million loops in each thread (and produces the wrong result), while the version with mutexes requires 3.1 seconds.</p>
<p class="indent">At first, this seems expensive. But, consider the main loop executed by the version that does not employ a mutex (<a href="ch30.xhtml#ch30ex1">Listing 30-1</a>). In that version, the <em>threadFunc()</em> function executes a <span class="literal">for</span> loop that increments a loop control variable, compares that variable against another variable, performs two assignments and another increment operation, and then branches back to the top of the loop. The version that uses a mutex (<a href="ch30.xhtml#ch30ex2">Listing 30-2</a>) performs the same steps, and locks and unlocks the mutex each time around the loop. In other words, the cost of locking and unlocking a mutex is somewhat less than ten times the cost of the operations that we listed for the first program. This is relatively cheap. Furthermore, in the typical case, a thread would spend much more time doing other work, and perform relatively fewer mutex lock and unlock operations, so that the performance impact of using a mutex is not significant in most applications.</p>
<p class="indent">To put this further in perspective, running some simple test programs on the same system showed that 20 million loops locking and unlocking a file region using <em>fcntl()</em> (<a href="ch55.xhtml#ch55lev1sec03">Section 55.3</a>) require 44 seconds, and 20 million loops incrementing and decrementing a System V semaphore (<a href="ch47.xhtml#ch47">Chapter 47</a>) require 28 seconds. The problem with file locks and semaphores is that they always require a system call for the lock and unlock operations, and each system call has a small, but appreciable, cost (<a href="ch03.xhtml#ch03lev1sec01">Section 3.1</a>). By contrast, mutexes are implemented using atomic machine-language operations (performed on memory locations visible to all threads) and require system calls only in case of lock contention.</p>
<div class="block">
<p class="noindent">On Linux, mutexes are implemented using <em>futexes</em> (an acronym derived from <em>fast user space mutexes</em>), and lock contentions are dealt with using the <em>futex()</em> system call. We don&#8217;t describe futexes in this book (they are not intended for direct use in user-space applications), but details can be found in [<a href="bib.xhtml#bib20">Drepper, 2004 (a)</a>], which also describes how mutexes are implemented using futexes. [<a href="bib.xhtml#bib26">Franke et al., 2002</a>] is a (now outdated) paper written by the developers of futexes, which describes the early futex implementation and looks at the performance gains derived from futexes.</p>
</div>
<h4 class="h4" id="ch30lev2sec04"><span epub:type="pagebreak" id="page_639"/><strong>30.1.4 Mutex Deadlocks</strong></h4>
<p class="noindenta">Sometimes, a thread needs to simultaneously access two or more different shared resources, each of which is governed by a separate mutex. When more than one thread is locking the same set of mutexes, deadlock situations can arise. <a href="ch30.xhtml#ch30fig3">Figure 30-3</a> shows an example of a deadlock in which each thread successfully locks one mutex, and then tries to lock the mutex that the other thread has already locked. Both threads will remain blocked indefinitely.</p>
<div class="image"><img src="../images/f30-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch30fig3"/><strong>Figure 30-3:</strong> A deadlock when two threads lock two mutexes</p>
<p class="noindent">The simplest way to avoid such deadlocks is to define a mutex hierarchy. When threads can lock the same set of mutexes, they should always lock them in the same order. For example, in the scenario in <a href="ch30.xhtml#ch30fig3">Figure 30-3</a>, the deadlock could be avoided if the two threads always lock the mutexes in the order <em>mutex1</em> followed by <em>mutex2</em>. Sometimes, there is a logically obvious hierarchy of mutexes. However, even if there isn&#8217;t, it may be possible to devise an arbitrary hierarchical order that all threads should follow.</p>
<p class="indent">An alternative strategy that is less frequently used is &#8220;try, and then back off.&#8221; In this strategy, a thread locks the first mutex using <em>pthread_mutex_lock()</em>, and then locks the remaining mutexes using <em>pthread_mutex_trylock()</em>. If any of the <em>pthread_mutex_trylock()</em> calls fails (with <span class="literal">EBUSY</span>), then the thread releases all mutexes, and then tries again, perhaps after a delay interval. This approach is less efficient than a lock hierarchy, since multiple iterations may be required. On the other hand, it can be more flexible, since it doesn&#8217;t require a rigid mutex hierarchy. An example of this strategy is shown in [<a href="bib.xhtml#bib10">Butenhof, 1996</a>].</p>
<h4 class="h4" id="ch30lev2sec05"><strong>30.1.5 Dynamically Initializing a Mutex</strong></h4>
<p class="noindenta">The static initializer value <span class="literal">PTHREAD_MUTEX_INITIALIZER</span> can be used only for initializing a statically allocated mutex with default attributes. In all other cases, we must dynamically initialize the mutex using <em>pthread_mutex_init()</em>.</p>
<div class="box">
<p class="programsa">#include &lt;pthread.h&gt;<br/><br/>int <span class="codestrong">pthread_mutex_init</span>(pthread_mutex_t *<span class="font1">mutex</span>, const pthread_mutexattr_t *<span class="font1">attr</span>);</p>
<p class="right">Returns 0 on success, or a positive error number on error</p>
</div>
<p class="noindent">The <em>mutex</em> argument identifies the mutex to be initialized. The <em>attr</em> argument is a pointer to a <em>pthread_mutexattr_t</em> object that has previously been initialized to define the attributes for the mutex. (We say some more about mutex attributes in the next section.) If <em>attr</em> is specified as <span class="literal">NULL</span>, then the mutex is assigned various default attributes.</p>
<p class="indent"><span epub:type="pagebreak" id="page_640"/>SUSv3 specifies that initializing an already initialized mutex results in undefined behavior; we should not do this.</p>
<p class="indentb">Among the cases where we must use <em>pthread_mutex_init()</em> rather than a static initializer are the following:</p>
<p class="bull">&#8226; The mutex was dynamically allocated on the heap. For example, suppose that we create a dynamically allocated linked list of structures, and each structure in the list includes a <em>pthread_mutex_t</em> field that holds a mutex that is used to protect access to that structure.</p>
<p class="bull">&#8226; The mutex is an automatic variable allocated on the stack.</p>
<p class="bull">&#8226; We want to initialize a statically allocated mutex with attributes other than the defaults.</p>
<p class="noindentt">When an automatically or dynamically allocated mutex is no longer required, it should be destroyed using <em>pthread_mutex_destroy()</em>. (It is not necessary to call <em>pthread_mutex_destroy()</em> on a mutex that was statically initialized using <span class="literal">PTHREAD_MUTEX_INITIALIZER</span>.)</p>
<div class="box">
<p class="programsa">#include &lt;pthread.h&gt;<br/><br/>int <span class="codestrong">pthread_mutex_destroy</span>(pthread_mutex_t *<span class="font1">mutex</span>);</p>
<p class="right">Returns 0 on success, or a positive error number on error</p>
</div>
<p class="noindent">It is safe to destroy a mutex only when it is unlocked, and no thread will subsequently try to lock it. If the mutex resides in a region of dynamically allocated memory, then it should be destroyed before freeing that memory region. An automatically allocated mutex should be destroyed before its host function returns.</p>
<p class="indent">A mutex that has been destroyed with <em>pthread_mutex_destroy()</em> can subsequently be reinitialized by <em>pthread_mutex_init()</em>.</p>
<h4 class="h4" id="ch30lev2sec06"><strong>30.1.6 Mutex Attributes</strong></h4>
<p class="noindenta">As noted earlier, the <em>pthread_mutex_init() attr</em> argument can be used to specify a <em>pthread_mutexattr_t</em> object that defines the attributes of a mutex. Various Pthreads functions can be used to initialize and retrieve the attributes in a <em>pthread_mutexattr_t</em> object. We won&#8217;t go into all of the details of mutex attributes or show the prototypes of the various functions that can be used to initialize the attributes in a <em>pthread_mutexattr_t</em> object. However, we&#8217;ll describe one of the attributes that can be set for a mutex: its type.</p>
<h4 class="h4" id="ch30lev2sec07"><strong>30.1.7 Mutex Types</strong></h4>
<p class="noindentab">In the preceding pages, we made a number of statements about the behavior of mutexes:</p>
<p class="bull">&#8226; A single thread may not lock the same mutex twice.</p>
<p class="bull">&#8226; A thread may not unlock a mutex that it doesn&#8217;t currently own (i.e., that it did not lock).</p>
<p class="bull">&#8226; A thread may not unlock a mutex that is not currently locked.</p>
<p class="noindenttb"><span epub:type="pagebreak" id="page_641"/>Precisely what happens in each of these cases depends on the <em>type</em> of the mutex. SUSv3 defines the following mutex types:</p>
<p class="term"><span class="literal">PTHREAD_MUTEX_NORMAL</span></p>
<p class="termlist">(Self-)deadlock detection is not provided for this type of mutex. If a thread tries to lock a mutex that it has already locked, then deadlock results. Unlocking a mutex that is not locked or that is locked by another thread produces undefined results. (On Linux, both of these operations succeed for this mutex type.)</p>
<p class="term"><span class="literal">PTHREAD_MUTEX_ERRORCHECK</span></p>
<p class="termlist">Error checking is performed on all operations. All three of the above scenarios cause the relevant Pthreads function to return an error. This type of mutex is typically slower than a normal mutex, but can be useful as a debugging tool to discover where an application is violating the rules about how a mutex should be used.</p>
<p class="term"><span class="literal">PTHREAD_MUTEX_RECURSIVE</span></p>
<p class="termlist">A recursive mutex maintains the concept of a lock count. When a thread first acquires the mutex, the lock count is set to 1. Each subsequent lock operation by the same thread increments the lock count, and each unlock operation decrements the count. The mutex is released (i.e., made available for other threads to acquire) only when the lock count falls to 0. Unlocking an unlocked mutex fails, as does unlocking a mutex that is currently locked by another thread.</p>
<p class="noindentt">The Linux threading implementation provides nonstandard static initializers for each of the above mutex types (e.g., <span class="literal">PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP</span>), so that the use of <em>pthread_mutex_init()</em> is not required to initialize these mutex types for statically allocated mutexes. However, portable applications should avoid the use of these initializers.</p>
<p class="indent">In addition to the above mutex types, SUSv3 defines the <span class="literal">PTHREAD_MUTEX_DEFAULT</span> type, which is the default type of mutex if we use <span class="literal">PTHREAD_MUTEX_INITIALIZER</span> or specify <em>attr</em> as <span class="literal">NULL</span> in a call to <em>pthread_mutex_init()</em>. The behavior of this mutex type is deliberately undefined in all three of the scenarios described at the start of this section, which allows maximum flexibility for efficient implementation of mutexes. On Linux, a <span class="literal">PTHREAD_MUTEX_DEFAULT</span> mutex behaves like a <span class="literal">PTHREAD_MUTEX_NORMAL</span> mutex.</p>
<p class="indent">The code shown in <a href="ch30.xhtml#ch30ex3">Listing 30-3</a> demonstrates how to set the type of a mutex, in this case to create an <em>error-checking</em> mutex.</p>
<p class="examplet"><a id="ch30ex3"/><strong>Listing 30-3:</strong> Setting the mutex type</p>
<p class="programsli">______________________________________________________________________<br/><br/>&#160;&#160;&#160;&#160;pthread_mutex_t mtx;<br/>&#160;&#160;&#160;&#160;pthread_mutexattr_t mtxAttr;<br/>&#160;&#160;&#160;&#160;int s, type;<br/><br/>&#160;&#160;&#160;&#160;s = pthread_mutexattr_init(&#38;mtxAttr);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutexattr_init");<br/><br/>&#160;&#160;&#160;&#160;s = pthread_mutexattr_settype(&#38;mtxAttr, PTHREAD_MUTEX_ERRORCHECK);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutexattr_settype");<br/><br/>&#160;&#160;&#160;&#160;s = pthread_mutex_init(&#38;mtx, &#38;mtxAttr);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_init");<br/><br/>&#160;&#160;&#160;&#160;s = pthread_mutexattr_destroy(&#38;mtxAttr);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* No longer needed */<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutexattr_destroy");<br/>______________________________________________________________________</p>
<h3 class="h3" id="ch30lev1sec02"><span epub:type="pagebreak" id="page_642"/><strong>30.2 Signaling Changes of State: Condition Variables</strong></h3>
<p class="noindenta">A mutex prevents multiple threads from accessing a shared variable at the same time. A condition variable allows one thread to inform other threads about changes in the state of a shared variable (or other shared resource) and allows the other threads to wait (block) for such notification.</p>
<p class="indent">A simple example that doesn&#8217;t use condition variables serves to demonstrate why they are useful. Suppose that we have a number of threads that produce some &#8220;result units&#8221; that are consumed by the main thread, and that we use a mutex-protected variable, <em>avail</em>, to represent the number of produced units awaiting consumption:</p>
<p class="programs">static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;<br/><br/>static int avail = 0;</p>
<div class="block">
<p class="noindent">The code segments shown in this section can be found in the file <span class="literal">threads/prod_no_condvar.c</span> in the source code distribution for this book.</p>
</div>
<p class="noindent">In the producer threads, we would have code such as the following:</p>
<p class="programs">/* Code to produce a unit omitted */<br/><br/>s = pthread_mutex_lock(&#38;mtx);<br/>if (s != 0)<br/>&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_lock");<br/><br/>avail++;&#160;&#160;&#160;&#160;/* Let consumer know another unit is available */<br/><br/>s = pthread_mutex_unlock(&#38;mtx);<br/>if (s != 0)<br/>&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_unlock");</p>
<p class="noindent">And in the main (consumer) thread, we could employ the following code:</p>
<p class="programs">for (;;) {<br/>&#160;&#160;&#160;&#160;s = pthread_mutex_lock(&#38;mtx);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_lock");<br/><br/>&#160;&#160;&#160;&#160;while (avail &gt; 0) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Consume all available units */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Do something with produced unit */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;avail--;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;s = pthread_mutex_unlock(&#38;mtx);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_unlock");<br/>}</p>
<p class="noindent"><span epub:type="pagebreak" id="page_643"/>The above code works, but it wastes CPU time, because the main thread continually loops, checking the state of the variable <em>avail</em>. A <em>condition variable</em> remedies this problem. It allows a thread to sleep (wait) until another thread notifies (signals) it that it must do something (i.e., that some &#8220;condition&#8221; has arisen that the sleeper must now respond to).</p>
<p class="indent">A condition variable is always used in conjunction with a mutex. The mutex provides mutual exclusion for accessing the shared variable, while the condition variable is used to signal changes in the variable&#8217;s state. (The use of the term <em>signal</em> here has nothing to do with the signals described in <a href="ch20.xhtml#ch20">Chapters 20</a> to <a href="ch22.xhtml#ch22">22</a>; rather, it is used in the sense of <em>indicate</em>.)</p>
<h4 class="h4" id="ch30lev2sec08"><strong>30.2.1 Statically Allocated Condition Variables</strong></h4>
<p class="noindenta">As with mutexes, condition variables can be allocated statically or dynamically. We defer discussion of dynamically allocated condition variables until <a href="ch30.xhtml#ch30lev2sec12">Section 30.2.5</a>, and consider statically allocated condition variables here.</p>
<p class="indent">A condition variable has the type <em>pthread_cond_t</em>. As with a mutex, a condition variable must be initialized before use. For a statically allocated condition variable, this is done by assigning it the value <span class="literal">PTHREAD_COND_INITIALIZER</span>, as in the following example:</p>
<p class="programs">pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</p>
<div class="block">
<p class="noindent">According to SUSv3, applying the operations that we describe in the remainder of this section to a <em>copy</em> of a condition variable yields results that are undefined. Operations should always be performed only on the original condition variable that has been statically initialized using <span class="literal">PTHREAD_COND_INITIALIZER</span> or dynamically initialized using <em>pthread_cond_init()</em> (described in <a href="ch30.xhtml#ch30lev2sec12">Section 30.2.5</a>).</p>
</div>
<h4 class="h4" id="ch30lev2sec09"><strong>30.2.2 Signaling and Waiting on Condition Variables</strong></h4>
<p class="noindenta">The principal condition variable operations are <em>signal</em> and <em>wait</em>. The signal operation is a notification to one or more waiting threads that a shared variable&#8217;s state has changed. The wait operation is the means of blocking until such a notification is received.</p>
<p class="indent">The <em>pthread_cond_signal()</em> and <em>pthread_cond_broadcast()</em> functions both signal the condition variable specified by <em>cond</em>. The <em>pthread_cond_wait()</em> function blocks a thread until the condition variable <em>cond</em> is signaled.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_644"/>#include &lt;pthread.h&gt;<br/><br/>int <span class="codestrong">pthread_cond_signal</span>(pthread_cond_t *<span class="font1">cond</span>);<br/>int <span class="codestrong">pthread_cond_broadcast</span>(pthread_cond_t *<span class="font1">cond</span>);<br/>int <span class="codestrong">pthread_cond_wait</span>(pthread_cond_t *<span class="font1">cond</span>, pthread_mutex_t *<span class="font1">mutex</span>);</p>
<p class="right">All return 0 on success, or a positive error number on error</p>
</div>
<p class="noindent">The difference between <em>pthread_cond_signal()</em> and <em>pthread_cond_broadcast()</em> lies in what happens if multiple threads are blocked in <em>pthread_cond_wait()</em>. With <em>pthread_cond_signal()</em>, we are simply guaranteed that at least one of the blocked threads is woken up; with <em>pthread_cond_broadcast()</em>, all blocked threads are woken up.</p>
<p class="indent">Using <em>pthread_cond_broadcast()</em> always yields correct results (since all threads should be programmed to handle redundant and spurious wake-ups), but <em>pthread_cond_signal()</em> can be more efficient. However, <em>pthread_cond_signal()</em> should be used only if just one of the waiting threads needs to be woken up to handle the change in state of the shared variable, and it doesn&#8217;t matter which one of the waiting threads is woken up. This scenario typically applies when all of the waiting threads are designed to perform exactly the same task. Given these assumptions, <em>pthread_cond_signal()</em> can be more efficient than <em>pthread_cond_broadcast()</em>, because it avoids the following possibility:</p>
<ol>
<li class="order"><p class="orderp">All waiting threads are awoken.</p></li>
<li class="order"><p class="orderp">One thread is scheduled first. This thread checks the state of the shared variable(s) (under protection of the associated mutex) and sees that there is work to be done. The thread performs the required work, changes the state of the shared variable(s) to indicate that the work has been done, and unlocks the associated mutex.</p></li>
<li class="order"><p class="orderp">Each of the remaining threads in turn locks the mutex and tests the state of the shared variable. However, because of the change made by the first thread, these threads see that there is no work to be done, and so unlock the mutex and go back to sleep (i.e., call <em>pthread_cond_wait()</em> once more).</p></li>
</ol>
<p class="noindent">By contrast, <em>pthread_cond_broadcast()</em> handles the case where the waiting threads are designed to perform different tasks (in which case they probably have different predicates associated with the condition variable).</p>
<p class="indent">A condition variable holds no state information. It is simply a mechanism for communicating information about the application&#8217;s state. If no thread is waiting on the condition variable at the time that it is signaled, then the signal is lost. A thread that later waits on the condition variable will unblock only when the variable is signaled once more.</p>
<p class="indent">The <em>pthread_cond_timedwait()</em> function is the same as <em>pthread_cond_wait()</em>, except that the <em>abstime</em> argument specifies an upper limit on the time that the thread will sleep while waiting for the condition variable to be signaled.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_645"/>#include &lt;pthread.h&gt;<br/><br/>int <span class="codestrong">pthread_cond_timedwait</span>(pthread_cond_t *<span class="font1">cond</span>, pthread_mutex_t *<span class="font1">mutex</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const struct timespec *<span class="font1">abstime</span>);</p>
<p class="right">Returns 0 on success, or a positive error number on error</p>
</div>
<p class="noindent">The <em>abstime</em> argument is a <em>timespec</em> structure (<a href="ch23.xhtml#ch23lev2sec02">Section 23.4.2</a>) specifying an absolute time expressed as seconds and nanoseconds since the Epoch (<a href="ch10.xhtml#ch10lev1sec01">Section 10.1</a>). If the time interval specified by <em>abstime</em> expires without the condition variable being signaled, then <em>pthread_cond_timedwait()</em> returns the error <span class="literal">ETIMEDOUT</span>.</p>
<h5 class="h5" id="ch30lev3sec03"><strong>Using a condition variable in the producer-consumer example</strong></h5>
<p class="noindenta">Let&#8217;s revise our previous example to use a condition variable. The declarations of our global variable and associated mutex and condition variable are as follows:</p>
<p class="programs">static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;<br/>static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;<br/><br/>static int avail = 0;</p>
<div class="block">
<p class="noindent">The code segments shown in this section can be found in the file <span class="literal">threads/prod_condvar.c</span> in the source code distribution for this book.</p>
</div>
<p class="noindent">The code in the producer threads is the same as before, except that we add a call to <em>pthread_cond_signal()</em>:</p>
<p class="programs">s = pthread_mutex_lock(&#38;mtx);<br/>if (s != 0)<br/>&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_lock");<br/><br/>avail++;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Let consumer know another unit is available */<br/><br/>s = pthread_mutex_unlock(&#38;mtx);<br/>if (s != 0)<br/>&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_unlock");<br/><br/>s = pthread_cond_signal(&#38;cond);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wake sleeping consumer */<br/>if (s != 0)<br/>&#160;&#160;&#160;&#160;errExitEN(s, "pthread_cond_signal");</p>
<p class="noindentb">Before considering the code of the consumer, we need to explain <em>pthread_cond_wait()</em> in greater detail. We noted earlier that a condition variable always has an associated mutex. Both of these objects are passed as arguments to <em>pthread_cond_wait()</em>, which performs the following steps:</p>
<p class="bull">&#8226; unlock the mutex specified by <em>mutex</em>;</p>
<p class="bull">&#8226; block the calling thread until another thread signals the condition variable <em>cond</em>; and</p>
<p class="bull">&#8226; relock <em>mutex</em>.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_646"/>The <em>pthread_cond_wait()</em> function is designed to perform these steps because, normally, we access a shared variable in the following manner:</p>
<p class="programs">s = pthread_mutex_lock(&#38;mtx);<br/>if (s != 0)<br/>&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_lock");<br/><br/>while (/* Check that shared variable is not in state we want */)<br/>&#160;&#160;&#160;&#160;pthread_cond_wait(&#38;cond, &#38;mtx);<br/><br/>/* Now shared variable is in desired state; do some work */<br/><br/>s = pthread_mutex_unlock(&#38;mtx);<br/>if (s != 0)<br/>&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_unlock");</p>
<p class="noindent">(We explain why the <em>pthread_cond_wait()</em> call is placed within a <span class="literal">while</span> loop rather than an <span class="literal">if</span> statement in the next section.)</p>
<p class="indent">In the above code, both accesses to the shared variable must be mutex-protected for the reasons that we explained earlier. In other words, there is a natural association of a mutex with a condition variable:</p>
<ol>
<li class="order"><p class="orderp">The thread locks the mutex in preparation for checking the state of the shared variable.</p></li>
<li class="order"><p class="orderp">The state of the shared variable is checked.</p></li>
<li class="order"><p class="orderp">If the shared variable is not in the desired state, then the thread must unlock the mutex (so that other threads can access the shared variable) before it goes to sleep on the condition variable.</p></li>
<li class="order"><p class="orderp">When the thread is reawakened because the condition variable has been signaled, the mutex must once more be locked, since, typically, the thread then immediately accesses the shared variable.</p></li>
</ol>
<p class="noindent">The <em>pthread_cond_wait()</em> function automatically performs the mutex unlocking and locking required in the last two of these steps. In the third step, releasing the mutex and blocking on the condition variable are performed atomically. In other words, it is not possible for some other thread to acquire the mutex and signal the condition variable before the thread calling <em>pthread_cond_wait()</em> has blocked on the condition variable.</p>
<div class="block">
<p class="noindent">There is a corollary to the observation that there is a natural relationship between a condition variable and a mutex: all threads that concurrently wait on a particular condition variable must specify the same mutex in their <em>pthread_cond_wait()</em> (or <em>pthread_cond_timedwait()</em>) calls. In effect, a <em>pthread_cond_wait()</em> call dynamically binds a condition variable to a unique mutex for the duration of the call. SUSv3 notes that the result of using more than one mutex for concurrent <em>pthread_cond_wait()</em> calls on the same condition variable is undefined.</p>
<p class="indent"><a href="ch32.xhtml#ch32">Chapter 32</a>, which describes thread cancellation, notes that <em>pthread_cond_wait()</em> is a cancellation point. If a thread is canceled while blocked in a call to <em>pthread_cond_wait()</em>, then the mutex is relocked before the first cancellation cleanup handler is called. This means a cleanup handler can safely unlock the mutex (as is done, for example, in <a href="ch32.xhtml#ch32ex2">Listing 32-2</a>).</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_647"/>Putting the above details together, we can now modify the main (consumer) thread to use <em>pthread_cond_wait()</em>, as follows:</p>
<p class="programs">for (;;) {<br/>&#160;&#160;&#160;&#160;s = pthread_mutex_lock(&#38;mtx);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_lock");<br/><br/>&#160;&#160;&#160;&#160;while (avail == 0) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for something to consume */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_cond_wait(&#38;cond, &#38;mtx);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_cond_wait");<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;while (avail &gt; 0) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Consume all available units */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Do something with produced unit */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;avail--;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;s = pthread_mutex_unlock(&#38;mtx);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_unlock");<br/><br/>&#160;&#160;&#160;&#160;/* Perhaps do other work here that doesn't require mutex lock */<br/>}</p>
<p class="noindent">We conclude with one final observation about the use of <em>pthread_cond_signal()</em> (and <em>pthread_cond_broadcast()</em>). In the producer code shown earlier, we called <em>pthread_mutex_unlock()</em>, and then called <em>pthread_cond_signal()</em>; that is, we first unlocked the mutex associated with the shared variable, and then signaled the corresponding condition variable. We could have reversed these two steps; SUSv3 permits them to be done in either order.</p>
<div class="block">
<p class="noindent">[<a href="bib.xhtml#bib10">Butenhof, 1996</a>] points out that, on some implementations, unlocking the mutex and then signaling the condition variable may yield better performance than performing these steps in the reverse sequence. If the mutex is unlocked only after the condition variable is signaled, the thread performing <em>pthread_cond_wait()</em> may wake up while the mutex is still locked, and then immediately go back to sleep again when it finds that the mutex is locked. This results in two superfluous context switches. Some implementations eliminate this problem by employing a technique called <em>wait morphing</em>, which moves the signaled thread from the condition variable wait queue to the mutex wait queue without performing a context switch if the mutex is locked.</p>
</div>
<h4 class="h4" id="ch30lev2sec10"><strong>30.2.3 Testing a Condition Variable&#8217;s Predicate</strong></h4>
<p class="noindenta">Each condition variable has an associated predicate involving one or more shared variables. For example, in the code segment in the preceding section, the predicate associated with <em>cond</em> is <em>(avail == 0)</em>. This code segment demonstrates a general design principle: a <em>pthread_cond_wait()</em> call must be governed by a <span class="literal">while</span> loop rather than an <span class="literal">if</span> statement. This is so because, on return from <em>pthread_cond_wait()</em>, there <span epub:type="pagebreak" id="page_648"/>are no guarantees about the state of the predicate; therefore, we should immediately recheck the predicate and resume sleeping if it is not in the desired state.</p>
<p class="indentb">We can&#8217;t make any assumptions about the state of the predicate upon return from <em>pthread_cond_wait()</em>, for the following reasons:</p>
<p class="bull">&#8226; <em>Other threads may be woken up first</em>. Perhaps several threads were waiting to acquire the mutex associated with the condition variable. Even if the thread that signaled the mutex set the predicate to the desired state, it is still possible that another thread might acquire the mutex first and change the state of the associated shared variable(s), and thus the state of the predicate.</p>
<p class="bull">&#8226; <em>Designing for &#8220;loose&#8221; predicates may be simpler</em>. Sometimes, it is easier to design applications based on condition variables that indicate <em>possibility</em> rather than <em>certainty</em>. In other words, signaling a condition variable would mean &#8220;there <em>may be</em> something&#8221; for the signaled thread to do, rather than &#8220;there <em>is</em> something&#8221; to do. Using this approach, the condition variable can be signaled based on approximations of the predicate&#8217;s state, and the signaled thread can ascertain if there really is something to do by rechecking the predicate.</p>
<p class="bull">&#8226; <em>Spurious wake-ups can occur</em>. On some implementations, a thread waiting on a condition variable may be woken up even though no other thread actually signaled the condition variable. Such spurious wake-ups are a (rare) consequence of the techniques required for efficient implementation on some multiprocessor systems, and are explicitly permitted by SUSv3.</p>
<h4 class="h4" id="ch30lev2sec11"><strong>30.2.4 Example Program: Joining Any Terminated Thread</strong></h4>
<p class="noindenta">We noted earlier that <em>pthread_join()</em> can be used to join with only a specific thread. It provides no mechanism for joining with <em>any</em> terminated thread. We now show how a condition variable can be used to circumvent this restriction.</p>
<p class="indent">The program in <a href="ch30.xhtml#ch30ex4">Listing 30-4</a> creates one thread for each of its command-line arguments. Each thread sleeps for the number of seconds specified in the corresponding command-line argument and then terminates. The sleep interval is our means of simulating the idea of a thread that does work for a period of time.</p>
<p class="indent">The program maintains a set of global variables recording information about all of the threads that have been created. For each thread, an element in the global <em>thread</em> array records the ID of the thread (the <em>tid</em> field) and its current state (the <em>state</em> field). The <em>state</em> field has one of the following values: <span class="literal">TS_ALIVE</span>, meaning the thread is alive; <span class="literal">TS_TERMINATED</span>, meaning the thread has terminated but not yet been joined; or <span class="literal">TS_JOINED</span>, meaning the thread has terminated and been joined.</p>
<p class="indent">As each thread terminates, it assigns the value <span class="literal">TS_TERMINATED</span> to the <em>state</em> field for its element in the <em>thread</em> array, increments a global counter of terminated but as yet unjoined threads (<em>numUnjoined</em>), and signals the condition variable <em>threadDied</em>.</p>
<p class="indent">The main thread employs a loop that continuously waits on the condition variable <em>threadDied</em>. Whenever <em>threadDied</em> is signaled and there are terminated threads that have not been joined, the main thread scans the <em>thread</em> array, looking for elements with <em>state</em> set to <span class="literal">TS_TERMINATED</span>. For each thread in this state, <em>pthread_join()</em> is called using the corresponding <em>tid</em> field from the <em>thread</em> array, and then the <em>state</em> is set to <span class="literal">TS_JOINED</span>. The main loop terminates when all of the threads created by the main thread have died&#8212;that is, when the global variable <em>numLive</em> is 0.</p>
<p class="indent"><span epub:type="pagebreak" id="page_649"/>The following shell session log demonstrates the use of the program in <a href="ch30.xhtml#ch30ex4">Listing 30-4</a>:</p>
<p class="programs">$ <span class="codestrong">./thread_multijoin 1 1 2 3 3</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create 5 threads</span><br/>Thread 0 terminating<br/>Thread 1 terminating<br/>Reaped thread 0 (numLive=4)<br/>Reaped thread 1 (numLive=3)<br/>Thread 2 terminating<br/>Reaped thread 2 (numLive=2)<br/>Thread 3 terminating<br/>Thread 4 terminating<br/>Reaped thread 3 (numLive=1)<br/>Reaped thread 4 (numLive=0)</p>
<p class="noindent">Finally, note that although the threads in the example program are created as joinable and are immediately reaped on termination using <em>pthread_join()</em>, we don&#8217;t need to use this approach in order to find out about thread termination. We could have made the threads detached, removed the use of <em>pthread_join()</em>, and simply used the <em>thread</em> array (and associated global variables) as the means of recording the termination of each thread.</p>
<p class="examplet"><a id="ch30ex4"/><strong>Listing 30-4:</strong> A main thread that can join with any terminated thread</p>
<p class="programsli">_________________________________________________ <span class="codestrong">threads/thread_multijoin.c</span><br/><br/>#include &lt;pthread.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static pthread_cond_t threadDied = PTHREAD_COND_INITIALIZER;<br/>static pthread_mutex_t threadMutex = PTHREAD_MUTEX_INITIALIZER;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Protects all of the following global variables */<br/><br/>static int totThreads = 0;&#160;&#160;&#160;&#160;&#160;&#160;/* Total number of threads created */<br/>static int numLive = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Total number of threads still alive or<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;terminated but not yet joined */<br/>static int numUnjoined = 0;&#160;&#160;&#160;&#160;&#160;/* Number of terminated threads that<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;have not yet been joined */<br/>enum tstate {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Thread states */<br/>&#160;&#160;&#160;&#160;TS_ALIVE,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Thread is alive */<br/>&#160;&#160;&#160;&#160;TS_TERMINATED,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Thread terminated, not yet joined */<br/>&#160;&#160;&#160;&#160;TS_JOINED&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Thread terminated, and joined */<br/>};<br/><br/>static struct {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Info about each thread */<br/>&#160;&#160;&#160;&#160;pthread_t tid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* ID of this thread */<br/>&#160;&#160;&#160;&#160;enum tstate state;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Thread state (TS_* constants above) */<br/>&#160;&#160;&#160;&#160;int sleepTime;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number seconds to live before terminating */<br/>} *thread;<br/><br/>static void *&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Start function for thread */<br/>threadFunc(void *arg)<br/>{<br/>&#160;&#160;&#160;&#160;int idx = (int) arg;<br/>&#160;&#160;&#160;&#160;int s;<br/><span epub:type="pagebreak" id="page_650"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep(thread[idx].sleepTime);&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Simulate doing some work */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Thread %d terminating\n", idx);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_mutex_lock(&#38;threadMutex);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_lock");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numUnjoined++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread[idx].state = TS_TERMINATED;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_mutex_unlock(&#38;threadMutex);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_unlock");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_cond_signal(&#38;threadDied);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_cond_signal");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return NULL;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;int<br/>&#160;&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int s, idx;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s nsecs...\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread = calloc(argc - 1, sizeof(*thread));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (thread == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("calloc");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create all threads */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (idx = 0; idx &lt; argc - 1; idx++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread[idx].sleepTime = getInt(argv[idx + 1], GN_NONNEG, NULL);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread[idx].state = TS_ALIVE;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_create(&#38;thread[idx].tid, NULL, threadFunc, (void *) idx);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_create");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;totThreads = argc - 1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numLive = totThreads;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Join with terminated threads */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (numLive &gt; 0) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_mutex_lock(&#38;threadMutex);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_lock");<br/><br/><span epub:type="pagebreak" id="page_651"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (numUnjoined == 0) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_cond_wait(&#38;threadDied, &#38;threadMutex);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_cond_wait");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (idx = 0; idx &lt; totThreads; idx++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (thread[idx].state == TS_TERMINATED) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_join(thread[idx].tid, NULL);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_join");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread[idx].state = TS_JOINED;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numLive--;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numUnjoined--;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Reaped thread %d (numLive=%d)\n", idx, numLive);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_mutex_unlock(&#38;threadMutex);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_mutex_unlock");<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________ <span class="codestrong">threads/thread_multijoin.c</span></p>
<h4 class="h4" id="ch30lev2sec12"><strong>30.2.5 Dynamically Allocated Condition Variables</strong></h4>
<p class="noindenta">The <em>pthread_cond_init()</em> function is used to dynamically initialize a condition variable. The circumstances in which we need to use <em>pthread_cond_init()</em> are analogous to those where <em>pthread_mutex_init()</em> is needed to dynamically initialize a mutex (<a href="ch30.xhtml#ch30lev2sec05">Section 30.1.5</a>); that is, we must use <em>pthread_cond_init()</em> to initialize automatically and dynamically allocated condition variables, and to initialize a statically allocated condition variable with attributes other than the defaults.</p>
<div class="box">
<p class="programsa">#include &lt;pthread.h&gt;<br/><br/>int <span class="codestrong">pthread_cond_init</span>(pthread_cond_t *<span class="font1">cond</span>, const pthread_condattr_t *<span class="font1">attr</span>);</p>
<p class="right">Returns 0 on success, or a positive error number on error</p>
</div>
<p class="noindent">The <em>cond</em> argument identifies the condition variable to be initialized. As with mutexes, we can specify an <em>attr</em> argument that has been previously initialized to determine attributes for the condition variable. Various Pthreads functions can be used to initialize the attributes in the <em>pthread_condattr_t</em> object pointed to by <em>attr</em>. If <em>attr</em> is <span class="literal">NULL</span>, a default set of attributes is assigned to the condition variable.</p>
<p class="indent"><span epub:type="pagebreak" id="page_652"/>SUSv3 specifies that initializing an already initialized condition variable results in undefined behavior; we should not do this.</p>
<p class="indent">When an automatically or dynamically allocated condition variable is no longer required, then it should be destroyed using <em>pthread_cond_destroy()</em>. It is not necessary to call <em>pthread_cond_destroy()</em> on a condition variable that was statically initialized using <span class="literal">PTHREAD_COND_INITIALIZER</span>.</p>
<div class="box">
<p class="programsa">#include &lt;pthread.h&gt;<br/><br/>int <span class="codestrong">pthread_cond_destroy</span>(pthread_cond_t *<span class="font1">cond</span>);</p>
<p class="right">Returns 0 on success, or a positive error number on error</p>
</div>
<p class="noindent">It is safe to destroy a condition variable only when no threads are waiting on it. If the condition variable resides in a region of dynamically allocated memory, then it should be destroyed before freeing that memory region. An automatically allocated condition variable should be destroyed before its host function returns.</p>
<p class="indent">A condition variable that has been destroyed with <em>pthread_cond_destroy()</em> can subsequently be reinitialized by <em>pthread_cond_init()</em>.</p>
<h3 class="h3" id="ch30lev1sec03"><strong>30.3 Summary</strong></h3>
<p class="noindenta">The greater sharing provided by threads comes at a cost. Threaded applications must employ synchronization primitives such as mutexes and condition variables in order to coordinate access to shared variables. A mutex provides exclusive access to a shared variable. A condition variable allows one or more threads to wait for notification that some other thread has changed the state of a shared variable.</p>
<h5 class="h5" id="ch30lev3sec04"><strong>Further information</strong></h5>
<p class="noindenta">Refer to the sources of further information listed in <a href="ch29.xhtml#ch29lev1sec10">Section 29.10</a>.</p>
<h3 class="h3" id="ch30lev1sec04"><strong>30.4 Exercises</strong></h3>
<p class="exer"><a id="ch30exe1"/><strong>30-1.</strong>&#160;&#160;&#160;Modify the program in <a href="ch30.xhtml#ch30ex1">Listing 30-1</a> (<span class="literal">thread_incr.c</span>) so that each loop in the thread&#8217;s start function outputs the current value of <em>glob</em> and some identifier that uniquely identifies the thread. The unique identifier for the thread could be specified as an argument to the <em>pthread_create()</em> call used to create the thread. For this program, that would require changing the argument of the thread&#8217;s start function to be a pointer to a structure containing the unique identifier and a loop limit value. Run the program, redirecting output to a file, and then inspect the file to see what happens to <em>glob</em> as the kernel scheduler alternates execution between the two threads.</p>
<p class="exer"><span epub:type="pagebreak" id="page_653"/><a id="ch30exe2"/><strong>30-2.</strong>&#160;&#160;&#160;Implement a set of thread-safe functions that update and search an unbalanced binary tree. This library should include functions (with the obvious purposes) of the following form:</p>
<p class="programs1">initialize(tree);<br/>add(tree, char *key, void *value);<br/>delete(tree, char *key)<br/>Boolean lookup(char *key, void **value)</p>
<p class="exerp">In the above prototypes, <em>tree</em> is a structure that points to the root of the tree (you will need to define a suitable structure for this purpose). Each element of the tree holds a key-value pair. You will also need to define the structure for each element to include a mutex that protects that element so that only one thread at a time can access it. The <em>initialize()</em>, <em>add()</em>, and <em>lookup()</em> functions are relatively simple to implement. The <em>delete()</em> operation requires a little more effort.</p>
<div class="block">
<p class="noindent">Removing the need to maintain a balanced tree greatly simplifies the locking requirements of the implementation, but carries the risk that certain patterns of input would result in a tree that performs poorly. Maintaining a balanced tree necessitates moving nodes between subtrees during the <em>add()</em> and <em>delete()</em> operations, which requires much more complex locking strategies.<span epub:type="pagebreak" id="page_654"/></p>
</div>
</body>
</html>
