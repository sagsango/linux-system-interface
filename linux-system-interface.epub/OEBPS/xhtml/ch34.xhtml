<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch34"><span epub:type="pagebreak" id="page_699"/><strong><span class="big">34</span></strong><br/><strong>PROCESS GROUPS, SESSIONS, AND JOB CONTROL</strong></h2>
<p class="noindenta">Process groups and sessions form a two-level hierarchical relationship between processes: a process group is a collection of related processes, and a session is a collection of related process groups. The meaning of the term <em>related</em> in each case will become clear in the course of this chapter.</p>
<p class="indent">Process groups and sessions are abstractions defined to support shell job control, which allows interactive users to run commands in the foreground or in the background. The term <em>job</em> is often used synonymously with the term <em>process group</em>.</p>
<p class="indent">This chapter describes process groups, sessions, and job control.</p>
<h3 class="h3" id="ch34lev1sec01"><strong>34.1 Overview</strong></h3>
<p class="noindenta">A <em>process group</em> is a set of one or more processes sharing the same <em>process group identifier</em> (PGID). A process group ID is a number of the same type (<em>pid_t</em>) as a process ID. A process group has a <em>process group leader</em>, which is the process that becomes the first member of the group and whose process ID becomes the process group ID of the group. A new process inherits its parent&#8217;s process group ID.</p>
<p class="indent">A process group has a <em>lifetime</em>, which is the period of time beginning when the leader joins the group and ending when the last member process leaves the group. A process may leave a process group either by terminating or by joining another <span epub:type="pagebreak" id="page_700"/>process group. The process group leader need not be the last member of a process group.</p>
<p class="indent">A <em>session</em> is a collection of process groups. A process&#8217;s session membership is determined by its <em>session identifier</em> (SID), which, like the process group ID, is a number of type <em>pid_t</em>. A <em>session leader</em> is the process that creates a new session and whose process ID becomes the session ID. A new process inherits its parent&#8217;s session ID.</p>
<p class="indent">All of the processes in a session share a single <em>controlling terminal</em>. The controlling terminal is established when the session leader first opens a terminal device. A terminal may be the controlling terminal of at most one session.</p>
<p class="indent">At any point in time, one of the process groups in a session is the <em>foreground process group</em> for the terminal, and the others are <em>background process groups</em>. Only processes in the foreground process group can read input from the controlling terminal. When the user types one of the signal-generating terminal characters on the controlling terminal, a signal is sent to all members of the foreground process group. These characters are the <em>interrupt</em> character (usually <em>Control-C</em>), which generates <span class="literal">SIGINT</span>; the <em>quit</em> character (usually <em>Control-\</em>), which generates <span class="literal">SIGQUIT</span>; and the <em>suspend</em> character (usually <em>Control-Z</em>), which generates <span class="literal">SIGTSTP</span>.</p>
<p class="indent">As a consequence of establishing the connection to (i.e., opening) the controlling terminal, the session leader becomes the <em>controlling process</em> for the terminal. The principal significance of being the controlling process is that the kernel sends this process a <span class="literal">SIGHUP</span> signal if a terminal disconnect occurs.</p>
<div class="block">
<p class="noindent">By inspecting the Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/stat</span> files, we can determine the process group ID and session ID of any process. We can also determine the device ID of the process&#8217;s controlling terminal (expressed as a single decimal integer containing both major and minor IDs) and the process ID of the controlling process for that terminal. See the <em>proc(5)</em> manual page for further details.</p>
</div>
<p class="noindent">The main use of sessions and process groups is for shell job control. Looking at a specific example from this domain helps clarify these concepts. For an interactive login, the controlling terminal is the one on which the user logs in. The login shell becomes the session leader and the controlling process for the terminal, and is also made the sole member of its own process group. Each command or pipeline of commands started from the shell results in the creation of one or more processes, and the shell places all of these processes in a new process group. (These processes are initially the only members of that process group, although any child processes that they create will also be members of the group.) A command or pipeline is created as a background process group if it is terminated with an ampersand (<span class="literal">&#38;</span>). Otherwise, it becomes the foreground process group. All processes created during the login session are part of the same session.</p>
<div class="block">
<p class="noindent">In a windowing environment, the controlling terminal is a pseudoterminal, and there is a separate session for each terminal window, with the window&#8217;s startup shell being the session leader and controlling process for the terminal.</p>
<p class="indent">Process groups occasionally find uses in areas other than job control, since they have two useful properties: a parent process can wait on any of its children in a particular process group (<a href="ch26.xhtml#ch26lev2sec02">Section 26.1.2</a>), and a signal can be sent to all of the members of a process group (<a href="ch20.xhtml#ch20lev1sec05">Section 20.5</a>).</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_701"/><a href="ch34.xhtml#ch34fig1">Figure 34-1</a> shows the process group and session relationships between the various processes resulting from the execution of the following commands:</p>
<p class="programs">$ <span class="codestrong">echo $$</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Display the PID of the shell</span><br/>400<br/>$ <span class="codestrong">find / 2&gt; /dev/null | wc -l &#38;</span>&#160;&#160;&#160;&#160;&#160;<span class="font1">Creates 2 processes in background group</span><br/>[1] 659<br/>$ <span class="codestrong">sort &lt; longlist | uniq -c</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Creates 2 processes in foreground group</span></p>
<p class="noindent">At this point, the shell (<em>bash</em>), <em>find</em>, <em>wc</em>, <em>sort</em>, and <em>uniq</em> are all running.</p>
<div class="image"><img src="../images/f34-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch34fig1"/><strong>Figure 34-1:</strong> Relationships between process groups, sessions, and the controlling terminal</p>
<h3 class="h3" id="ch34lev1sec02"><strong>34.2 Process Groups</strong></h3>
<p class="noindenta">Each process has a numeric process group ID that defines the process group to which it belongs. A new process inherits its parent&#8217;s process group ID. A process can obtain its process group ID using <em>getpgrp()</em>.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>pid_t <span class="codestrong">getpgrp</span>(void);</p>
<p class="right">Always successfully returns process group ID of calling process</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_702"/>If the value returned by <em>getpgrp()</em> matches the caller&#8217;s process ID, this process is the leader of its process group.</p>
<p class="indent">The <em>setpgid()</em> system call changes the process group of the process whose process ID is <em>pid</em> to the value specified in <em>pgid</em>.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">setpgid</span>(pid_t <span class="font1">pid</span>, pid_t <span class="font1">pgid</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">If <em>pid</em> is specified as 0, the calling process&#8217;s process group ID is changed. If <em>pgid</em> is specified as 0, then the process group ID of the process specified by <em>pid</em> is made the same as its process ID. Thus, the following <em>setpgid()</em> calls are equivalent:</p>
<p class="programs">setpgid(0, 0);<br/>setpgid(getpid(), 0);<br/>setpgid(getpid(), getpid());</p>
<p class="noindent">If <em>setpgid()</em> changes the process group ID of the target process (the process specified by <em>pid</em>) to be the same as its process ID, then the target process is made the leader of a new process group whose ID is the same as the process ID. If <em>septgid()</em> changes the process group ID of the target process to a value different from its process ID, then the target process is moved to the existing process group specified by <em>pgid</em>. If <em>setpgid()</em> leaves the process group ID of the target process unchanged, then the call has no effect on the target process.</p>
<p class="indent">The typical callers of <em>setpgid()</em> (and <em>setsid()</em>, described in <a href="ch34.xhtml#ch34lev1sec03">Section 34.3</a>) are programs such as the shell and <em>login(1)</em>. In <a href="ch37.xhtml#ch37lev1sec02">Section 37.2</a>, we&#8217;ll see that a program also calls <em>setsid()</em> as one of the steps on the way to becoming a daemon.</p>
<p class="indentb">Several restrictions apply when calling <em>setpgid()</em>:</p>
<p class="bull">&#8226; The <em>pid</em> argument may specify only the calling process or one of its children. Violation of this rule results in the error <span class="literal">ESRCH</span>.</p>
<p class="bull">&#8226; When moving a process between groups, the calling process and the process specified by <em>pid</em> (which may be one and the same), as well as the target process group, must all be part of the same session. Violation of this rule results in the error <span class="literal">EPERM</span>.</p>
<p class="bull">&#8226; The <em>pid</em> argument may not specify a process that is a session leader. Violation of this rule results in the error <span class="literal">EPERM</span>.</p>
<p class="bull">&#8226; A process may not change the process group ID of one of its children after that child has performed an <em>exec()</em>. Violation of this rule results in the error <span class="literal">EACCES</span>. The rationale for this constraint is that it could confuse a program if its process group ID were changed after it had commenced.</p>
<h5 class="h5" id="ch34lev3sec01"><span epub:type="pagebreak" id="page_703"/><strong>Using <em>setpgid()</em> in a job-control shell</strong></h5>
<p class="noindentab">The restriction that a process may not change the process group ID of one of its children after that child has performed an <em>exec()</em> affects the programming of job-control shells, which have the following requirements:</p>
<p class="bull">&#8226; All of the processes in a job (i.e., a command or a pipeline) must be placed in a single process group. (We can see the desired result by looking at the two process groups created by <em>bash</em> in <a href="ch34.xhtml#ch34fig1">Figure 34-1</a>.) This step permits the shell to use <em>killpg()</em> (or, equivalently, <em>kill()</em> with a negative <em>pid</em> argument) to simultaneously send job-control signals to all of the members of the process group. Naturally, this step must be carried out before any job-control signals are sent.</p>
<p class="bull">&#8226; Each of the child processes must be transferred to the process group before it execs a program, since the program itself is ignorant of manipulations of the process group ID.</p>
<p class="noindentt">For each process in the job, either the parent or the child could use <em>setpgid()</em> to change the process group ID of the child. However, because the scheduling of the parent and child is indeterminate after a <em>fork()</em> (<a href="ch24.xhtml#ch24lev1sec04">Section 24.4</a>), we can&#8217;t rely on the parent changing the child&#8217;s process group ID before the child does an <em>exec()</em>; nor can we rely on the child changing its process group ID before the parent tries to send any job-control signals to it. (Dependence on either one of these behaviors would result in a race condition.) Therefore, job-control shells are programmed so that the parent and the child process both call <em>setpgid()</em> to change the child&#8217;s process group ID to the same value immediately after a <em>fork()</em>, and the parent ignores any occurrence of the <span class="literal">EACCES</span> error on the <em>setpgid()</em> call. In other words, in a job-control shell, we&#8217;ll find code something like that shown in <a href="ch34.xhtml#ch34ex1">Listing 34-1</a>.</p>
<p class="examplet"><a id="ch34ex1"/><strong>Listing 34-1:</strong> How a job-control shell sets the process group ID of a child process</p>
<p class="programsli">______________________________________________________________________<br/><br/>&#160;&#160;&#160;&#160;pid_t childPid;<br/>&#160;&#160;&#160;&#160;pid_t pipelinePgid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* PGID to which processes in a pipeline<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;are to be assigned */<br/>&#160;&#160;&#160;&#160;/* Other code */<br/><br/>&#160;&#160;&#160;&#160;childPid = fork();<br/>&#160;&#160;&#160;&#160;switch (childPid) {<br/>&#160;&#160;&#160;&#160;case -1: /* fork() failed */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Handle error */<br/><br/>&#160;&#160;&#160;&#160;case 0: /* Child */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (setpgid(0, pipelinePgid) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Handle error */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child carries on to exec the required program */<br/><br/>&#160;&#160;&#160;&#160;default: /* Parent (shell) */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (setpgid(childPid, pipelinePgid) == -1 &#38;&#38; errno != EACCES)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Handle error */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent carries on to do other things */<br/>&#160;&#160;&#160;&#160;}<br/>______________________________________________________________________</p>
<p class="noindent"><span epub:type="pagebreak" id="page_704"/>Things are slightly more complex than shown in <a href="ch34.xhtml#ch34ex1">Listing 34-1</a>, since, when creating the processes for a pipeline, the parent shell records the process ID of the first process in the pipeline and uses this as the process group ID (<em>pipelinePgid</em>) for all of the processes in the group.</p>
<h5 class="h5" id="ch34lev3sec02"><strong>Other (obsolete) interfaces for retrieving and modifying process group IDs</strong></h5>
<p class="noindenta">The different suffixes in the names of the <em>getpgrp()</em> and <em>setpgid()</em> system calls deserve explanation.</p>
<p class="indent">In the beginning, 4.2BSD provided a <em>getpgrp(pid)</em> system call that returned the process group ID of the process specified by <em>pid</em>. In practice, <em>pid</em> was always used to specify the calling process. Consequently, the POSIX committee deemed the call to be more complex than necessary, and instead adopted the System V <em>getpgrp()</em> call, which took no arguments and returned the process group ID of the calling process.</p>
<p class="indent">In order to change the process group ID, 4.2BSD provided the call <em>setpgrp(pid, pgid)</em>, which operated in a similar manner to <em>setpgid()</em>. The principal difference was that the BSD <em>setpgrp()</em> could be used to set the process group ID to any value. (We noted earlier that <em>setpgid()</em> can&#8217;t transfer a process into a process group in a different session.) This resulted in some security issues and was also more flexible than required for implementing job control. Consequently, the POSIX committee settled on a more restrictive function and gave it the name <em>setpgid()</em>.</p>
<p class="indent">To further complicate matters, SUSv3 specifies <em>getpgid(pid)</em>, with the same semantics as the old BSD <em>getpgrp()</em>, and also weakly specifies an alternative, System V&#8211;derived version of <em>setpgrp()</em>, taking no arguments, as being approximately equivalent to <em>setpgid(0, 0)</em>.</p>
<p class="indent">Although the <em>setpgid()</em> and <em>getpgrp()</em> system calls that we described earlier are sufficient for implementing shell job control, Linux, like most other UNIX implementations, also provides <em>getpgid(pid)</em> and <em>setpgrp(void)</em>. For backward compatibility, many BSD-derived implementations continue to provide <em>setprgp(pid, pgid)</em> as a synonym for <em>setpgid(pid, pgid)</em>.</p>
<p class="indent">If we explicitly define the <span class="literal">_BSD_SOURCE</span> feature test macro when compiling a program, then <em>glibc</em> provides the BSD-derived versions of <em>setpgrp()</em> and <em>getpgrp()</em>, instead of the default versions.</p>
<h3 class="h3" id="ch34lev1sec03"><strong>34.3 Sessions</strong></h3>
<p class="noindenta">A <em>session</em> is a collection of process groups. The session membership of a process is defined by its numeric session ID. A new process inherits its parent&#8217;s session ID. The <em>getsid()</em> system call returns the session ID of the process specified by <em>pid</em>.</p>
<div class="box">
<p class="programsa">#define _XOPEN_SOURCE 500<br/>#include &lt;unistd.h&gt;<br/><br/>pid_t <span class="codestrong">getsid</span>(pid_t <span class="font1">pid</span>);</p>
<p class="right">Returns session ID of specified process, or &#8211;1 on error</p>
</div>
<p class="noindent">If <em>pid</em> is specified as 0, <em>getsid()</em> returns the session ID of the calling process.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_705"/>On a few UNIX implementations (e.g., HP-UX 11), <em>getsid()</em> can be used to retrieve the session ID of a process only if it is in the same session as the calling process. (SUSv3 permits this possibility.) In other words, the call merely serves, by its success or failure (<span class="literal">EPERM</span>), to inform us if the specified process is in the same session as the caller. This restriction doesn&#8217;t apply on Linux or on most other implementations.</p>
</div>
<p class="noindent">If the calling process is not a process group leader, <em>setsid()</em> creates a new session.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>pid_t <span class="codestrong">setsid</span>(void);</p>
<p class="right">Returns session ID of new session, or &#8211;1 on error</p>
</div>
<p class="noindentb">The <em>setsid()</em> system call creates a new session as follows:</p>
<p class="bull">&#8226; The calling process becomes the leader of a new session, and is made the leader of a new process group within that session. The calling process&#8217;s process group ID and session ID are set to the same value as its process ID.</p>
<p class="bull">&#8226; The calling process has no controlling terminal. Any previously existing connection to a controlling terminal is broken.</p>
<p class="noindentt">If the calling process is a process group leader, <em>setsid()</em> fails with the error <span class="literal">EPERM</span>. The simplest way of ensuring that this doesn&#8217;t happen is to perform a <em>fork()</em> and have the parent exit while the child carries on to call <em>setsid()</em>. Since the child inherits its parent&#8217;s process group ID and receives its own unique process ID, it can&#8217;t be a process group leader.</p>
<p class="indent">The restriction against a process group leader being able to call <em>setsid()</em> is necessary because, without it, the process group leader would be able to place itself in another (new) session, while other members of the process group remained in the original session. (A new process group would not be created, since, by definition, the process group leader&#8217;s process group ID is already the same as its process ID.) This would violate the strict two-level hierarchy of sessions and process groups, whereby all members of a process group must be part of the same session.</p>
<div class="block">
<p class="noindent">When a new process is created via <em>fork()</em>, the kernel ensures not only that it has a unique process ID, but also that the process ID doesn&#8217;t match the process group ID or session ID of any existing process. Thus, even if the leader of a process group or a session has exited, a new process can&#8217;t reuse the leader&#8217;s process ID and thereby accidentally become the leader of an existing session or process group.</p>
</div>
<p class="noindent"><a href="ch34.xhtml#ch34ex2">Listing 34-2</a> demonstrates the use of <em>setsid()</em> to create a new session. To check that it no longer has a controlling terminal, this program attempts to open the special file <span class="literal">/dev/tty</span> (described in the next section). When we run this program, we see the following:</p>
<p class="programs">$ <span class="codestrong">ps -p $$ -o 'pid pgid sid command'</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">$$ is PID of shell</span><br/>&#160;&#160;PID&#160;&#160;PGID&#160;&#160;&#160;SID COMMAND<br/>12243 12243 12243 bash&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">PID, PGID, and SID of shell</span><br/>$ <span class="codestrong">./t_setsid</span><br/>$ PID=12352, PGID=12352, SID=12352<br/>ERROR [ENXIO Device not configured] open /dev/tty</p>
<p class="noindent"><span epub:type="pagebreak" id="page_706"/>As can be seen from the output, the process successfully places itself in a new process group within a new session. Since this session has no controlling terminal, the <em>open()</em> call fails. (In the penultimate line of program output above, we see a shell prompt mixed with the program output, because the shell notices that the parent process has exited after the <em>fork()</em> call, and so prints its next prompt before the child has completed.)</p>
<p class="examplet"><a id="ch34ex2"/><strong>Listing 34-2:</strong> Creating a new session</p>
<p class="programsli">_________________________________________________________ <span class="codestrong">pgsjc/t_setsid.c</span><br/><br/>#define _XOPEN_SOURCE 500<br/>#include &lt;unistd.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;if (fork() != 0)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Exit if parent, or on error */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_exit(EXIT_SUCCESS);<br/><br/>&#160;&#160;&#160;&#160;if (setsid() == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("setsid");<br/><br/>&#160;&#160;&#160;&#160;printf("PID=%ld, PGID=%ld, SID=%ld\n", (long) getpid(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) getpgrp(), (long) getsid(0));<br/><br/>&#160;&#160;&#160;&#160;if (open("/dev/tty", O_RDWR) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open /dev/tty");<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________________ <span class="codestrong">pgsjc/t_setsid.c</span></p>
<h3 class="h3" id="ch34lev1sec04"><strong>34.4 Controlling Terminals and Controlling Processes</strong></h3>
<p class="noindenta">All of the processes in a session may have a (single) controlling terminal. Upon creation, a session has no controlling terminal; the controlling terminal is established when the session leader first opens a terminal that is not already the controlling terminal for a session, unless the <span class="literal">O_NOCTTY</span> flag is specified when calling <em>open()</em>. A terminal may be the controlling terminal for at most one session.</p>
<div class="block">
<p class="noindent">SUSv3 specifies the function <em>tcgetsid(int fd)</em> (prototyped in <span class="literal">&lt;termios.h&gt;</span>), which returns the ID of the session associated with the controlling terminal specified by <em>fd</em>. This function is provided in <em>glibc</em> (where it is implemented using the <em>ioctl()</em> <span class="literal">TIOCGSID</span> operation).</p>
</div>
<p class="noindent">The controlling terminal is inherited by the child of a <em>fork()</em> and preserved across an <em>exec()</em>.</p>
<p class="indent">When a session leader opens a controlling terminal, it simultaneously becomes the controlling process for the terminal. If a terminal disconnect subsequently occurs, the kernel sends the controlling process a <span class="literal">SIGHUP</span> signal to inform it of this event. We go into further detail on this point in <a href="ch34.xhtml#ch34lev2sec02">Section 34.6.2</a>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_707"/>If a process has a controlling terminal, opening the special file <span class="literal">/dev/tty</span> obtains a file descriptor for that terminal. This is useful if standard input and output are redirected, and a program wants to ensure that it is communicating with the controlling terminal. For example, the <em>getpass()</em> function described in <a href="ch08.xhtml#ch08lev1sec05">Section 8.5</a> opens <span class="literal">/dev/tty</span> for this purpose. If the process doesn&#8217;t have a controlling terminal, opening <span class="literal">/dev/tty</span> fails with the error <span class="literal">ENXIO</span>.</p>
<h5 class="h5" id="ch34lev3sec03"><strong>Removing a process&#8217;s association with the controlling terminal</strong></h5>
<p class="noindenta">The <em>ioctl(fd, TIOCNOTTY)</em> operation can be used to remove a process&#8217;s association with its controlling terminal, specified via the file descriptor <em>fd</em>. After this call, attempts to open <span class="literal">/dev/tty</span> will fail. (Although not specified in SUSv3, the <span class="literal">TIOCNOTTY</span> operation is supported on most UNIX implementations.)</p>
<p class="indent">If the calling process is the controlling process for the terminal, then as for the termination of the controlling process (<a href="ch34.xhtml#ch34lev2sec02">Section 34.6.2</a>), the following steps occur:</p>
<ol>
<li class="order"><p class="orderp">All processes in the session lose their association with the controlling terminal.</p></li>
<li class="order"><p class="orderp">The controlling terminal loses its association with the session, and can therefore be acquired as the controlling terminal by another session leader.</p></li>
<li class="order"><p class="orderp">The kernel sends a <span class="literal">SIGHUP</span> signal (and a <span class="literal">SIGCONT</span> signal) to all members of the foreground process group, to inform them of the loss of the controlling terminal.</p></li>
</ol>
<h5 class="h5" id="ch34lev3sec04"><strong>Establishing a controlling terminal on BSD</strong></h5>
<p class="noindenta">SUSv3 leaves the manner in which a session acquires a controlling terminal unspecified, merely stating that specifying the <span class="literal">O_NOCTTY</span> flag when opening a terminal guarantees that the terminal won&#8217;t become a controlling terminal for the session. The Linux semantics that we have described above derive from System V.</p>
<p class="indent">On BSD systems, opening a terminal in the session leader never causes the terminal to become a controlling terminal, regardless of whether the <span class="literal">O_NOCTTY</span> flag is specified. Instead, the session leader uses the <em>ioctl()</em> <span class="literal">TIOCSCTTY</span> operation to explicitly establish the terminal referred to by the file descriptor <em>fd</em> as the controlling terminal:</p>
<p class="programs">if (ioctl(fd, TIOCSCTTY, 0) == -1)<br/>&#160;&#160;&#160;&#160;errExit("ioctl");</p>
<p class="noindent">This operation can be performed only if the session doesn&#8217;t already have a controlling terminal.</p>
<p class="indent">The <span class="literal">TIOCSCTTY</span> operation is also available on Linux, but it is not widespread on other (non-BSD) implementations.</p>
<h5 class="h5" id="ch34lev3sec05"><strong>Obtaining a pathname that refers to the controlling terminal: <em>ctermid()</em></strong></h5>
<p class="noindenta">The <em>ctermid()</em> function returns a pathname referring to the controlling terminal.</p>
<div class="box">
<p class="programsa">#include &lt;stdio.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Defines L_ctermid constant */<br/><br/>char *<span class="codestrong">ctermid</span>(char *<span class="font1">ttyname</span>);</p>
<p class="right">Returns pointer to string containing pathname of controlling terminal, or <span class="literal">NULL</span> if pathname could not be determined</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_708"/>The <em>ctermid()</em> function returns the controlling terminal&#8217;s pathname in two different ways: via the function result and via the buffer pointed to by <em>ttyname</em>.</p>
<p class="indent">If <em>ttyname</em> is not <span class="literal">NULL</span>, then it should be a buffer of at least <span class="literal">L_ctermid</span> bytes, and the pathname is copied into this array. In this case, the function return value is also a pointer to this buffer. If <em>ttyname</em> is <span class="literal">NULL</span>, <em>ctermid()</em> returns a pointer to a statically allocated buffer containing the pathname. When <em>ttyname</em> is <span class="literal">NULL</span>, <em>ctermid()</em> is not reentrant.</p>
<p class="indent">On Linux and other UNIX implementations, <em>ctermid()</em> typically yields the string <span class="literal">/dev/tty</span>. The purpose of this function is to ease portability to non-UNIX systems.</p>
<h3 class="h3" id="ch34lev1sec05"><strong>34.5 Foreground and Background Process Groups</strong></h3>
<p class="noindenta">The controlling terminal maintains the notion of a foreground process group. Within a session, only one process group can be in the foreground at a particular moment; all of the other process groups in the session are background process groups. The foreground process group is the only process group that can freely read and write on the controlling terminal. When one of the signal-generating terminal characters is typed on the controlling terminal, the terminal driver delivers the corresponding signal to the members of the foreground process group. We describe further details in <a href="ch34.xhtml#ch34lev1sec07">Section 34.7</a>.</p>
<div class="block">
<p class="noindent">In theory, situations can arise where a session has no foreground process group. This could happen, for example, if all processes in the foreground process group terminate, and no other process notices this fact and moves itself into the foreground. In practice, such situations are rare. Normally, the shell is the process monitoring the status of the foreground process group, and it moves itself back into the foreground when it notices (via <em>wait()</em>) that the foreground process group has terminated.</p>
</div>
<p class="noindent">The <em>tcgetpgrp()</em> and <em>tcsetpgrp()</em> functions respectively retrieve and change the process group of a terminal. These functions are used primarily by job-control shells.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>pid_t <span class="codestrong">tcgetpgrp</span>(int <span class="font1">fd</span>);</p>
<p class="right">Returns process group ID of terminal&#8217;s foreground process group, or &#8211;1 on error</p>
<p class="programsat">int <span class="codestrong">tcsetpgrp</span>(int <span class="font1">fd</span>, pid_t <span class="font1">pgid</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>tcgetpgrp()</em> function returns the process group ID of the foreground process group of the terminal referred to by the file descriptor <em>fd</em>, which must be the controlling terminal of the calling process.</p>
<div class="block">
<p class="noindent">If there is no foreground process group for this terminal, <em>tcgetpgrp()</em> returns a value greater than 1 that doesn&#8217;t match the ID of any existing process group. (This is the behavior specified by SUSv3.)</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_709"/>The <em>tcsetpgrp()</em> function changes the foreground process group for a terminal. If the calling process has a controlling terminal, and the file descriptor <em>fd</em> refers to that terminal, then <em>tcsetpgrp()</em> sets the foreground process group of the terminal to the value specified in <em>pgid</em>, which must match the process group ID of one of the processes in the calling process&#8217;s session.</p>
<p class="indent">Both <em>tcgetpgrp()</em> and <em>tcsetpgrp()</em> are standardized in SUSv3. On Linux, as on many other UNIX implementations, these functions are implemented using two unstandardized <em>ioctl()</em> operations: <span class="literal">TIOCGPGRP</span> and <span class="literal">TIOCSPGRP</span>.</p>
<h3 class="h3" id="ch34lev1sec06"><strong>34.6 The</strong> <span class="literal"><span class="codestrong">SIGHUP</span></span> <strong>Signal</strong></h3>
<p class="noindentab">When a controlling process loses its terminal connection, the kernel sends it a <span class="literal">SIGHUP</span> signal to inform it of this fact. (A <span class="literal">SIGCONT</span> signal is also sent, to ensure that the process is restarted in case it had been previously stopped by a signal.) Typically, this may occur in two circumstances:</p>
<p class="bull">&#8226; When a &#8220;disconnect&#8221; is detected by the terminal driver, indicating a loss of signal on a modem or terminal line.</p>
<p class="bull">&#8226; When a terminal window is closed on a workstation. This occurs because the last open file descriptor for the master side of the pseudoterminal associated with the terminal window is closed.</p>
<p class="noindentt">The default action of <span class="literal">SIGHUP</span> is to terminate a process. If the controlling process instead handles or ignores this signal, then further attempts to read from the terminal return end-of-file.</p>
<div class="block">
<p class="noindent">SUSv3 states that if both a terminal disconnect occurs and one of the conditions giving rise to an <span class="literal">EIO</span> error from <em>read()</em> exists, then it is unspecified whether <em>read()</em> returns end-of-file or fails with the error <span class="literal">EIO</span>. Portable programs must allow for both possibilities. We look at the circumstances in which <em>read()</em> may fail with the <span class="literal">EIO</span> error in <a href="ch34.xhtml#ch34lev2sec04">Sections 34.7.2</a> and <a href="ch34.xhtml#ch34lev2sec06">34.7.4</a>.</p>
</div>
<p class="noindentb">The delivery of <span class="literal">SIGHUP</span> to the controlling process can set off a kind of chain reaction, resulting in the delivery of <span class="literal">SIGHUP</span> to many other processes. This may occur in two ways:</p>
<p class="bull">&#8226; The controlling process is typically a shell. The shell establishes a handler for <span class="literal">SIGHUP</span>, so that, before terminating, it can send a <span class="literal">SIGHUP</span> to each of the jobs that it has created. This signal terminates those jobs by default, but if instead they catch the signal, then they are thus informed of the shell&#8217;s demise.</p>
<p class="bull">&#8226; Upon termination of the controlling process for a terminal, the kernel disassociates all processes in the session from the controlling terminal, disassociates the controlling terminal from the session (so that it may be acquired as the controlling terminal by another session leader), and informs the members of the foreground process group of the terminal of the loss of their controlling terminal by sending them a <span class="literal">SIGHUP</span> signal.</p>
<p class="noindentt">We go into the details of each of these two cases in the next sections.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_710"/>The <span class="literal">SIGHUP</span> signal also finds other uses. In <a href="ch34.xhtml#ch34lev2sec06">Section 34.7.4</a>, we&#8217;ll see that <span class="literal">SIGHUP</span> is generated when a process group becomes orphaned. In addition, manually sending <span class="literal">SIGHUP</span> is conventionally used as a way of triggering a daemon process to reinitialize itself or reread its configuration file. (By definition, a daemon process doesn&#8217;t have a controlling terminal, and so can&#8217;t otherwise receive <span class="literal">SIGHUP</span> from the kernel.) We describe the use of <span class="literal">SIGHUP</span> with daemon processes in <a href="ch37.xhtml#ch37lev1sec04">Section 37.4</a>.</p>
</div>
<h4 class="h4" id="ch34lev2sec01"><strong>34.6.1 Handling of</strong> <span class="literal"><span class="codestrong">SIGHUP</span></span> <strong>by the Shell</strong></h4>
<p class="noindenta">In a login session, the shell is normally the controlling process for the terminal. Most shells are programmed so that, when run interactively, they establish a handler for <span class="literal">SIGHUP</span>. This handler terminates the shell, but beforehand sends a <span class="literal">SIGHUP</span> signal to each of the process groups (both foreground and background) created by the shell. (The <span class="literal">SIGHUP</span> signal may be followed by a <span class="literal">SIGCONT</span> signal, depending on the shell and whether or not the job is currently stopped.) How the processes in these groups respond to <span class="literal">SIGHUP</span> is application-dependent; if no special action is taken, they are terminated by default.</p>
<div class="block">
<p class="noindent">Some job-control shells also send <span class="literal">SIGHUP</span> to stopped background jobs if the shell exits normally (e.g., when we explicitly log out or type <em>Control-D</em> in a shell window). This is done by both <em>bash</em> and the Korn shell (after printing a message on the first logout attempt).</p>
<p class="indent">The <em>nohup(1)</em> command can be used to make a command immune to the <span class="literal">SIGHUP</span> signal&#8212;that is, start it with the disposition of <span class="literal">SIGHUP</span> set to <span class="literal">SIG_IGN</span>. The <em>bash</em> built-in command <em>disown</em> serves a similar purpose, removing a job from the shell&#8217;s list of jobs, so that the job is not sent <span class="literal">SIGHUP</span> when the shell terminates.</p>
</div>
<p class="noindent">We can use the program in <a href="ch34.xhtml#ch34ex3">Listing 34-3</a> to demonstrate that when the shell receives <span class="literal">SIGHUP</span>, it in turn sends <span class="literal">SIGHUP</span> to the jobs it has created. The main task of this program is to create a child process, and then have both the parent and the child pause to catch <span class="literal">SIGHUP</span> and display a message if it is received. If the program is given an optional command-line argument (which may be any string), the child places itself in a different process group (within the same session). This is useful to show that the shell doesn&#8217;t send <span class="literal">SIGHUP</span> to a process group that it did not create, even if it is in the same session as the shell. (Since the final <span class="literal">for</span> loop of the program loops forever, this program uses <em>alarm()</em> to establish a timer to deliver <span class="literal">SIGALRM</span>. The arrival of an unhandled <span class="literal">SIGALRM</span> signal guarantees process termination, if the process is not otherwise terminated.)</p>
<p class="examplet"><a id="ch34ex3"/><strong>Listing 34-3:</strong> Catching <span class="literal">SIGHUP</span></p>
<p class="programsli">_____________________________________________________ <span class="codestrong">pgsjc/catch_SIGHUP.c</span><br/><br/>#define _XOPEN_SOURCE 500<br/>#include &lt;unistd.h&gt;<br/>#include &lt;signal.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static void<br/>handler(int sig)<br/>{<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;pid_t childPid;<br/>&#160;&#160;&#160;&#160;struct sigaction sa;<br/><br/>&#160;&#160;&#160;&#160;setbuf(stdout, NULL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Make stdout unbuffered */<br/><br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;sa.sa_flags = 0;<br/>&#160;&#160;&#160;&#160;sa.sa_handler = handler;<br/>&#160;&#160;&#160;&#160;if (sigaction(SIGHUP, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;childPid = fork();<br/>&#160;&#160;&#160;&#160;if (childPid == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;if (childPid == 0 &#38;&#38; argc &gt; 1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (setpgid(0, 0) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Move to new process group */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("setpgid");<br/><br/>&#160;&#160;&#160;&#160;printf("PID=%ld; PPID=%ld; PGID=%ld; SID=%ld\n", (long) getpid(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) getppid(), (long) getpgrp(), (long) getsid(0));<br/><br/>&#160;&#160;&#160;&#160;alarm(60);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* An unhandled SIGALRM ensures this process<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;will die if nothing else terminates it */<br/>&#160;&#160;&#160;&#160;for(;;) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for signals */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pause();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%ld: caught SIGHUP\n", (long) getpid());<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>_____________________________________________________ <span class="codestrong">pgsjc/catch_SIGHUP.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_711"/>Suppose that we enter the following commands in a terminal window in order to run two instances of the program in <a href="ch34.xhtml#ch34ex3">Listing 34-3</a>, and then we close the terminal window:</p>
<p class="programs">$ <span class="codestrong">echo $$</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">PID of shell is ID of session</span><br/>5533<br/>$ <span class="codestrong">./catch_SIGHUP &gt; samegroup.log 2&gt;&#38;1 &#38;</span><br/>$ <span class="codestrong">./catch_SIGHUP x &gt; diffgroup.log 2&gt;&#38;1</span></p>
<p class="noindent">The first command results in the creation of two processes that remain in the process group created by the shell. The second command creates a child that places itself in a separate process group.</p>
<p class="indent">When we look at <span class="literal">samegroup.log</span>, we see that it contains the following output, indicating that both members of this process group were signaled by the shell:</p>
<p class="programs">$ <span class="codestrong">cat samegroup.log</span><br/>PID=5612; PPID=5611; PGID=5611; SID=5533&#160;&#160;&#160;&#160;<span class="font1">Child</span><br/>PID=5611; PPID=5533; PGID=5611; SID=5533&#160;&#160;&#160;&#160;<span class="font1">Parent</span><br/>5611: caught SIGHUP<br/>5612: caught SIGHUP</p>
<p class="noindent"><span epub:type="pagebreak" id="page_712"/>When we examine <span class="literal">diffgroup.log</span>, we find the following output, indicating that when the shell received <span class="literal">SIGHUP</span>, it did not send a signal to the process group that it did not create:</p>
<p class="programs">$ <span class="codestrong">cat diffgroup.log</span><br/>PID=5614; PPID=5613; PGID=5614; SID=5533&#160;&#160;&#160;&#160;<span class="font1">Child</span><br/>PID=5613; PPID=5533; PGID=5613; SID=5533&#160;&#160;&#160;&#160;<span class="font1">Parent</span><br/>5613: caught SIGHUP&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Parent was signaled, but not child</span></p>
<h4 class="h4" id="ch34lev2sec02"><strong>34.6.2</strong> <span class="literal"><span class="codestrong">SIGHUP</span></span> <strong>and Termination of the Controlling Process</strong></h4>
<p class="noindenta">If the <span class="literal">SIGHUP</span> signal that is sent to the controlling process as the result of a terminal disconnect causes the controlling process to terminate, then <span class="literal">SIGHUP</span> is sent to all of the members of the terminal&#8217;s foreground process group (refer to <a href="ch25.xhtml#ch25lev1sec02">Section 25.2</a>). This behavior is a consequence of the termination of the controlling process, rather than a behavior associated specifically with the <span class="literal">SIGHUP</span> signal. If the controlling process terminates for any reason, then the foreground process group is signaled with <span class="literal">SIGHUP</span>.</p>
<div class="block">
<p class="noindent">On Linux, the <span class="literal">SIGHUP</span> signal is followed by a <span class="literal">SIGCONT</span> signal to ensure that the process group is resumed if it had earlier been stopped by a signal. However, SUSv3 doesn&#8217;t specify this behavior, and most other UNIX implementations don&#8217;t send a <span class="literal">SIGCONT</span> in this circumstance.</p>
</div>
<p class="noindent">We can use the program in <a href="ch34.xhtml#ch34ex4">Listing 34-4</a> to demonstrate that termination of the controlling process causes a <span class="literal">SIGHUP</span> signal to be sent to all members of the terminal&#8217;s foreground process group. This program creates one child process for each of its command-line arguments <span class="ent">&#x2461;</span>. If the corresponding command-line argument is the letter <em>d</em>, then the child process places itself in its own (different) process group <span class="ent">&#x2462;</span>; otherwise, the child remains in the same process group as its parent. (We use the letter <em>s</em> to specify the latter action, although any letter other than <em>d</em> can be used.) Each child then establishes a handler for <span class="literal">SIGHUP</span> <span class="ent">&#x2463;</span>. To ensure that they terminate if no event occurs that would otherwise terminate them, the parent and the children both call <em>alarm()</em> to set a timer that delivers a <span class="literal">SIGALRM</span> signal after 60 seconds <span class="ent">&#x2464;</span>. Finally, all processes (including the parent) print out their process ID and process group ID <span class="ent">&#x2465;</span> and then loop waiting for signals to arrive <span class="ent">&#x2466;</span>. When a signal is delivered, the handler prints the process ID of the process and signal number <span class="ent">&#x2460;</span>.</p>
<p class="examplet"><a id="ch34ex4"/><strong>Listing 34-4:</strong> Catching <span class="literal">SIGHUP</span> when a terminal disconnect occurs</p>
<p class="programsli">______________________________________________________ <span class="codestrong">pgsjc/disc_SIGHUP.c</span><br/><br/>&#160;&#160;&#160;#define _GNU_SOURCE&#160;&#160;&#160;&#160;&#160;/* Get strsignal() declaration from &lt;string.h&gt; */<br/>&#160;&#160;&#160;#include &lt;string.h&gt;<br/>&#160;&#160;&#160;#include &lt;signal.h&gt;<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Handler for SIGHUP */<br/>&#160;&#160;&#160;handler(int sig)<br/>&#160;&#160;&#160;{<br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;printf("PID %ld: caught signal %2d (%s)\n", (long) getpid(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sig, strsignal(sig));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* UNSAFE (see <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>) */<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;pid_t parentPid, childPid;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int j;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sigaction sa;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s {d|s}... [ &gt; sig.log 2&gt;&#38;1 ]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;setbuf(stdout, NULL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Make stdout unbuffered */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;parentPid = getpid();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("PID of parent process is:&#160;&#160;&#160;&#160;&#160;&#160;&#160;%ld\n", (long) parentPid);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Foreground process group ID is: %ld\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) tcgetpgrp(STDIN_FILENO));<br/><br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;for (j = 1; j &lt; argc; j++) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create child processes */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;childPid = fork();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (childPid == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork");<br/><br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (childPid == 0) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If child... */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argv[j][0] == 'd')&#160;&#160;&#160;&#160;&#160;&#160;/* 'd' --&gt; to different pgrp */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (setpgid(0, 0) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("setpgid");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_flags = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_handler = handler;<br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGHUP, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child exits loop */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* All processes fall through to here */<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;alarm(60);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Ensure each process eventually terminates */<br/><br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;printf("PID=%ld PGID=%ld\n", (long) getpid(), (long) getpgrp());<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (;;)<br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pause();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for signals */<br/>&#160;&#160;&#160;}<br/>______________________________________________________ <span class="codestrong">pgsjc/disc_SIGHUP.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_713"/>Suppose that we run the program in <a href="ch34.xhtml#ch34ex4">Listing 34-4</a> in a terminal window with the following command:</p>
<p class="programs">$ <span class="codestrong">exec ./disc_SIGHUP d s s &gt; sig.log 2&gt;&#38;1</span></p>
<p class="noindent">The <em>exec</em> command is a shell built-in command that causes the shell to do an <em>exec()</em>, replacing itself with the named program. Since the shell was the controlling process for the terminal, our program is now the controlling process and will receive <span epub:type="pagebreak" id="page_714"/><span class="literal">SIGHUP</span> when the terminal window is closed. After closing the terminal window, we find the following lines in the file <span class="literal">sig.log</span>:</p>
<p class="programs">PID of parent process is:&#160;&#160;&#160;&#160;&#160;&#160;&#160;12733<br/>Foreground process group ID is: 12733<br/>PID=12755 PGID=12755&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">First child is in a different process group</span><br/>PID=12756 PGID=12733&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Remaining children are in same PG as parent</span><br/>PID=12757 PGID=12733<br/>PID=12733 PGID=12733&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">This is the parent process</span><br/>PID 12756: caught signal&#160;&#160;1 (Hangup)<br/>PID 12757: caught signal&#160;&#160;1 (Hangup)</p>
<p class="noindent">Closing the terminal window caused <span class="literal">SIGHUP</span> to be sent to the controlling process (the parent), which terminated as a result. We see that the two children that were in the same process group as the parent (i.e., the foreground process group for the terminal) also both received <span class="literal">SIGHUP</span>. However, the child that was in a separate (background) process group did not receive this signal.</p>
<h3 class="h3" id="ch34lev1sec07"><strong>34.7 Job Control</strong></h3>
<p class="noindenta">Job control is a feature that first appeared around 1980 in the C shell on BSD. Job control permits a shell user to simultaneously execute multiple commands (jobs), one in the foreground and the others in the background. Jobs can be stopped and resumed, and moved between the foreground and background, as described in the following paragraphs.</p>
<div class="block">
<p class="noindent">In the initial POSIX.1 standard, support for job control was optional. Later UNIX standards made support mandatory.</p>
</div>
<p class="noindent">In the days of character-based dumb terminals (physical terminal devices that were limited to displaying ASCII characters), many shell users knew how to use shell job-control commands. With the advent of bit-mapped monitors running the X Window System, knowledge of shell job control is less common. However, job control remains a useful feature. Using job control to manage multiple simultaneous commands can be faster and simpler than switching back and forth between multiple windows. For those readers unfamiliar with job control, we begin with a short tutorial on its use. We then go on to look at a few details of the implementation of job control and consider the implications of job control for application design.</p>
<h4 class="h4" id="ch34lev2sec03"><strong>34.7.1 Using Job Control Within the Shell</strong></h4>
<p class="noindenta">When we enter a command terminated by an ampersand (<span class="literal">&#38;</span>), it is run as a background job, as illustrated by the following examples:</p>
<p class="programs">$ <span class="codestrong">grep -r SIGHUP /usr/src/linux &gt;x &#38;</span><br/>[1] 18932&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Job 1: process running grep has PID 18932</span><br/>$ <span class="codestrong">sleep 60 &#38;</span><br/>[2] 18934&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Job 2: process running sleep has PID 18934</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_715"/>Each job that is placed in the background is assigned a unique job number by the shell. This job number is shown in square brackets after the job is started in the background, and also when the job is manipulated or monitored by various job-control commands. The number following the job number is the process ID of the process created to execute the command, or, in the case of a pipeline, the process ID of the last process in the pipeline. In the commands described in the following paragraphs, jobs can be referred to using the notation <em>%num</em>, where <em>num</em> is the number assigned to this job by the shell.</p>
<div class="block">
<p class="noindent">In many cases, the <em>%num</em> argument can be omitted, in which case the <em>current</em> job is used by default. The current job is the last job that was stopped in the foreground (using the <em>suspend</em> character described below), or, if there is no such job, then the last job that was started in the background. (There are some variations in the details of how different shells determine which background job is considered the current job.) In addition, the notation <em>%%</em> or <em>%+</em> refers to the current job, and the notation <em>%&#8211;</em> refers to the <em>previous current</em> job. The current and previous current jobs are marked by a plus (+) and a minus (&#8211;) sign, respectively, in the output produced by the <em>jobs</em> command, which we describe next.</p>
</div>
<p class="noindent">The <em>jobs</em> shell built-in command lists all background jobs:</p>
<p class="programs">$ <span class="codestrong">jobs</span><br/>[1]- Running&#160;&#160;&#160;&#160;&#160;&#160;&#160;grep -r SIGHUP /usr/src/linux &gt;x &#38;<br/>[2]+ Running&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep 60 &#38;</p>
<p class="noindent">At this point, the shell is the foreground process for the terminal. Since only a foreground process can read input from the controlling terminal and receive terminal-generated signals, sometimes it is necessary to move a background job into the foreground. This is done using the <em>fg</em> shell built-in command:</p>
<p class="programs">$ <span class="codestrong">fg %1</span><br/>grep -r SIGHUP /usr/src/linux &gt;x</p>
<p class="noindent">As demonstrated in this example, the shell redisplays a job&#8217;s command line whenever the job is moved between the foreground and the background. Below, we&#8217;ll see that the shell also does this whenever the job&#8217;s state changes in the background.</p>
<p class="indent">When a job is running in the foreground, we can suspend it using the terminal <em>suspend</em> character (normally <em>Control-Z</em>), which sends the <span class="literal">SIGTSTP</span> signal to the terminal&#8217;s foreground process group:</p>
<p class="programs"><span class="font1">Type Control-Z</span><br/>[1]+ Stopped&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;grep -r SIGHUP /usr/src/linux &gt;x</p>
<p class="noindent">After we typed <em>Control-Z</em>, the shell displays the command that has been stopped in the background. If desired, we can use the <em>fg</em> command to resume the job in the foreground, or use the <em>bg</em> command to resume it in the background. In both cases, the shell resumes the stopped job by sending it a <span class="literal">SIGCONT</span> signal.</p>
<p class="programs">$ <span class="codestrong">bg %1</span><br/>[1]+ grep -r SIGHUP /usr/src/linux &gt;x &#38;</p>
<p class="noindent"><span epub:type="pagebreak" id="page_716"/>We can stop a background job by sending it a <span class="literal">SIGSTOP</span> signal:</p>
<p class="programs">$ <span class="codestrong">kill -STOP %1</span><br/>[1]+ Stopped&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;grep -r SIGHUP /usr/src/linux &gt;x<br/>$ <span class="codestrong">jobs</span><br/>[1]+ Stopped&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;grep -r SIGHUP /usr/src/linux &gt;x<br/>[2]- Running&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep 60 &#38;<br/>$ <span class="codestrong">bg %1</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Restart job in background</span><br/>[1]+ grep -r SIGHUP /usr/src/linux &gt;x &#38;</p>
<div class="block">
<p class="noindent">The Korn and C shells provide the command <em>stop</em> as a shorthand for <em>kill &#8211;stop</em>.</p>
</div>
<p class="noindent">When a background job eventually completes, the shell prints a message prior to displaying the next shell prompt:</p>
<p class="programs"><span class="font1">Press Enter to see a further shell prompt</span><br/>[1]- Done&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;grep -r SIGHUP /usr/src/linux &gt;x<br/>[2]+ Done&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep 60<br/>$</p>
<p class="noindent">Only processes in the foreground job may read from the controlling terminal. This restriction prevents multiple jobs from competing for terminal input. If a background job tries to read from the terminal, it is sent a <span class="literal">SIGTTIN</span> signal. The default action of <span class="literal">SIGTTIN</span> is to stop the job:</p>
<p class="programs">$ <span class="codestrong">cat &gt; x.txt &#38;</span><br/>[1] 18947<br/>$<br/><span class="font1">Press Enter once more in order to see job state changes displayed prior to next shell prompt</span><br/>[1]+ Stopped&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cat &gt;x.txt<br/>$</p>
<div class="block">
<p class="noindent">It may not always be necessary to press the <em>Enter</em> key to see the job state changes in the previous example and some of the following examples. Depending on kernel scheduling decisions, the shell may receive notification about changes in the state of the background job before the next shell prompt is displayed.</p>
</div>
<p class="noindent">At this point, we must bring the job into the foreground (<em>fg</em>), and provide the required input. If desired, we can then continue execution of the job in the background by first suspending it and then resuming it in the background (<em>bg</em>). (Of course, in this particular example, <em>cat</em> would immediately be stopped again, since it would once more try to read from the terminal.)</p>
<p class="indent">By default, background jobs are allowed to perform output to the controlling terminal. However, if the <span class="literal">TOSTOP</span> flag (<em>terminal output stop</em>, <a href="ch62.xhtml#ch62lev1sec05">Section 62.5</a>) is set for the terminal, then attempts by background jobs to perform terminal output result in the generation of a <span class="literal">SIGTTOU</span> signal. (We can set the <span class="literal">TOSTOP</span> flag using the <em>stty</em> command, which is described in <a href="ch62.xhtml#ch62lev1sec03">Section 62.3</a>.) Like <span class="literal">SIGTTIN</span>, a <span class="literal">SIGTTOU</span> signal stops the job.</p>
<p class="programs">$ <span class="codestrong">stty tostop</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Enable</span> TOSTOP <span class="font1">flag for this terminal</span><br/>$ <span class="codestrong">date &#38;</span><br/>[1] 19023<br/>$<br/><span class="font1">Press Enter once more to see job state changes displayed prior to next shell prompt</span><br/>[1]+ Stopped&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;date</p>
<p class="noindent"><span epub:type="pagebreak" id="page_717"/>We can then see the output of the job by bringing it into the foreground:</p>
<p class="programs">$ <span class="codestrong">fg</span><br/>date<br/>Tue Dec 28 16:20:51 CEST 2010</p>
<p class="noindent">The various states of a job under job control, as well as the shell commands and terminal characters (and the accompanying signals) used to move a job between these states, are summarized in <a href="ch34.xhtml#ch34fig2">Figure 34-2</a>. This figure also includes a notional <em>terminated</em> state for a job. This state can be reached by sending various signals to the job, including <span class="literal">SIGINT</span> and <span class="literal">SIGQUIT</span>, which can be generated from the keyboard.</p>
<div class="image"><img src="../images/f34-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch34fig2"/><strong>Figure 34-2:</strong> Job-control states</p>
<h4 class="h4" id="ch34lev2sec04"><strong>34.7.2 Implementing Job Control</strong></h4>
<p class="noindenta">In this section, we examine various aspects of the implementation of job control, and conclude with an example program that makes the operation of job control more transparent.</p>
<p class="indentb">Although optional in the original POSIX.1 standard, later standards, including SUSv3, require that an implementation support job control. This support requires the following:</p>
<p class="bull">&#8226; The implementation must provide certain job-control signals: <span class="literal">SIGTSTP</span>, <span class="literal">SIGSTOP</span>, <span class="literal">SIGCONT</span>, <span class="literal">SIGTTOU</span>, and <span class="literal">SIGTTIN</span>. In addition, the <span class="literal">SIGCHLD</span> signal (<a href="ch26.xhtml#ch26lev1sec03">Section 26.3</a>) is also necessary, since it allows the shell (the parent of all jobs) to find out when one of its children terminates or is stopped.</p>
<p class="bull">&#8226; The terminal driver must support generation of the job-control signals, so that when certain characters are typed, or terminal I/O and certain other terminal operations (described below) are performed from a background job, an appropriate signal (as shown in <a href="ch34.xhtml#ch34fig2">Figure 34-2</a>) is sent to the relevant process group. In <span epub:type="pagebreak" id="page_718"/>order to be able to carry out these actions, the terminal driver must also record the session ID (controlling process) and foreground process group ID associated with a terminal (<a href="ch34.xhtml#ch34fig1">Figure 34-1</a>).</p>
<p class="bull">&#8226; The shell must support job control (most modern shells do so). This support is provided in the form of the commands described earlier to move a job between the foreground and background and monitor the state of jobs. Certain of these commands send signals to a job (as shown in <a href="ch34.xhtml#ch34fig2">Figure 34-2</a>). In addition, when performing operations that move a job between the <em>running in foreground</em> and any of the other states, the shell uses calls to <em>tcsetpgrp()</em> to adjust the terminal driver&#8217;s record of the foreground process group.</p>
<div class="block">
<p class="noindent">In <a href="ch20.xhtml#ch20lev1sec05">Section 20.5</a>, we saw that signals can generally be sent to a process only if the real or effective user ID of the sending process matches the real user ID or saved set-user-ID of the receiving process. However, <span class="literal">SIGCONT</span> is an exception to this rule. The kernel allows a process (e.g., the shell) to send <span class="literal">SIGCONT</span> to any process in the same session, regardless of process credentials. This relaxation of the rules for <span class="literal">SIGCONT</span> is required so that if a user starts a set-user-ID program that changes its credentials (in particular, its real user ID), it is still possible to resume it with <span class="literal">SIGCONT</span> if it is stopped.</p>
</div>
<h5 class="h5" id="ch34lev3sec06"><strong>The</strong> <span class="literal"><span class="codestrong">SIGTTIN</span></span> <strong>and</strong> <span class="literal"><span class="codestrong">SIGTTOU</span></span> <strong>signals</strong></h5>
<p class="noindentab">SUSv3 specifies (and Linux implements) some special cases that apply with respect to the generation of the <span class="literal">SIGTTIN</span> and <span class="literal">SIGTTOU</span> signals for background jobs:</p>
<p class="bull">&#8226; <span class="literal">SIGTTIN</span> is not sent if the process is currently blocking or ignoring this signal. Instead, a <em>read()</em> from the controlling terminal fails, setting <em>errno</em> to <span class="literal">EIO</span>. The rationale for this behavior is that the process would otherwise have no way of knowing that the <em>read()</em> was not permitted.</p>
<p class="bull">&#8226; Even if the terminal <span class="literal">TOSTOP</span> flag is set, <span class="literal">SIGTTOU</span> is not sent if the process is currently blocking or ignoring this signal. Instead, a <em>write()</em> to the controlling terminal is permitted (i.e., the <span class="literal">TOSTOP</span> flag is ignored).</p>
<p class="bull">&#8226; Regardless of the setting of the <span class="literal">TOSTOP</span> flag, certain functions that change terminal driver data structures result in the generation of <span class="literal">SIGTTOU</span> for a background process if it tries to apply them to its controlling terminal. These functions include <em>tcsetpgrp()</em>, <em>tcsetattr()</em>, <em>tcflush()</em>, <em>tcflow()</em>, <em>tcsendbreak()</em>, and <em>tcdrain()</em>. (These functions are described in <a href="ch62.xhtml#ch62">Chapter 62</a>.) If <span class="literal">SIGTTOU</span> is being blocked or ignored, these calls succeed.</p>
<h5 class="h5" id="ch34lev3sec07"><strong>Example program: demonstrating the operation of job control</strong></h5>
<p class="noindenta">The program in <a href="ch34.xhtml#ch34ex5">Listing 34-5</a> allows us to see how the shell organizes the commands in a pipeline into a job (process group). This program also allows us to monitor certain of the signals sent and the changes made to the terminal&#8217;s foreground process group setting under job control. The program is designed so that multiple instances can be run in a pipeline, as in the following example:</p>
<p class="programs">$ <span class="codestrong">./job_mon | ./job_mon | ./job_mon</span></p>
<p class="noindentb"><span epub:type="pagebreak" id="page_719"/>The program in <a href="ch34.xhtml#ch34ex5">Listing 34-5</a> performs the following steps:</p>
<p class="bull">&#8226; On startup, the program installs a single handler for <span class="literal">SIGINT</span>, <span class="literal">SIGTSTP</span>, and <span class="literal">SIGCONT</span> <span class="ent">&#x2463;</span>. The handler carries out the following steps:</p>
<p class="dash1">&#8211; Display the foreground process group for the terminal <span class="ent">&#x2460;</span>. To avoid multiple identical lines of output, this is done only by the process group leader.</p>
<p class="dash1">&#8211; Display the ID of the process, the process&#8217;s position in the pipeline, and the signal received <span class="ent">&#x2461;</span>.</p>
<p class="dash1">&#8211; The handler must do some extra work if it catches <span class="literal">SIGTSTP</span>, since, when caught, this signal doesn&#8217;t stop a process. So, to actually stop the process, the handler raises the <span class="literal">SIGSTOP</span> signal <span class="ent">&#x2462;</span>, which always stops a process. (We refine this treatment of <span class="literal">SIGTSTP</span> in <a href="ch34.xhtml#ch34lev2sec05">Section 34.7.3</a>.)</p>
<p class="bull">&#8226; If the program is the initial process in the pipeline, it prints headings for the output produced by all of the processes <span class="ent">&#x2465;</span>. In order to test whether it is the initial (or final) process in the pipeline, the program uses the <em>isatty()</em> function (described in <a href="ch62.xhtml#ch62lev1sec10">Section 62.10</a>) to check whether its standard input (or output) is a terminal <span class="ent">&#x2464;</span>. If the specified file descriptor refers to a pipe, <em>isatty()</em> returns false (0).</p>
<p class="bull">&#8226; The program builds a message to be passed to its successor in the pipeline. This message is an integer indicating the position of this process in the pipeline. Thus, for the initial process, the message contains the number 1. If the program is the initial process in the pipeline, the message is initialized to 0. If it is not the initial process in the pipeline, the program first reads this message from its predecessor <span class="ent">&#x2466;</span>. The program increments the message value before proceeding to the next steps <span class="ent">&#x2467;</span>.</p>
<p class="bull">&#8226; Regardless of its position in the pipeline, the program displays a line containing its pipeline position, process ID, parent process ID, process group ID, and session ID <span class="ent">&#x2468;</span>.</p>
<p class="bull">&#8226; Unless it is the last command in the pipeline, the program writes an integer message for its successor in the pipeline <span class="ent">&#x2469;</span>.</p>
<p class="bull">&#8226; Finally, the program loops forever, using <em>pause()</em> to wait for signals <span class="ent">&#x246A;</span>.</p>
<p class="examplet"><a id="ch34ex5"/><strong>Listing 34-5:</strong> Observing the treatment of a process under job control</p>
<p class="programsli">__________________________________________________________ <span class="codestrong">pgsjc/job_mon.c</span><br/><br/>&#160;&#160;&#160;#define _GNU_SOURCE&#160;&#160;&#160;&#160;&#160;/* Get declaration of strsignal() from &lt;string.h&gt; */<br/>&#160;&#160;&#160;#include &lt;string.h&gt;<br/>&#160;&#160;&#160;#include &lt;signal.h&gt;<br/>&#160;&#160;&#160;#include &lt;fcntl.h&gt;<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;static int cmdNum;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Our position in pipeline */<br/><br/>&#160;&#160;&#160;static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Handler for various signals */<br/>&#160;&#160;&#160;handler(int sig)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* UNSAFE: This handler uses non-async-signal-safe functions<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(fprintf(), strsignal(); see <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>) */<br/><span class="ent"><span epub:type="pagebreak" id="page_720"/>&#x2460;</span>&#160;&#160;&#160;&#160;&#160;if (getpid() == getpgrp())&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If process group leader */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(stderr, "Terminal FG process group: %ld\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) tcgetpgrp(STDERR_FILENO));<br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;fprintf(stderr, "Process %ld (%d) received signal %d (%s)\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) getpid(), cmdNum, sig, strsignal(sig));<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If we catch SIGTSTP, it won't actually stop us. Therefore we<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;raise SIGSTOP so we actually get stopped. */<br/><br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;if (sig == SIGTSTP)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;raise(SIGSTOP);<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sigaction sa;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_flags = SA_RESTART;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_handler = handler;<br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGINT, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGTSTP, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGCONT, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If stdin is a terminal, this is the first process in pipeline:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print a heading and initialize message to be sent down pipe */<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;if (isatty(STDIN_FILENO)) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(stderr, "Terminal FG process group: %ld\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) tcgetpgrp(STDIN_FILENO));<br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(stderr, "Command&#160;&#160;&#160;PID&#160;&#160;PPID&#160;&#160;PGRP&#160;&#160;&#160;SID\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cmdNum = 0;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Not first in pipeline, so read message from pipe */<br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (read(STDIN_FILENO, &#38;cmdNum, sizeof(cmdNum)) &lt;= 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("read got EOF or error");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/><span class="ent">&#x2467;</span>&#160;&#160;&#160;&#160;&#160;cmdNum++;<br/><span class="ent">&#x2468;</span>&#160;&#160;&#160;&#160;&#160;fprintf(stderr, "%4d&#160;&#160;&#160;&#160;%5ld %5ld %5ld %5ld\n", cmdNum,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) getpid(), (long) getppid(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) getpgrp(), (long) getsid(0));<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If not the last process, pass a message to the next process */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (!isatty(STDOUT_FILENO))&#160;&#160;&#160;/* If not tty, then should be pipe */<br/><span class="ent">&#x2469;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (write(STDOUT_FILENO, &#38;cmdNum, sizeof(cmdNum)) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("write");<br/><br/><span class="ent">&#x246A;</span>&#160;&#160;&#160;&#160;&#160;for(;;)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for signals */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pause();<br/>&#160;&#160;&#160;}<br/>__________________________________________________________ <span class="codestrong">pgsjc/job_mon.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_721"/>The following shell session demonstrates the use of the program in <a href="ch34.xhtml#ch34ex5">Listing 34-5</a>. We begin by displaying the process ID of the shell (which is the session leader, and the leader of a process group of which it is the sole member), and then create a background job containing two processes:</p>
<p class="programs">$ <span class="codestrong">echo $$</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Show PID of the shell</span><br/>1204<br/>$ <span class="codestrong">./job_mon | ./job_mon &#38;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Start a job containing 2 processes</span><br/>[1] 1227<br/>Terminal FG process group: 1204<br/>Command&#160;&#160;&#160;PID&#160;&#160;PPID&#160;&#160;PGRP&#160;&#160;&#160;SID<br/>&#160;&#160;&#160;1&#160;&#160;&#160;&#160;&#160;1226&#160;&#160;1204&#160;&#160;1226&#160;&#160;1204<br/>&#160;&#160;&#160;2&#160;&#160;&#160;&#160;&#160;1227&#160;&#160;1204&#160;&#160;1226&#160;&#160;1204</p>
<p class="noindent">From the above output, we can see that the shell remains the foreground process for the terminal. We can also see that the new job is in the same session as the shell and that all of the processes are in the same process group. Looking at the process IDs, we can see that the processes in the job were created in the same order as the commands were given on the command line. (Most shells do things this way, but some shell implementations create the processes in a different order.)</p>
<p class="indent">We continue, creating a second background job consisting of three processes:</p>
<p class="programs">$ <span class="codestrong">./job_mon | ./job_mon | ./job_mon &#38;</span><br/>[2] 1230<br/>Terminal FG process group: 1204<br/>Command&#160;&#160;&#160;PID&#160;&#160;PPID&#160;&#160;PGRP&#160;&#160;&#160;SID<br/>&#160;&#160;&#160;1&#160;&#160;&#160;&#160;&#160;1228&#160;&#160;1204&#160;&#160;1228&#160;&#160;1204<br/>&#160;&#160;&#160;2&#160;&#160;&#160;&#160;&#160;1229&#160;&#160;1204&#160;&#160;1228&#160;&#160;1204<br/>&#160;&#160;&#160;3&#160;&#160;&#160;&#160;&#160;1230&#160;&#160;1204&#160;&#160;1228&#160;&#160;1204</p>
<p class="noindent">We see that the shell is still the foreground process group for the terminal. We also see that the processes for the new job are in the same session as the shell, but are in a different process group from the first job. Now we bring the second job into the foreground and send it a <span class="literal">SIGINT</span> signal:</p>
<p class="programs">$ <span class="codestrong">fg</span><br/>./job_mon | ./job_mon | ./job_mon<br/><span class="font1">Type Control-C to generate</span> SIGINT <span class="font1">(signal 2)</span><br/>Process 1230 (3) received signal 2 (Interrupt)<br/>Process 1229 (2) received signal 2 (Interrupt)<br/>Terminal FG process group: 1228<br/>Process 1228 (1) received signal 2 (Interrupt)</p>
<p class="noindent">From the above output, we see that the <span class="literal">SIGINT</span> signal was delivered to all of the processes in the foreground process group. We also see that this job is now the foreground process group for the terminal. Next, we send a <span class="literal">SIGTSTP</span> signal to the job:</p>
<p class="programs"><span class="font1">Type Control-Z to generate</span> SIGTSTP <span class="font1">(signal 20 on Linux/x86-32).</span><br/>Process 1230 (3) received signal 20 (Stopped)<br/>Process 1229 (2) received signal 20 (Stopped)<br/>Terminal FG process group: 1228<br/>Process 1228 (1) received signal 20 (Stopped)<br/><br/>[2]+&#160;&#160;Stopped&#160;&#160;&#160;&#160;&#160;&#160;&#160;./job_mon | ./job_mon | ./job_mon</p>
<p class="noindent"><span epub:type="pagebreak" id="page_722"/>Now all members of the process group are stopped. The output indicates that process group 1228 was the foreground job. However, after this job was stopped, the shell became the foreground process group, although we can&#8217;t tell this from the output.</p>
<p class="indent">We then proceed by restarting the job using the <em>bg</em> command, which delivers a <span class="literal">SIGCONT</span> signal to the processes in the job:</p>
<p class="programs">$ <span class="codestrong">bg</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Resume job in background</span><br/>[2]+ ./job_mon | ./job_mon | ./job_mon &#38;<br/>Process 1230 (3) received signal 18 (Continued)<br/>Process 1229 (2) received signal 18 (Continued)<br/>Terminal FG process group: 1204&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">The shell is in the foreground</span><br/>Process 1228 (1) received signal 18 (Continued)<br/>$ <span class="codestrong">kill %1 %2</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">We've finished: clean up</span><br/>[1]-&#160;&#160;Terminated&#160;&#160;&#160;&#160;./job_mon | ./job_mon<br/>[2]+&#160;&#160;Terminated&#160;&#160;&#160;&#160;./job_mon | ./job_mon | ./job_mon</p>
<h4 class="h4" id="ch34lev2sec05"><strong>34.7.3 Handling Job-Control Signals</strong></h4>
<p class="noindenta">Because the operation of job control is transparent to most applications, they don&#8217;t need to take special action for dealing with job-control signals. One exception is programs that perform screen handling, such as <em>vi</em> and <em>less</em>. Such programs control the precise layout of text on a terminal and change various terminal settings, including settings that allow terminal input to be read a character (rather than a line) at a time. (We describe the various terminal settings in <a href="ch62.xhtml#ch62">Chapter 62</a>.)</p>
<p class="indent">Screen-handling programs need to handle the terminal stop signal (<span class="literal">SIGTSTP</span>). The signal handler should reset the terminal into canonical (line-at-a-time) input mode and place the cursor at the bottom-left corner of the terminal. When resumed, the program sets the terminal back into the mode required by the program, checks the terminal window size (which may have been changed by the user in the meantime), and redraws the screen with the desired contents.</p>
<div class="block">
<p class="noindent">When we suspend or exit a terminal-handling program, such as <em>vi</em> on an <em>xterm</em> or other terminal emulator, we typically see that the terminal is redrawn with the text that was visible before the program was started. The terminal emulator achieves this effect by catching two character sequences that programs employing the <em>terminfo</em> or <em>termcap</em> packages are required to output when assuming and releasing control of terminal layout. The first of these sequences, called <em>smcup</em> (normally <em>Escape</em> followed by <span class="literal">[?1049h</span>), causes the terminal emulator to switch to its &#8220;alternate&#8221; screen. The second sequence, called <em>rmcup</em> (normally <em>Escape</em> followed by <span class="literal">[?1049l</span>), causes the terminal emulator to revert to its default screen, thus resulting in the reappearance of the original text that was on display before the screen-handling program took control of the terminal.</p>
</div>
<p class="noindent">When handling <span class="literal">SIGTSTP</span>, we should be aware of some subtleties. We have already noted the first of these in <a href="ch34.xhtml#ch34lev2sec04">Section 34.7.2</a>: if <span class="literal">SIGTSTP</span> is caught, then it doesn&#8217;t perform its default action of stopping a process. We dealt with this issue in <a href="ch34.xhtml#ch34ex5">Listing 34-5</a> by having the handler for <span class="literal">SIGTSTP</span> raise the <span class="literal">SIGSTOP</span> signal. Since <span class="literal">SIGSTOP</span> can&#8217;t be caught, blocked, or ignored, it is guaranteed to immediately stop the process. However, this approach is not quite correct. In <a href="ch26.xhtml#ch26lev2sec03">Section 26.1.3</a>, we saw that a parent process <span epub:type="pagebreak" id="page_723"/>can use the wait status value returned by <em>wait()</em> or <em>waitpid()</em> to determine which signal caused one of its child to stop. If we raise the <span class="literal">SIGSTOP</span> signal in the handler for <span class="literal">SIGTSTP</span>, it will (misleadingly) appear to the parent that the child was stopped by <span class="literal">SIGSTOP</span>.</p>
<p class="indent">The proper approach in this situation is to have the <span class="literal">SIGTSTP</span> handler raise a further <span class="literal">SIGTSTP</span> signal to stop the process, as follows:</p>
<ol>
<li class="order"><p class="orderp">The handler resets the disposition of <span class="literal">SIGTSTP</span> to its default (<span class="literal">SIG_DFL</span>).</p></li>
<li class="order"><p class="orderp">The handler raises <span class="literal">SIGTSTP</span>.</p></li>
<li class="order"><p class="orderp">Since <span class="literal">SIGTSTP</span> was blocked on entry to the handler (unless the <span class="literal">SA_NODEFER</span> flag was specified), the handler unblocks this signal. At this point, the pending <span class="literal">SIGTSTP</span> raised in the previous step performs its default action: the process is immediately suspended.</p></li>
<li class="order"><p class="orderp">At some later time, the process will be resumed upon receipt of <span class="literal">SIGCONT</span>. At this point, execution of the handler continues.</p></li>
<li class="order"><p class="orderp">Before returning, the handler reblocks the <span class="literal">SIGTSTP</span> signal and reestablishes itself to handle the next occurrence of the <span class="literal">SIGTSTP</span> signal.</p></li>
</ol>
<p class="noindent">The step of reblocking the <span class="literal">SIGTSTP</span> signal is needed to prevent the handler from being recursively called if another <span class="literal">SIGTSTP</span> signal was delivered after the handler reestablished itself, but before the handler returned. As noted in <a href="ch22.xhtml#ch22lev1sec07">Section 22.7</a>, recursive invocations of a signal handler could cause stack overflow if a rapid stream of signals is delivered. Blocking the signal also avoids problems if the signal handler needs to perform some other actions (e.g., saving or restoring values from global variables) after reestablishing the handler but before returning.</p>
<h5 class="h5" id="ch34lev3sec08"><strong>Example program</strong></h5>
<p class="noindenta">The handler in <a href="ch34.xhtml#ch34ex6">Listing 34-6</a> implements the steps described above to correctly handle <span class="literal">SIGTSTP</span>. (We show another example of the handling of the <span class="literal">SIGTSTP</span> signal in <a href="ch62.xhtml#ch62ex4">Listing 62-4</a>, on <a href="ch62.xhtml#page_1313">page 1313</a>.) After establishing the <span class="literal">SIGTSTP</span> handler, the <em>main()</em> function of this program sits in a loop waiting for signals. Here is an example of what we see when running this program:</p>
<p class="programs">$ <span class="codestrong">./handling_SIGTSTP</span><br/><span class="font1">Type Control-Z, sending</span> SIGTSTP<br/>Caught SIGTSTP&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">This message is printed by</span> SIGTSTP <span class="font1">handler</span><br/><br/>[1]+&#160;&#160;Stopped&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;./handling_SIGTSTP<br/>$ <span class="codestrong">fg</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Sends</span> SIGCONT<br/>./handling_SIGTSTP<br/>Exiting SIGTSTP handler&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Execution of handler continues; handler returns</span><br/>Main&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">pause() call in main() was interrupted by handler</span><br/><span class="font1">Type Control-C to terminate the program</span></p>
<p class="noindent">In a screen-handling program such as <em>vi</em>, the <em>printf()</em> calls inside the signal handler in <a href="ch34.xhtml#ch34ex6">Listing 34-6</a> would be replaced by code that caused the program to modify the terminal mode and redraw the terminal display, as outlined above. (Because of the need to avoid calling non-async-signal-safe functions, described in <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>, the handler should do this by setting a flag to inform the main program to redraw the screen.)</p>
<p class="indent"><span epub:type="pagebreak" id="page_724"/>Note that the <span class="literal">SIGTSTP</span> handler may interrupt certain blocking system calls (as described in <a href="ch21.xhtml#ch21lev1sec05">Section 21.5</a>). This point is illustrated in the above program output by the fact that, after the <em>pause()</em> call is interrupted, the main program prints the message <em>Main</em>.</p>
<p class="examplet"><a id="ch34ex6"/><strong>Listing 34-6:</strong> Handling <span class="literal">SIGTSTP</span></p>
<p class="programsli">__________________________________________________ <span class="codestrong">pgsjc/handling_SIGTSTP.c</span><br/><br/>#include &lt;signal.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Handler for SIGTSTP */<br/>tstpHandler(int sig)<br/>{<br/>&#160;&#160;&#160;&#160;sigset_t tstpMask, prevMask;<br/>&#160;&#160;&#160;&#160;int savedErrno;<br/>&#160;&#160;&#160;&#160;struct sigaction sa;<br/><br/>&#160;&#160;&#160;&#160;savedErrno = errno;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* In case we change 'errno' here */<br/><br/>&#160;&#160;&#160;&#160;printf("Caught SIGTSTP\n");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* UNSAFE (see <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>) */<br/><br/>&#160;&#160;&#160;&#160;if (signal(SIGTSTP, SIG_DFL) == SIG_ERR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("signal");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Set handling to default */<br/><br/>&#160;&#160;&#160;&#160;raise(SIGTSTP);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Generate a further SIGTSTP */<br/><br/>&#160;&#160;&#160;&#160;/* Unblock SIGTSTP; the pending SIGTSTP immediately suspends the program */<br/><br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;tstpMask);<br/>&#160;&#160;&#160;&#160;sigaddset(&#38;tstpMask, SIGTSTP);<br/>&#160;&#160;&#160;&#160;if (sigprocmask(SIG_UNBLOCK, &#38;tstpMask, &#38;prevMask) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask");<br/><br/>&#160;&#160;&#160;&#160;/* Execution resumes here after SIGCONT */<br/><br/>&#160;&#160;&#160;&#160;if (sigprocmask(SIG_SETMASK, &#38;prevMask, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Reblock SIGTSTP */<br/><br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Reestablish handler */<br/>&#160;&#160;&#160;&#160;sa.sa_flags = SA_RESTART;<br/>&#160;&#160;&#160;&#160;sa.sa_handler = tstpHandler;<br/>&#160;&#160;&#160;&#160;if (sigaction(SIGTSTP, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;printf("Exiting SIGTSTP handler\n");<br/>&#160;&#160;&#160;&#160;errno = savedErrno;<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct sigaction sa;<br/><br/>&#160;&#160;&#160;&#160;/* Only establish handler for SIGTSTP if it is not being ignored */<br/><br/>&#160;&#160;&#160;&#160;if (sigaction(SIGTSTP, NULL, &#38;sa) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;if (sa.sa_handler != SIG_IGN) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_flags = SA_RESTART;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_handler = tstpHandler;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGTSTP, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;for (;;) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for signals */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pause();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Main\n");<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>__________________________________________________ <span class="codestrong">pgsjc/handling_SIGTSTP.c</span></p>
<h5 class="h5" id="ch34lev3sec09"><span epub:type="pagebreak" id="page_725"/><strong>Dealing with ignored job-control and terminal-generated signals</strong></h5>
<p class="noindenta">The program in <a href="ch34.xhtml#ch34ex6">Listing 34-6</a> establishes a signal handler for <span class="literal">SIGTSTP</span> only if that signal is not being ignored. This is an instance of the more general rule that applications should handle job-control and terminal-generated signals only if these signals were not previously being ignored. In the case of job-control signals (<span class="literal">SIGTSTP</span>, <span class="literal">SIGTTIN</span>, and <span class="literal">SIGTTOU</span>), this prevents an application from attempting to handle these signals if it is started from a non-job-control shell (such as the traditional Bourne shell). In a non-job-control shell, the dispositions of these signals are set to <span class="literal">SIG_IGN</span>; only job-control shells set the dispositions of these signals to <span class="literal">SIG_DFL</span>.</p>
<p class="indent">A similar statement also applies to the other signals that can be generated from the terminal: <span class="literal">SIGINT</span>, <span class="literal">SIGQUIT</span>, and <span class="literal">SIGHUP</span>. In the case of <span class="literal">SIGINT</span> and <span class="literal">SIGQUIT</span>, the reason is that when a command is executed in the background under non-job-control shells, the resulting process is not placed in a separate process group. Instead, the process stays in the same group as the shell, and the shell sets the disposition of <span class="literal">SIGINT</span> and <span class="literal">SIGQUIT</span> to be ignored before execing the command. This ensures that the process is not killed if the user types the terminal <em>interrupt</em> or <em>quit</em> characters (which should affect only the job that is notionally in the foreground). If the process subsequently undoes the shell&#8217;s manipulations of the dispositions of these signals, then it once more becomes vulnerable to receiving them.</p>
<p class="indent">The <span class="literal">SIGHUP</span> signal is ignored if a command is executed via <em>nohup(1)</em>. This prevents the command from being killed as a consequence of a terminal hangup. Thus, an application should not attempt to change the disposition if it is being ignored.</p>
<h4 class="h4" id="ch34lev2sec06"><strong>34.7.4 Orphaned Process Groups (and</strong> <span class="literal"><span class="codestrong">SIGHUP</span></span> <strong>Revisited)</strong></h4>
<p class="noindenta">In <a href="ch26.xhtml#ch26lev1sec02">Section 26.2</a>, we saw that an orphaned process is one that has been adopted by <em>init</em> (process ID 1) after its parent terminated. Within a program, we can create an orphaned child using the following code:</p>
<p class="programs">if (fork() != 0)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Exit if parent (or on error) */<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);</p>
<p class="noindent"><span epub:type="pagebreak" id="page_726"/>Suppose that we include this code in a program executed from the shell. <a href="ch34.xhtml#ch34fig3">Figure 34-3</a> shows the state of processes before and after the parent exits.</p>
<p class="indent">After the parent terminates, the child process in <a href="ch34.xhtml#ch34fig3">Figure 34-3</a> is not only an orphaned process, it is also part of an <em>orphaned process group</em>. SUSv3 defines a process group as orphaned if &#8220;the parent of every member is either itself a member of the group or is not a member of the group&#8217;s session.&#8221; Put another way, a process group is not orphaned if at least one of its members has a parent in the same session but in a different process group. In <a href="ch34.xhtml#ch34fig3">Figure 34-3</a>, the process group containing the child is orphaned because the child is in a process group on its own and its parent (<em>init</em>) is in a different session.</p>
<div class="block">
<p class="noindent">By definition, a session leader is in an orphaned process group. This follows because <em>setsid()</em> creates a new process group in the new session, and the parent of the session leader is in a different session.</p>
</div>
<div class="image"><img src="../images/f34-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch34fig3"/><strong>Figure 34-3:</strong> Steps in the creation of an orphaned process group</p>
<p class="noindent">To see why orphaned process groups are important, we need to view things from the perspective of shell job control. Consider the following scenario based on <a href="ch34.xhtml#ch34fig3">Figure 34-3</a>:</p>
<ol>
<li class="order"><p class="orderp">Before the parent process exits, the child was stopped (perhaps because the parent sent it a stop signal).</p></li>
<li class="order"><p class="orderp">When the parent process exits, the shell removes the parent&#8217;s process group from its list of jobs. The child is adopted by <em>init</em> and becomes a background process for the terminal. The process group containing the child is orphaned.</p></li>
<li class="order"><p class="orderp">At this point, there is no process that monitors the state of the stopped child via <em>wait()</em>.</p></li>
</ol>
<p class="noindent"><span epub:type="pagebreak" id="page_727"/>Since the shell did not create the child process, it is not aware of the child&#8217;s existence or that the child is part of the same process group as the deceased parent. Furthermore, the <em>init</em> process checks only for a terminated child, and then reaps the resulting zombie process. Consequently, the stopped child might languish forever, since no other process knows to send it a <span class="literal">SIGCONT</span> signal in order to cause it to resume execution.</p>
<p class="indent">Even if a stopped process in an orphaned process group has a still-living parent in a different session, that parent is not guaranteed to be able to send <span class="literal">SIGCONT</span> to the stopped child. A process may send <span class="literal">SIGCONT</span> to any other process in the same session, but if the child is in a different session, the normal rules for sending signals apply (<a href="ch20.xhtml#ch20lev1sec05">Section 20.5</a>), so the parent may not be able to send a signal to the child if the child is a privileged process that has changed its credentials.</p>
<p class="indent">To prevent scenarios such as the one described above, SUSv3 specifies that if a process group becomes orphaned and has any stopped members, then all members of the group are sent a <span class="literal">SIGHUP</span> signal, to inform them that they have become disconnected from their session, followed by a <span class="literal">SIGCONT</span> signal, to ensure that they resume execution. If the orphaned process group doesn&#8217;t have any stopped members, no signals are sent.</p>
<p class="indent">A process group may become orphaned either because the last parent in a different process group in the same session terminated or because of the termination of the last process within the group that had a parent in another group. (The latter case is the one illustrated in <a href="ch34.xhtml#ch34fig3">Figure 34-3</a>.) In either case, the treatment of a newly orphaned process group containing stopped children is the same.</p>
<div class="block">
<p class="noindent">Sending <span class="literal">SIGHUP</span> and <span class="literal">SIGCONT</span> to a newly orphaned process group that contains stopped members is done in order to eliminate a specific loophole in the job-control framework. There is nothing to prevent the members of an already-orphaned process group from later being stopped if another process (with suitable privileges) sends them a stop signal. In this case, the processes will remain stopped until some process (again with suitable privileges) sends them a <span class="literal">SIGCONT</span> signal.</p>
<p class="indent">When called by a member of an orphaned process group, the <em>tcsetpgrp()</em> function (<a href="ch34.xhtml#ch34lev1sec05">Section 34.5</a>) fails with the error <span class="literal">ENOTTY</span>, and calls to the <em>tcsetattr()</em>, <em>tcflush()</em>, <em>tcflow()</em>, <em>tcsendbreak()</em>, and <em>tcdrain()</em> functions (all described in <a href="ch62.xhtml#ch62">Chapter 62</a>) fail with the error <span class="literal">EIO</span>.</p>
</div>
<h5 class="h5" id="ch34lev3sec10"><strong>Example program</strong></h5>
<p class="noindenta">The program in <a href="ch34.xhtml#ch34ex7">Listing 34-7</a> demonstrates the treatment of orphaned processes that we have just described. After establishing handlers for <span class="literal">SIGHUP</span> and <span class="literal">SIGCONT</span> <span class="ent">&#x2461;</span>, this program creates one child process for each command-line argument <span class="ent">&#x2462;</span>. Each child then stops itself (by raising <span class="literal">SIGSTOP</span>) <span class="ent">&#x2463;</span>, or waits for signals (using <em>pause()</em>) <span class="ent">&#x2464;</span>. The choice of action by the child is determined by whether or not the corresponding command-line argument starts with the letter <em>s</em> (for <em>stop</em>). (We use a command-line argument starting with the letter <em>p</em> to specify the converse action of calling <em>pause()</em>, although any character other than the letter <em>s</em> can be used.)</p>
<p class="indent">After creating all of the children, the parent sleeps for a few seconds to allow the children time to get set up <span class="ent">&#x2465;</span>. (As noted in <a href="ch24.xhtml#ch24lev1sec02">Section 24.2</a>, using <em>sleep()</em> in this way is an imperfect, but sometimes viable method of accomplishing this result.) The parent then exits <span class="ent">&#x2466;</span>, at which point the process group containing the children becomes orphaned. If any of the children receives a signal as a consequence of the <span epub:type="pagebreak" id="page_728"/>process group becoming orphaned, the signal handler is invoked, and it displays the child&#8217;s process ID and the signal number <span class="ent">&#x2460;</span>.</p>
<p class="examplet"><a id="ch34ex7"/><strong>Listing 34-7:</strong> <span class="literal">SIGHUP</span> and orphaned process groups</p>
<p class="programsli">_______________________________________________ <span class="codestrong">pgsjc/orphaned_pgrp_SIGHUP.c</span><br/><br/>&#160;&#160;&#160;#define _GNU_SOURCE&#160;&#160;&#160;&#160;&#160;/* Get declaration of strsignal() from &lt;string.h&gt; */<br/>&#160;&#160;&#160;#include &lt;string.h&gt;<br/>&#160;&#160;&#160;#include &lt;signal.h&gt;<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Signal handler */<br/>&#160;&#160;&#160;handler(int sig)<br/>&#160;&#160;&#160;{<br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;printf("PID=%ld: caught signal %d (%s)\n", (long) getpid(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sig, strsignal(sig));&#160;&#160;&#160;&#160;&#160;/* UNSAFE (see <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>) */<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int j;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sigaction sa;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s {s|p} ...\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;setbuf(stdout, NULL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Make stdout unbuffered */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_flags = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_handler = handler;<br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGHUP, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigaction(SIGCONT, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("parent: PID=%ld, PPID=%ld, PGID=%ld, SID=%ld\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) getpid(), (long) getppid(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) getpgrp(), (long) getsid(0));<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Create one child for each command-line argument */<br/><br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;for (j = 1; j &lt; argc; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (fork()) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case -1:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("child:&#160;&#160;PID=%ld, PPID=%ld, PGID=%ld, SID=%ld\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) getpid(), (long) getppid(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) getpgrp(), (long) getsid(0));<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argv[j][0] == 's') {&#160;&#160;&#160;&#160;/* Stop via signal */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("PID=%ld stopping\n", (long) getpid());<br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;raise(SIGSTOP);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for signal */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;alarm(60);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* So we die if not SIGHUPed */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("PID=%ld pausing\n", (long) getpid());<br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pause();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_exit(EXIT_SUCCESS);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent carries on round loop */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent falls through to here after creating all children */<br/><br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;sleep(3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Give children a chance to start */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("parent exiting\n");<br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* And orphan them and their group */<br/>&#160;&#160;&#160;}<br/>_______________________________________________ <span class="codestrong">pgsjc/orphaned_pgrp_SIGHUP.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_729"/>The following shell session log shows the results of two different runs of the program in <a href="ch34.xhtml#ch34ex7">Listing 34-7</a>:</p>
<p class="programs">$ <span class="codestrong">echo $$</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Display PID of shell, which is also the session ID</span><br/>4785<br/>$ <span class="codestrong">./orphaned_pgrp_SIGHUP s p</span><br/>parent: PID=4827, PPID=4785, PGID=4827, SID=4785<br/>child:&#160;&#160;PID=4828, PPID=4827, PGID=4827, SID=4785<br/>PID=4828 stopping<br/>child:&#160;&#160;PID=4829, PPID=4827, PGID=4827, SID=4785<br/>PID=4829 pausing<br/>parent exiting<br/>$ PID=4828: caught signal 18 (Continued)<br/>PID=4828: caught signal 1 (Hangup)<br/>PID=4829: caught signal 18 (Continued)<br/>PID=4829: caught signal 1 (Hangup)<br/><span class="font1">Press Enter to get another shell prompt</span><br/>$ <span class="codestrong">./orphaned_pgrp_SIGHUP p p</span><br/>parent: PID=4830, PPID=4785, PGID=4830, SID=4785<br/>child:&#160;&#160;PID=4831, PPID=4830, PGID=4830, SID=4785<br/>PID=4831 pausing<br/>child:&#160;&#160;PID=4832, PPID=4830, PGID=4830, SID=4785<br/>PID=4832 pausing<br/>parent exiting</p>
<p class="noindent">The first run creates two children in the to-be-orphaned process group: one stops itself and the other pauses. (In this run, the shell prompt appears in the middle of the children&#8217;s output because the shell notices that the parent has already exited.) As can be seen, both children receive <span class="literal">SIGCONT</span> and <span class="literal">SIGHUP</span> after the parent exits. In the second run, two children are created, neither stops itself, and consequently no signals are sent when the parent exits.</p>
<h5 class="h5" id="ch34lev3sec11"><span epub:type="pagebreak" id="page_730"/><strong>Orphaned process groups and the</strong> <span class="literal"><span class="codestrong">SIGTSTP</span></span>, <span class="literal"><span class="codestrong">SIGTTIN</span></span><strong>, and</strong> <span class="literal"><span class="codestrong">SIGTTOU</span></span> <strong>signals</strong></h5>
<p class="noindenta">Orphaned process groups also affect the semantics for delivery of the <span class="literal">SIGTSTP</span>, <span class="literal">SIGTTIN</span>, and <span class="literal">SIGTTOU</span> signals.</p>
<p class="indent">In <a href="ch34.xhtml#ch34lev2sec03">Section 34.7.1</a>, we saw that <span class="literal">SIGTTIN</span> is sent to a background process if it tries to <em>read()</em> from the controlling terminal, and <span class="literal">SIGTTOU</span> is sent to a background process that tries to <em>write()</em> to the controlling terminal if the terminal&#8217;s <span class="literal">TOSTOP</span> flag is set. However, it makes no sense to send these signals to an orphaned process group since, once stopped, it will never be resumed again. For this reason, instead of sending <span class="literal">SIGTTIN</span> or <span class="literal">SIGTTOU</span>, the kernel causes <em>read()</em> or <em>write()</em> to fail with the error <span class="literal">EIO</span>.</p>
<p class="indent">For similar reasons, if delivery of <span class="literal">SIGTSTP</span>, <span class="literal">SIGTTIN</span>, or <span class="literal">SIGTTOU</span> would stop a member of an orphaned process group, then the signal is silently discarded. (If the signal is being handled, then it is delivered to the process.) This behavior occurs no matter how the signal is sent&#8212;for example, whether the signal is generated by the terminal driver or sent by an explicit call to <em>kill()</em>.</p>
<h3 class="h3" id="ch34lev1sec08"><strong>34.8 Summary</strong></h3>
<p class="noindenta">Sessions and process groups (also known as jobs) form a two-level hierarchy of processes: a session is a collection of process groups, and a process group is a collection of processes. A session leader is the process that created the session using <em>setsid()</em>. A process group leader is the first member of a process group. All of the members of a process group share the same process group ID (which is the same as the process ID of the process group leader), and all processes in the process groups that constitute a session have the same session ID (which is the same as the process ID of the session leader). Each session may have a controlling terminal (<span class="literal">/dev/tty</span>), which is established when the session leader opens a terminal device. Opening the controlling terminal also causes the session leader to become the controlling process for the terminal.</p>
<p class="indent">Sessions and process groups were defined to support shell job control (although occasionally they find other uses in applications). Under job control, the shell is the session leader and controlling process for the terminal on which it is running. Each job (a simple command or a pipeline) executed by the shell is created as a separate process group, and the shell provides commands to move a job between three states: running in the foreground, running in the background, and stopped in the background.</p>
<p class="indent">To support job control, the terminal driver maintains a record of the foreground process group (job) for the controlling terminal. The terminal driver delivers job-control signals to the foreground job when certain characters are typed. These signals either terminate or stop the foreground job.</p>
<p class="indent">The notion of the terminal&#8217;s foreground job is also used to arbitrate terminal I/O requests. Only processes in the foreground job may read from the controlling terminal. Background jobs are prevented from reading by delivery of the <span class="literal">SIGTTIN</span> signal, whose default action is to stop the job. If the terminal <span class="literal">TOSTOP</span> is set, then background jobs are also prevented from writing to the controlling terminal by delivery of a <span class="literal">SIGTTOU</span> signal, whose default action is to stop the job.</p>
<p class="indent">When a terminal disconnect occurs, the kernel delivers a <span class="literal">SIGHUP</span> signal to the controlling process to inform it of the fact. Such an event may result in a chain reaction <span epub:type="pagebreak" id="page_731"/>whereby a <span class="literal">SIGHUP</span> signal is delivered to many other processes. First, if the controlling process is a shell (as is typically the case), then, before terminating, the shell sends <span class="literal">SIGHUP</span> to each of the process groups it has created. Second, if delivery of <span class="literal">SIGHUP</span> results in termination of a controlling process, then the kernel also sends <span class="literal">SIGHUP</span> to all of the members of the foreground process group of the controlling terminal.</p>
<p class="indent">In general, applications don&#8217;t need to be cognizant of job-control signals. One exception is when a program performs screen-handling operations. Such programs need to correctly handle the <span class="literal">SIGTSTP</span> signal, resetting terminal attributes to sane values before the process is suspended, and restoring the correct (application-specific) terminal attributes when the application is once more resumed following delivery of a <span class="literal">SIGCONT</span> signal.</p>
<p class="indent">A process group is considered to be orphaned if none of its member processes has a parent in a different process group in the same session. Orphaned process groups are significant because there is no process outside the group that can both monitor the state of any stopped processes within the group and is always allowed to send a <span class="literal">SIGCONT</span> signal to these stopped processes in order to restart them. This could result in such stopped processes languishing forever on the system. To avoid this possibility, when a process group with stopped member processes becomes orphaned, all members of the process group are sent a <span class="literal">SIGHUP</span> signal, followed by a <span class="literal">SIGCONT</span> signal, to notify them that they have become orphaned and ensure that they are restarted.</p>
<h5 class="h5" id="ch34lev3sec12"><strong>Further information</strong></h5>
<p class="noindenta"><a href="ch09.xhtml#ch09">Chapter 9</a> of [<a href="bib.xhtml#bib94">Stevens &#38; Rago, 2005</a>] covers similar material to this chapter, and includes a description of the steps that occur during login to establish the session for a login shell. The <em>glibc</em> manual contains a lengthy description of the functions relating to job control and the implementation of job control within the shell. The SUSv3 rationale contains an extensive discussion of sessions, process groups, and job control.</p>
<h3 class="h3" id="ch34lev1sec09"><strong>34.9 Exercises</strong></h3>
<p class="exer"><a id="ch34exe1"/><strong>34-1.</strong>&#160;&#160;&#160;Suppose a parent process performs the following steps:</p>
<p class="programs1">/* Call fork() to create a number of child processes, each of which<br/>&#160;&#160;&#160;remains in same process group as the parent */<br/><br/>/* Sometime later... */<br/>signal(SIGUSR1, SIG_IGN);&#160;&#160;&#160;&#160;&#160;/* Parent makes itself immune to SIGUSR1 */<br/><br/>killpg(getpgrp(), SIGUSR1);&#160;&#160;&#160;/* Send signal to children created earlier */</p>
<p class="exerp">What problem might be encountered with this application design? (Consider shell pipelines.) How could this problem be avoided?</p>
<p class="exer"><a id="ch34exe2"/><strong>34-2.</strong>&#160;&#160;&#160;Write a program to verify that a parent process can change the process group ID of one of its children before the child performs an <em>exec()</em>, but not afterward.</p>
<p class="exer"><a id="ch34exe3"/><strong>34-3.</strong>&#160;&#160;&#160;Write a program to verify that a call to <em>setsid()</em> from a process group leader fails.</p>
<p class="exer"><span epub:type="pagebreak" id="page_732"/><a id="ch34exe4"/><strong>34-4.</strong>&#160;&#160;&#160;Modify the program in <a href="ch34.xhtml#ch34ex4">Listing 34-4</a> (<span class="literal">disc_SIGHUP.c</span>) to verify that, if the controlling process doesn&#8217;t terminate as a consequence of receiving <span class="literal">SIGHUP</span> (i.e., it instead ignores or catches the signal and continues execution), then the kernel doesn&#8217;t send <span class="literal">SIGHUP</span> to the members of the foreground process group.</p>
<p class="exer"><a id="ch34exe5"/><strong>34-5.</strong>&#160;&#160;&#160;Suppose that, in the signal handler of <a href="ch34.xhtml#ch34ex6">Listing 34-6</a>, the code that unblocks the <span class="literal">SIGTSTP</span> signal was moved to the start of the handler. What potential race condition does this create?</p>
<p class="exer"><a id="ch34exe6"/><strong>34-6.</strong>&#160;&#160;&#160;Write a program to verify that when a process in an orphaned process group attempts to <em>read()</em> from the controlling terminal, the <em>read()</em> fails with the error <span class="literal">EIO</span>.</p>
<p class="exer"><a id="ch34exe7"/><strong>34-7.</strong>&#160;&#160;&#160;Write a program to verify that if one of the signals <span class="literal">SIGTTIN</span>, <span class="literal">SIGTTOU</span>, or <span class="literal">SIGTSTP</span> is sent to a member of an orphaned process group, then the signal is discarded (i.e., has no effect) if it would stop the process (i.e., the disposition is <span class="literal">SIG_DFL</span>), but is delivered if a handler is installed for the signal.</p>
</body>
</html>
