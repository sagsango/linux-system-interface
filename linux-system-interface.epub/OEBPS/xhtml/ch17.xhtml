<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch17"><span epub:type="pagebreak" id="page_319"/><strong><span class="big">17</span></strong><br/><strong>ACCESS CONTROL LISTS</strong></h2>
<p class="noindenta"><a href="ch15.xhtml#ch15lev1sec04">Section 15.4</a> described the traditional UNIX (and Linux) file permissions scheme. For many applications, this scheme is sufficient. However, some applications need finer control over the permissions granted to specific users and groups. To meet this requirement, many UNIX systems implement an extension to the traditional UNIX file permissions model known as <em>access control lists</em> (ACLs). ACLs allow file permissions to be specified per user or per group, for an arbitrary number of users and groups. Linux provides ACLs from kernel 2.6 onward.</p>
<div class="block">
<p class="noindent">Support for ACLs is optional for each file system, and is controlled by kernel configuration options under the <em>File systems</em> menu. <em>Reiserfs</em> support for ACLs has been available since kernel 2.6.7.</p>
<p class="indent">In order to be able to create ACLs on an <em>ext2</em>, <em>ext3</em>, <em>ext4</em>, or <em>Reiserfs</em> file system, the file system must be mounted with the <em>mount &#8211;o acl</em> option.</p>
</div>
<p class="noindent">ACLs have never been formally standardized for UNIX systems. An attempt was made to do this in the form of the POSIX.1e and POSIX.2c draft standards, which aimed to specify, respectively, the application program interface (API) and the shell commands for ACLs (as well as other features, such as capabilities). Ultimately, this standardization attempt foundered, and these draft standards were withdrawn. Nevertheless, many UNIX implementations (including Linux) base their ACL implementations on these draft standards (usually on the final version, <em>Draft 17</em>). However, because there are many variations across ACL implementations (in part <span epub:type="pagebreak" id="page_320"/>springing from the incompleteness of the draft standards), writing portable programs that use ACLs presents some difficulties.</p>
<p class="indent">This chapter provides a description of ACLs and a brief tutorial on their use. It also describes some of the library functions used for manipulating and retrieving ACLs. We won&#8217;t go into detail on all of these functions because there are so many of them. (For the details, see the manual pages.)</p>
<h3 class="h3" id="ch17lev1sec01"><strong>17.1 Overview</strong></h3>
<p class="noindenta">An ACL is a series of ACL entries, each of which defines the file permissions for an individual user or group of users (see <a href="ch17.xhtml#ch17fig1">Figure 17-1</a>).</p>
<div class="image"><img src="../images/f17-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch17fig1"/><strong>Figure 17-1:</strong> An access control list</p>
<h5 class="h5" id="ch17lev3sec01"><strong>ACL entries</strong></h5>
<p class="noindentab">Each ACL entry consists of the following parts:</p>
<p class="bull">&#8226; a <em>tag type</em>, which indicates whether this entry applies to a user, to a group, or to some other category of user;</p>
<p class="bull">&#8226; an optional <em>tag qualifier</em>, which identifies a specific user or group (i.e., a user ID or a group ID); and</p>
<p class="bull">&#8226; a <em>permission set</em>, which specifies the permissions (read, write, and execute) that are granted by the entry.</p>
<p class="noindenttb">The tag type has one of the following values:</p>
<p class="term"><span class="literal">ACL_USER_OBJ</span></p>
<p class="termlist">This entry specifies the permissions granted to the file owner. Each ACL contains exactly one <span class="literal">ACL_USER_OBJ</span> entry. This entry corresponds to the traditional file <em>owner</em> (<em>user</em>) permissions.</p>
<p class="term"><span class="literal">ACL_USER</span></p>
<p class="termlist">This entry specifies the permissions granted to the user identified by the tag qualifier. An ACL may contain zero or more <span class="literal">ACL_USER</span> entries, but at most one <span class="literal">ACL_USER</span> entry may be defined for a particular user.</p>
<p class="term"><span epub:type="pagebreak" id="page_321"/><span class="literal">ACL_GROUP_OBJ</span></p>
<p class="termlist">This entry specifies permissions granted to the file group. Each ACL contains exactly one <span class="literal">ACL_GROUP_OBJ</span> entry. This entry corresponds to the traditional file <em>group</em> permissions, unless the ACL also contains an <span class="literal">ACL_MASK</span> entry.</p>
<p class="term"><span class="literal">ACL_GROUP</span></p>
<p class="termlist">This entry specifies the permissions granted to the group identified by the tag qualifier. An ACL may contain zero or more <span class="literal">ACL_GROUP</span> entries, but at most one <span class="literal">ACL_GROUP</span> entry may be defined for a particular group.</p>
<p class="term"><span class="literal">ACL_MASK</span></p>
<p class="termlist">This entry specifies the maximum permissions that may be granted by <span class="literal">ACL_USER</span>, <span class="literal">ACL_GROUP_OBJ</span>, and <span class="literal">ACL_GROUP</span> entries. An ACL contains at most one <span class="literal">ACL_MASK</span> entry. If the ACL contains <span class="literal">ACL_USER</span> or <span class="literal">ACL_GROUP</span> entries, then an <span class="literal">ACL_MASK</span> entry is mandatory. We say more about this tag type shortly.</p>
<p class="term"><span class="literal">ACL_OTHER</span></p>
<p class="termlist">This entry specifies the permissions that are granted to users that don&#8217;t match any other ACL entry. Each ACL contains exactly one <span class="literal">ACL_OTHER</span> entry. This entry corresponds to the traditional file <em>other</em> permissions.</p>
<p class="noindentt">The tag qualifier is employed only for <span class="literal">ACL_USER</span> and <span class="literal">ACL_GROUP</span> entries. It specifies either a user ID or a group ID.</p>
<h5 class="h5" id="ch17lev3sec02"><strong>Minimal and extended ACLs</strong></h5>
<p class="noindenta">A <em>minimal</em> ACL is one that is semantically equivalent to the traditional file permission set. It contains exactly three entries: one of each of the types <span class="literal">ACL_USER_OBJ</span>, <span class="literal">ACL_GROUP_OBJ</span>, and <span class="literal">ACL_OTHER</span>. An <em>extended</em> ACL is one that additionally contains <span class="literal">ACL_USER</span>, <span class="literal">ACL_GROUP</span>, and <span class="literal">ACL_MASK</span> entries.</p>
<p class="indent">One reason for drawing a distinction between minimal ACLs and extended ACLs is that the latter provide a semantic extension to the traditional permissions model. Another reason concerns the Linux implementation of ACLs. ACLs are implemented as <em>system</em> extended attributes (<a href="ch16.xhtml#ch16">Chapter 16</a>). The extended attribute used for maintaining a file access ACL is named <em>system.posix_acl_access</em>. This extended attribute is required only if the file has an extended ACL. The permissions information for a minimal ACL can be (and is) stored in the traditional file permission bits.</p>
<h3 class="h3" id="ch17lev1sec02"><strong>17.2 ACL Permission-Checking Algorithm</strong></h3>
<p class="noindenta">Permission checking on a file that has an ACL is performed in the same circumstances as for the traditional file permissions model (<a href="ch15.xhtml#ch15lev2sec07">Section 15.4.3</a>). Checks are performed in the following order, until one of the criteria is matched:</p>
<ol>
<li class="order"><p class="orderp">If the process is privileged, all access is granted. There is one exception to this statement, analogous to the traditional permissions model described in <a href="ch15.xhtml#ch15lev2sec07">Section 15.4.3</a>. When executing a file, a privileged process is granted execute permission only if that permission is granted via at least one of the ACL entries on the file.</p></li>
<li class="order"><p class="orderp"><span epub:type="pagebreak" id="page_322"/>If the effective user ID of the process matches the owner (user ID) of the file, then the process is granted the permissions specified in the <span class="literal">ACL_USER_OBJ</span> entry. (To be strictly accurate, on Linux, it is the process&#8217;s file-system IDs, rather than its effective IDs, that are used for the checks described in this section, as described in <a href="ch09.xhtml#ch09lev1sec05">Section 9.5</a>.)</p></li>
<li class="order"><p class="orderp">If the effective user ID of the process matches the tag qualifier in one of the <span class="literal">ACL_USER</span> entries, then the process is granted the permissions specified in that entry, masked (ANDed) against the value of the <span class="literal">ACL_MASK</span> entry.</p></li>
<li class="order"><p class="orderp">If one of the process&#8217;s group IDs (i.e., the effective group ID or any of the supplementary group IDs) matches the file group (this corresponds to the <span class="literal">ACL_GROUP_OBJ</span> entry) or the tag qualifier of any of the <span class="literal">ACL_GROUP</span> entries, then access is determined by checking each of the following, until a match is found:</p>
<p class="olista">a) If one of the process&#8217;s group IDs matches the file group, and the <span class="literal">ACL_GROUP_OBJ</span> entry grants the requested permissions, then this entry determines the access granted to the file. The granted access is restricted by masking (ANDing) against the value in the <span class="literal">ACL_MASK</span> entry, if present.</p>
<p class="olista">b) If one of the process&#8217;s group IDs matches the tag qualifier in an <span class="literal">ACL_GROUP</span> entry for the file, and that entry grants the requested permissions, then this entry determines the permissions granted. The granted access is restricted by masking (ANDing) against the value in the <span class="literal">ACL_MASK</span> entry.</p>
<p class="olista">c) Otherwise, access is denied.</p></li>
<li class="order"><p class="orderp">Otherwise, the process is granted the permissions specified in the <span class="literal">ACL_OTHER</span> entry.</p></li>
</ol>
<p class="noindent">We can clarify the rules relating to group IDs with some examples. Suppose we have a file whose group ID is 100, and that file is protected by the ACL shown in <a href="ch17.xhtml#ch17fig1">Figure 17-1</a>. If a process whose group ID is 100 makes the call <em>access(file, R_OK)</em>, then that call would succeed (i.e., return 0). (We describe <em>access()</em> in <a href="ch15.xhtml#ch15lev2sec08">Section 15.4.4</a>.) On the other hand, even though the <span class="literal">ACL_GROUP_OBJ</span> entry grants all permissions, the call <em>access(file, R_OK | W_OK | X_OK)</em> would fail (i.e., return &#8211;1, with <em>errno</em> set to <span class="literal">EACCES</span>) because the <span class="literal">ACL_GROUP_OBJ</span> permissions are masked (ANDed) against the <span class="literal">ACL_MASK</span> entry, and this entry denies execute permission.</p>
<p class="indent">As another example using <a href="ch17.xhtml#ch17fig1">Figure 17-1</a>, suppose we have a process that has a group ID of 102 and that also contains the group ID 103 in its supplementary group IDs. For this process, the calls <em>access(file, R_OK)</em> and <em>access(file, W_OK)</em> would both succeed, since they would match the <span class="literal">ACL_GROUP</span> entries for the group IDs 102 and 103, respectively. On the other hand, the call <em>access(file, R_OK | W_OK)</em> would fail because there is no matching <span class="literal">ACL_GROUP</span> entry that grants both read and write permissions.</p>
<h3 class="h3" id="ch17lev1sec03"><span epub:type="pagebreak" id="page_323"/><strong>17.3 Long and Short Text Forms for ACLs</strong></h3>
<p class="noindentab">When manipulating ACLs using the <em>setfacl</em> and <em>getfacl</em> commands (described in a moment) or certain ACL library functions, we specify textual representations of the ACL entries. Two formats are permitted for these textual representations:</p>
<p class="bull">&#8226; <em>Long text form</em> ACLs contain one ACL entry per line, and may include comments, which are started by a <span class="literal">#</span> character and continue to the end-of-line. The <em>getfacl</em> command displays ACLs in long text form. The <em>setfacl &#8211;M acl-file</em> option, which takes an ACL specification from a file, expects the specification to be in long text form.</p>
<p class="bull">&#8226; <em>Short text form</em> ACLs consist of a sequence of ACL entries separated by commas.</p>
<p class="noindentt">In both forms, each ACL entry consists of three parts separated by colons:</p>
<div class="box2">
<p class="noindenta"><em>tag-type</em><span class="literal">:[</span><em>tag-qualifier</em><span class="literal">]:</span> <em>permissions</em></p>
</div>
<p class="noindent">The <em>tag-type</em> is one of the values shown in the first column of <a href="ch17.xhtml#ch17table1">Table 17-1</a>. The <em>tag-type</em> may optionally be followed by a <em>tag-qualifier</em>, which identifies a user or group, either by name or numeric identifier. The <em>tag-qualifier</em> is present only for <span class="literal">ACL_USER</span> and <span class="literal">ACL_GROUP</span> entries.</p>
<p class="indent">The following are all short text form ACLs corresponding to a traditional permissions mask of 0650:</p>
<p class="programs">u::rw-,g::r-x,o::---<br/>u::rw,g::rx,o::-<br/>user::rw,group::rx,other::-</p>
<p class="noindent">The following short text form ACL includes two named users, a named group, and a mask entry:</p>
<p class="programs">u::rw,u:paulh:rw,u:annabel:rw,g::r,g:teach:rw,m::rwx,o::-</p>
<p class="tablecap"><a id="ch17table1"/><strong>Table 17-1:</strong> Interpretation of ACL entry text forms</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Tag text forms</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Tag qualifier present?</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Corresponding tag type</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Entry for</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">u</span>, <span class="literal">user</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">N</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ACL_USER_OBJ</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">File owner (user)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">u</span>, <span class="literal">user</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">Y</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ACL_USER</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Specified user</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">g</span>, <span class="literal">group</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">N</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ACL_GROUP_OBJ</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">File group</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">g</span>, <span class="literal">group</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">Y</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ACL_GROUP</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Specified group</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">m</span>, <span class="literal">mask</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">N</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ACL_MASK</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Mask for group class</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">o</span>, <span class="literal">other</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec">N</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">ACL_OTHER</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Other users</p></td>
</tr>
</tbody>
</table>
<h3 class="h3" id="ch17lev1sec04"><span epub:type="pagebreak" id="page_324"/><strong>17.4 The</strong> <span class="literal"><span class="codestrong">ACL_MASK</span></span> <strong>Entry and the ACL Group Class</strong></h3>
<p class="noindenta">If an ACL contains <span class="literal">ACL_USER</span> or <span class="literal">ACL_GROUP</span> entries, then it must contain an <span class="literal">ACL_MASK</span> entry. If the ACL doesn&#8217;t contain any <span class="literal">ACL_USER</span> or <span class="literal">ACL_GROUP</span> entries, then the <span class="literal">ACL_MASK</span> entry is optional.</p>
<p class="indent">The <span class="literal">ACL_MASK</span> entry acts as an upper limit on the permissions granted by ACL entries in the so-called <em>group class</em>. The group class is the set of all <span class="literal">ACL_USER</span>, <span class="literal">ACL_GROUP</span>, and <span class="literal">ACL_GROUP_OBJ</span> entries in the ACL.</p>
<p class="indent">The purpose of the <span class="literal">ACL_MASK</span> entry is to provide consistent behavior when running ACL-unaware applications. As an example of why the mask entry is needed, suppose that the ACL on a file includes the following entries:</p>
<p class="programs">user::rwx&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# ACL_USER_OBJ<br/>user:paulh:r-x&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# ACL_USER<br/>group::r-x&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# ACL_GROUP_OBJ<br/>group:teach:--x&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# ACL_GROUP<br/>other::--x&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# ACL_OTHER</p>
<p class="noindent">Now suppose that a program executes the following <em>chmod()</em> call on this file:</p>
<p class="programs">chmod(pathname, 0700);&#160;&#160;&#160;&#160;&#160;/* Set permissions to rwx------ */</p>
<p class="noindentb">In an ACL-unaware application, this means &#8220;Deny access to everyone except the file owner.&#8221; These semantics should hold even in the presence of ACLs. In the absence of an <span class="literal">ACL_MASK</span> entry, this behavior could be implemented in various ways, but there are problems with each approach:</p>
<p class="bull">&#8226; Simply modifying the <span class="literal">ACL_GROUP_OBJ</span> and <span class="literal">ACL_OTHER</span> entries to have the mask <span class="literal">---</span>would be insufficient, since the user <em>paulh</em> and the group <em>teach</em> would still have some permissions on the file.</p>
<p class="bull">&#8226; Another possibility would be to apply the new group and other permission settings (i.e., all permissions disabled) to all of the <span class="literal">ACL_USER</span>, <span class="literal">ACL_GROUP</span>, <span class="literal">ACL_GROUP_OBJ</span>, and <span class="literal">ACL_OTHER</span> entries in the ACL:</p>
<p class="programsbl">user::rwx&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# ACL_USER_OBJ<br/>user:paulh:---&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# ACL_USER<br/>group::---&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# ACL_GROUP_OBJ<br/>group:teach:---&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# ACL_GROUP<br/>other::---&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# ACL_OTHER</p>
<p class="noindent">The problem with this approach is that the ACL-unaware application would thereby inadvertently destroy the file permission semantics established by ACL-aware applications, since the following call (for example) would not restore the <span class="literal">ACL_USER</span> and <span class="literal">ACL_GROUP</span> entries of the ACL to their former states:</p>
<p class="programs">chmod(pathname, 751);</p>
<p class="bull"><span epub:type="pagebreak" id="page_325"/>&#8226; To avoid these problems, we might consider making the <span class="literal">ACL_GROUP_OBJ</span> entry the limiting set for all <span class="literal">ACL_USER</span> and <span class="literal">ACL_GROUP</span> entries. However, this would mean that the <span class="literal">ACL_GROUP_OBJ</span> permissions would always need to be set to the union of all permissions allowed in all <span class="literal">ACL_USER</span> and <span class="literal">ACL_GROUP</span> entries. This would conflict with the use of the <span class="literal">ACL_GROUP_OBJ</span> entry for determining the permissions accorded to the file group.</p>
<p class="noindenttb">The <span class="literal">ACL_MASK</span> entry was devised to solve these problems. It provides a mechanism that allows the traditional meanings of <em>chmod()</em> operations to be implemented, without destroying the file permission semantics established by ACL-aware applications. When an ACL has an <span class="literal">ACL_MASK</span> entry:</p>
<p class="bull">&#8226; all changes to traditional group permissions via <em>chmod()</em> change the setting of the <span class="literal">ACL_MASK</span> entry (rather than the <span class="literal">ACL_GROUP_OBJ</span> entry); and</p>
<p class="bull">&#8226; a call to <em>stat()</em> returns the <span class="literal">ACL_MASK</span> permissions (instead of the <span class="literal">ACL_GROUP_OBJ</span> permissions) in the group permission bits of the <em>st_mode</em> field (<a href="ch15.xhtml#ch15fig1">Figure 15-1</a>, on <a href="ch15.xhtml#page_281">page 281</a>).</p>
<p class="noindentt">While the <span class="literal">ACL_MASK</span> entry provides a way of preserving ACL information in the face of ACL-unaware applications, the reverse is not guaranteed. The presence of ACLs overrides the effect of traditional operations on file group permissions. For example, suppose that we have placed the following ACL on a file:</p>
<p class="programs">user::rw-,group::---,mask::---,other::r--</p>
<p class="noindent">If we then execute the command <em>chmod g+rw</em> on this file, the ACL becomes:</p>
<p class="programs">user::rw-,group::---,mask::rw-,other::r--</p>
<p class="noindent">In this case, group still has no access to the file. One workaround for this is to modify the ACL entry for group to grant all permissions. Consequently, group will then always obtain whatever permissions are granted to the <span class="literal">ACL_MASK</span> entry.</p>
<h3 class="h3" id="ch17lev1sec05"><strong>17.5 The <em>getfacl</em> and <em>setfacl</em> Commands</strong></h3>
<p class="noindenta">From the shell, we can use the <em>getfacl</em> command to view the ACL on a file.</p>
<p class="programs">$ <span class="codestrong">umask 022</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Set shell umask to known state</span><br/>$ <span class="codestrong">touch tfile</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create a new file</span><br/>$ <span class="codestrong">getfacl tfile</span><br/># file: tfile<br/># owner: mtk<br/># group: users<br/>user::rw-<br/>group::r--<br/>other::r--</p>
<p class="noindent">From the output of the <em>getfacl</em> command, we see that the new file is created with a minimal ACL. When displaying the text form of this ACL, <em>getfacl</em> precedes the ACL <span epub:type="pagebreak" id="page_326"/>entries with three lines showing the name and ownership of the file. We can prevent these lines from being displayed by specifying the <em>&#8211;&#8211;omit&#8211;header</em> option.</p>
<p class="indent">Next, we demonstrate that changes to a file&#8217;s permissions using the traditional <em>chmod</em> command are carried through to the ACL.</p>
<p class="programs">$ <span class="codestrong">chmod u=rwx,g=rx,o=x tfile</span><br/>$ <span class="codestrong">getfacl --omit-header tfile</span><br/>user::rwx<br/>group::r-x<br/>other::--x</p>
<p class="noindent">The <em>setfacl</em> command modifies a file ACL. Here, we use the <em>setfacl &#8211;m</em> command to add an <span class="literal">ACL_USER</span> and an <span class="literal">ACL_GROUP</span> entry to the ACL:</p>
<p class="programs">$ <span class="codestrong">setfacl -m u:paulh:rx,g:teach:x tfile</span><br/>$ <span class="codestrong">getfacl --omit-header tfile</span><br/>user::rwx<br/>user:paulh:r-x&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ACL_USER <span class="font1">entry</span><br/>group::r-x<br/>group:teach:--x&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ACL_GROUP <span class="font1">entry</span><br/>mask::r-x&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ACL_MASK <span class="font1">entry</span><br/>other::--x</p>
<p class="noindent">The <em>setfacl &#8211;m</em> option modifies existing ACL entries, or adds new entries if corresponding entries with the given tag type and qualifier do not already exist. We can additionally use the <em>&#8211;R</em> option to recursively apply the specified ACL to all of the files in a directory tree.</p>
<p class="indent">From the output of the <em>getfacl</em> command, we can see that <em>setfacl</em> automatically created an <span class="literal">ACL_MASK</span> entry for this ACL.</p>
<p class="indent">The addition of the <span class="literal">ACL_USER</span> and <span class="literal">ACL_GROUP</span> entries converts this ACL into an extended ACL, and <em>ls &#8211;l</em> indicates this fact by appending a plus sign (<span class="literal">+</span>) after the traditional file permissions mask:</p>
<p class="programs">$ <span class="codestrong">ls -l tfile</span><br/>-rwxr-x--x+&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0 Dec 3 15:42 tfile</p>
<p class="noindent">We continue by using <em>setfacl</em> to disable all permissions except execute on the <span class="literal">ACL_MASK</span> entry, and then view the ACL once more with <em>getfacl</em>:</p>
<p class="programs">$ <span class="codestrong">setfacl -m m::x tfile</span><br/>$ <span class="codestrong">getfacl --omit-header tfile</span><br/>user::rwx<br/>user:paulh:r-x&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#effective:--x<br/>group::r-x&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#effective:--x<br/>group:teach:--x<br/>mask::--x<br/>other::--x</p>
<p class="noindent">The <span class="literal">#effective:</span> comments that <em>getfacl</em> prints after the entries for the user <em>paulh</em> and the file group (<span class="literal">group::</span>) inform us that after masking (ANDing) against the <span class="literal">ACL_MASK</span> entry, the permissions granted by each of these entries will actually be less than those specified in the entry.</p>
<p class="indent"><span epub:type="pagebreak" id="page_327"/>We then use <em>ls &#8211;l</em> to once more view the traditional permission bits of the file. We see that the displayed group class permission bits reflect the permissions in the <span class="literal">ACL_MASK</span> entry (<span class="literal">--x</span>), rather than those in the <span class="literal">ACL_GROUP</span> entry (<span class="literal">r-x</span>):</p>
<p class="programs">$ <span class="codestrong">ls -l tfile</span><br/>-rwx--x--x+&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0 Dec 3 15:42 tfile</p>
<p class="noindent">The <em>setfacl &#8211;x</em> command can be used to remove entries from an ACL. Here, we remove the entries for the user <em>paulh</em> and the group <em>teach</em> (no permissions are specified when removing entries):</p>
<p class="programs">$ <span class="codestrong">setfacl -x u:paulh,g:teach tfile</span><br/>$ <span class="codestrong">getfacl --omit-header tfile</span><br/>user::rwx<br/>group::r-x<br/>mask::r-x<br/>other::--x</p>
<p class="noindent">Note that during the above operation, <em>setfacl</em> automatically adjusted the mask entry to be the union of all of the group class entries. (There was just one such entry: <span class="literal">ACL_GROUP_OBJ</span>.) If we want to prevent such adjustment, then we must specify the <em>&#8211;n</em> option to <em>setfacl</em>.</p>
<p class="indent">Finally, we note that the <em>setfacl &#8211;b</em> option can be used to remove all extended entries from an ACL, leaving just the minimal (i.e., user, group, and other) entries.</p>
<h3 class="h3" id="ch17lev1sec06"><strong>17.6 Default ACLs and File Creation</strong></h3>
<p class="noindenta">In the discussion of ACLs so far, we have been describing <em>access</em> ACLs. As its name implies, an access ACL is used in determining the permissions that a process has when accessing the file associated with the ACL. We can create a second type of ACL on directories: a <em>default</em> ACL.</p>
<p class="indent">A default ACL plays no part in determining the permissions granted when accessing the directory. Instead, its presence or absence determines the ACL(s) and permissions that are placed on files and subdirectories that are created in the directory. (A default ACL is stored as an extended attribute named <em>system.posix_acl_default</em>.)</p>
<p class="indent">To view and set the default ACL of a directory, we use the <em>&#8211;d</em> option of the <em>getfacl</em> and <em>setfacl</em> commands.</p>
<p class="programs">$ <span class="codestrong">mkdir sub</span><br/>$ <span class="codestrong">setfacl -d -m u::rwx,u:paulh:rx,g::rx,g:teach:rwx,o::- sub</span><br/>$ <span class="codestrong">getfacl -d --omit-header sub</span><br/>user::rwx<br/>user:paulh:r-x<br/>group::r-x<br/>group:teach:rwx<br/>mask::rwx&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">setfacl generated</span> ACL_MASK <span class="font1">entry automatically</span><br/>other::---</p>
<p class="noindent">We can remove a default ACL from a directory using the <em>setfacl &#8211;k</em> option.</p>
<p class="noindentb"><span epub:type="pagebreak" id="page_328"/>If a directory has a default ACL, then:</p>
<p class="bull">&#8226; A new subdirectory created in this directory inherits the directory&#8217;s default ACL as its default ACL. In other words, default ACLs propagate down through a directory tree as new subdirectories are created.</p>
<p class="bull">&#8226; A new file or subdirectory created in this directory inherits the directory&#8217;s default ACL as its access ACL. The ACL entries that correspond to the traditional file permission bits are masked (ANDed) against the corresponding bits of the <em>mode</em> argument in the system call (<em>open()</em>, <em>mkdir()</em>, and so on) used to create the file or subdirectory. By &#8220;corresponding ACL entries,&#8221; we mean:</p>
<p class="dash1">&#8211; <span class="literal">ACL_USER_OBJ</span>;</p>
<p class="dash1">&#8211; <span class="literal">ACL_MASK</span> or, if <span class="literal">ACL_MASK</span> is absent, then <span class="literal">ACL_GROUP_OBJ</span>; and</p>
<p class="dash1">&#8211; <span class="literal">ACL_OTHER</span>.</p>
<p class="noindentt">When a directory has a default ACL, the process umask (<a href="ch15.xhtml#ch15lev2sec10">Section 15.4.6</a>) doesn&#8217;t play a part in determining the permissions in the entries of the access ACL of a new file created in that directory.</p>
<p class="indent">As an example of how a new file inherits its access ACL from the parent directory&#8217;s default ACL, suppose we used the following <em>open()</em> call to create a new file in the directory created above:</p>
<p class="programs">open("sub/tfile", O_RDWR | O_CREAT,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S_IRWXU | S_IXGRP | S_IXOTH);&#160;&#160;&#160;/* rwx--x--x */</p>
<p class="noindent">The new file would have the following access ACL:</p>
<p class="programs">$ <span class="codestrong">getfacl --omit-header sub/tfile</span><br/>user::rwx<br/>user:paulh:r-x&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#effective:--x<br/>group::r-x&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#effective:--x<br/>group:teach:rwx&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#effective:--x<br/>mask::--x<br/>other::---</p>
<p class="noindentb">If a directory doesn&#8217;t have a default ACL, then:</p>
<p class="bull">&#8226; New subdirectories created in this directory also do not have a default ACL.</p>
<p class="bull">&#8226; The permissions of the new file or directory are set following the traditional rules (<a href="ch15.xhtml#ch15lev2sec10">Section 15.4.6</a>): the file permissions are set to the value in the <em>mode</em> argument (given to <em>open()</em>, <em>mkdir()</em>, and so on), less the bits that are turned off by the process umask. This results in a minimal ACL on the new file.</p>
<h3 class="h3" id="ch17lev1sec07"><strong>17.7 ACL Implementation Limits</strong></h3>
<p class="noindentab">The various file-system implementations impose limits on the number of entries in an ACL:</p>
<p class="bull">&#8226; On <em>ext2</em>, <em>ext3</em>, and <em>ext4</em>, the total number of ACLs on a file is governed by the requirement that the bytes in all of the names and values of a file&#8217;s extended attributes must be contained in a single logical disk block (<a href="ch16.xhtml#ch16lev1sec02">Section 16.2</a>). Each <span epub:type="pagebreak" id="page_329"/>ACL entry requires 8 bytes, so that the maximum number of ACL entries for a file is somewhat less (because of some overhead for the name of the extended attribute for the ACL) than one-eighth of the block size. Thus, a 4096-byte block size allows for a maximum of around 500 ACL entries. (Kernels before 2.6.11 imposed an arbitrary limitation of 32 entries for ACLs on <em>ext2</em> and <em>ext3</em>.)</p>
<p class="bull">&#8226; On <em>XFS</em>, an ACL is limited to 25 entries.</p>
<p class="bull">&#8226; On <em>Reiserfs</em> and <em>JFS</em>, ACLs can contain up to 8191 entries. This limit is a consequence of the size limitation (64 kB) imposed by the VFS on the value of an extended attribute (<a href="ch16.xhtml#ch16lev1sec02">Section 16.2</a>).</p>
<div class="block1">
<p class="noindent">At the time of writing, <em>Btrfs</em> limits ACLs to around 500 entries. However, since <em>Btrfs</em> was still under heavy development, this limit may change.</p>
</div>
<p class="noindentb">Although most of the above file systems allow large numbers of entries to be created in an ACL, this should be avoided for the following reasons:</p>
<p class="bull">&#8226; The maintenance of lengthy ACLs becomes a complex and potentially error-prone system administration task.</p>
<p class="bull">&#8226; The amount of time required to scan the ACL for the matching entry (or matching entries in the case of group ID checks) increases linearly with the number of ACL entries.</p>
<p class="noindentt">Generally, we can keep the number of ACL entries on a file down to a reasonable number by defining suitable groups in the system group file (<a href="ch08.xhtml#ch08lev1sec03">Section 8.3</a>) and using those groups within the ACL.</p>
<h3 class="h3" id="ch17lev1sec08"><strong>17.8 The ACL API</strong></h3>
<p class="noindenta">The POSIX.1e draft standard defined a large suite of functions and data structures for manipulating ACLs. Since they are so numerous, we won&#8217;t attempt to describe the details of all of these functions. Instead, we provide an overview of their usage and conclude with an example program.</p>
<p class="indent">Programs that use the ACL API should include <span class="literal">&lt;sys/acl.h&gt;</span>. It may also be necessary to include <span class="literal">&lt;acl/libacl.h&gt;</span> if the program makes use of various Linux extensions to the POSIX.1e draft standard. (A list of the Linux extensions is provided in the <em>acl(5)</em> manual page.) Programs using this API must be compiled with the <em>&#8211;lacl</em> option, in order to link against the <em>libacl</em> library.</p>
<div class="block">
<p class="noindent">As already noted, on Linux, ACLs are implemented using extended attributes, and the ACL API is implemented as a set of library functions that manipulate user-space data structures, and, where necessary, make calls to <em>getxattr()</em> and <em>setxattr()</em> to retrieve and modify the on-disk <em>system</em> extended attribute that holds the ACL representation. It is also possible (though not recommended) for an application to use <em>getxattr()</em> and <em>setxattr()</em> to manipulate ACLs directly.</p>
</div>
<h5 class="h5" id="ch17lev3sec03"><span epub:type="pagebreak" id="page_330"/><strong>Overview</strong></h5>
<p class="noindenta">The functions that constitute the ACL API are listed in the <em>acl(5)</em> manual page. At first sight, this plethora of functions and data structures can seem bewildering. <a href="ch17.xhtml#ch17fig2">Figure 17-2</a> provides an overview of the relationship between the various data structures and indicates the use of many of the ACL functions.</p>
<div class="image"><img src="../images/f17-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch17fig2"/><strong>Figure 17-2:</strong> Relationship between ACL library functions and data structures</p>
<p class="noindentb">From <a href="ch17.xhtml#ch17fig2">Figure 17-2</a>, we can see that the ACL API considers an ACL as a hierarchical object:</p>
<p class="bull">&#8226; An ACL consists of one or more ACL entries.</p>
<p class="bull">&#8226; Each ACL entry consists of a tag type, an optional tag qualifier, and a permission set.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_331"/>We now look briefly at the various ACL functions. In most cases, we don&#8217;t describe the error returns from each function. Functions that return an integer (<em>status</em>) typically return 0 on success and &#8211;1 on error. Functions that return a handle (pointer) return <span class="literal">NULL</span> on error. Errors can be diagnosed using <em>errno</em> in the usual manner.</p>
<div class="block">
<p class="noindent">A <em>handle</em> is an abstract term for some technique used to refer to an object or data structure. The representation of a handle is private to the API implementation. It may be, for example, a pointer, an array index, or a hash key.</p>
</div>
<h5 class="h5" id="ch17lev3sec04"><strong>Fetching a file&#8217;s ACL into memory</strong></h5>
<p class="noindenta">The <em>acl_get_file()</em> function retrieves a copy of the ACL of the file identified by <em>pathname</em>.</p>
<p class="programs">acl_t acl;<br/><br/>acl = acl_get_file(pathname, type);</p>
<p class="noindent">This function retrieves either the access ACL or the default ACL, depending on whether <em>type</em> is specified as <span class="literal">ACL_TYPE_ACCESS</span> or <span class="literal">ACL_TYPE_DEFAULT</span>. As its function result, <em>acl_get_file()</em> returns a handle (of type <em>acl_t</em>) for use with other ACL functions.</p>
<h5 class="h5" id="ch17lev3sec05"><strong>Retrieving entries from an in-memory ACL</strong></h5>
<p class="noindenta">The <em>acl_get_entry()</em> function returns a handle (of type <em>acl_entry_t</em>) referring to one of the ACL entries within the in-memory ACL referred to by its <em>acl</em> argument. This handle is returned in the location pointed to by the final function argument.</p>
<p class="programs">acl_entry_t entry;<br/><br/>status = acl_get_entry(acl, entry_id, &#38;entry);</p>
<p class="noindent">The <em>entry_id</em> argument determines which entry&#8217;s handle is returned. If <em>entry_id</em> is specified as <span class="literal">ACL_FIRST_ENTRY</span>, then a handle for the first entry in the ACL is returned. If <em>entry_id</em> is specified as <span class="literal">ACL_NEXT_ENTRY</span>, then a handle is returned for the entry following the last ACL entry that was retrieved. Thus, we can loop through all of the entries in an ACL by specifying <em>entry_id</em> as <span class="literal">ACL_FIRST_ENTRY</span> in the first call to <em>acl_get_entry()</em> and specifying <em>entry_id</em> as <span class="literal">ACL_NEXT_ENTRY</span> in subsequent calls.</p>
<p class="indent">The <em>acl_get_entry()</em> function returns 1 if it successfully fetches an ACL entry, 0 if there are no more entries, or &#8211;1 on error.</p>
<h5 class="h5" id="ch17lev3sec06"><strong>Retrieving and modifying attributes in an ACL entry</strong></h5>
<p class="noindenta">The <em>acl_get_tag_type()</em> and <em>acl_set_tag_type()</em> functions retrieve and modify the tag type in the ACL entry referred to by their <em>entry</em> argument.</p>
<p class="programs">acl_tag_t tag_type;<br/><br/>status = acl_get_tag_type(entry, &#38;tag_type);<br/>status = acl_set_tag_type(entry, tag_type);</p>
<p class="noindent">The <em>tag_type</em> argument has the type <em>acl_type_t</em> (an integer type), and has one of the values <span class="literal">ACL_USER_OBJ</span>, <span class="literal">ACL_USER</span>, <span class="literal">ACL_GROUP_OBJ</span>, <span class="literal">ACL_GROUP</span>, <span class="literal">ACL_OTHER</span>, or <span class="literal">ACL_MASK</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_332"/>The <em>acl_get_qualifier()</em> and <em>acl_set_qualifier()</em> functions retrieve and modify the tag qualifier in the ACL entry referred to by their <em>entry</em> argument. Here is an example, in which we assume that we have already determined that this is an <span class="literal">ACL_USER</span> entry by inspecting the tag type:</p>
<p class="programs">uid_t *qualp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Pointer to UID */<br/><br/>qualp = acl_get_qualifier(entry);<br/>status = acl_set_qualifier(entry, qualp);</p>
<p class="noindent">The tag qualifier is valid only if the tag type of this entry is <span class="literal">ACL_USER</span> or <span class="literal">ACL_GROUP</span>. In the former case, <em>qualp</em> is a pointer to a user ID (<em>uid_t *</em>); in the latter case, it is a pointer to a group ID (<em>gid_t *</em>).</p>
<p class="indent">The <em>acl_get_permset()</em> and <em>acl_set_permset()</em> functions retrieve and modify the permission set in the ACL entry referred to by their <em>entry</em> argument.</p>
<p class="programs">acl_permset_t permset;<br/><br/>status = acl_get_permset(entry, &#38;permset);<br/>status = acl_set_permset(entry, permset);</p>
<p class="noindent">The <em>acl_permset_t</em> data type is a handle referring to a permission set.</p>
<p class="indent">The following functions are used to manipulate the contents of a permission set:</p>
<p class="programs">int is_set;<br/><br/>is_set = acl_get_perm(permset, perm);<br/><br/>status = acl_add_perm(permset, perm);<br/>status = acl_delete_perm(permset, perm);<br/>status = acl_clear_perms(permset);</p>
<p class="noindentb">In each of these calls, <em>perm</em> is specified as <span class="literal">ACL_READ</span>, <span class="literal">ACL_WRITE</span>, or <span class="literal">ACL_EXECUTE</span>, with the obvious meanings. These functions are used as follows:</p>
<p class="bull">&#8226; The <em>acl_get_perm()</em> function returns 1 (true) if the permission specified in <em>perm</em> is enabled in the permission set referred to by <em>permset</em>, or 0 if it is not. This function is a Linux extension to the POSIX.1e draft standard.</p>
<p class="bull">&#8226; The <em>acl_add_perm()</em> function adds the permission specified in <em>perm</em> to the permission set referred to by <em>permset</em>.</p>
<p class="bull">&#8226; The <em>acl_delete_perm()</em> function removes the permission specified in <em>perm</em> from the permission set referred to by <em>permset</em>. (It is not an error to remove a permission if it is not present in the set.)</p>
<p class="bull">&#8226; The <em>acl_clear_perms()</em> function removes all permissions from the permission set referred to by <em>permset</em>.</p>
<h5 class="h5" id="ch17lev3sec07"><strong>Creating and deleting ACL entries</strong></h5>
<p class="noindenta">The <em>acl_create_entry()</em> function creates a new entry in an existing ACL. A handle referring to the new entry is returned in the location pointed to by the second function argument.</p>
<p class="programs"><span epub:type="pagebreak" id="page_333"/>acl_entry_t entry;<br/><br/>status = acl_create_entry(&#38;acl, &#38;entry);</p>
<p class="noindent">The new entry can then be populated using the functions described previously.</p>
<p class="indent">The <em>acl_delete_entry()</em> function removes an entry from an ACL.</p>
<p class="programs">status = acl_delete_entry(acl, entry);</p>
<h5 class="h5" id="ch17lev3sec08"><strong>Updating a file&#8217;s ACL</strong></h5>
<p class="noindenta">The <em>acl_set_file()</em> function is the converse of <em>acl_get_file()</em>. It updates the on-disk ACL with the contents of the in-memory ACL referred to by its <em>acl</em> argument.</p>
<p class="programs">int status;<br/><br/>status = acl_set_file(pathname, type, acl);</p>
<p class="noindent">The <em>type</em> argument is either <span class="literal">ACL_TYPE_ACCESS</span>, to update the access ACL, or <span class="literal">ACL_TYPE_DEFAULT</span>, to update a directory&#8217;s default ACL.</p>
<h5 class="h5" id="ch17lev3sec09"><strong>Converting an ACL between in-memory and text form</strong></h5>
<p class="noindenta">The <em>acl_from_text()</em> function translates a string containing a long or short text form ACL into an in-memory ACL, and returns a handle that can be used to refer to the ACL in subsequent function calls.</p>
<p class="programs">acl = acl_from_text(acl_string);</p>
<p class="noindent">The <em>acl_to_text()</em> function performs the reverse conversion, returning a long text form string corresponding to the ACL referred to by its <em>acl</em> argument.</p>
<p class="programs">char *str;<br/>ssize_t len;<br/><br/>str = acl_to_text(acl, &#38;len);</p>
<p class="noindent">If the <em>len</em> argument is not specified as <span class="literal">NULL</span>, then the buffer it points to is used to return the length of the string returned as the function result.</p>
<h5 class="h5" id="ch17lev3sec10"><strong>Other functions in the ACL API</strong></h5>
<p class="noindenta">The following paragraphs describe several other commonly used ACL functions that are not shown in <a href="ch17.xhtml#ch17fig2">Figure 17-2</a>.</p>
<p class="indent">The <em>acl_calc_mask(&#38;acl)</em> function calculates and sets the permissions in the <span class="literal">ACL_MASK</span> entry of the in-memory ACL whose handle is pointed to by its argument. Typically, we use this function whenever we create or modify an ACL. The <span class="literal">ACL_MASK</span> permissions are calculated as the union of the permissions in all <span class="literal">ACL_USER</span>, <span class="literal">ACL_GROUP</span>, and <span class="literal">ACL_GROUP_OBJ</span> entries. A useful property of this function is that it creates the <span class="literal">ACL_MASK</span> entry if it doesn&#8217;t already exist. This means that if we add <span class="literal">ACL_USER</span> and <span class="literal">ACL_GROUP</span> entries to a previously minimal ACL, then we can use this function to ensure the creation of the <span class="literal">ACL_MASK</span> entry.</p>
<p class="indentb"><span epub:type="pagebreak" id="page_334"/>The <em>acl_valid(acl)</em> function returns 0 if the ACL referred to by its argument is valid, or &#8211;1 otherwise. An ACL is valid if all of the following are true:</p>
<p class="bull">&#8226; the <span class="literal">ACL_USER_OBJ</span>, <span class="literal">ACL_GROUP_OBJ</span>, and <span class="literal">ACL_OTHER</span> entries appear exactly once;</p>
<p class="bull">&#8226; there is an <span class="literal">ACL_MASK</span> entry if any <span class="literal">ACL_USER</span> or <span class="literal">ACL_GROUP</span> entries are present;</p>
<p class="bull">&#8226; there is at most one <span class="literal">ACL_MASK</span> entry;</p>
<p class="bull">&#8226; each <span class="literal">ACL_USER</span> entry has a unique user ID; and</p>
<p class="bull">&#8226; each <span class="literal">ACL_GROUP</span> entry has a unique group ID.</p>
<div class="block">
<p class="noindent">The <em>acl_check()</em> and <em>acl_error()</em> functions (both are Linux extensions) are alternatives to <em>acl_valid()</em> that are less portable, but provide a more precise description of the error in a malformed ACL. See the manual pages for details.</p>
</div>
<p class="noindent">The <em>acl_delete_def_file(pathname)</em> function removes the default ACL on the directory referred to by <em>pathname</em>.</p>
<p class="indent">The <em>acl_init(count)</em> function creates a new, empty ACL structure that initially contains space for at least <em>count</em> ACL entries. (The <em>count</em> argument is a hint to the system about intended usage, not a hard limit.) A handle for the new ACL is returned as the function result.</p>
<p class="indent">The <em>acl_dup(acl)</em> function creates a duplicate of the ACL referred to by <em>acl</em> and returns a handle for the duplicate ACL as its function result.</p>
<p class="indent">The <em>acl_free(handle)</em> function frees memory allocated by other ACL functions. For example, we must use <em>acl_free()</em> to free memory allocated by calls to <em>acl_from_text()</em>, <em>acl_to_text()</em>, <em>acl_get_file()</em>, <em>acl_init()</em>, and <em>acl_dup()</em>.</p>
<h5 class="h5" id="ch17lev3sec11"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch17.xhtml#ch17ex1">Listing 17-1</a> demonstrates the use of some of the ACL library functions. This program retrieves and displays the ACL on a file (i.e., it provides a subset of the functionality of the <em>getfacl</em> command). If the <em>&#8211;d</em> command-line option is specified, then the program displays the default ACL (of a directory) instead of the access ACL.</p>
<p class="indent">Here is an example of the use of this program:</p>
<p class="programs">$ <span class="codestrong">touch tfile</span><br/>$ <span class="codestrong">setfacl -m 'u:annie:r,u:paulh:rw,g:teach:r' tfile</span><br/>$ <span class="codestrong">./acl_view tfile</span><br/>user_obj&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rw-<br/>user&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;annie&#160;&#160;&#160;&#160;r--<br/>user&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;paulh&#160;&#160;&#160;&#160;rw-<br/>group_obj&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;r--<br/>group&#160;&#160;&#160;&#160;&#160;&#160;&#160;teach&#160;&#160;&#160;&#160;r--<br/>mask&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rw-<br/>other&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;r--</p>
<div class="block">
<p class="noindent">The source code distribution of this book also includes a program, <span class="literal">acl/acl_update.c</span>, that performs updates on an ACL (i.e., it provides a subset of the functionality of the <em>setfacl</em> command).</p>
</div>
<p class="examplet"><span epub:type="pagebreak" id="page_335"/><a id="ch17ex1"/><strong>Listing 17-1:</strong> Display the access or default ACL on a file</p>
<p class="programsli">___________________________________________________________ <span class="codestrong">acl/acl_view.c</span><br/><br/>#include &lt;acl/libacl.h&gt;<br/>#include &lt;sys/acl.h&gt;<br/>#include "ugid_functions.h"<br/>#include "tlpi_hdr.h"<br/><br/>static void<br/>usageError(char *progName)<br/>{<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "Usage: %s [-d] filename\n", progName);<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;acl_t acl;<br/>&#160;&#160;&#160;&#160;acl_type_t type;<br/>&#160;&#160;&#160;&#160;acl_entry_t entry;<br/>&#160;&#160;&#160;&#160;acl_tag_t tag;<br/>&#160;&#160;&#160;&#160;uid_t *uidp;<br/>&#160;&#160;&#160;&#160;gid_t *gidp;<br/>&#160;&#160;&#160;&#160;acl_permset_t permset;<br/>&#160;&#160;&#160;&#160;char *name;<br/>&#160;&#160;&#160;&#160;int entryId, permVal, opt;<br/><br/>&#160;&#160;&#160;&#160;type = ACL_TYPE_ACCESS;<br/>&#160;&#160;&#160;&#160;while ((opt = getopt(argc, argv, "d")) != -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (opt) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'd': type = ACL_TYPE_DEFAULT;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case '?': usageError(argv[0]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (optind + 1 != argc)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0]);<br/><br/>&#160;&#160;&#160;&#160;acl = acl_get_file(argv[optind], type);<br/>&#160;&#160;&#160;&#160;if (acl == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("acl_get_file");<br/><br/>&#160;&#160;&#160;&#160;/* Walk through each entry in this ACL */<br/><br/>&#160;&#160;&#160;&#160;for (entryId = ACL_FIRST_ENTRY; ; entryId = ACL_NEXT_ENTRY) {<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (acl_get_entry(acl, entryId, &#38;entry) != 1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Exit on error or no more entries */<br/><br/><span epub:type="pagebreak" id="page_336"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Retrieve and display tag type */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (acl_get_tag_type(entry, &#38;tag) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("acl_get_tag_type");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%-12s", (tag == ACL_USER_OBJ) ?&#160;&#160;"user_obj" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(tag == ACL_USER) ?&#160;&#160;&#160;&#160;&#160;&#160;"user" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(tag == ACL_GROUP_OBJ) ? "group_obj" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(tag == ACL_GROUP) ?&#160;&#160;&#160;&#160;&#160;"group" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(tag == ACL_MASK) ?&#160;&#160;&#160;&#160;&#160;&#160;"mask" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(tag == ACL_OTHER) ?&#160;&#160;&#160;&#160;&#160;"other" : "???");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Retrieve and display optional tag qualifier */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (tag == ACL_USER) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;uidp = acl_get_qualifier(entry);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (uidp == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("acl_get_qualifier");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;name = userNameFromID(*uidp);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (name == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%-8d ", *uidp);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%-8s ", name);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (acl_free(uidp) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("acl_free");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else if (tag == ACL_GROUP) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;gidp = acl_get_qualifier(entry);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (gidp == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("acl_get_qualifier");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;name = groupNameFromId(*gidp);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (name == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%-8d ", *gidp);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%-8s ", name);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (acl_free(gidp) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("acl_free");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Retrieve and display permissions */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (acl_get_permset(entry, &#38;permset) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("acl_get_permset");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;permVal = acl_get_perm(permset, ACL_READ);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (permVal == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("acl_get_perm - ACL_READ");<br/><span epub:type="pagebreak" id="page_337"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%c", (permVal == 1) ? 'r' : '-');<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;permVal = acl_get_perm(permset, ACL_WRITE);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (permVal == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("acl_get_perm - ACL_WRITE");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%c", (permVal == 1) ? 'w' : '-');<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;permVal = acl_get_perm(permset, ACL_EXECUTE);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (permVal == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("acl_get_perm - ACL_EXECUTE");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%c", (permVal == 1) ? 'x' : '-');<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("\n");<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (acl_free(acl) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("acl_free");<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>___________________________________________________________ <span class="codestrong">acl/acl_view.c</span></p>
<h3 class="h3" id="ch17lev1sec09"><strong>17.9 Summary</strong></h3>
<p class="noindenta">From version 2.6 onward, Linux supports ACLs. ACLs extend the traditional UNIX file permissions model, allowing file permissions to be controlled on a peruser and per-group basis.</p>
<h5 class="h5" id="ch17lev3sec12"><strong>Further information</strong></h5>
<p class="noindenta">The final versions (<em>Draft 17</em>) of the draft POSIX.1e and POSIX.2c standards are available online at <em><a href="http://wt.tuxomania.net/publications/posix.1e/">http://wt.tuxomania.net/publications/posix.1e/</a></em>.</p>
<p class="indent">The <em>acl(5)</em> manual page gives an overview of ACLs and some guidance on the portability of the various ACL library functions implemented on Linux.</p>
<p class="indent">Details of the Linux implementation of ACLs and extended attributes can be found in [<a href="bib.xhtml#bib38">Gr&#252;nbacher, 2003</a>]. Andreas Gr&#252;nbacher maintains a web site containing information about ACLs at <em><a href="http://acl.bestbits.at/">http://acl.bestbits.at/</a></em>.</p>
<h3 class="h3" id="ch17lev1sec10"><strong>17.10 Exercise</strong></h3>
<p class="exer"><a id="ch17exe1"/><strong>17-1.</strong>&#160;&#160;&#160;Write a program that displays the permissions from the ACL entry that corresponds to a particular user or group. The program should take two command-line arguments. The first argument is either of the letters <em>u</em> or <em>g</em>, indicating whether the second argument identifies a user or group. (The functions defined in <a href="ch08.xhtml#ch8ex1">Listing 8-1</a>, on <a href="ch08.xhtml#page_159">page 159</a>, can be used to allow the second command-line argument to be specified numerically or as a name.) If the ACL entry that corresponds to the given user or group falls into the group class, then the program should additionally display the permissions that would apply after the ACL entry has been modified by the ACL mask entry.<span epub:type="pagebreak" id="page_338"/></p>
</body>
</html>
