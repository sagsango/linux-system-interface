<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch33"><span epub:type="pagebreak" id="page_681"/><strong><span class="big">33</span></strong><br/><strong>THREADS: FURTHER DETAILS</strong></h2>
<p class="noindenta">This chapter provides further details on various aspects of POSIX threads. We discuss the interaction of threads with aspects of the traditional UNIX API&#8212;in particular, signals and the process control primitives (<em>fork()</em>, <em>exec()</em>, and <em>_exit()</em>). We also provide an overview of the two POSIX threads implementations available on Linux&#8212;LinuxThreads and NPTL&#8212;and note where each of these implementations deviates from the SUSv3 specification of Pthreads.</p>
<h3 class="h3" id="ch33lev1sec01"><strong>33.1 Thread Stacks</strong></h3>
<p class="noindenta">Each thread has its own stack whose size is fixed when the thread is created. On Linux/x86-32, for all threads other than the main thread, the default size of the per-thread stack is 2 MB. (On some 64-bit architectures, the default size is higher; for example, it is 32 MB on IA-64.) The main thread has a much larger space for stack growth (refer to <a href="ch29.xhtml#ch29fig1">Figure 29-1</a>, on <a href="ch29.xhtml#page_618">page 618</a>).</p>
<p class="indent">Occasionally, it is useful to change the size of a thread&#8217;s stack. The <em>pthread_attr_setstacksize()</em> function sets a thread attribute (<a href="ch29.xhtml#ch29lev1sec08">Section 29.8</a>) that determines the size of the stack in threads created using the thread attributes object. The related <em>pthread_attr_setstack()</em> function can be used to control both the size and the location of the stack, but setting the location of a stack can decrease application portability. The manual pages provide details of these functions.</p>
<p class="indent">One reason to change the size of per-thread stacks is to allow for larger stacks for threads that allocate large automatic variables or make nested function calls of <span epub:type="pagebreak" id="page_682"/>great depth (perhaps because of recursion). Alternatively, an application may want to reduce the size of per-thread stacks to allow for a greater number of threads within a process. For example, on x86-32, where the user-accessible virtual address space is 3 GB, the default stack size of 2 MB means that we can create a maximum of around 1500 threads. (The precise maximum depends on how much virtual memory is consumed by the text and data segments, shared libraries, and so on.) The minimum stack that can be employed on a particular architecture can be determined by calling <em>sysconf(_SC_THREAD_STACK_MIN)</em>. For the NPTL implementation on Linux/x86-32, this call returns the value 16,384.</p>
<div class="block">
<p class="noindent">Under the NPTL threading implementation, if the stack size resource limit (<span class="literal">RLIMIT_STACK</span>) is set to anything other than <em>unlimited</em>, then it is used as the default stack size when creating new threads. This limit must be set <em>before</em> the program is executed, typically by using the <em>ulimit &#8211;s</em> shell built-in command (<em>limit stacksize</em> in the C shell) before executing the program. It is not sufficient to use <em>setrlimit()</em> within the main program to set the limit, because NPTL makes its determination of the default stack size during the run-time initialization that occurs before <em>main()</em> is invoked.</p>
</div>
<h3 class="h3" id="ch33lev1sec02"><strong>33.2 Threads and Signals</strong></h3>
<p class="noindenta">The UNIX signal model was designed with the UNIX process model in mind, and predated the arrival of Pthreads by a couple of decades. As a result, there are some significant conflicts between the signal and thread models. These conflicts arose primarily from the need to maintain the traditional signal semantics for single-threaded processes (i.e., the signal semantics of traditional programs should not be changed by Pthreads), while at the same time developing a signal model that would be usable within a multithreaded process.</p>
<p class="indent">The differences between the signal and thread models mean that combining signals and threads is complex, and should be avoided whenever possible. Nevertheless, sometimes we must deal with signals in a threaded program. In this section, we discuss the interactions between threads and signals, and describe various functions that are useful in threaded programs that deal with signals.</p>
<h4 class="h4" id="ch33lev2sec01"><strong>33.2.1 How the UNIX Signal Model Maps to Threads</strong></h4>
<p class="noindentab">To understand how UNIX signals map to the Pthreads model, we need to know which aspects of the signal model are process-wide (i.e., are shared by all of the threads in the process) as opposed to those aspects that are specific to individual threads within the process. The following list summarizes the key points:</p>
<p class="bull">&#8226; Signal actions are process-wide. If any unhandled signal whose default action is <em>stop</em> or <em>terminate</em> is delivered to any thread in a process, then all of the threads in the process are stopped or terminated.</p>
<p class="bull">&#8226; Signal dispositions are process-wide; all threads in a process share the same disposition for each signal. If one thread uses <em>sigaction()</em> to establish a handler for, say, <span class="literal">SIGINT</span>, then that handler may be invoked from any thread to which the <span class="literal">SIGINT</span> is delivered. Similarly, if one thread sets the disposition of a signal to <em>ignore</em>, then that signal is ignored by all threads.</p>
<p class="bull"><span epub:type="pagebreak" id="page_683"/>&#8226; A signal may be directed to either the process as a whole or to a specific thread. A signal is thread-directed if:</p>
<p class="dash1">&#8211; it is generated as the direct result of the execution of a specific hardware instruction within the context of the thread (i.e., the hardware exceptions described in <a href="ch22.xhtml#ch22lev1sec04">Section 22.4</a>: <span class="literal">SIGBUS</span>, <span class="literal">SIGFPE</span>, <span class="literal">SIGILL</span>, and <span class="literal">SIGSEGV</span>);</p>
<p class="dash1">&#8211; it is a <span class="literal">SIGPIPE</span> signal generated when the thread tried to write to a broken pipe; or</p>
<p class="dash1">&#8211; it is sent using <em>pthread_kill()</em> or <em>pthread_sigqueue()</em>, which are functions (described in <a href="ch33.xhtml#ch33lev2sec03">Section 33.2.3</a>) that allow one thread to send a signal to another thread within the same process.</p>
<p class="bullp">All signals generated by other mechanisms are process-directed. Examples are signals sent from another process using <em>kill()</em> or <em>sigqueue()</em>; signals such as <span class="literal">SIGINT</span> and <span class="literal">SIGTSTP</span>, generated when the user types one of the terminal special characters that generate a signal; and signals generated for software events such as the resizing of a terminal window (<span class="literal">SIGWINCH</span>) or the expiration of a timer (e.g., <span class="literal">SIGALRM</span>).</p>
<p class="bull">&#8226; When a signal is delivered to a multithreaded process that has established a signal handler, the kernel arbitrarily selects one thread in the process to which to deliver the signal and invokes the handler in that thread. This behavior is consistent with maintaining the traditional signal semantics. It would not make sense for a process to perform the signal handling actions multiple times in response to a single signal.</p>
<p class="bull">&#8226; The signal mask is per-thread. (There is no notion of a process-wide signal mask that governs all threads in a multithreaded process.) Threads can independently block or unblock different signals using <em>pthread_sigmask()</em>, a new function defined by the Pthreads API. By manipulating the per-thread signal masks, an application can control which thread(s) may handle a signal that is directed to the whole process.</p>
<p class="bull">&#8226; The kernel maintains a record of the signals that are pending for the process as a whole, as well as a record of the signals that are pending for each thread. A call to <em>sigpending()</em> returns the union of the set of signals that are pending for the process and those that are pending for the calling thread. In a newly created thread, the per-thread set of pending signals is initially empty. A thread-directed signal can be delivered only to the target thread. If the thread is blocking the signal, it will remain pending until the thread unblocks the signal (or terminates).</p>
<p class="bull">&#8226; If a signal handler interrupts a call to <em>pthread_mutex_lock()</em>, then the call is always automatically restarted. If a signal handler interrupts a call to <em>pthread_cond_wait()</em>, then the call either is restarted automatically (this is what Linux does) or returns 0, indicating a spurious wake-up (in which case a well-designed application will recheck the corresponding predicate and restart the call, as described in <a href="ch30.xhtml#ch30lev2sec10">Section 30.2.3</a>). SUSv3 requires these two functions to behave as described here.</p>
<p class="bull">&#8226; The alternate signal stack is per-thread (refer to the description of <em>sigaltstack()</em> in <a href="ch21.xhtml#ch21lev1sec03">Section 21.3</a>). A newly created thread doesn&#8217;t inherit the alternate signal stack from its creator.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_684"/>More precisely, SUSv3 specifies that there is a separate alternate signal stack for each kernel scheduling entity (KSE). On a system with a 1:1 threading implementation, as on Linux, there is one KSE per thread (see <a href="ch33.xhtml#ch33lev1sec04">Section 33.4</a>).</p>
</div>
<h4 class="h4" id="ch33lev2sec02"><strong>33.2.2 Manipulating the Thread Signal Mask</strong></h4>
<p class="noindenta">When a new thread is created, it inherits a copy of the signal mask of the thread that created it. A thread can use <em>pthread_sigmask()</em> to change its signal mask, to retrieve the existing mask, or both.</p>
<div class="box">
<p class="programsa">#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">pthread_sigmask</span>(int <span class="font1">how</span>, const sigset_t *<span class="font1">set</span>, sigset_t *<span class="font1">oldset</span>);</p>
<p class="right">Returns 0 on success, or a positive error number on error</p>
</div>
<p class="noindent">Other than the fact that it operates on the thread signal mask, the use of <em>pthread_sigmask()</em> is the same as the use of <em>sigprocmask()</em> (<a href="ch20.xhtml#ch20lev1sec10">Section 20.10</a>).</p>
<div class="block">
<p class="noindent">SUSv3 notes that the use of <em>sigprocmask()</em> within a multithreaded program is unspecified. We can&#8217;t portably employ <em>sigprocmask()</em> in a multithreaded program. In practice, <em>sigprocmask()</em> and <em>pthread_sigmask()</em> are identical on many implementations, including Linux.</p>
</div>
<h4 class="h4" id="ch33lev2sec03"><strong>33.2.3 Sending a Signal to a Thread</strong></h4>
<p class="noindenta">The <em>pthread_kill()</em> function sends the signal <em>sig</em> to a thread in the same process as the caller. The target thread is identified by the argument <em>thread</em>.</p>
<div class="box">
<p class="programsa">#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">pthread_kill</span>(pthread_t <span class="font1">thread</span>, int <span class="font1">sig</span>);</p>
<p class="right">Returns 0 on success, or a positive error number on error</p>
</div>
<p class="noindent">Because a thread ID is guaranteed to be unique only within a process (see <a href="ch29.xhtml#ch29lev1sec05">Section 29.5</a>), we can&#8217;t use <em>pthread_kill()</em> to send a signal to a thread in another process.</p>
<div class="block">
<p class="noindent">The <em>pthread_kill()</em> function is implemented using the Linux-specific <em>tgkill(tgid, tid, sig)</em> system call, which sends the signal <em>sig</em> to the thread identified by <em>tid</em> (a kernel thread ID of the type returned by <em>gettid()</em>) within the thread group identified by <em>tgid</em>. See the <em>tgkill(2)</em> manual page for further details.</p>
</div>
<p class="noindent">The Linux-specific <em>pthread_sigqueue()</em> function combines the functionality of <em>pthread_kill()</em> and <em>sigqueue()</em> (<a href="ch22.xhtml#ch22lev2sec01">Section 22.8.1</a>): it sends a signal with accompanying data to a thread in the same process as the caller.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_685"/>#define _GNU_SOURCE<br/>#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">pthread_sigqueue</span>(pthread_t <span class="font1">thread</span>, int <span class="font1">sig</span>, const union sigval <span class="font1">value</span>);</p>
<p class="right">Returns 0 on success, or a positive error number on error</p>
</div>
<p class="noindent">As with <em>pthread_kill()</em>, <em>sig</em> specifies the signal to be sent, and <em>thread</em> identifies the target thread. The <em>value</em> argument specifies the data to accompany the signal, and is used in the same way as the equivalent argument of <em>sigqueue()</em>.</p>
<div class="block">
<p class="noindent">The <em>pthread_sigqueue()</em> function was added to <em>glibc</em> in version 2.11 and requires support from the kernel. This support is provided by the <em>rt_tgsigqueueinfo()</em> system call, which was added in Linux 2.6.31.</p>
</div>
<h4 class="h4" id="ch33lev2sec04"><strong>33.2.4 Dealing with Asynchronous Signals Sanely</strong></h4>
<p class="noindentab">In <a href="ch20.xhtml#ch20">Chapters 20</a> to <a href="ch22.xhtml#ch22">22</a>, we discussed various factors&#8212;such as reentrancy issues, the need to restart interrupted system calls, and avoiding race conditions&#8212;that can make it complex to deal with asynchronously generated signals via signal handlers. Furthermore, none of the functions in the Pthreads API is among the set of async-signal-safe functions that we can safely call from within a signal handler (<a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>). For these reasons, multithreaded programs that must deal with asynchronously generated signals generally should not use a signal handler as the mechanism to receive notification of signal delivery. Instead, the preferred approach is the following:</p>
<p class="bull">&#8226; All threads block all of the asynchronous signals that the process might receive. The simplest way to do this is to block the signals in the main thread before any other threads are created. Each subsequently created thread will inherit a copy of the main thread&#8217;s signal mask.</p>
<p class="bull">&#8226; Create a single dedicated thread that accepts incoming signals using <em>sigwaitinfo()</em>, <em>sigtimedwait()</em>, or <em>sigwait()</em>. We described <em>sigwaitinfo()</em> and <em>sigtimedwait()</em> in <a href="ch22.xhtml#ch22lev1sec10">Section 22.10</a>. We describe <em>sigwait()</em> below.</p>
<p class="noindentt">The advantage of this approach is that asynchronously generated signals are received synchronously. As it accepts incoming signals, the dedicated thread can safely modify shared variables (under mutex control) and call non-async-signal-safe functions. It can also signal condition variables, and employ other thread and process communication and synchronization mechanisms.</p>
<p class="indent">The <em>sigwait()</em> function waits for the delivery of one of the signals in the signal set pointed to by <em>set</em>, accepts that signal, and returns it in <em>sig</em>.</p>
<div class="box">
<p class="programsa">#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">sigwait</span>(const sigset_t *<span class="font1">set</span>, int *<span class="font1">sig</span>);</p>
<p class="right">Returns 0 on success, or a positive error number on error</p>
</div>
<p class="noindentb"><span epub:type="pagebreak" id="page_686"/>The operation of <em>sigwait()</em> is the same as <em>sigwaitinfo()</em>, except that:</p>
<p class="bull">&#8226; instead of returning a <em>siginfo_t</em> structure describing the signal, <em>sigwait()</em> returns just the signal number; and</p>
<p class="bull">&#8226; the return value is consistent with other thread-related functions (rather than the 0 or &#8211;1 returned by traditional UNIX system calls).</p>
<p class="noindentt">If multiple threads are waiting for the same signal with <em>sigwait()</em>, only one of the threads will actually accept the signal when it arrives. Which of the threads this will be is indeterminate.</p>
<h3 class="h3" id="ch33lev1sec03"><strong>33.3 Threads and Process Control</strong></h3>
<p class="noindenta">Like the signals mechanism, <em>exec()</em>, <em>fork()</em>, and <em>exit()</em> predate the Pthreads API. In the following paragraphs, we note some details concerning the use of these system calls in threaded programs.</p>
<h5 class="h5" id="ch33lev3sec01"><strong>Threads and <em>exec()</em></strong></h5>
<p class="noindenta">When any thread calls one of the <em>exec()</em> functions, the calling program is completely replaced. All threads, except the one that called <em>exec()</em>, vanish immediately. None of the threads executes destructors for thread-specific data or calls cleanup handlers. All of the (process-private) mutexes and condition variables belonging to the process also disappear. After an <em>exec()</em>, the thread ID of the remaining thread is unspecified.</p>
<h5 class="h5" id="ch33lev3sec02"><strong>Threads and <em>fork()</em></strong></h5>
<p class="noindentab">When a multithreaded process calls <em>fork()</em>, only the calling thread is replicated in the child process. (The ID of the thread in the child is the same as the ID of the thread that called <em>fork()</em> in the parent.) All of the other threads vanish in the child; no thread-specific data destructors or cleanup handlers are executed for those threads. This can lead to various problems:</p>
<p class="bull">&#8226; Although only the calling thread is replicated in the child, the states of global variables, as well as all Pthreads objects such as mutexes and condition variables, are preserved in the child. (This is so because these Pthreads objects are allocated within the parent&#8217;s memory, and the child gets a duplicate of that memory.) This can lead to tricky scenarios. For example, suppose that another thread had locked a mutex at the time of the <em>fork()</em> and is part-way through updating a global data structure. In this case, the thread in the child would not be able to unlock the mutex (since it is not the mutex owner) and would block if it tried to acquire the mutex. Furthermore, the child&#8217;s copy of the global data structure is probably in an inconsistent state, because the thread that was updating it vanished part-way through the update.</p>
<p class="bull">&#8226; Since destructors for thread-specific data and cleanup handlers are not called, a <em>fork()</em> in a multithreaded program can cause memory leaks in the child. Furthermore, the thread-specific data items created by other threads are likely to be inaccessible to the thread in the new child, since it doesn&#8217;t have pointers referring to these items.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_687"/>Because of these problems, the usual recommendation is that the only use of <em>fork()</em> in a multithreaded process should be one that is followed by an immediate <em>exec()</em>. The <em>exec()</em> causes all of the Pthreads objects in the child process to disappear as the new program overwrites the memory of the process.</p>
<p class="indent">For programs that must use a <em>fork()</em> that is not followed by an <em>exec()</em>, the Pthreads API provides a mechanism for defining <em>fork handlers</em>. Fork handlers are established using a <em>pthread_atfork()</em> call of the following form:</p>
<p class="programs">pthread_atfork(prepare_func, parent_func, child_func);</p>
<p class="noindent">Each <em>pthread_atfork()</em> call adds <em>prepare_func</em> to a list of functions that will be automatically executed (in reverse order of registration) before the new child process is created when <em>fork()</em> is called. Similarly, <em>parent_func</em> and <em>child_func</em> are added to a list of functions that will be called automatically (in order of registration), in, respectively, the parent and child process, just before <em>fork()</em> returns.</p>
<p class="indent">Fork handlers are sometimes useful for library code that makes use of threads. In the absence of fork handlers, there would be no way for the library to deal with applications that naively make use of the library and call <em>fork()</em>, unaware that the library has created some threads.</p>
<p class="indent">The child produced by <em>fork()</em> inherits fork handlers from the thread that called <em>fork()</em>. During an <em>exec()</em>, fork handlers are not preserved (they can&#8217;t be, since the code of the handlers is overwritten during the <em>exec()</em>).</p>
<p class="indent">Further details on fork handlers, and examples of their use, can be found in [<a href="bib.xhtml#bib10">Butenhof, 1996</a>].</p>
<div class="block">
<p class="noindent">On Linux, fork handlers are not called if a program using the NPTL threading library calls <em>vfork()</em>. However, in a program using LinuxThreads, fork handlers are called in this case.</p>
</div>
<h5 class="h5" id="ch33lev3sec03"><strong>Threads and <em>exit()</em></strong></h5>
<p class="noindenta">If any thread calls <em>exit()</em> or, equivalently, the main thread does a <span class="literal">return</span>, all threads vanish after higher-level cleanups have been performed (e.g., calling C++ destructors); no thread-specific data destructors or cleanup handlers are executed.</p>
<h3 class="h3" id="ch33lev1sec04"><strong>33.4 Thread Implementation Models</strong></h3>
<p class="noindenta">In this section, we go into some theory, briefly considering three different models for implementing a threading API. This provides useful background for <a href="ch33.xhtml#ch33lev1sec05">Section 33.5</a>, where we consider the Linux threading implementations. The differences between these implementation models hinge on how threads are mapped onto <em>kernel scheduling entities</em> (KSEs), which are the units to which the kernel allocates the CPU and other system resources. (In traditional UNIX implementations that predate threads, the term <em>kernel scheduling entity</em> is synonymous with the term <em>process</em>.)</p>
<h5 class="h5" id="ch33lev3sec04"><strong>Many-to-one (M:1) implementations (user-level threads)</strong></h5>
<p class="noindenta">In M:1 threading implementations, all of the details of thread creation, scheduling, and synchronization (mutex locking, waiting on condition variables, and so on) are <span epub:type="pagebreak" id="page_688"/>handled entirely within the process by a user-space threading library. The kernel knows nothing about the existence of multiple threads within the process.</p>
<p class="indent">M:1 implementations have a few advantages. The greatest advantage is that many threading operations&#8212;for example, creating and terminating a thread, context switching between threads, and mutex and condition variable operations&#8212;are fast, since a switch to kernel mode is not required. Furthermore, since kernel support for the threading library is not required, an M:1 implementation can be relatively easily ported from one system to another.</p>
<p class="indentb">However, M:1 implementations suffer from some serious disadvantages:</p>
<p class="bull">&#8226; When a thread makes a system call such as <em>read()</em>, control passes from the user-space threading library to the kernel. This means that if the <em>read()</em> call blocks, then all threads in the process are blocked.</p>
<p class="bull">&#8226; The kernel can&#8217;t schedule the threads of a process. Since the kernel is unaware of the existence of multiple threads within the process, it can&#8217;t schedule the separate threads to different processors on multiprocessor hardware. Nor is it possible to meaningfully assign a thread in one process a higher priority than a thread in another process, since the scheduling of the threads is handled entirely within the process.</p>
<h5 class="h5" id="ch33lev3sec05"><strong>One-to-one (1:1) implementations (kernel-level threads)</strong></h5>
<p class="noindenta">In a 1:1 threading implementation, each thread maps onto a separate KSE. The kernel handles each thread&#8217;s scheduling separately. Thread synchronization operations are implemented using system calls into the kernel.</p>
<p class="indent">1:1 implementations eliminate the disadvantages suffered by M:1 implementations. A blocking system call does not cause all of the threads in a process to block, and the kernel can schedule the threads of a process onto different CPUs on multiprocessor hardware.</p>
<p class="indent">However, operations such as thread creation, context switching, and synchronization are slower on a 1:1 implementation, since a switch into kernel mode is required. Furthermore, the overhead required to maintain a separate KSE for each of the threads in an application that contains a large number of threads may place a significant load on the kernel scheduler, degrading overall system performance.</p>
<p class="indent">Despite these disadvantages, a 1:1 implementation is usually preferred over an M:1 implementation. Both of the Linux threading implementations&#8212;LinuxThreads and NPTL&#8212;employ the 1:1 model.</p>
<div class="block">
<p class="noindent">During the development of NPTL, significant effort went into rewriting the kernel scheduler and devising a threading implementation that would allow the efficient execution of multithreaded processes containing many thousands of threads. Subsequent testing showed that this goal was achieved.</p>
</div>
<h5 class="h5" id="ch33lev3sec06"><strong>Many-to-many (M:N) implementations (two-level model)</strong></h5>
<p class="noindenta">M:N implementations aim to combine the advantages of the 1:1 and M:1 models, while eliminating their disadvantages.</p>
<p class="indent">In the M:N model, each process can have multiple associated KSEs, and several threads may map to each KSE. This design permits the kernel to distribute the threads of an application across multiple CPUs, while eliminating the possible scaling problems associated with applications that employ large numbers of threads.</p>
<p class="indent"><span epub:type="pagebreak" id="page_689"/>The most significant disadvantage of the M:N model is complexity. The task of thread scheduling is shared between the kernel and the user-space threading library, which must cooperate and communicate information with one another. Managing signals according to the requirements of SUSv3 is also complex under an M:N implementation.</p>
<div class="block">
<p class="noindent">An M:N implementation was initially considered for the NPTL threading implementation, but rejected as requiring changes to the kernel that were too wide ranging and perhaps unnecessary, given the ability of the Linux scheduler to scale well, even when dealing with large numbers of KSEs.</p>
</div>
<h3 class="h3" id="ch33lev1sec05"><strong>33.5 Linux Implementations of POSIX Threads</strong></h3>
<p class="noindentab">Linux has two main implementations of the Pthreads API:</p>
<p class="bull">&#8226; <em>LinuxThreads</em>: This is the original Linux threading implementation, developed by Xavier Leroy.</p>
<p class="bull">&#8226; <em>NPTL (Native POSIX Threads Library)</em>: This is the modern Linux threading implementation, developed by Ulrich Drepper and Ingo Molnar as a successor to LinuxThreads. NPTL provides performance that is superior to LinuxThreads, and it adheres more closely to the SUSv3 specification for Pthreads. Support for NPTL required changes to the kernel, and these changes appeared in Linux 2.6.</p>
<div class="block">
<p class="noindent">For a while, it appeared that the successor to LinuxThreads would be another implementation, called Next Generation POSIX Threads (NGPT), a threading implementation developed at IBM. NGPT employed an M:N design and performed significantly better than LinuxThreads. However, the NPTL developers decided to pursue a new implementation. This approach was justified&#8212;the 1:1-design NPTL was shown to perform better than NGPT. Following the release of NPTL, development of NGPT was discontinued.</p>
</div>
<p class="noindent">In the following sections, we consider further details of these two implementations, and note the points where they deviate from the SUSv3 requirements for Pthreads.</p>
<p class="indent">At this point, it is worth emphasizing that the LinuxThreads implementation is now obsolete; it is not supported in <em>glibc</em> 2.4 and later. All new thread library development occurs only in NPTL.</p>
<h4 class="h4" id="ch33lev2sec05"><strong>33.5.1 LinuxThreads</strong></h4>
<p class="noindentab">For many years, LinuxThreads was the main threading implementation on Linux, and it was sufficient for implementing a variety of threaded applications. The essentials of the LinuxThreads implementation are as follows:</p>
<p class="bull">&#8226; Threads are created using a <em>clone()</em> call that specifies the following flags:</p>
<p class="programsbl">CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND</p>
<p class="bullp">This means that LinuxThreads threads share virtual memory, file descriptors, file system&#8211;related information (umask, root directory, and current working directory), and signal dispositions. However, threads don&#8217;t share process IDs and parent process IDs.</p>
<p class="bull"><span epub:type="pagebreak" id="page_690"/>&#8226; In addition to the threads created by the application, LinuxThreads creates an additional &#8220;manager&#8221; thread that handles thread creation and termination.</p>
<p class="bull">&#8226; The implementation uses signals for its internal operation. With kernels that support realtime signals (Linux 2.2 and later), the first three realtime signals are used. With older kernels, <span class="literal">SIGUSR1</span> and <span class="literal">SIGUSR2</span> are used. Applications can&#8217;t use these signals. (The use of signals results in high latency for various thread synchronization operations.)</p>
<h5 class="h5" id="ch33lev3sec07"><strong>LinuxThreads deviations from specified behavior</strong></h5>
<p class="noindentab">LinuxThreads doesn&#8217;t conform to the SUSv3 specification for Pthreads on a number of points. (The LinuxThreads implementation was constrained by the kernel features available at the time that it was developed; it was as conformant as practicable within those constraints.) The following list summarizes the nonconformances:</p>
<p class="bull">&#8226; Calls to <em>getpid()</em> return a different value in each of the threads of a process. Calls to <em>getppid()</em> in threads other than the main thread return the process ID of the manager thread, which reflects the fact that every thread other than the main thread is created by the manager thread. Calls to <em>getppid()</em> in the other threads should return the same value as a call to <em>getppid()</em> in the main thread.</p>
<p class="bull">&#8226; If one thread creates a child using <em>fork()</em>, then any other thread should be able to obtain the termination status of that child using <em>wait()</em> (or similar). However, this is not so; only the thread that created the child process can <em>wait()</em> for it.</p>
<p class="bull">&#8226; If a thread calls <em>exec()</em>, then, as required by SUSv3, all other threads are terminated. However, if the <em>exec()</em> is done from any thread other than the main thread, then the resulting process will have the same process ID as the calling thread&#8212;that is, a process ID that is different from the main thread&#8217;s process ID. According to SUSv3, the process ID should be the same as that of the main thread.</p>
<p class="bull">&#8226; Threads don&#8217;t share credentials (user and group IDs). When a multithreaded process is executing a set-user-ID program, this can lead to scenarios in which one thread can&#8217;t send a signal to another thread using <em>pthread_kill()</em>, because the credentials of the two threads have been changed in such a way that the sending thread no longer has permission to signal the target thread (refer to <a href="ch20.xhtml#ch20fig2">Figure 20-2</a>, on <a href="ch20.xhtml#page_403">page 403</a>). Furthermore, since the LinuxThreads implementation uses signals internally, various Pthreads operations can fail or hang if a thread changes its credentials.</p>
<p class="bull">&#8226; Various aspects of the SUSv3 specification for the interaction between threads and signals are not honored:</p>
<p class="dash1">&#8211; A signal that is sent to a process using <em>kill()</em> or <em>sigqueue()</em> should be delivered to, and handled by, an arbitrary thread in the target process that is not blocking the signal. However, since LinuxThreads threads have different process IDs, a signal can be targeted only at a specific thread. If that thread is blocking the signal, it remains pending, even if there are other threads that are not blocking the signal.</p>
<p class="dash1"><span epub:type="pagebreak" id="page_691"/>&#8211; LinuxThreads doesn&#8217;t support the notion of signals that are pending for a process as whole; only per-thread pending signals are supported.</p>
<p class="dash1">&#8211; If a signal is directed at a process group that contains a multithreaded application, then the signal will be handled by all threads in the application (i.e., all threads that have established a signal handler), rather than by a single (arbitrary) thread. Such a signal may, for example, be generated by typing one of the terminal characters that generates a job-control signal for the foreground process group.</p>
<p class="dash1">&#8211; The alternate signal stack settings (established by <em>sigaltstack()</em>) are per-thread. However, because a new thread wrongly inherits its alternate signal stack settings from the caller of <em>pthread_create()</em>, the two threads share an alternate signal stack. SUSv3 requires that a new thread should start with no alternate signal stack defined. The consequence of this LinuxThreads nonconformance is that if two threads happen to simultaneously handle different signals on their shared alternate signal stacks at the same time, chaos is likely to result (e.g., a program crash). This problem may be very hard to reproduce and debug, since its occurrence depends on the probably rare event that the two signals are handled at the same time.</p>
<div class="block1">
<p class="noindent">In a program using LinuxThreads, a new thread could make a call to <em>sigaltstack()</em> to ensure that it uses a different alternate signal stack from the thread that created it (or no stack at all). However, portable programs (and library functions that create threads) won&#8217;t know to do this, since it is not a requirement on other implementations. Furthermore, even if we employ this technique, there is still a possible race condition: the new thread could receive and handle a signal on the alternate stack before it has a chance to call <em>sigaltstack()</em>.</p>
</div>
<p class="bull">&#8226; Threads don&#8217;t share a common session ID and process group ID. The <em>setsid()</em> and <em>setpgid()</em> system calls can&#8217;t be used to change the session or process group membership of a multithreaded process.</p>
<p class="bull">&#8226; Record locks established using <em>fcntl()</em> are not shared. Overlapping lock requests of the same type are not merged.</p>
<p class="bull">&#8226; Threads don&#8217;t share resource limits. SUSv3 specifies that resource limits are process-wide attributes.</p>
<p class="bull">&#8226; The CPU time returned by <em>times()</em> and the resource usage information returned by <em>getrusage()</em> are per-thread. These system calls should return process-wide totals.</p>
<p class="bull">&#8226; Some versions of <em>ps(1)</em> show all of the threads in a process (including the manager thread) as separate items with distinct process IDs.</p>
<p class="bull">&#8226; Threads don&#8217;t share the nice value set by <em>setpriority()</em>.</p>
<p class="bull">&#8226; Interval timers created using <em>setitimer()</em> are not shared between threads.</p>
<p class="bull">&#8226; Threads don&#8217;t share System V semaphore undo (<em>semadj</em>) values.</p>
<h5 class="h5" id="ch33lev3sec08"><span epub:type="pagebreak" id="page_692"/><strong>Other problems with LinuxThreads</strong></h5>
<p class="noindentab">In addition to the above deviations from SUSv3, the LinuxThreads implementation has the following problems:</p>
<p class="bull">&#8226; If the manager thread is killed, then the remaining threads must be manually cleaned up.</p>
<p class="bull">&#8226; A core dump of a multithreaded program may not include all of the threads of the process (or even the one that triggered the core dump).</p>
<p class="bull">&#8226; The nonstandard <em>ioctl()</em> <span class="literal">TIOCNOTTY</span> operation can remove the process&#8217;s association with a controlling terminal only when called from the main thread.</p>
<h4 class="h4" id="ch33lev2sec06"><strong>33.5.2 NPTL</strong></h4>
<p class="noindentab">NPTL was designed to address most of the shortcomings of LinuxThreads. In particular:</p>
<p class="bull">&#8226; NPTL provides much closer conformance to the SUSv3 specification for Pthreads.</p>
<p class="bull">&#8226; Applications that employ large numbers of threads scale much better under NPTL than under LinuxThreads.</p>
<div class="block1">
<p class="noindent">NPTL allows an application to create large numbers of threads. The NPTL implementers were able to run test programs that created 100,000 threads. With LinuxThreads, the practical limit on the number of threads is a few thousand. (Admittedly, very few applications need such large numbers of threads.)</p>
</div>
<p class="noindentb">Work on implementing NPTL began in 2002 and progressed over the next year or so. In parallel, various changes were made within the Linux kernel to accommodate the requirements of NPTL. The changes that appeared in the Linux 2.6 kernel to support NPTL included the following:</p>
<p class="bull">&#8226; refinements to the implementation of thread groups (<a href="ch28.xhtml#ch28lev2sec01">Section 28.2.1</a>);</p>
<p class="bull">&#8226; the addition of futexes as a synchronization mechanism (futexes are a generic mechanism that was designed not just for NPTL);</p>
<p class="bull">&#8226; the addition of new system calls (<em>get_thread_area()</em> and <em>set_thread_area()</em>) to support thread-local storage;</p>
<p class="bull">&#8226; support for threaded core dumps and debugging of multithreaded processes;</p>
<p class="bull">&#8226; modifications to support management of signals in a manner consistent with the Pthreads model;</p>
<p class="bull">&#8226; the addition of a new <em>exit_group()</em> system call to terminate all of the threads in a process (starting with <em>glibc</em> 2.3, <em>_exit()</em>&#8212;and thus also the <em>exit()</em> library function&#8212;is aliased as a wrapper that invokes <em>exit_group()</em>, while a call to <em>pthread_exit()</em> invokes the true <em>_exit()</em> system call in the kernel, which terminates just the calling thread);</p>
<p class="bull">&#8226; a rewrite of the kernel scheduler to allow efficient scheduling of very large numbers (i.e., thousands) of KSEs;</p>
<p class="bull"><span epub:type="pagebreak" id="page_693"/>&#8226; improved performance for the kernel&#8217;s process termination code; and</p>
<p class="bull">&#8226; extensions to the <em>clone()</em> system call (<a href="ch28.xhtml#ch28lev1sec02">Section 28.2</a>).</p>
<p class="noindenttb">The essentials of the NPTL implementation are as follows:</p>
<p class="bull">&#8226; Threads are created using a <em>clone()</em> call that specifies the following flags:</p>
<p class="programsbl">CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND |<br/>CLONE_THREAD | CLONE_SETTLS | CLONE_PARENT_SETTID |<br/>CLONE_CHILD_CLEARTID | CLONE_SYSVSEM</p>
<p class="bullp">NPTL threads share all of the information that LinuxThreads threads share, and more. The <span class="literal">CLONE_THREAD</span> flag means that a thread is placed in the same thread group as its creator and shares the same process ID and parent process ID. The <span class="literal">CLONE_SYSVSEM</span> flag means that a thread shares System V semaphore undo values with its creator.</p>
<div class="block1">
<p class="noindent">When we use <em>ps(1)</em> to list a multithreaded process running under NPTL, we see just a single line of output. To see information about the threads within a process, we can use the <em>ps &#8211;L</em> option.</p>
</div>
<p class="bull">&#8226; The implementation makes internal use of the first two realtime signals. Applications can&#8217;t use these signals.</p>
<div class="block1">
<p class="noindent">One of these signals is used to implement thread cancellation. The other signal is used as part of a technique that ensures that all of the threads in a process have the same user and group IDs. This technique is required because, at the kernel level, threads have distinct user and group credentials. Therefore, the NPTL implementation does some work in the wrapper function for each system call that changes user and group IDs (<em>setuid()</em>, <em>setresuid()</em>, and so on, and their group analogs) that causes the IDs to be changed in all of the threads of the process.</p>
</div>
<p class="bull">&#8226; Unlike LinuxThreads, NPTL doesn&#8217;t use manager threads.</p>
<h5 class="h5" id="ch33lev3sec09"><strong>NPTL standards conformance</strong></h5>
<p class="noindentab">These changes mean that NPTL achieves much closer SUSv3 conformance than LinuxThreads. At the time of writing, the following nonconformance remains:</p>
<p class="bull">&#8226; Threads don&#8217;t share a nice value.</p>
<p class="noindenttb">There are some additional NPTL nonconformances in earlier 2.6.<em>x</em> kernels:</p>
<p class="bull">&#8226; In kernels before 2.6.16, the alternate signal stack was per-thread, but a new thread wrongly inherited alternate signal stack settings (established by <em>sigaltstack()</em>) from the caller of <em>pthread_create()</em>, with the consequence that the two threads shared an alternate signal stack.</p>
<p class="bull">&#8226; In kernels before 2.6.16, only a thread group leader (i.e., the main thread) could start a new session by calling <em>setsid()</em>.</p>
<p class="bull">&#8226; In kernels before 2.6.16, only a thread group leader could use <em>setpgid()</em> to make the host process a process group leader.</p>
<p class="bull"><span epub:type="pagebreak" id="page_694"/>&#8226; In kernels prior to 2.6.12, interval timers created using <em>setitimer()</em> were not shared between the threads of a process.</p>
<p class="bull">&#8226; In kernels prior to 2.6.10, resource limit settings were not shared between the threads of a process.</p>
<p class="bull">&#8226; In kernels prior to 2.6.9, the CPU time returned by <em>times()</em> and the resource usage information returned by <em>getrusage()</em> were per-thread.</p>
<p class="noindentt">NPTL was designed to be ABI-compatible with LinuxThreads. This means that programs that were linked against a GNU C library providing LinuxThreads don&#8217;t need to be relinked in order to use NPTL. However, some behaviors may change when the program is run with NPTL, primarily because NPTL adheres more closely to the SUSv3 specification for Pthreads.</p>
<h4 class="h4" id="ch33lev2sec07"><strong>33.5.3 Which Threading Implementation?</strong></h4>
<p class="noindentab">Some Linux distributions ship with a GNU C library that provides both LinuxThreads and NPTL, with the default being determined by the dynamic linker according to the underlying kernel on which the system is running. (These distributions are by now historical because, since version 2.4, <em>glibc</em> no longer provides LinuxThreads.) Therefore, we may sometimes need to answer the following questions:</p>
<p class="bull">&#8226; Which threading implementation is available in a particular Linux distribution?</p>
<p class="bull">&#8226; On a Linux distribution that provides both LinuxThreads and NPTL, which implementation is used by default, and how can we explicitly select the implementation that is used by a program?</p>
<h5 class="h5" id="ch33lev3sec10"><strong>Discovering the threading implementation</strong></h5>
<p class="noindenta">We can use a few techniques to discover the threading implementation that is available on a particular system, or to discover the default implementation that will be employed when a program is run on a system that provides both threading implementations.</p>
<p class="indent">On a system providing <em>glibc</em> version 2.3.2 or later, we can use the following command to discover which threading implementation the system provides, or, if it provides both implementation, then which one is used by default:</p>
<p class="programs">$ <span class="codestrong">getconf GNU_LIBPTHREAD_VERSION</span></p>
<p class="noindent">On a system where NPTL is the only or the default implementation, this will display a string such as the following:</p>
<p class="programs">NPTL 2.3.4</p>
<div class="block">
<p class="noindent">Since <em>glibc</em> 2.3.2, a program can obtain similar information by using <em>confstr(3)</em> to retrieve the value of the <em>glibc</em>-specific <span class="literal">_CS_GNU_LIBPTHREAD_VERSION</span> configuration variable.</p>
</div>
<p class="noindent">On systems with older GNU C libraries, we must do a little more work. First, the following command can be used to show the pathname of the GNU C library that is <span epub:type="pagebreak" id="page_695"/>used when we run a program (here, we use the example of the standard <em>ls</em> program, which resides at <span class="literal">/bin/ls</span>):</p>
<p class="programs">$ <span class="codestrong">ldd /bin/ls | grep libc.so</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;libc.so.6 =&gt; /lib/tls/libc.so.6 (0x40050000)</p>
<div class="block">
<p class="noindent">We say a little more about the <em>ldd</em> (list dynamic dependencies) program in <a href="ch41.xhtml#ch41lev1sec05">Section 41.5</a>.</p>
</div>
<p class="noindent">The pathname of the GNU C library is shown after the <span class="literal">=&gt;</span>. If we execute this pathname as a command, then <em>glibc</em> displays a range of information about itself. We can <em>grep</em> through this information to select the line that displays the threading implementation:</p>
<p class="programs">$ <span class="codestrong">/lib/tls/libc.so.6 | egrep -i 'threads|nptl'</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Native POSIX Threads Library by Ulrich Drepper et al</p>
<p class="noindent">We include <em>nptl</em> in the <em>egrep</em> regular expression because some <em>glibc</em> releases containing NPTL instead display a string like this:</p>
<p class="programs1">NPTL 0.61 by Ulrich Drepper</p>
<p class="noindent">Since the <em>glibc</em> pathname may vary from one Linux distribution to another, we can employ shell command substitution to produce a command line that will display the threading implementation in use on any Linux system, as follows:</p>
<p class="programs">$ <span class="codestrong">$(ldd /bin/ls | grep libc.so | awk '{print $3}') | egrep -i 'threads|nptl'</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Native POSIX Threads Library by Ulrich Drepper et al</p>
<h5 class="h5" id="ch33lev3sec11"><strong>Selecting the threading implementation used by a program</strong></h5>
<p class="noindenta">On a Linux system that provides both NPTL and LinuxThreads, it is sometimes useful to be able to explicitly control which threading implementation is used. The most common example of this requirement is when we have an older program that depends on some (probably nonstandard) behavior of LinuxThreads, so that we want to force the program to run with that threading implementation, instead of the default NPTL.</p>
<p class="indent">For this purpose, we can employ a special environment variable understood by the dynamic linker: <span class="literal">LD_ASSUME_KERNEL</span>. As its name suggests, this environment variable tells the dynamic linker to operate as though it is running on top of a particular Linux kernel version. By specifying a kernel version that doesn&#8217;t provide support for NPTL (e.g., <span class="literal">2.2.5</span>), we can ensure that LinuxThreads is used. Thus, we could run a multithreaded program with LinuxThreads using the following command:</p>
<p class="programs">$ <span class="codestrong">LD_ASSUME_KERNEL=2.2.5 ./prog</span></p>
<p class="noindent">When we combine this environment variable setting with the command that we described earlier to show the threading implementation that is used, we see something like the following:</p>
<p class="programs">$ <span class="codestrong">export LD_ASSUME_KERNEL=2.2.5</span><br/>$ <span class="codestrong">$(ldd /bin/ls | grep libc.so | awk '{print $3}') | egrep -i 'threads|nptl'</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;linuxthreads-0.10 by Xavier Leroy</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_696"/>The range of kernel version numbers that can be specified in <span class="literal">LD_ASSUME_KERNEL</span> is subject to some limits. In several common distributions that supply both NPTL and LinuxThreads, specifying the version number as 2.2.5 is sufficient to ensure the use of LinuxThreads. For a fuller description of the use of this environment variable, see <em><a href="http://people.redhat.com/drepper/assumekernel.html">http://people.redhat.com/drepper/assumekernel.html</a></em>.</p>
</div>
<h3 class="h3" id="ch33lev1sec06"><strong>33.6 Advanced Features of the Pthreads API</strong></h3>
<p class="noindentab">Some advanced features of the Pthreads API include the following:</p>
<p class="bull">&#8226; <em>Realtime scheduling</em>: We can set realtime scheduling policies and priorities for threads. This is similar to the process realtime scheduling system calls described in <a href="ch35.xhtml#ch35lev1sec03">Section 35.3</a>.</p>
<p class="bull">&#8226; <em>Process shared mutexes and condition variables</em>: SUSv3 specifies an option to allow mutexes and condition variables to be shared between processes (rather than just among the threads of a single process). In this case, the condition variable or mutex must be located in a region of memory shared between the processes. NPTL supports this feature.</p>
<p class="bull">&#8226; <em>Advanced thread-synchronization primitives</em>: These facilities include barriers, read-write locks, and spin locks.</p>
<p class="noindentt">Further details on all of these features can be found in [<a href="bib.xhtml#bib10">Butenhof, 1996</a>].</p>
<h3 class="h3" id="ch33lev1sec07"><strong>33.7 Summary</strong></h3>
<p class="noindenta">Threads don&#8217;t mix well with signals; multithreaded application designs should avoid the use of signals whenever possible. If a multithreaded application must deal with asynchronous signals, usually the cleanest way to do so is to block signals in all threads, and have a single dedicated thread that accepts incoming signals using <em>sigwait()</em> (or similar). This thread can then safely perform tasks such as modifying shared variables (under mutex control) and calling non-async-signal-safe functions.</p>
<p class="indent">Two threading implementations are commonly available on Linux: LinuxThreads and NPTL. LinuxThreads has been available on Linux for many years, but there are a number of points where it doesn&#8217;t conform to the requirements of SUSv3 and it is now obsolete. The more recent NPTL implementation provides closer SUSv3 conformance and superior performance, and is the implementation provided in modern Linux distributions.</p>
<h5 class="h5" id="ch33lev3sec12"><strong>Further information</strong></h5>
<p class="noindenta">Refer to the sources of further information listed in <a href="ch29.xhtml#ch29lev1sec10">Section 29.10</a>.</p>
<p class="indent">The author of LinuxThreads documented the implementation in a web page that can be found at <em><a href="http://pauillac.inria.fr/~xleroy/linuxthreads/">http://pauillac.inria.fr/~xleroy/linuxthreads/</a></em>. The NPTL implementation is described by its implementers in a (now somewhat out-of-date) paper that is available online at <em><a href="http://people.redhat.com/drepper/nptl-design.pdf">http://people.redhat.com/drepper/nptl-design.pdf</a></em>.</p>
<h3 class="h3" id="ch33lev1sec08"><span epub:type="pagebreak" id="page_697"/><strong>33.8 Exercises</strong></h3>
<p class="exer"><a id="ch33exe1"/><strong>33-1.</strong>&#160;&#160;&#160;Write a program to demonstrate that different threads in the same process can have different sets of pending signals, as returned by <em>sigpending()</em>. You can do this by using <em>pthread_kill()</em> to send different signals to two different threads that have blocked these signals, and then have each of the threads call <em>sigpending()</em> and display information about pending signals. (You may find the functions in <a href="ch20.xhtml#ch20ex4">Listing 20-4</a> useful.)</p>
<p class="exer"><a id="ch33exe2"/><strong>33-2.</strong>&#160;&#160;&#160;Suppose that a thread creates a child using <em>fork()</em>. When the child terminates, is it guaranteed that the resulting <span class="literal">SIGCHLD</span> signal will be delivered to the thread that called <em>fork()</em> (as opposed to some other thread in the process)?<span epub:type="pagebreak" id="page_698"/></p>
</body>
</html>
