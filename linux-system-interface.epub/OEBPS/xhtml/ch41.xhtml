<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch41"><span epub:type="pagebreak" id="page_833"/><strong><span class="big">41</span></strong><br/><strong>FUNDAMENTALS OF SHARED LIBRARIES</strong></h2>
<p class="noindenta">Shared libraries are a technique for placing library functions into a single unit that can be shared by multiple processes at run time. This technique can save both disk space and RAM. This chapter covers the fundamentals of shared libraries. The next chapter covers a number of advanced features of shared libraries.</p>
<h3 class="h3" id="ch41lev1sec01"><strong>41.1 Object Libraries</strong></h3>
<p class="noindenta">One way of building a program is simply to compile each of its source files to produce corresponding object files, and then link all of these object files together to produce the executable program, like so:</p>
<p class="programs">$ <span class="codestrong">cc -g -c prog.c mod1.c mod2.c mod3.c</span><br/>$ <span class="codestrong">cc -g -o prog_nolib prog.o mod1.o mod2.o mod3.o</span></p>
<div class="block">
<p class="noindent">Linking is actually performed by the separate linker program, <em>ld</em>. When we link a program using the <em>cc</em> (or <em>gcc</em>) command, the compiler invokes <em>ld</em> behind the scenes. On Linux, the linker should always be invoked indirectly via <em>gcc</em>, since <em>gcc</em> ensures that <em>ld</em> is invoked with the correct options and links the program against the correct library files.</p>
</div>
<p class="noindent">In many cases, however, we may have source files that are used by several programs. As a first step toward saving ourselves some work, we could compile these source files <span epub:type="pagebreak" id="page_834"/>just once, and then link them into different executables as required. Although this technique saves us compilation time, it still suffers from the disadvantage that we must name all of the object files during the link phase. Furthermore, our directories may be inconveniently cluttered with a large number of object files.</p>
<p class="indent">To get around these problems, we can group a set of object files into a single unit, known as an <em>object library</em>. Object libraries are of two types: <em>static</em> and <em>shared</em>. Shared libraries are the more modern type of object library, and provide several advantages over static libraries, as we describe in <a href="ch41.xhtml#ch41lev1sec03">Section 41.3</a>.</p>
<h5 class="h5" id="ch41lev3sec01"><strong>An aside: including debugger information when compiling a program</strong></h5>
<p class="noindenta">In the <em>cc</em> command shown above, we used the <em>&#8211;g</em> option to include debugging information in the compiled program. In general, it is a good idea to always create programs and libraries that allow debugging. (In earlier times, debugging information was sometimes omitted so that the resulting executable used less disk and RAM, but nowadays disk and RAM are cheap.)</p>
<p class="indent">In addition, on some architectures, such as x86-32, the <em>&#8211;fomit&#8211;frame&#8211;pointer</em> option should not be specified because this makes debugging impossible. (On some architectures, such as x86-64, this option is enabled by default since it doesn&#8217;t prevent debugging.) For the same reason, executables and libraries should not be stripped of debugging information using <em>strip(1)</em>.</p>
<h3 class="h3" id="ch41lev1sec02"><strong>41.2 Static Libraries</strong></h3>
<p class="noindenta">Before starting our discussion of shared libraries, we begin with a brief description of static libraries in order to make clear the differences and advantages of shared libraries.</p>
<p class="indentb">Static libraries, also known as <em>archives</em>, were the first type of library to be provided on UNIX systems. They provide the following benefits:</p>
<p class="bull">&#8226; We can place a set of commonly used object files into a single library file that can then be used to build multiple executables, without needing to recompile the original source files when building each application.</p>
<p class="bull">&#8226; Link commands become simpler. Instead of listing a long series of object files on the link command line, we specify just the name of the static library. The linker knows how to search the static library and extract the objects required by the executable.</p>
<h5 class="h5" id="ch41lev3sec02"><strong>Creating and maintaining a static library</strong></h5>
<p class="noindenta">In effect, a static library is simply a file holding copies of all of the object files added to it. The archive also records various attributes of each of the component object files, including file permissions, numeric user and group IDs, and last modification time. By convention, static libraries have names of the form <span class="literal">lib</span><em>name</em><span class="literal">.a</span>.</p>
<p class="indent">A static library is created and maintained using the <em>ar(1)</em> command, which has the following general form:</p>
<p class="programs">$ <span class="codestrong">ar <span class="codeitalic">options archive object-file</span></span>...</p>
<p class="noindentb"><span epub:type="pagebreak" id="page_835"/>The <em>options</em> argument consists of a series of letters, one of which is the <em>operation code</em>, while the others are <em>modifiers</em> that influence the way the operation is carried out. Some commonly used operation codes are the following:</p>
<p class="bull">&#8226; <em>r</em> (replace): Insert an object file into the archive, replacing any previous object file of the same name. This is the standard method for creating and updating an archive. Thus, we might build an archive with the following commands:</p>
<p class="programsbl">$ <span class="codestrong">cc -g -c mod1.c mod2.c mod3.c</span><br/>$ <span class="codestrong">ar r libdemo.a mod1.o mod2.o mod3.o</span><br/>$ <span class="codestrong">rm mod1.o mod2.o mod3.o</span></p>
<p class="bullp">As shown above, after building the library, we can delete the original object files if desired, since they are no longer required.</p>
<p class="bull">&#8226; <em>t</em> (table of contents): Display a table of contents of the archive. By default, this lists just the names of the object files in the archive. By adding the <em>v</em> (verbose) modifier, we additionally see all of the other attributes recorded in the archive for each object file, as in the following example:</p>
<p class="programsbl">$ <span class="codestrong">ar tv libdemo.a</span><br/>rw-r--r-- 1000/100 1001016 Nov 15 12:26 2009 mod1.o<br/>rw-r--r-- 1000/100 406668 Nov 15 12:21 2009 mod2.o<br/>rw-r--r-- 1000/100&#160;&#160;46672 Nov 15 12:21 2009 mod3.o</p>
<p class="bullp">The additional attributes that we see for each object are, from left to right, its permissions when it was added to the archive, its user ID and group ID, its size, and the date and time when it was last modified.</p>
<p class="bull">&#8226; <em>d</em> (delete): Delete a named module from the archive, as in this example:</p>
<p class="programsbl">$ <span class="codestrong">ar d libdemo.a mod3.o</span></p>
<h5 class="h5" id="ch41lev3sec03"><strong>Using a static library</strong></h5>
<p class="noindenta">We can link a program against a static library in two ways. The first is to name the static library as part of the link command, as in the following:</p>
<p class="programs">$ <span class="codestrong">cc -g -c prog.c</span><br/>$ <span class="codestrong">cc -g -o prog prog.o libdemo.a</span></p>
<p class="noindent">Alternatively, we can place the library in one of the standard directories searched by the linker (e.g., <span class="literal">/usr/lib</span>), and then specify the library name (i.e., the filename of the library without the <span class="literal">lib</span> prefix and <span class="literal">.a</span> suffix) using the <em>&#8211;l</em> option:</p>
<p class="programs">$ <span class="codestrong">cc -g -o prog prog.o -ldemo</span></p>
<p class="noindent">If the library resides in a directory not normally searched by the linker, we can specify that the linker should search this additional directory using the <em>&#8211;L</em> option:</p>
<p class="programs">$ <span class="codestrong">cc -g -o prog prog.o -L<span class="codeitalic">mylibdir</span> -ldemo</span></p>
<p class="noindent">Although a static library may contain many object modules, the linker includes only those modules that the program requires.</p>
<p class="noindent"><span epub:type="pagebreak" id="page_836"/>Having linked the program, we can run it in the usual way:</p>
<p class="programs">$ <span class="codestrong">./prog</span><br/>Called mod1-x1<br/>Called mod2-x2</p>
<h3 class="h3" id="ch41lev1sec03"><strong>41.3 Overview of Shared Libraries</strong></h3>
<p class="noindentab">When a program is built by linking against a static library (or, for that matter, without using a library at all), the resulting executable file includes copies of all of the object files that were linked into the program. Thus, when several different executables use the same object modules, each executable has its own copy of the object modules. This redundancy of code has several disadvantages:</p>
<p class="bull">&#8226; Disk space is wasted storing multiple copies of the same object modules. Such wastage can be considerable.</p>
<p class="bull">&#8226; If several different programs using the same modules are running at the same time, then each holds separate copies of the object modules in virtual memory, thus increasing the overall virtual memory demands on the system.</p>
<p class="bull">&#8226; If a change is required (perhaps a security or bug fix) to an object module in a static library, then all executables using that module must be relinked in order to incorporate the change. This disadvantage is further compounded by the fact that the system administrator needs to be aware of which applications were linked against the library.</p>
<p class="noindentt">Shared libraries were designed to address these shortcomings. The key idea of a shared library is that a single copy of the object modules is shared by all programs requiring the modules. The object modules are not copied into the linked executable; instead, a single copy of the library is loaded into memory at run time, when the first program requiring modules from the shared library is started. When other programs using the same shared library are later executed, they use the copy of the library that is already loaded into memory. The use of shared libraries means that executable programs require less space on disk and (when running) in virtual memory.</p>
<div class="block">
<p class="noindent">Although the code of a shared library is shared among multiple processes, its variables are not. Each process that uses the library has its own copies of the global and static variables that are defined within the library.</p>
</div>
<p class="noindentb">Shared libraries provide the following further advantages:</p>
<p class="bull">&#8226; Because overall program size is smaller, in some cases, programs can be loaded into memory and started more quickly. This point holds true only for large shared libraries that are already in use by another program. The first program to load a shared library will actually take longer to start, since the shared library must be found and loaded into memory.</p>
<p class="bull">&#8226; Since object modules are not copied into the executable files, but instead maintained centrally in the shared library, it is possible (subject to limitations described in <a href="ch41.xhtml#ch41lev1sec08">Section 41.8</a>) to make changes to the object modules without requiring programs to be relinked in order to see the changes. Such changes can be carried out even while running programs are using an existing version of the shared library.</p>
<p class="noindenttb"><span epub:type="pagebreak" id="page_837"/>The principal costs of this added functionality are the following:</p>
<p class="bull">&#8226; Shared libraries are more complex than static libraries, both at the conceptual level, and at the practical level of creating shared libraries and building the programs that use them.</p>
<p class="bull">&#8226; Shared libraries must be compiled to use position-independent code (described in <a href="ch41.xhtml#ch41lev2sec02">Section 41.4.2</a>), which has a performance overhead on most architectures because it requires the use of an extra register ([<a href="bib.xhtml#bib43">Hubicka, 2003</a>]).</p>
<p class="bull">&#8226; <em>Symbol relocation</em> must be performed at run time. During symbol relocation, references to each symbol (a variable or function) in a shared library need to be modified to correspond to the actual run-time location at which the symbol is placed in virtual memory. Because of this relocation process, a program using a shared library may take a little more time to execute than its statically linked equivalent.</p>
<div class="block">
<p class="noindent">One further use of shared libraries is as a building block in the <em>Java Native Interface</em> (JNI), which allows Java code to directly access features of the underlying operating system by calling C functions within a shared library. For further information, see [<a href="bib.xhtml#bib56">Liang, 1999</a>] and [<a href="bib.xhtml#bib80">Rochkind, 2004</a>].</p>
</div>
<h3 class="h3" id="ch41lev1sec04"><strong>41.4 Creating and Using Shared Libraries&#8212;A First Pass</strong></h3>
<p class="noindenta">To begin understanding how shared libraries operate, we look at the minimum sequence of steps required to build and use a shared library. For the moment, we&#8217;ll ignore the convention that is normally used to name shared library files. This convention, described in <a href="ch41.xhtml#ch41lev1sec06">Section 41.6</a>, allows programs to automatically load the most up-to-date version of the libraries they require, and also allows multiple incompatible versions (so-called <em>major versions</em>) of a library to coexist peacefully.</p>
<p class="indent">In this chapter, we concern ourselves only with Executable and Linking Format (ELF) shared libraries, since ELF is the format employed for executables and shared libraries in modern versions of Linux, as well as in many other UNIX implementations.</p>
<div class="block">
<p class="noindent">ELF supersedes the older <em>a.out</em> and <em>COFF</em> formats.</p>
</div>
<h4 class="h4" id="ch41lev2sec01"><strong>41.4.1 Creating a Shared Library</strong></h4>
<p class="noindenta">In order to build a shared version of the static library we created earlier, we perform the following steps:</p>
<p class="programs">$ <span class="codestrong">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c</span><br/>$ <span class="codestrong">gcc -g -shared -o libfoo.so mod1.o mod2.o mod3.o</span></p>
<p class="noindent">The first of these commands creates the three object modules that are to be put into the library. (We explain the <em>cc &#8211;fPIC</em> option in the next section.) The <em>cc &#8211;shared</em> command creates a shared library containing the three object modules.</p>
<p class="indent">By convention, shared libraries have the prefix <span class="literal">lib</span> and the suffix <span class="literal">.so</span> (for <em>shared object</em>).</p>
<p class="indent">In our examples, we use the <em>gcc</em> command, rather than the equivalent <em>cc</em> command, to emphasize that the command-line options we are using to create shared libraries <span epub:type="pagebreak" id="page_838"/>are compiler-dependent. Using a different C compiler on another UNIX implementation will probably require different options.</p>
<p class="indent">Note that it is possible to compile the source files and create the shared library in a single command:</p>
<p class="programs">$ <span class="codestrong">gcc -g -fPIC -Wall mod1.c mod2.c mod3.c -shared -o libfoo.so</span></p>
<p class="noindent">However, to clearly distinguish the compilation and library building steps, we&#8217;ll write the two as separate commands in the examples shown in this chapter.</p>
<p class="indent">Unlike static libraries, it is not possible to add or remove individual object modules from a previously built shared library. As with normal executables, the object files within a shared library no longer maintain distinct identities.</p>
<h4 class="h4" id="ch41lev2sec02"><strong>41.4.2 Position-Independent Code</strong></h4>
<p class="noindenta">The <em>cc &#8211;fPIC</em> option specifies that the compiler should generate <em>position-independent code</em>. This changes the way that the compiler generates code for operations such as accessing global, static, and external variables; accessing string constants; and taking the addresses of functions. These changes allow the code to be located at any virtual address at run time. This is necessary for shared libraries, since there is no way of knowing at link time where the shared library code will be located in memory. (The run-time memory location of a shared library depends on various factors, such as the amount of memory already taken up by the program that is loading the library and which other shared libraries the program has already loaded.)</p>
<p class="indent">On Linux/x86-32, it is possible to create a shared library using modules compiled without the <em>&#8211;fPIC</em> option. However, doing so loses some of the benefits of shared libraries, since pages of program text containing position-dependent memory references are not shared across processes. On some architectures, it is impossible to build shared libraries without the <em>&#8211;fPIC</em> option.</p>
<p class="indent">In order to determine whether an existing object file has been compiled with the <em>&#8211;fPIC</em> option, we can check for the presence of the name <span class="literal">_GLOBAL_OFFSET_TABLE_</span> in the object file&#8217;s symbol table, using either of the following commands:</p>
<p class="programs">$ <span class="codestrong">nm mod1.o | grep _GLOBAL_OFFSET_TABLE_</span><br/>$ <span class="codestrong">readelf -s mod1.o | grep _GLOBAL_OFFSET_TABLE_</span></p>
<p class="noindent">Conversely, if either of the following equivalent commands yields any output, then the specified shared library includes at least one object module that was not compiled with <em>&#8211;fPIC</em>:</p>
<p class="programs">$ <span class="codestrong">objdump --all-headers libfoo.so | grep TEXTREL</span><br/>$ <span class="codestrong">readelf -d libfoo.so | grep TEXTREL</span></p>
<p class="noindent">The string <span class="literal">TEXTREL</span> indicates the presence of an object module whose text segment contains a reference that requires run-time relocation.</p>
<p class="indent">We say more about the <em>nm</em>, <em>readelf</em>, and <em>objdump</em> commands in <a href="ch41.xhtml#ch41lev1sec05">Section 41.5</a>.</p>
<h4 class="h4" id="ch41lev2sec03"><span epub:type="pagebreak" id="page_839"/><strong>41.4.3 Using a Shared Library</strong></h4>
<p class="noindentab">In order to use a shared library, two steps must occur that are not required for programs that use static libraries:</p>
<p class="bull">&#8226; Since the executable file no longer contains copies of the object files that it requires, it must have some mechanism for identifying the shared library that it needs at run time. This is done by embedding the name of the shared library inside the executable during the link phase. (In ELF parlance, the library dependency is recorded in a <span class="literal">DT_NEEDED</span> tag in the executable.) The list of all of a program&#8217;s shared library dependencies is referred to as its <em>dynamic dependency list</em>.</p>
<p class="bull">&#8226; At run time, there must be some mechanism for resolving the embedded library name&#8212;that is, for finding the shared library file corresponding to the name specified in the executable file&#8212;and then loading the library into memory, if it is not already present.</p>
<p class="noindentt">Embedding the name of the library inside the executable happens automatically when we link our program with a shared library:</p>
<p class="programs">$ <span class="codestrong">gcc -g -Wall -o prog prog.c libfoo.so</span></p>
<p class="noindent">If we now attempt to run our program, we receive the following error message:</p>
<p class="programs">$ <span class="codestrong">./prog</span><br/>./prog: error in loading shared libraries: libfoo.so: cannot<br/>open shared object file: No such file or directory</p>
<p class="noindent">This brings us to the second required step: <em>dynamic linking</em>, which is the task of resolving the embedded library name at run time. This task is performed by the <em>dynamic linker</em> (also called the <em>dynamic linking loader</em> or the <em>run-time linker</em>). The dynamic linker is itself a shared library, named <span class="literal">/lib/ld-linux.so.2</span>, which is employed by every ELF executable that uses shared libraries.</p>
<div class="block">
<p class="noindent">The pathname <span class="literal">/lib/ld-linux.so.2</span> is normally a symbolic link pointing to the dynamic linker executable file. This file has the name <span class="literal">ld-</span><em>version</em><span class="literal">.so</span>, where <em>version</em> is the <em>glibc</em> version installed on the system&#8212;for example, <span class="literal">ld-2.11.so</span>. The pathname of the dynamic linker differs on some architectures. For example, on IA-64, the dynamic linker symbolic link is named <span class="literal">/lib/ld-linux-ia64.so.2</span>.</p>
</div>
<p class="noindent">The dynamic linker examines the list of shared libraries required by a program and uses a set of predefined rules in order to find the library files in the file system. Some of these rules specify a set of standard directories in which shared libraries normally reside. For example, many shared libraries reside in <span class="literal">/lib</span> and <span class="literal">/usr/lib</span>. The error message above occurs because our library resides in the current working directory, which is not part of the standard list searched by the dynamic linker.</p>
<div class="block">
<p class="noindent">Some architectures (e.g., zSeries, PowerPC64, and x86-64) support execution of both 32-bit and 64-bit programs. On such systems, the 32-bit libraries reside in <span class="literal">*/lib</span> subdirectories, and the 64-bit libraries reside in <span class="literal">*/lib64</span> subdirectories.</p>
</div>
<h5 class="h5" id="ch41lev3sec04"><span epub:type="pagebreak" id="page_840"/><strong>The</strong> <span class="literal"><span class="codestrong">LD_LIBRARY_PATH</span></span> <strong>environment variable</strong></h5>
<p class="noindenta">One way of informing the dynamic linker that a shared library resides in a nonstandard directory is to specify that directory as part of a colon-separated list of directories in the <span class="literal">LD_LIBRARY_PATH</span> environment variable. (Semicolons can also be used to separate the directories, in which case the list must be quoted to prevent the shell from interpreting the semicolons.) If <span class="literal">LD_LIBRARY_PATH</span> is defined, then the dynamic linker searches for the shared library in the directories it lists before looking in the standard library directories. (Later, we&#8217;ll see that a production application should never rely on <span class="literal">LD_LIBRARY_PATH</span>, but for now, this variable provides us with a simple way of getting started with shared libraries.) Thus, we can run our program with the following command:</p>
<p class="programs">$ <span class="codestrong">LD_LIBRARY_PATH=. ./prog</span><br/>Called mod1-x1<br/>Called mod2-x2</p>
<p class="noindent">The (<em>bash</em>, Korn, and Bourne) shell syntax used in the above command creates an environment variable definition within the process executing <em>prog</em>. This definition tells the dynamic linker to search for shared libraries in <span class="literal">.</span>, the current working directory.</p>
<div class="block">
<p class="noindent">An empty directory specification in the <span class="literal">LD_LIBRARY_PATH</span> list (e.g., the middle specification in <em>dirx::diry</em>) is equivalent to <span class="literal">.</span>, the current working directory (but note that setting <span class="literal">LD_LIBRARY_PATH</span> to an empty string does not achieve the same result). We avoid this usage (SUSv3 discourages the corresponding usage in the <span class="literal">PATH</span> environment variable).</p>
</div>
<h5 class="h5" id="ch41lev3sec05"><strong>Static linking and dynamic linking contrasted</strong></h5>
<p class="noindenta">Commonly, the term <em>linking</em> is used to describe the use of the linker, <em>ld</em>, to combine one or more compiled object files into a single executable file. Sometimes, the term <em>static</em> linking is used to distinguish this step from <em>dynamic</em> linking, the run-time loading of the shared libraries used by an executable. (Static linking is sometimes also referred to as <em>link editing</em>, and a static linker such as <em>ld</em> is sometimes referred to as a link editor.) Every program&#8212;including those that use shared libraries&#8212;goes through a static-linking phase. At run time, a program that employs shared libraries additionally undergoes dynamic linking.</p>
<h4 class="h4" id="ch41lev2sec04"><strong>41.4.4 The Shared Library Soname</strong></h4>
<p class="noindenta">In the example presented so far, the name that was embedded in the executable and sought by the dynamic linker at run time was the actual name of the shared library file. This is referred to as the library&#8217;s <em>real name</em>. However, it is possible&#8212;in fact, usual&#8212;to create a shared library with a kind of alias, called a <em>soname</em> (the <span class="literal">DT_SONAME</span> tag in ELF parlance).</p>
<p class="indent"><span epub:type="pagebreak" id="page_841"/>If a shared library has a soname, then, during static linking, the soname is embedded in the executable file instead of the real name, and subsequently used by the dynamic linker when searching for the library at run time. The purpose of the soname is to provide a level of indirection that permits an executable to use, at run time, a version of the shared library that is different from (but compatible with) the library against which it was linked.</p>
<p class="indent">In <a href="ch41.xhtml#ch41lev1sec06">Section 41.6</a>, we&#8217;ll look at the conventions used for the shared library real name and soname. For now, we show a simplified example to demonstrate the principles.</p>
<p class="indent">The first step in using a soname is to specify it when the shared library is created:</p>
<p class="programs">$ <span class="codestrong">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c</span><br/>$ <span class="codestrong">gcc -g -shared -Wl,-soname,libbar.so -o libfoo.so mod1.o mod2.o mod3.o</span></p>
<p class="noindent">The <em>&#8211;Wl,&#8211;soname,libbar.so</em> option is an instruction to the linker to mark the shared library <span class="literal">libfoo.so</span> with the soname <span class="literal">libbar.so</span>.</p>
<p class="indent">If we want to determine the soname of an existing shared library, we can use either of the following commands:</p>
<p class="programs">$ <span class="codestrong">objdump -p libfoo.so | grep SONAME</span><br/>&#160;SONAME&#160;&#160;&#160;&#160;&#160;&#160;&#160;libbar.so<br/>$ <span class="codestrong">readelf -d libfoo.so | grep SONAME</span><br/>&#160;0x0000000e (SONAME)&#160;&#160;&#160;&#160;&#160;&#160;Library soname: [libbar.so]</p>
<p class="noindent">Having created a shared library with a soname, we then create the executable as usual:</p>
<p class="programs">$ <span class="codestrong">gcc -g -Wall -o prog prog.c libfoo.so</span></p>
<p class="noindent">However, this time, the linker detects that the library <span class="literal">libfoo.so</span> contains the soname <span class="literal">libbar.so</span> and embeds the latter name inside the executable.</p>
<p class="indent">Now when we attempt to run the program, this is what we see:</p>
<p class="programs">$ <span class="codestrong">LD_LIBRARY_PATH=. ./prog</span><br/>prog: error in loading shared libraries: libbar.so: cannot open<br/>shared object file: No such file or directory</p>
<p class="noindent">The problem here is that the dynamic linker can&#8217;t find anything named <span class="literal">libbar.so</span>. When using a soname, one further step is required: we must create a symbolic link from the soname to the real name of the library. This symbolic link must be created in one of the directories searched by the dynamic linker. Thus, we could run our program as follows:</p>
<p class="programs">$ <span class="codestrong">ln -s libfoo.so libbar.so</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create soname symbolic link in current directory</span><br/>$ <span class="codestrong">LD_LIBRARY_PATH=. ./prog</span><br/>Called mod1-x1<br/>Called mod2-x2</p>
<p class="noindent"><span epub:type="pagebreak" id="page_842"/><a href="ch41.xhtml#ch41fig1">Figure 41-1</a> shows the compilation and linking steps involved in producing a shared library with an embedded soname, linking a program against that shared library, and creating the soname symbolic link needed to run the program.</p>
<div class="image"><img src="../images/f41-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch41fig1"/><strong>Figure 41-1:</strong> Creating a shared library and linking a program against it</p>
<p class="noindent"><a href="ch41.xhtml#ch41fig2">Figure 41-2</a> shows the steps that occur when the program created in <a href="ch41.xhtml#ch41fig1">Figure 41-1</a> is loaded into memory in preparation for execution.</p>
<div class="block">
<p class="noindent">To find out which shared libraries a process is currently using, we can list the contents of the corresponding Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/maps</span> file (<a href="ch48.xhtml#ch48lev1sec05">Section 48.5</a>).</p>
</div>
<div class="image"><span epub:type="pagebreak" id="page_843"/><img src="../images/f41-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch41fig2"/><strong>Figure 41-2:</strong> Execution of a program that loads a shared library</p>
<h3 class="h3" id="ch41lev1sec05"><strong>41.5 Useful Tools for Working with Shared Libraries</strong></h3>
<p class="noindenta">In this section, we briefly describe a few tools that are useful for analyzing shared libraries, executable files, and compiled object (<span class="literal">.o</span>) files.</p>
<h5 class="h5" id="ch41lev3sec06"><strong>The <em>ldd</em> command</strong></h5>
<p class="noindenta">The <em>ldd(1)</em> (list dynamic dependencies) command displays the shared libraries that a program (or a shared library) requires to run. Here&#8217;s an example:</p>
<p class="programs">$ <span class="codestrong">ldd prog</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;libdemo.so.1 =&gt; /usr/lib/libdemo.so.1 (0x40019000)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;libc.so.6 =&gt; /lib/tls/libc.so.6 (0x4017b000)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)</p>
<p class="noindent"><span epub:type="pagebreak" id="page_844"/>The <em>ldd</em> command resolves each library reference (employing the same search conventions as the dynamic linker) and displays the results in the following form:</p>
<div class="box2">
<p class="noindenta"><em>library-name</em> <span class="literal">=&gt;</span> <em>resolves-to-path</em></p>
</div>
<p class="noindent">For most ELF executables, <em>ldd</em> will list entries for at least <span class="literal">ld-linux.so.2</span>, the dynamic linker, and <span class="literal">libc.so.6</span>, the standard C library.</p>
<div class="block">
<p class="noindent">The name of the C library is different on some architectures. For example, this library is named <span class="literal">libc.so.6.1</span> on IA-64 and Alpha.</p>
</div>
<h5 class="h5" id="ch41lev3sec07"><strong>The <em>objdump</em> and <em>readelf</em> commands</strong></h5>
<p class="noindenta">The <em>objdump</em> command can be used to obtain various information&#8212;including disassembled binary machine code&#8212;from an executable file, compiled object, or shared library. It can also be used to display information from the headers of the various ELF sections of these files; in this usage, it resembles <em>readelf</em>, which displays similar information, but in a different format. Sources of further information about <em>objdump</em> and <em>readelf</em> are listed at the end of this chapter.</p>
<h5 class="h5" id="ch41lev3sec08"><strong>The <em>nm</em> command</strong></h5>
<p class="noindenta">The <em>nm</em> command lists the set of symbols defined within an object library or executable program. One use of this command is to find out which of several libraries defines a symbol. For example, to find out which library defines the <em>crypt()</em> function, we could do the following:</p>
<p class="programs">$ <span class="codestrong">nm -A /usr/lib/lib*.so 2&gt; /dev/null | grep ' crypt$'</span><br/>/usr/lib/libcrypt.so:00007080 W crypt</p>
<p class="noindent">The <em>&#8211;A</em> option to <em>nm</em> specifies that the library name should be listed at the start of each line displaying a symbol. This is necessary because, by default, <em>nm</em> lists the library name once, and then, on subsequent lines, all of the symbols it contains, which isn&#8217;t useful for the kind of filtering shown in the above example. In addition, we discard standard error output in order to hide error messages about files in formats unrecognized by <em>nm</em>. From the above output, we can see that <em>crypt()</em> is defined in the <em>libcrypt</em> library.</p>
<h3 class="h3" id="ch41lev1sec06"><strong>41.6 Shared Library Versions and Naming Conventions</strong></h3>
<p class="noindenta">Let&#8217;s consider what is entailed by shared library versioning. Typically, successive versions of a shared library are compatible with one another, meaning that the functions in each module present the same calling interface and are semantically equivalent (i.e., they achieve identical results). Such differing but compatible versions are referred to as <em>minor versions</em> of a shared library. Occasionally, however, it is necessary to create a new <em>major version</em> of a library&#8212;one that is incompatible with a previous version. (In <a href="ch41.xhtml#ch41lev1sec08">Section 41.8</a>, we&#8217;ll see more precisely what may cause such incompatibilities.) At the same time, it must still be possible to continue running programs that require the older version of the library.</p>
<p class="indent">To deal with these versioning requirements, a standard naming convention is employed for shared library real names and sonames.</p>
<h5 class="h5" id="ch41lev3sec09"><span epub:type="pagebreak" id="page_845"/><strong>Real names, sonames, and linker names</strong></h5>
<p class="noindenta">Each incompatible version of a shared library is distinguished by a unique <em>major version identifier</em>, which forms part of its real name. By convention, the major version identifier takes the form of a number that is sequentially incremented with each incompatible release of the library. In addition to the major version identifier, the real name also includes a <em>minor version identifier</em>, which distinguishes compatible minor versions within the library major version. The real name employs the format convention <span class="literal">lib</span><em>name</em><span class="literal">.so.</span><em>major-id</em><span class="literal">.</span><em>minor-id</em>.</p>
<p class="indent">Like the major version identifier, the minor version identifier can be any string, but, by convention, it is either a number, or two numbers separated by a dot, with the first number identifying the minor version, and the second number indicating a patch level or revision number within the minor version. Some examples of real names of shared libraries are the following:</p>
<p class="programs">libdemo.so.1.0.1<br/>libdemo.so.1.0.2&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Minor version, compatible with version 1.0.1</span><br/>libdemo.so.2.0.0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">New major version, incompatible with version 1.*</span><br/>libreadline.so.5.0</p>
<p class="noindent">The soname of the shared library includes the same major version identifier as its corresponding real library name, but excludes the minor version identifier. Thus, the soname has the form <span class="literal">lib</span><em>name</em><span class="literal">.so.</span><em>major-id</em>.</p>
<p class="indent">Usually, the soname is created as a relative symbolic link in the directory that contains the real name. The following are some examples of sonames, along with the real names to which they might be symbolically linked:</p>
<p class="programs">libdemo.so.1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-&gt; libdemo.so.1.0.2<br/>libdemo.so.2&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-&gt; libdemo.so.2.0.0<br/>libreadline.so.5&#160;&#160;&#160;&#160;-&gt; libreadline.so.5.0</p>
<p class="noindent">For a particular major version of a shared library, there may be several library files distinguished by different minor version identifiers. Normally, the soname corresponding to each major library version points to the most recent minor version within the major version (as shown in the above examples for <span class="literal">libdemo.so</span>). This setup allows for the correct versioning semantics during the run-time operation of shared libraries. Because the static-linking phase embeds a copy of the (minor version&#8211;independent) soname in the executable, and the soname symbolic link may subsequently be modified to point to a newer (minor) version of the shared library, it is possible to ensure that an executable loads the most up-to-date minor version of the library at run time. Furthermore, since different major versions of a library have different sonames, they can happily coexist and be accessed by the programs that require them.</p>
<p class="indent">In addition to the real name and soname, a third name is usually defined for each shared library: the <em>linker name</em>, which is used when linking an executable against the shared library. The linker name is a symbolic link containing just the library name without the major or minor version identifiers, and thus has the form <span class="literal">lib</span><em>name</em><span class="literal">.so</span>. The linker name allows us to construct version-independent link commands that automatically operate with the correct (i.e., most up-to-date) version of the shared library.</p>
<p class="indent"><span epub:type="pagebreak" id="page_846"/>Typically, the linker name is created in the same directory as the file to which it refers. It can be linked either to the real name or to the soname of the most recent major version of the library. Usually, a link to the soname is preferable, so that changes to the soname are automatically reflected in the linker name. (In <a href="ch41.xhtml#ch41lev1sec07">Section 41.7</a>, we&#8217;ll see that the <em>ldconfig</em> program automates the task of keeping sonames up to date, and thus implicitly maintains linker names if we use the convention just described.)</p>
<div class="block">
<p class="noindent">If we want to link a program against an older major version of a shared library, we can&#8217;t use the linker name. Instead, as part of the link command, we would need to indicate the required (major) version by specifying a particular real name or soname.</p>
</div>
<p class="noindent">The following are some examples of linker names:</p>
<p class="programs">libdemo.so&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-&gt; libdemo.so.2<br/>libreadline.so&#160;&#160;&#160;&#160;&#160;&#160;&#160;-&gt; libreadline.so.5</p>
<p class="noindent"><a href="ch41.xhtml#ch41table1">Table 41-1</a> summarizes information about the shared library real name, soname, and linker name, and <a href="ch41.xhtml#ch41fig3">Figure 41-3</a> portrays the relationship between these names.</p>
<p class="tablecap"><a id="ch41table1"/><strong>Table 41-1:</strong> Summary of shared library names</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Name</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Format</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">real name</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">lib</span><em>name</em><span class="literal">.so.</span><em>maj</em><span class="literal">.</span><em>min</em></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">File holding library code; one instance per major-plus-minor version of the library.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">soname</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">lib</span><em>name</em><span class="literal">.so.</span><em>maj</em></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">One instance per major version of library; embedded in executable at link time; used at run time to find library via a symbolic link with same name that points to corresponding (most up-to-date) real name.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table">linker name</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">lib</span><em>name</em><span class="literal">.so</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Symbolic link to latest real name or (more usually) latest soname; single instance; allows construction of version-independent link commands.</p></td>
</tr>
</tbody>
</table>
<div class="image"><img src="../images/f41-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch41fig3"/><strong>Figure 41-3:</strong> Conventional arrangement of shared library names</p>
<h5 class="h5" id="ch41lev3sec10"><strong>Creating a shared library using standard conventions</strong></h5>
<p class="noindenta">Putting all of the above information together, we now show how to build our demonstration library following the standard conventions. First, we create the object files:</p>
<p class="programs">$ <span class="codestrong">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c</span></p>
<p class="noindent">Then we create the shared library with the real name <span class="literal">libdemo.so.1.0.1</span> and the soname <span class="literal">libdemo.so.1</span>.</p>
<p class="programs"><span epub:type="pagebreak" id="page_847"/>$ <span class="codestrong">gcc -g -shared -Wl,-soname,libdemo.so.1 -o libdemo.so.1.0.1 \</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codestrong">mod1.o mod2.o mod3.o</span></p>
<p class="noindent">Next, we create appropriate symbolic links for the soname and linker name:</p>
<p class="programs">$ <span class="codestrong">ln -s libdemo.so.1.0.1 libdemo.so.1</span><br/>$ <span class="codestrong">ln -s libdemo.so.1 libdemo.so</span></p>
<p class="noindent">We can employ <em>ls</em> to verify the setup (with <em>awk</em> used to select the fields of interest):</p>
<p class="programs">$ <span class="codestrong">ls -l libdemo.so* | awk '{print $1, $9, $10, $11}'</span><br/>lrwxrwxrwx libdemo.so -&gt; libdemo.so.1<br/>lrwxrwxrwx libdemo.so.1 -&gt; libdemo.so.1.0.1<br/>-rwxr-xr-x libdemo.so.1.0.1</p>
<p class="noindent">Then we can build our executable using the linker name (note that the link command makes no mention of version numbers), and run the program as usual:</p>
<p class="programs">$ <span class="codestrong">gcc -g -Wall -o prog prog.c -L. -ldemo</span><br/>$ <span class="codestrong">LD_LIBRARY_PATH=. ./prog</span><br/>Called mod1-x1<br/>Called mod2-x2</p>
<h3 class="h3" id="ch41lev1sec07"><strong>41.7 Installing Shared Libraries</strong></h3>
<p class="noindentab">In the examples up to now, we created a shared library in a user-private directory, and then used the <span class="literal">LD_LIBRARY_PATH</span> environment variable to ensure that the dynamic linker searched that directory. Both privileged and unprivileged users may use this technique. However, this technique should not be employed in production applications. More usually, a shared library and its associated symbolic links are installed in one of a number of standard library directories, in particular, one of the following:</p>
<p class="bull">&#8226; <span class="literal">/usr/lib</span>, the directory in which most standard libraries are installed;</p>
<p class="bull">&#8226; <span class="literal">/lib</span>, the directory into which libraries required during system startup should be installed (since, during system startup, <span class="literal">/usr/lib</span> may not be mounted yet);</p>
<p class="bull">&#8226; <span class="literal">/usr/local/lib</span>, the directory into which nonstandard or experimental libraries should be installed (placing libraries in this directory is also useful if <span class="literal">/usr/lib</span> is a network mount shared among multiple systems and we want to install a library just for use on this system); or</p>
<p class="bull">&#8226; one of the directories listed in <span class="literal">/etc/ld.so.conf</span> (described shortly).</p>
<p class="noindentt">In most cases, copying a file into one of these directories requires superuser privilege.</p>
<p class="indent">After installation, the symbolic links for the soname and linker name must be created, usually as relative symbolic links in the same directory as the library file. Thus, to install our demonstration library in <span class="literal">/usr/lib</span> (whose permissions only allow updates by <em>root</em>), we would do the following:</p>
<p class="programs">$ <span class="codestrong">su</span><br/>Password:<br/># <span class="codestrong">mv libdemo.so.1.0.1 /usr/lib</span><br/># <span class="codestrong">cd /usr/lib</span><br/># <span class="codestrong">ln -s libdemo.so.1.0.1 libdemo.so.1</span><br/># <span class="codestrong">ln -s libdemo.so.1 libdemo.so</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_848"/>The last two lines in this shell session create the soname and linker name symbolic links.</p>
<h5 class="h5" id="ch41lev3sec11"><strong><em>ldconfig</em></strong></h5>
<p class="noindentab">The <em>ldconfig(8)</em> program addresses two potential problems with shared libraries:</p>
<p class="bull">&#8226; Shared libraries can reside in a variety of directories. If the dynamic linker needed to search all of these directories in order to find a library, then loading libraries could be very slow.</p>
<p class="bull">&#8226; As new versions of libraries are installed or old versions are removed, the soname symbolic links may become out of date.</p>
<p class="noindentt">The <em>ldconfig</em> program solves these problems by performing two tasks:</p>
<ol>
<li class="order"><p class="orderp">It searches a standard set of directories and creates or updates a cache file, <span class="literal">/etc/ld.so.cache</span>, to contain a list of the (latest minor versions of each of the) major library versions in all of these directories. The dynamic linker in turn uses this cache file when resolving library names at run time. To build the cache, <em>ldconfig</em> searches the directories specified in the file <span class="literal">/etc/ld.so.conf</span> and then <span class="literal">/lib</span> and <span class="literal">/usr/lib</span>. The <span class="literal">/etc/ld.so.conf</span> file consists of a list of directory pathnames (these should be specified as absolute pathnames), separated by newlines, spaces, tabs, commas, or colons. In some distributions, the directory <span class="literal">/usr/local/lib</span> is included in this list. (If not, we may need to add it manually.)</p>
<div class="block1b">
<p class="noindent">The command <em>ldconfig &#8211;p</em> displays the current contents of <span class="literal">/etc/ld.so.cache</span>.</p>
</div></li>
<li class="order"><p class="orderp">It examines the latest minor version (i.e., the version with the highest minor number) of each major version of each library to find the embedded soname and then creates (or updates) relative symbolic links for each soname in the same directory.</p></li>
</ol>
<p class="noindent">In order to correctly perform these actions, <em>ldconfig</em> expects libraries to be named according to the conventions described earlier (i.e., library real names include major and minor identifiers that increase appropriately from one library version to the next).</p>
<p class="indent">By default, <em>ldconfig</em> performs both of the above actions. Command-line options can be used to selectively inhibit either action: the <em>&#8211;N</em> option prevents rebuilding of the cache, and the <em>&#8211;X</em> option inhibits the creation of the soname symbolic links. In addition, the <em>&#8211;v</em> (<em>verbose</em>) option causes <em>ldconfig</em> to display output describing its actions.</p>
<p class="indent">We should run <em>ldconfig</em> whenever a new library is installed, an existing library is updated or removed, or the list of directories in <span class="literal">/etc/ld.so.conf</span> is changed.</p>
<p class="indent">As an example of the operation of <em>ldconfig</em>, suppose we wanted to install two different major versions of a library. We would do this as follows:</p>
<p class="programs">$ <span class="codestrong">su</span><br/>Password:<br/># <span class="codestrong">mv libdemo.so.1.0.1 libdemo.so.2.0.0 /usr/lib</span><br/># <span class="codestrong">ldconfig -v | grep libdemo</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;libdemo.so.1 -&gt; libdemo.so.1.0.1 (changed)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;libdemo.so.2 -&gt; libdemo.so.2.0.0 (changed)</p>
<p class="noindent"><span epub:type="pagebreak" id="page_849"/>Above, we filter the output of <em>ldconfig</em>, so that we see just the information relating to libraries named <span class="literal">libdemo</span>.</p>
<p class="indent">Next, we list the files named <span class="literal">libdemo</span> in <span class="literal">/usr/lib</span> to verify the setup of the soname symbolic links:</p>
<p class="programs"># <span class="codestrong">cd /usr/lib</span><br/># <span class="codestrong">ls -l libdemo* | awk '{print $1, $9, $10, $11}'</span><br/>lrwxrwxrwx libdemo.so.1 -&gt; libdemo.so.1.0.1<br/>-rwxr-xr-x libdemo.so.1.0.1<br/>lrwxrwxrwx libdemo.so.2 -&gt; libdemo.so.2.0.0<br/>-rwxr-xr-x libdemo.so.2.0.0</p>
<p class="noindent">We must still create the symbolic link for the linker name, as shown in the next command:</p>
<p class="programs"># <span class="codestrong">ln -s libdemo.so.2 libdemo.so</span></p>
<p class="noindent">However, if we install a new 2.<em>x</em> minor version of our library, then, since the linker name points to the latest soname, <em>ldconfig</em> has the effect of also keeping the linker name up to date, as the following example shows:</p>
<p class="programs"># <span class="codestrong">mv libdemo.so.2.0.1 /usr/lib</span><br/># <span class="codestrong">ldconfig -v | grep libdemo</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;libdemo.so.1 -&gt; libdemo.so.1.0.1<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;libdemo.so.2 -&gt; libdemo.so.2.0.1 (changed)</p>
<p class="noindent">If we are building and using a private library (i.e., one that is not installed in one of the standard directories), we can have <em>ldconfig</em> create the soname symbolic link for us by using the <em>&#8211;n</em> option. This specifies that <em>ldconfig</em> should process only libraries in the directories on the command line and should not update the cache file. In the following example, we use <em>ldconfig</em> to process libraries in the current working directory:</p>
<p class="programs">$ <span class="codestrong">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c</span><br/>$ <span class="codestrong">gcc -g -shared -Wl,-soname,libdemo.so.1 -o libdemo.so.1.0.1 \<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mod1.o mod2.o mod3.o</span><br/>$ <span class="codestrong">/sbin/ldconfig -nv .</span><br/>.:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;libdemo.so.1 -&gt; libdemo.so.1.0.1<br/>$ <span class="codestrong">ls -l libdemo.so* | awk '{print $1, $9, $10, $11}'</span><br/>lrwxrwxrwx libdemo.so.1 -&gt; libdemo.so.1.0.1<br/>-rwxr-xr-x libdemo.so.1.0.1</p>
<p class="noindent">In the above example, we specified the full pathname when running <em>ldconfig</em>, because we were using an unprivileged account whose <span class="literal">PATH</span> environment variable did not include the <span class="literal">/sbin</span> directory.</p>
<h3 class="h3" id="ch41lev1sec08"><span epub:type="pagebreak" id="page_850"/><strong>41.8 Compatible Versus Incompatible Libraries</strong></h3>
<p class="noindenta">Over time, we may need to make changes to the code of a shared library. Such changes result in a new version of the library that is either <em>compatible</em> with previous version(s), meaning that we need to change only the minor version identifier of the library&#8217;s real name, or <em>incompatible</em>, meaning that we must define a new major version of the library.</p>
<p class="indentb">A change to a library is compatible with an existing library version if <em>all</em> of the following conditions hold true:</p>
<p class="bull">&#8226; The semantics of each public function and variable in the library remain unchanged. In other words, each function keeps the same argument list, and continues to produce its specified effect on global variables and returned arguments, and returns the same result value. Thus, changes that result in an improvement in performance or fix a bug (resulting in closer conformance to specified behavior) can be regarded as compatible changes.</p>
<p class="bull">&#8226; No function or variable in the library&#8217;s public API is removed. It is, however, compatible to add new functions and variables to the public API.</p>
<p class="bull">&#8226; Structures allocated within and returned by each function remain unchanged. Similarly, public structures exported by the library remain unchanged. One exception to this rule is that, under certain circumstances, new items may be added to the end of an existing structure, though even this may be subject to pitfalls if, for example, the calling program tries to allocate arrays of this structure type. Library designers sometimes circumvent this limitation by defining exported structures to be larger than is required in the initial release of the library, with some extra padding fields being &#8220;reserved for future use.&#8221;</p>
<p class="noindentt">If none of these conditions is violated, then the new library name can be updated by adjusting the minor version of the existing name. Otherwise, a new major version of the library should be created.</p>
<h3 class="h3" id="ch41lev1sec09"><strong>41.9 Upgrading Shared Libraries</strong></h3>
<p class="noindenta">One of the advantages of shared libraries is that a new major or minor version of a library can be installed even while running programs are using an existing version. All that we need to do is create the new library version, install it in the appropriate directory, and update the soname and linker name symbolic links as required (or, more usually, have <em>ldconfig</em> do the job for us). To produce a new minor version (i.e., a compatible upgrade) of the shared library <span class="literal">/usr/lib/libdemo.1.0.1</span>, we would do the following:</p>
<p class="programs">$ <span class="codestrong">su</span><br/>Password:<br/># <span class="codestrong">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c</span><br/># <span class="codestrong">gcc -g -shared -Wl,-soname,libdemo.so.1 -o libdemo.so.1.0.2 \<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mod1.o mod2.o mod3.o</span><br/># <span class="codestrong">mv libdemo.so.1.0.2 /usr/lib</span><br/># <span class="codestrong">ldconfig -v | grep libdemo</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;libdemo.so.1 -&gt; libdemo.so.1.0.2 (changed)</p>
<p class="noindent"><span epub:type="pagebreak" id="page_851"/>Assuming the linker name was already correctly set up (i.e., to point to the library soname), we would not need to modify it.</p>
<p class="indent">Already running programs will continue to use the previous minor version of the shared library. Only when they are terminated and restarted will they too use the new minor version of the shared library.</p>
<p class="indent">If we subsequently wanted to create a new major version (2.0.0) of the shared library, we would do the following:</p>
<p class="programs"># <span class="codestrong">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c</span><br/># <span class="codestrong">gcc -g -shared -Wl,-soname,libdemo.so.2 -o libdemo.so.2.0.0 \<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mod1.o mod2.o mod3.o</span><br/># <span class="codestrong">mv libdemo.so.2.0.0 /usr/lib</span><br/># <span class="codestrong">ldconfig -v | grep libdemo</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;libdemo.so.1 -&gt; libdemo.so.1.0.2<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;libdemo.so.2 -&gt; libdemo.so.2.0.0 (changed)<br/># <span class="codestrong">cd /usr/lib</span><br/># <span class="codestrong">ln -sf libdemo.so.2 libdemo.so</span></p>
<p class="noindent">As can be seen in the above output, <em>ldconfig</em> automatically creates a soname symbolic link for the new major version. However, as the last command shows, we must manually update the linker name symbolic link.</p>
<h3 class="h3" id="ch41lev1sec10"><strong>41.10 Specifying Library Search Directories in an Object File</strong></h3>
<p class="noindenta">We have already seen two ways of informing the dynamic linker of the location of shared libraries: using the <span class="literal">LD_LIBRARY_PATH</span> environment variable and installing a shared library into one of the standard library directories (<span class="literal">/lib</span>, <span class="literal">/usr/lib</span>, or one of the directories listed in <span class="literal">/etc/ld.so.conf</span>).</p>
<p class="indent">There is a third way: during the static editing phase, we can insert into the executable a list of directories that should be searched at run time for shared libraries. This is useful if we have libraries that reside in fixed locations that are not among the standard locations searched by the dynamic linker. To do this, we employ the <em>&#8211;rpath</em> linker option when creating an executable:</p>
<p class="programs">$ <span class="codestrong">gcc -g -Wall -Wl,-rpath,/home/mtk/pdir -o prog prog.c libdemo.so</span></p>
<p class="noindent">The above command copies the string <em>/home/mtk/pdir</em> into the run-time library path (<em>rpath</em>) list of the executable <em>prog</em>, so, that when the program is run, the dynamic linker will also search this directory when resolving shared library references.</p>
<p class="indent">If necessary, the <em>&#8211;rpath</em> option can be specified multiple times; all of the directories are concatenated into a single ordered <em>rpath</em> list placed in the executable file. Alternatively, multiple directories can be specified as a colon-separated list within a single <em>&#8211;rpath</em> option. At run time, the dynamic linker searches the directories in the order they were specified in the <em>&#8211;rpath</em> option(s).</p>
<div class="block">
<p class="noindent">An alternative to the <em>&#8211;rpath</em> option is the <span class="literal">LD_RUN_PATH</span> environment variable. This variable can be assigned a string containing a series of colon-separated directories that are to be used as the <em>rpath</em> list when building the executable file. <span class="literal">LD_RUN_PATH</span> is employed only if the <em>&#8211;rpath</em> option is not specified when building the executable.</p>
</div>
<h5 class="h5" id="ch41lev3sec12"><span epub:type="pagebreak" id="page_852"/><strong>Using the <em>&#8211;rpath</em> linker option when building a shared library</strong></h5>
<p class="noindenta">The <em>&#8211;rpath</em> linker option can also be useful when building a shared library. Suppose we have one shared library, <span class="literal">libx1.so</span>, that depends on another, <span class="literal">libx2.so</span>, as shown in <a href="ch41.xhtml#ch41fig4">Figure 41-4</a>. Suppose also that these libraries reside in the nonstandard directories <span class="literal">d1</span> and <span class="literal">d2</span>, respectively. We now go through the steps required to build these libraries and the program that uses them.</p>
<div class="image"><img src="../images/f41-04.jpg" alt="image"/></div>
<p class="figcap"><a id="ch41fig4"/><strong>Figure 41-4:</strong> A shared library that depends on another shared library</p>
<p class="noindent">First, we build <span class="literal">libx2.so</span>, in the directory <span class="literal">pdir/d2</span>. (To keep the example simple, we dispense with library version numbering and explicit sonames.)</p>
<p class="programs">$ <span class="codestrong">cd /home/mtk/pdir/d2</span><br/>$ <span class="codestrong">gcc -g -c -fPIC -Wall modx2.c</span><br/>$ <span class="codestrong">gcc -g -shared -o libx2.so modx2.o</span></p>
<p class="noindent">Next, we build <span class="literal">libx1.so</span>, in the directory <span class="literal">pdir/d1</span>. Since <span class="literal">libx1.so</span> depends on <span class="literal">libx2.so</span>, which is not in a standard directory, we specify the latter&#8217;s run-time location with the <em>&#8211;rpath</em> linker option. This could be different from the link-time location of the library (specified by the <em>&#8211;L</em> option), although in this case the two locations are the same.</p>
<p class="programs">$ <span class="codestrong">cd /home/mtk/pdir/d1</span><br/>$ <span class="codestrong">gcc -g -c -Wall -fPIC modx1.c</span><br/>$ <span class="codestrong">gcc -g -shared -o libx1.so modx1.o -Wl,-rpath,/home/mtk/pdir/d2 \</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codestrong">-L/home/mtk/pdir/d2 -lx2</span></p>
<p class="noindent">Finally, we build the main program, in the <span class="literal">pdir</span> directory. Since the main program makes use of <span class="literal">libx1.so</span>, and this library resides in a nonstandard directory, we again employ the <em>&#8211;rpath</em> linker option:</p>
<p class="programs">$ <span class="codestrong">cd /home/mtk/pdir</span><br/>$ <span class="codestrong">gcc -g -Wall -o prog prog.c -Wl,-rpath,/home/mtk/pdir/d1 \</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codestrong">-L/home/mtk/pdir/d1 -lx1</span></p>
<p class="noindent">Note that we did not need to mention <span class="literal">libx2.so</span> when linking the main program. Since the linker is capable of analyzing the <em>rpath</em> list in <span class="literal">libx1.so</span>, it can find <span class="literal">libx2.so</span>, and thus is able to satisfy the requirement that all symbols can be resolved at static link time.</p>
<p class="indent">We can use the following commands to examine <span class="literal">prog</span> and <span class="literal">libx1.so</span> in order to see the contents of their <em>rpath</em> lists:</p>
<p class="programs">$ <span class="codestrong">objdump -p prog | grep PATH</span><br/>RPATH&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/home/mtk/pdir/d1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;libx1.so <span class="font1">will be sought here at run time</span><br/>$ <span class="codestrong">objdump -p d1/libx1.so | grep PATH</span><br/>RPATH&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/home/mtk/pdir/d2&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;libx2.so <span class="font1">will be sought here at run time</span></p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_853"/>We can also view the <em>rpath</em> lists by grepping the output of the <em>readelf &#8211;&#8211;dynamic</em> (or, equivalently, <em>readelf &#8211;d</em>) command.</p>
</div>
<p class="noindent">We can use the <em>ldd</em> command to show the complete set of dynamic dependencies of <span class="literal">prog</span>:</p>
<p class="programs">$ <span class="codestrong">ldd prog</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;libx1.so =&gt; /home/mtk/pdir/d1/libx1.so (0x40017000)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;libc.so.6 =&gt; /lib/tls/libc.so.6 (0x40024000)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;libx2.so =&gt; /home/mtk/pdir/d2/libx2.so (0x4014c000)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)</p>
<h5 class="h5" id="ch41lev3sec13"><strong>The ELF</strong> <span class="literal"><span class="codestrong">DT_RPATH</span></span> <strong>and</strong> <span class="literal"><span class="codestrong">DT_RUNPATH</span></span> <strong>entries</strong></h5>
<p class="noindenta">In the original ELF specification, only one type of <em>rpath</em> list could be embedded in an executable or shared library. This corresponded to the <span class="literal">DT_RPATH</span> tag in an ELF file. Later ELF specifications deprecated <span class="literal">DT_RPATH</span>, and introduced a new tag, <span class="literal">DT_RUNPATH</span>, for representing <em>rpath</em> lists. The difference between these two types of <em>rpath</em> lists is their relative precedence with respect to the <span class="literal">LD_LIBRARY_PATH</span> environment variable when the dynamic linker searches for shared libraries at run time: <span class="literal">DT_RPATH</span> has higher precedence, while <span class="literal">DT_RUNPATH</span> has lower precedence (refer to <a href="ch41.xhtml#ch41lev1sec11">Section 41.11</a>).</p>
<p class="indent">By default, the linker creates the <em>rpath</em> list as a <span class="literal">DT_RPATH</span> tag. To have the linker instead create the <em>rpath</em> list as a <span class="literal">DT_RUNPATH</span> entry, we must additionally employ the <em>&#8211;&#8211;enable&#8211;new&#8211;dtags</em> (<em>enable new dynamic tags</em>) linker option. If we rebuild our program using this option, and inspect the resulting executable file with <em>objdump</em>, we see the following:</p>
<p class="programs">$ <span class="codestrong">gcc -g -Wall -o prog prog.c -Wl,--enable-new-dtags \</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codestrong">-Wl,-rpath,/home/mtk/pdir/d1 -L/home/mtk/pdir/d1 -lx1</span><br/>$ <span class="codestrong">objdump -p prog | grep PATH</span><br/>&#160;&#160;RPATH&#160;&#160;&#160;&#160;&#160;&#160;&#160;/home/mtk/pdir/d1<br/>&#160;&#160;RUNPATH&#160;&#160;&#160;&#160;&#160;/home/mtk/pdir/d1</p>
<p class="noindent">As can be seen, the executable contains both <span class="literal">DT_RPATH</span> and <span class="literal">DT_RUNPATH</span> tags. The linker duplicates the <em>rpath</em> list in this way for the benefit of older dynamic linkers that may not understand the <span class="literal">DT_RUNPATH</span> tag. (Support for <span class="literal">DT_RUNPATH</span> was added in version 2.2 of <em>glibc</em>.) Dynamic linkers that understand the <span class="literal">DT_RUNPATH</span> tag ignore the <span class="literal">DT_RPATH</span> tag (see <a href="ch41.xhtml#ch41lev1sec11">Section 41.11</a>).</p>
<h5 class="h5" id="ch41lev3sec14"><strong>Using</strong> <span class="literal"><span class="codestrong">$ORIGIN</span></span> <strong>in <em>rpath</em></strong></h5>
<p class="noindenta">Suppose that we want to distribute an application that uses some of its own shared libraries, but we don&#8217;t want to require the user to install the libraries in one of the standard directories. Instead, we would like to allow the user to unpack the application under an arbitrary directory of their choice and then immediately be able to run the application. The problem is that the application has no way of determining where its shared libraries are located, unless it requests the user to set <span class="literal">LD_LIBRARY_PATH</span> or we require the user to run some sort of installation script that identifies the required directories. Neither of these approaches is desirable.</p>
<p class="indent">To get around this problem, the dynamic linker is built to understand a special string, <span class="literal">$ORIGIN</span> (or, equivalently, <span class="literal">${ORIGIN}</span>), in an <em>rpath</em> specification. The dynamic <span epub:type="pagebreak" id="page_854"/>linker interprets this string to mean &#8220;the directory containing the application.&#8221; This means that we can, for example, build an application with the following command:</p>
<p class="programs">$ <span class="codestrong">gcc -Wl,-rpath,'$ORIGIN'/lib</span> ...</p>
<p class="noindent">This presumes that at run time the application&#8217;s shared libraries will reside in the subdirectory <span class="literal">lib</span> under the directory that contains the application executable. We can then provide the user with a simple installation package that contains the application and associated libraries, and the user can install the package in any location and then run the application (i.e., a so-called &#8220;turn-key application&#8221;).</p>
<h3 class="h3" id="ch41lev1sec11"><strong>41.11 Finding Shared Libraries at Run Time</strong></h3>
<p class="noindenta">When resolving library dependencies, the dynamic linker first inspects each dependency string to see if it contains a slash (<span class="literal">/</span>), which can occur if we specified an explicit library pathname when linking the executable. If a slash is found, then the dependency string is interpreted as a pathname (either absolute or relative), and the library is loaded using that pathname. Otherwise, the dynamic linker searches for the shared library using the following rules:</p>
<ol>
<li class="order"><p class="orderp">If the executable has any directories listed in its <span class="literal">DT_RPATH</span> run-time library path list (<em>rpath</em>) and the executable does <em>not</em> contain a <span class="literal">DT_RUNPATH</span> list, then these directories are searched (in the order that they were supplied when linking the program).</p></li>
<li class="order"><p class="orderp">If the <span class="literal">LD_LIBRARY_PATH</span> environment variable is defined, then each of the colon-separated directories listed in its value is searched in turn. If the executable is a set-user-ID or set-group-ID program, then <span class="literal">LD_LIBRARY_PATH</span> is ignored. This is a security measure to prevent users from tricking the dynamic linker into loading a private version of a library with the same name as a library required by the executable.</p></li>
<li class="order"><p class="orderp">If the executable has any directories listed in its <span class="literal">DT_RUNPATH</span> run-time library path list, then these directories are searched (in the order that they were supplied when linking the program).</p></li>
<li class="order"><p class="orderp">The file <span class="literal">/etc/ld.so.cache</span> is checked to see if it contains an entry for the library.</p></li>
<li class="order"><p class="orderp">The directories <span class="literal">/lib</span> and <span class="literal">/usr/lib</span> are searched (in that order).</p></li>
</ol>
<h3 class="h3" id="ch41lev1sec12"><strong>41.12 Run-Time Symbol Resolution</strong></h3>
<p class="noindenta">Suppose that a global symbol (i.e., a function or variable) is defined in multiple locations, such as in an executable and in a shared library, or in multiple shared libraries. How is a reference to that symbol resolved?</p>
<p class="indent">For example, suppose that we have a main program and a shared library, both of which define a global function, <em>xyz()</em>, and another function within the shared library calls <em>xyz()</em>, as shown in <a href="ch41.xhtml#ch41fig5">Figure 41-5</a>.</p>
<div class="image"><span epub:type="pagebreak" id="page_855"/><img src="../images/f41-05.jpg" alt="image"/></div>
<p class="figcap"><a id="ch41fig5"/><strong>Figure 41-5:</strong> Resolving a global symbol reference</p>
<p class="noindent">When we build the shared library and the executable program, and then run the program, this is what we see:</p>
<p class="programs">$ <span class="codestrong">gcc -g -c -fPIC -Wall -c foo.c</span><br/>$ <span class="codestrong">gcc -g -shared -o libfoo.so foo.o</span><br/>$ <span class="codestrong">gcc -g -o prog prog.c libfoo.so</span><br/>$ <span class="codestrong">LD_LIBRARY_PATH=. ./prog</span><br/>main-xyz</p>
<p class="noindent">From the last line of output, we can see that the definition of <em>xyz()</em> in the main program overrides (interposes) the one in the shared library.</p>
<p class="indentb">Although this may at first appear surprising, there is a good historical reason why things are done this way. The first shared library implementations were designed so that the default semantics for symbol resolution exactly mirrored those of applications linked against static equivalents of the same libraries. This means that the following semantics apply:</p>
<p class="bull">&#8226; A definition of a global symbol in the main program overrides a definition in a library.</p>
<p class="bull">&#8226; If a global symbol is defined in multiple libraries, then a reference to that symbol is bound to the first definition found by scanning libraries in the left-to-right order in which they were listed on the static link command line.</p>
<p class="noindentt">Although these semantics make the transition from static to shared libraries relatively straightforward, they can cause some problems. The most significant problem is that these semantics conflict with the model of a shared library as implementing a self-contained subsystem. By default, a shared library can&#8217;t guarantee that a reference to one of its own global symbols will actually be bound to the library&#8217;s definition of that symbol. Consequently, the properties of a shared library can change when it is aggregated into a larger unit. This can lead to applications breaking in unexpected ways, and also makes it difficult to perform divide-and-conquer debugging (i.e., trying to reproduce a problem using fewer or different shared libraries).</p>
<p class="indent">In the above scenario, if we wanted to ensure that the invocation of <em>xyz()</em> in the shared library actually called the version of the function defined within the library, then we could use the <em>&#8211;Bsymbolic</em> linker option when building the shared library:</p>
<p class="programs">$ <span class="codestrong">gcc -g -c -fPIC -Wall foo.c</span><br/>$ <span class="codestrong">gcc -g -shared -Wl,-Bsymbolic -o libfoo.so foo.o</span><br/>$ <span class="codestrong">gcc -g -o prog prog.c libfoo.so</span><br/>$ <span class="codestrong">LD_LIBRARY_PATH=. ./prog</span><br/>foo-xyz</p>
<p class="noindent"><span epub:type="pagebreak" id="page_856"/>The <em>&#8211;Bsymbolic</em> linker option specifies that references to global symbols within a shared library should be preferentially bound to definitions (if they exist) within that library. (Note that, regardless of this option, calling <em>xyz()</em> from the main program would always invoke the version of <em>xyz()</em> defined in the main program.)</p>
<h3 class="h3" id="ch41lev1sec13"><strong>41.13 Using a Static Library Instead of a Shared Library</strong></h3>
<p class="noindenta">Although it is almost always preferable to use shared libraries, there are occasional situations where static libraries may be appropriate. In particular, the fact that a statically linked application contains all of the code that it requires at run time can be advantageous. For example, static linking is useful if the user can&#8217;t, or doesn&#8217;t wish to, install a shared library on the system where the program is to be used, or if the program is to be run in an environment (perhaps a <em>chroot</em> jail, for example) where shared libraries are unavailable. In addition, even a compatible shared library upgrade may unintentionally introduce a bug that breaks an application. By linking an application statically, we can ensure that it is immune to changes in the shared libraries on a system and that it has all of the code it requires to run (at the expense of a larger program size, and consequent increased disk and memory requirements).</p>
<p class="indentb">By default, where the linker has a choice of a shared and a static library of the same name (e.g., we link using <em>&#8211;Lsomedir &#8211;ldemo</em>, and both <span class="literal">libdemo.so</span> and <span class="literal">libdemo.a</span> exist), the shared version of the library is used. To force usage of the static version of the library, we may do one of the following:</p>
<p class="bull">&#8226; Specify the pathname of the static library (including the <span class="literal">.a</span> extension) on the <em>gcc</em> command line.</p>
<p class="bull">&#8226; Specify the <em>&#8211;static</em> option to <em>gcc</em>.</p>
<p class="bull">&#8226; Use the <em>gcc</em> options <em>&#8211;Wl,&#8211;Bstatic</em> and <em>&#8211;Wl,&#8211;Bdynamic</em> to explicitly toggle the linker&#8217;s choice between static and shared libraries. These options can be intermingled with <em>&#8211;l</em> options on the <em>gcc</em> command line. The linker processes the options in the order in which they are specified.</p>
<h3 class="h3" id="ch41lev1sec14"><strong>41.14 Summary</strong></h3>
<p class="noindenta">An object library is an aggregation of compiled object modules that can be employed by programs that are linked against the library. Like other UNIX implementations, Linux provides two types of object libraries: static libraries, which were the only type of library available under early UNIX systems, and the more modern shared libraries.</p>
<p class="indent">Because they provide several advantages over static libraries, shared libraries are the predominant type of library in use on contemporary UNIX systems. The advantages of shared libraries spring primarily from the fact that when a program is linked against the library, copies of the object modules required by the program are not included in the resulting executable. Instead, the (static) linker merely includes information in the executable file about the shared libraries that are <span epub:type="pagebreak" id="page_857"/>required at run time. When the file is executed, the dynamic linker uses this information to load the required shared libraries. At run time, all programs using the same shared library share a single copy of that library in memory. Since shared libraries are not copied into executable files, and a single memory-resident copy of the shared library is employed by all programs at run time, shared libraries reduce the amount of disk space and memory required by the system.</p>
<p class="indent">The shared library soname provides a level of indirection in resolving shared library references at run time. If a shared library has a soname, then this name, rather than the library&#8217;s real name, is recorded in the resulting executable produced by the static linker. A versioning scheme, whereby a shared library is given a real name of the form <span class="literal">lib</span><em>name</em><span class="literal">.so.</span><em>major-id.minor-id</em>, while the soname has the form <span class="literal">lib</span><em>name</em><span class="literal">.so.</span><em>major-id</em>, allows for the creation of programs that automatically employ the latest minor version of the shared library (without requiring the programs to be relinked), while also allowing for the creation of new, incompatible major versions of the library.</p>
<p class="indent">In order to find a shared library at run time, the dynamic linker follows a standard set of search rules, which include searching a set of directories (e.g., <span class="literal">/lib</span> and <span class="literal">/usr/lib</span>) in which most shared libraries are installed.</p>
<h5 class="h5" id="ch41lev3sec15"><strong>Further information</strong></h5>
<p class="noindenta">Various information related to static and shared libraries can be found in the <em>ar(1)</em>, <em>gcc(1)</em>, <em>ld(1)</em>, <em>ldconfig(8)</em>, <em>ld.so(8)</em>, <em>dlopen(3)</em>, <em>readelf(1)</em>, and <em>objdump(1)</em> manual pages and in the <em>info</em> documentation for <em>ld</em>. [<a href="bib.xhtml#bib21">Drepper, 2004 (b)</a>] covers many of the finer details of writing shared libraries on Linux. Further useful information can also be found in David Wheeler&#8217;s <em>Program Library HOWTO</em>, which is online at the LDP web site, <em><a href="http://www.tldp.org/">http://www.tldp.org/</a></em>. The GNU shared library scheme has many similarities to that implemented in Solaris, and therefore it is worth reading Sun&#8217;s <em>Linker and Libraries Guide</em> (available at <em><a href="http://docs.sun.com/">http://docs.sun.com/</a></em>) for further information and examples. [<a href="bib.xhtml#bib54">Levine, 2000</a>] provides an introduction to the operation of static and dynamic linkers.</p>
<p class="indent">Information about GNU <em>Libtool</em>, a tool that shields the programmer from the implementation-specific details of building shared libraries, can be found online at <em><a href="http://www.gnu.org/software/libtool">http://www.gnu.org/software/libtool</a></em> and in [<a href="bib.xhtml#bib106">Vaughan et al., 2000</a>].</p>
<p class="indent">The document <em>Executable and Linking Format</em>, from the <em>Tools Interface Standards</em> committee, provides details on ELF. This document can be found online at <em><a href="http://refspecs.freestandards.org/elf/elf.pdf">http://refspecs.freestandards.org/elf/elf.pdf</a></em>. [<a href="bib.xhtml#bib60">Lu, 1995</a>] also provides a lot of useful detail on ELF.</p>
<h3 class="h3" id="ch41lev1sec15"><strong>41.15 Exercise</strong></h3>
<p class="exer"><a id="ch41exe1"/><strong>41-1.</strong>&#160;&#160;&#160;Try compiling a program with and without the <em>&#8211;static</em> option, to see the difference in size between an executable dynamically linked with the C library and one that is linked against the static version of the C library.<span epub:type="pagebreak" id="page_858"/></p>
</body>
</html>
