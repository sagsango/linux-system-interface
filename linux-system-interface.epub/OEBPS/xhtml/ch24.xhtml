<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch24"><span epub:type="pagebreak" id="page_513"/><strong><span class="big">24</span></strong><br/><strong>PROCESS CREATION</strong></h2>
<p class="noindenta">In this and the next four chapters, we look at how a process is created and terminates, and how a process can execute a new program. This chapter covers process creation. However, before diving into that subject, we present a short overview of the main system calls covered in these chapters.</p>
<h3 class="h3" id="ch24lev1sec01"><strong>24.1 Overview of <em>fork()</em>, <em>exit()</em>, <em>wait()</em>, and <em>execve()</em></strong></h3>
<p class="noindentab">The principal topics of this and the next few chapters are the system calls <em>fork()</em>, <em>exit()</em>, <em>wait()</em>, and <em>execve()</em>. Each of these system calls has variants, which we&#8217;ll also look at. For now, we provide an overview of these four system calls and how they are typically used together.</p>
<p class="bull">&#8226; The <em>fork()</em> system call allows one process, the parent, to create a new process, the child. This is done by making the new child process an (almost) exact duplicate of the parent: the child obtains copies of the parent&#8217;s stack, data, heap, and text segments (<a href="ch06.xhtml#ch06lev1sec03">Section 6.3</a>). The term <em>fork</em> derives from the fact that we can envisage the parent process as dividing to yield two copies of itself.</p>
<p class="bull">&#8226; The <em>exit(status)</em> library function terminates a process, making all resources (memory, open file descriptors, and so on) used by the process available for subsequent reallocation by the kernel. The <em>status</em> argument is an integer that determines the termination status for the process. Using the <em>wait()</em> system call, the parent can retrieve this status.</p>
<div class="block1">
<p class="noindent"><span epub:type="pagebreak" id="page_514"/>The <em>exit()</em> library function is layered on top of the <em>_exit()</em> system call. In <a href="ch25.xhtml#ch25">Chapter 25</a>, we explain the difference between the two interfaces. In the meantime, we&#8217;ll just note that, after a <em>fork()</em>, generally only one of the parent and child terminate by calling <em>exit()</em>; the other process should terminate using <em>_exit()</em>.</p>
</div>
<p class="bull">&#8226; The <em>wait(&#38;status)</em> system call has two purposes. First, if a child of this process has not yet terminated by calling <em>exit()</em>, then <em>wait()</em> suspends execution of the process until one of its children has terminated. Second, the termination status of the child is returned in the status argument of <em>wait()</em>.</p>
<p class="bull">&#8226; The <em>execve(pathname, argv, envp)</em> system call loads a new program (<em>pathname</em>, with argument list <em>argv</em>, and environment list <em>envp</em>) into a process&#8217;s memory. The existing program text is discarded, and the stack, data, and heap segments are freshly created for the new program. This operation is often referred to as <em>execing</em> a new program. Later, we&#8217;ll see that several library functions are layered on top of <em>execve()</em>, each of which provides a useful variation in the programming interface. Where we don&#8217;t care about these interface variations, we follow the common convention of referring to these calls generically as <em>exec()</em>, but be aware that there is no system call or library function with this name.</p>
<p class="noindentt">Some other operating systems combine the functionality of <em>fork()</em> and <em>exec()</em> into a single operation&#8212;a so-called <em>spawn</em>&#8212;that creates a new process that then executes a specified program. By comparison, the UNIX approach is usually simpler and more elegant. Separating these two steps makes the APIs simpler (the <em>fork()</em> system call takes <em>no</em> arguments) and allows a program a great degree of flexibility in the actions it performs between the two steps. Moreover, it is often useful to perform a <em>fork()</em> without a following <em>exec()</em>.</p>
<div class="block">
<p class="noindent">SUSv3 specifies the optional <em>posix_spawn()</em> function, which combines the effect of <em>fork()</em> and <em>exec()</em>. This function, and several related APIs specified by SUSv3, are implemented on Linux in <em>glibc</em>. SUSv3 specifies <em>posix_spawn()</em> to permit portable applications to be written for hardware architectures that don&#8217;t provide swap facilities or memory-management units (this is typical of many embedded systems). On such architectures, a traditional <em>fork()</em> is difficult or impossible to implement.</p>
</div>
<p class="noindent"><a href="ch24.xhtml#ch24fig1">Figure 24-1</a> provides an overview of how <em>fork()</em>, <em>exit()</em>, <em>wait()</em>, and <em>execve()</em> are commonly used together. (This diagram outlines the steps taken by the shell in executing a command: the shell continuously executes a loop that reads a command, performs various processing on it, and then forks a child process to exec the command.)</p>
<p class="indent">The use of <em>execve()</em> shown in this diagram is optional. Sometimes, it is instead useful to have the child carry on executing the same program as the parent. In either case, the execution of the child is ultimately terminated by a call to <em>exit()</em> (or by delivery of a signal), yielding a termination status that the parent can obtain via <em>wait()</em>.</p>
<p class="indent">The call to <em>wait()</em> is likewise optional. The parent can simply ignore its child and continue executing. However, we&#8217;ll see later that the use of <em>wait()</em> is usually desirable, and is often employed within a handler for the <span class="literal">SIGCHLD</span> signal, which the kernel generates for a parent process when one of its children terminates. (By default, <span class="literal">SIGCHLD</span> is ignored, which is why we label it as being optionally delivered in the diagram.)</p>
<div class="image"><span epub:type="pagebreak" id="page_515"/><img src="../images/f24-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch24fig1"/><strong>Figure 24-1:</strong> Overview of the use of <em>fork()</em>, <em>exit()</em>, <em>wait()</em>, and <em>execve()</em></p>
<h3 class="h3" id="ch24lev1sec02"><strong>24.2 Creating a New Process: <em>fork()</em></strong></h3>
<p class="noindenta">In many applications, creating multiple processes can be a useful way of dividing up a task. For example, a network server process may listen for incoming client requests and create a new child process to handle each request; meanwhile, the server process continues to listen for further client connections. Dividing tasks up in this way often makes application design simpler. It also permits greater concurrency (i.e., more tasks or requests can be handled simultaneously).</p>
<p class="indent">The <em>fork()</em> system call creates a new process, the <em>child</em>, which is an almost exact duplicate of the calling process, the <em>parent</em>.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_516"/>#include &lt;unistd.h&gt;<br/><br/>pid_t <span class="codestrong">fork</span>(void);</p>
<p class="right">In parent: returns process ID of child on success, or &#8211;1 on error; in successfully created child: always returns 0</p>
</div>
<p class="noindent">The key point to understanding <em>fork()</em> is to realize that after it has completed its work, two processes exist, and, in each process, execution continues from the point where <em>fork()</em> returns.</p>
<p class="indent">The two processes are executing the same program text, but they have separate copies of the stack, data, and heap segments. The child&#8217;s stack, data, and heap segments are initially exact duplicates of the corresponding parts of the parent&#8217;s memory. After the <em>fork()</em>, each process can modify the variables in its stack, data, and heap segments without affecting the other process.</p>
<p class="indent">Within the code of a program, we can distinguish the two processes via the value returned from <em>fork()</em>. For the parent, <em>fork()</em> returns the process ID of the newly created child. This is useful because the parent may create, and thus need to track, several children (via <em>wait()</em> or one of its relatives). For the child, <em>fork()</em> returns 0. If necessary, the child can obtain its own process ID using <em>getpid()</em>, and the process ID of its parent using <em>getppid()</em>.</p>
<p class="indent">If a new process can&#8217;t be created, <em>fork()</em> returns &#8211;1. Possible reasons for failure are that the resource limit (<span class="literal">RLIMIT_NPROC</span>, described in <a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a>) on the number of processes permitted to this (real) user ID has been exceeded or that the systemwide limit on the number of processes that can be created has been reached.</p>
<p class="indent">The following idiom is sometimes employed when calling <em>fork()</em>:</p>
<p class="programs">pid_t childPid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Used in parent after successful fork()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;to record PID of child */<br/>switch (childPid = fork()) {<br/>case -1:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* fork() failed */<br/>&#160;&#160;&#160;&#160;/* Handle error */<br/><br/>case 0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child of successful fork() comes here */<br/>&#160;&#160;&#160;&#160;/* Perform actions specific to child */<br/><br/>default:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent comes here after successful fork() */<br/>&#160;&#160;&#160;&#160;/* Perform actions specific to parent */<br/>}</p>
<p class="noindent">It is important to realize that after a <em>fork()</em>, it is indeterminate which of the two processes is next scheduled to use the CPU. In poorly written programs, this indeterminacy can lead to errors known as race conditions, which we describe further in <a href="ch24.xhtml#ch24lev1sec04">Section 24.4</a>.</p>
<p class="indent"><a href="ch24.xhtml#ch24ex1">Listing 24-1</a> demonstrates the use of <em>fork()</em>. This program creates a child that modifies the copies of global and automatic variables that it inherits during the <em>fork()</em>.</p>
<p class="indent">The use of <em>sleep()</em> (in the code executed by the parent) in this program permits the child to be scheduled for the CPU before the parent, so that the child can complete its work and terminate before the parent continues execution. Using <em>sleep()</em> in <span epub:type="pagebreak" id="page_517"/>this manner is not a foolproof method of guaranteeing this result; we look at a better method in <a href="ch24.xhtml#ch24lev1sec05">Section 24.5</a>.</p>
<p class="indent">When we run the program in <a href="ch24.xhtml#ch24ex1">Listing 24-1</a>, we see the following output:</p>
<p class="programs">$ <span class="codestrong">./t_fork</span><br/>PID=28557 (child)&#160;&#160;idata=333 istack=666<br/>PID=28556 (parent) idata=111 istack=222</p>
<p class="noindent">The above output demonstrates that the child process gets its own copy of the stack and data segments at the time of the <em>fork()</em>, and it is able to modify variables in these segments without affecting the parent.</p>
<p class="examplet"><a id="ch24ex1"/><strong>Listing 24-1:</strong> Using <em>fork()</em></p>
<p class="programsli">________________________________________________________ <span class="codestrong">procexec/t_fork.c</span><br/><br/>#include "tlpi_hdr.h"<br/><br/>static int idata = 111;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allocated in data segment */<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int istack = 222;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allocated in stack segment */<br/>&#160;&#160;&#160;&#160;pid_t childPid;<br/><br/>&#160;&#160;&#160;&#160;switch (childPid = fork()) {<br/>&#160;&#160;&#160;&#160;case -1:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;case 0:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;idata *= 3;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;istack *= 3;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;default:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep(3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Give child a chance to execute */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;/* Both parent and child come here */<br/><br/>&#160;&#160;&#160;&#160;printf("PID=%ld %s idata=%d istack=%d\n", (long) getpid(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(childPid == 0) ? "(child) " : "(parent)", idata, istack);<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>________________________________________________________ <span class="codestrong">procexec/t_fork.c</span></p>
<h4 class="h4" id="ch24lev2sec01"><strong>24.2.1 File Sharing Between Parent and Child</strong></h4>
<p class="noindenta">When a <em>fork()</em> is performed, the child receives duplicates of all of the parent&#8217;s file descriptors. These duplicates are made in the manner of <em>dup()</em>, which means that corresponding descriptors in the parent and the child refer to the same open file description. As we saw in <a href="ch05.xhtml#ch05lev1sec04">Section 5.4</a>, the open file description contains the current <span epub:type="pagebreak" id="page_518"/>file offset (as modified by <em>read()</em>, <em>write()</em>, and <em>lseek()</em>) and the open file status flags (set by <em>open()</em> and changed by the <em>fcntl()</em> <span class="literal">F_SETFL</span> operation). Consequently, these attributes of an open file are shared between the parent and child. For example, if the child updates the file offset, this change is visible through the corresponding descriptor in the parent.</p>
<p class="indent">The fact that these attributes are shared by the parent and child after a <em>fork()</em> is demonstrated by the program in <a href="ch24.xhtml#ch24ex2">Listing 24-2</a>. This program opens a temporary file using <em>mkstemp()</em>, and then calls <em>fork()</em> to create a child process. The child changes the file offset and open file status flags of the temporary file, and exits. The parent then retrieves the file offset and flags to verify that it can see the changes made by the child. When we run the program, we see the following:</p>
<p class="programs">$ <span class="codestrong">./fork_file_sharing</span><br/>File offset before fork(): 0<br/>O_APPEND flag before fork() is: off<br/>Child has exited<br/>File offset in parent: 1000<br/>O_APPEND flag in parent is: on</p>
<div class="block">
<p class="noindent">For an explanation of why we cast the return value from <em>lseek()</em> to <em>long long</em> in <a href="ch24.xhtml#ch24ex2">Listing 24-2</a>, see <a href="ch05.xhtml#ch05lev1sec10">Section 5.10</a>.</p>
</div>
<p class="examplet"><a id="ch24ex2"/><strong>Listing 24-2:</strong> Sharing of file offset and open file status flags between parent and child</p>
<p class="programsli">_______________________________________________ <span class="codestrong">procexec/fork_file_sharing.c</span><br/><br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include &lt;sys/wait.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int fd, flags;<br/>&#160;&#160;&#160;&#160;char template[] = "/tmp/testXXXXXX";<br/><br/>&#160;&#160;&#160;&#160;setbuf(stdout, NULL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Disable buffering of stdout */<br/><br/>&#160;&#160;&#160;&#160;fd = mkstemp(template);<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mkstemp");<br/><br/>&#160;&#160;&#160;&#160;printf("File offset before fork(): %lld\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long long) lseek(fd, 0, SEEK_CUR));<br/><br/>&#160;&#160;&#160;&#160;flags = fcntl(fd, F_GETFL);<br/>&#160;&#160;&#160;&#160;if (flags == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fcntl - F_GETFL");<br/>&#160;&#160;&#160;&#160;printf("O_APPEND flag before fork() is: %s\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(flags &#38; O_APPEND) ? "on" : "off");<br/><br/>&#160;&#160;&#160;&#160;switch (fork()) {<br/>&#160;&#160;&#160;&#160;case -1:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;case 0:&#160;&#160;&#160;&#160;&#160;/* Child: change file offset and status flags */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (lseek(fd, 1000, SEEK_SET) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("lseek");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flags = fcntl(fd, F_GETFL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Fetch current flags */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (flags == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fcntl - F_GETFL");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flags |= O_APPEND;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Turn O_APPEND on */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (fcntl(fd, F_SETFL, flags) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fcntl - F_SETFL");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_exit(EXIT_SUCCESS);<br/><br/>&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;/* Parent: can see file changes made by child */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (wait(NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("wait");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for child exit */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Child has exited\n");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("File offset in parent: %lld\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long long) lseek(fd, 0, SEEK_CUR));<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flags = fcntl(fd, F_GETFL);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (flags == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fcntl - F_GETFL");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("O_APPEND flag in parent is: %s\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(flags &#38; O_APPEND) ? "on" : "off");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>_______________________________________________ <span class="codestrong">procexec/fork_file_sharing.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_519"/>Sharing of open file attributes between the parent and child processes is frequently useful. For example, if the parent and child are both writing to a file, sharing the file offset ensures that the two processes don&#8217;t overwrite each other&#8217;s output. It does not, however, prevent the output of the two processes from being randomly intermingled. If this is not desired, then some form of process synchronization is required. For example, the parent can use the <em>wait()</em> system call to pause until the child has exited. This is what the shell does, so that it prints its prompt only after the child process executing a command has terminated (unless the user explicitly runs the command in the background by placing an ampersand character at the end of the command).</p>
<p class="indent">If sharing of open file attributes in this manner is not required, then an application should be designed so that, after a <em>fork()</em>, the parent and child use different file descriptors, with each process closing unused descriptors (i.e., those used by the other process) immediately after forking. (If one of the processes performs an <em>exec()</em>, the close-on-exec flag described in <a href="ch27.xhtml#ch27lev1sec04">Section 27.4</a> can also be useful.) These steps are shown in <a href="ch24.xhtml#ch24fig2">Figure 24-2</a>.</p>
<div class="image"><span epub:type="pagebreak" id="page_520"/><img src="../images/f24-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch24fig2"/><strong>Figure 24-2:</strong> Duplication of file descriptors during <em>fork()</em>, and closing of unused descriptors</p>
<h4 class="h4" id="ch24lev2sec02"><strong>24.2.2 Memory Semantics of <em>fork()</em></strong></h4>
<p class="noindentab">Conceptually, we can consider <em>fork()</em> as creating copies of the parent&#8217;s text, data, heap, and stack segments. (Indeed, in some early UNIX implementations, such duplication was literally performed: a new process image was created by copying the parent&#8217;s memory to swap space, and making that swapped-out image the child process while the parent kept its own memory.) However, actually performing a simple copy of the parent&#8217;s virtual memory pages into the new child process would be wasteful for a number of reasons&#8212;one being that a <em>fork()</em> is often followed by an immediate <em>exec()</em>, which replaces the process&#8217;s text with a new program and reinitializes <span epub:type="pagebreak" id="page_521"/>the process&#8217;s data, heap, and stack segments. Most modern UNIX implementations, including Linux, use two techniques to avoid such wasteful copying:</p>
<p class="bull">&#8226; The kernel marks the text segment of each process as read-only, so that a process can&#8217;t modify its own code. This means that the parent and child can share the same text segment. The <em>fork()</em> system call creates a text segment for the child by building a set of per-process page-table entries that refer to the same physical memory page frames already used by the parent.</p>
<p class="bull">&#8226; For the pages in the data, heap, and stack segments of the parent process, the kernel employs a technique known as <em>copy-on-write</em>. (The implementation of copy-on-write is described in [<a href="bib.xhtml#bib04">Bach, 1986</a>] and [<a href="bib.xhtml#bib09">Bovet &#38; Cesati, 2005</a>].) Initially, the kernel sets things up so that the page-table entries for these segments refer to the same physical memory pages as the corresponding page-table entries in the parent, and the pages themselves are marked read-only. After the <em>fork()</em>, the kernel traps any attempts by either the parent or the child to modify one of these pages, and makes a duplicate copy of the about-to-be-modified page. This new page copy is assigned to the faulting process, and the corresponding page-table entry for the other process is adjusted appropriately. From this point on, the parent and child can each modify their private copies of the page, without the changes being visible to the other process. <a href="ch24.xhtml#ch24fig3">Figure 24-3</a> illustrates the copy-on-write technique.</p>
<div class="image"><img src="../images/f24-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch24fig3"/><strong>Figure 24-3:</strong> Page tables before and after modification of a shared copy-on-write page</p>
<h5 class="h5" id="ch24lev3sec01"><strong>Controlling a process&#8217;s memory footprint</strong></h5>
<p class="noindenta">We can combine the use of <em>fork()</em> and <em>wait()</em> to control the memory footprint of a process. The process&#8217;s memory footprint is the range of virtual memory pages used by the process, as affected by factors such as the adjustment of the stack as functions <span epub:type="pagebreak" id="page_522"/>are called and return, calls to <em>exec()</em>, and, of particular interest to this discussion, modification of the heap as a consequence of calls to <em>malloc()</em> and <em>free()</em>.</p>
<p class="indentb">Suppose that we bracket a call to some function, <em>func()</em>, using <em>fork()</em> and <em>wait()</em> in the manner shown in <a href="ch24.xhtml#ch24ex3">Listing 24-3</a>. After executing this code, we know that the memory footprint of the parent is unchanged from the point before <em>func()</em> was called, since all possible changes will have occurred in the child process. This can be useful for the following reasons:</p>
<p class="bull">&#8226; If we know that <em>func()</em> causes memory leaks or excessive fragmentation of the heap, this technique eliminates the problem. (We might not otherwise be able to deal with these problems if we don&#8217;t have access to the source code of <em>func()</em>.)</p>
<p class="bull">&#8226; Suppose that we have some algorithm that performs memory allocation while doing a tree analysis (for example, a game program that analyzes a range of possible moves and their responses). We could code such a program to make calls to <em>free()</em> to deallocate all of the allocated memory. However, in some cases, it is simpler to employ the technique we describe here in order to allow us to backtrack, leaving the caller (the parent) with its original memory footprint unchanged.</p>
<p class="noindentt">In the implementation shown in <a href="ch24.xhtml#ch24ex3">Listing 24-3</a>, the result of <em>func()</em> must be expressed in the 8 bits that <em>exit()</em> passes from the terminating child to the parent calling <em>wait()</em>. However, we could employ a file, a pipe, or some other interprocess communication technique to allow <em>func()</em> to return larger results.</p>
<p class="examplet"><a id="ch24ex3"/><strong>Listing 24-3:</strong> Calling a function without changing the process&#8217;s memory footprint</p>
<p class="programsli">__________________________________________________ <span class="font1">from</span> <span class="codestrong">procexec/footprint.c</span><br/><br/>&#160;&#160;&#160;&#160;pid_t childPid;<br/>&#160;&#160;&#160;&#160;int status;<br/><br/>&#160;&#160;&#160;&#160;childPid = fork();<br/>&#160;&#160;&#160;&#160;if (childPid == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;if (childPid == 0)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child calls func() and */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(func(arg));&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* uses return value as exit status */<br/><br/>&#160;&#160;&#160;&#160;/* Parent waits for child to terminate. It can determine the<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;result of func() by inspecting 'status'. */<br/><br/>&#160;&#160;&#160;&#160;if (wait(&#38;status) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("wait");<br/>__________________________________________________ <span class="font1">from</span> <span class="codestrong">procexec/footprint.c</span></p>
<h3 class="h3" id="ch24lev1sec03"><strong>24.3 The <em>vfork()</em> System Call</strong></h3>
<p class="noindenta">Early BSD implementations were among those in which <em>fork()</em> performed a literal duplication of the parent&#8217;s data, heap, and stack. As noted earlier, this is wasteful, especially if the <em>fork()</em> is followed by an immediate <em>exec()</em>. For this reason, later versions of BSD introduced the <em>vfork()</em> system call, which was far more efficient than BSD&#8217;s <em>fork()</em>, although it operated with slightly different (in fact, somewhat strange) semantics. <span epub:type="pagebreak" id="page_523"/>Modern UNIX implementations employing copy-on-write for implementing <em>fork()</em> are much more efficient than older <em>fork()</em> implementations, thus largely eliminating the need for <em>vfork()</em>. Nevertheless, Linux (like many other UNIX implementations) provides a <em>vfork()</em> system call with BSD semantics for programs that require the fastest possible fork. However, because the unusual semantics of <em>vfork()</em> can lead to some subtle program bugs, its use should normally be avoided, except in the rare cases where it provides worthwhile performance gains.</p>
<p class="indent">Like <em>fork()</em>, <em>vfork()</em> is used by the calling process to create a new child process. However, <em>vfork()</em> is expressly designed to be used in programs where the child performs an immediate <em>exec()</em> call.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>pid_t <span class="codestrong">vfork</span>(void);</p>
<p class="right">In parent: returns process ID of child on success, or &#8211;1 on error; in successfully created child: always returns 0</p>
</div>
<p class="noindentb">Two features distinguish the <em>vfork()</em> system call from <em>fork()</em> and make it more efficient:</p>
<p class="bull">&#8226; No duplication of virtual memory pages or page tables is done for the child process. Instead, the child shares the parent&#8217;s memory until it either performs a successful <em>exec()</em> or calls <em>_exit()</em> to terminate.</p>
<p class="bull">&#8226; Execution of the parent process is suspended until the child has performed an <em>exec()</em> or <em>_exit()</em>.</p>
<p class="noindentt">These points have some important implications. Since the child is using the parent&#8217;s memory, any changes made by the child to the data, heap, or stack segments will be visible to the parent once it resumes. Furthermore, if the child performs a function return between the <em>vfork()</em> and a later <em>exec()</em> or <em>_exit()</em>, this will also affect the parent. This is similar to the example described in <a href="ch06.xhtml#ch06lev1sec08">Section 6.8</a> of trying to <em>longjmp()</em> into a function from which a return has already been performed. Similar chaos&#8212;typically a segmentation fault (<span class="literal">SIGSEGV</span>)&#8212;is likely to result.</p>
<p class="indent">There are a few things that the child process can do between <em>vfork()</em> and <em>exec()</em> without affecting the parent. Among these are operations on open file descriptors (but not <em>stdio</em> file streams). Since the file descriptor table for each process is maintained in kernel space (<a href="ch05.xhtml#ch05lev1sec04">Section 5.4</a>) and is duplicated during <em>vfork()</em>, the child process can perform file descriptor operations without affecting the parent.</p>
<div class="block">
<p class="noindent">SUSv3 says that the behavior of a program is undefined if it: a) modifies any data other than a variable of type <em>pid_t</em> used to store the return value of <em>vfork()</em>; b) returns from the function in which <em>vfork()</em> was called; or c) calls any other function before successfully calling <em>_exit()</em> or performing an <em>exec()</em>.</p>
<p class="indent">When we look at the <em>clone()</em> system call in <a href="ch28.xhtml#ch28lev1sec02">Section 28.2</a>, we&#8217;ll see that a child created using <em>fork()</em> or <em>vfork()</em> also obtains its own copies of a few other process attributes.</p>
</div>
<p class="noindent">The semantics of <em>vfork()</em> mean that after the call, the child is guaranteed to be scheduled for the CPU before the parent. In <a href="ch24.xhtml#ch24lev1sec02">Section 24.2</a>, we noted that this is not a guarantee made by <em>fork()</em>, after which either the parent or the child may be scheduled first.</p>
<p class="indent"><span epub:type="pagebreak" id="page_524"/><a href="ch24.xhtml#ch24ex4">Listing 24-4</a> shows the use of <em>vfork()</em>, demonstrating both of the semantic features that distinguish it from <em>fork()</em>: the child shares the parent&#8217;s memory, and the parent is suspended until the child terminates or calls <em>exec()</em>. When we run this program, we see the following output:</p>
<p class="programs">$ <span class="codestrong">./t_vfork</span><br/>Child executing&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Even though child slept, parent was not scheduled</span><br/>Parent executing<br/>istack=666</p>
<p class="noindent">From the last line of output, we can see that the change made by the child to the variable <em>istack</em> was performed on the parent&#8217;s variable.</p>
<p class="examplet"><a id="ch24ex4"/><strong>Listing 24-4:</strong> Using <em>vfork()</em></p>
<p class="programsli">________________________________________________________<span class="codestrong">procexec/t_vfork.c</span><br/><br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int istack = 222;<br/><br/>&#160;&#160;&#160;&#160;switch (vfork()) {<br/>&#160;&#160;&#160;&#160;case -1:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("vfork");<br/><br/>&#160;&#160;&#160;&#160;case 0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child executes first, in parent's memory space */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep(3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Even if we sleep for a while,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;parent still is not scheduled */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;write(STDOUT_FILENO, "Child executing\n", 16);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;istack *= 3;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* This change will be seen by parent */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_exit(EXIT_SUCCESS);<br/><br/>&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent is blocked until child exits */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;write(STDOUT_FILENO, "Parent executing\n", 17);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("istack=%d\n", istack);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>________________________________________________________<span class="codestrong">procexec/t_vfork.c</span></p>
<p class="noindent">Except where speed is absolutely critical, new programs should avoid the use of <em>vfork()</em> in favor of <em>fork()</em>. This is because, when <em>fork()</em> is implemented using copy-on-write semantics (as is done on most modern UNIX implementations), it approaches the speed of <em>vfork()</em>, and we avoid the eccentric behaviors associated with <em>vfork()</em> described above. (We show some speed comparisons between <em>fork()</em> and <em>vfork()</em> in <a href="ch28.xhtml#ch28lev1sec03">Section 28.3</a>.)</p>
<p class="indent">SUSv3 marks <em>vfork()</em> as obsolete, and SUSv4 goes further, removing the specification of <em>vfork()</em>. SUSv3 leaves many details of the operation of <em>vfork()</em> unspecified, allowing the possibility that it is implemented as a call to <em>fork()</em>. When implemented in this manner, the BSD semantics for <em>vfork()</em> are not preserved. Some UNIX systems do indeed implement <em>vfork()</em> as a call to <em>fork()</em>, and Linux also did this in kernel 2.0 and earlier.</p>
<p class="indent"><span epub:type="pagebreak" id="page_525"/>Where it is used, <em>vfork()</em> should generally be immediately followed by a call to <em>exec()</em>. If the <em>exec()</em> call fails, the child process should terminate using <em>_exit()</em>. (The child of a <em>vfork()</em> should not terminate by calling <em>exit()</em>, since that would cause the parent&#8217;s <em>stdio</em> buffers to be flushed and closed. We go into more detail on this point in <a href="ch25.xhtml#ch25lev1sec04">Section 25.4</a>.)</p>
<p class="indent">Other uses of <em>vfork()</em>&#8212;in particular, those relying on its unusual semantics for memory sharing and process scheduling&#8212;are likely to render a program nonportable, especially to implementations where <em>vfork()</em> is implemented simply as a call to <em>fork()</em>.</p>
<h3 class="h3" id="ch24lev1sec04"><strong>24.4 Race Conditions After <em>fork()</em></strong></h3>
<p class="noindenta">After a <em>fork()</em>, it is indeterminate which process&#8212;the parent or the child&#8212;next has access to the CPU. (On a multiprocessor system, they may both simultaneously get access to a CPU.) Applications that implicitly or explicitly rely on a particular sequence of execution in order to achieve correct results are open to failure due to <em>race conditions</em>, which we described in <a href="ch05.xhtml#ch05lev1sec01">Section 5.1</a>. Such bugs can be hard to find, as their occurrence depends on scheduling decisions that the kernel makes according to system load.</p>
<p class="indent">We can use the program in <a href="ch24.xhtml#ch24ex5">Listing 24-5</a> to demonstrate this indeterminacy. This program loops, using <em>fork()</em> to create multiple children. After each <em>fork()</em>, both parent and child print a message containing the loop counter value and a string indicating whether the process is the parent or child. For example, if we asked the program to produce just one child, we might see the following:</p>
<p class="programs">$ <span class="codestrong">./fork_whos_on_first 1</span><br/>0 parent<br/>0 child</p>
<p class="noindent">We can use this program to create a large number of children, and then analyze the output to see whether the parent or the child is the first to print its message each time. Analyzing the results when using this program to create 1 million children on a Linux/x86-32 2.2.19 system showed that the parent printed its message first in all but 332 cases (i.e., in 99.97% of the cases).</p>
<div class="block">
<p class="noindent">The results from running the program in <a href="ch24.xhtml#ch24ex5">Listing 24-5</a> were analyzed using the script <span class="literal">procexec/fork_whos_on_first.count.awk</span>, which is provided in the source code distribution for this book.</p>
</div>
<p class="noindent">From these results, we may surmise that, on Linux 2.2.19, execution always continues with the parent process after a <em>fork()</em>. The reason that the child occasionally printed its message first was that, in 0.03% of cases, the parent&#8217;s CPU time slice ran out before it had time to print its message. In other words, if this example represented a case where we were relying on the parent to always be scheduled first after <em>fork()</em>, then things would usually go right, but one time out of every 3000, things would go wrong. Of course, if the application expected that the parent should be able to carry out a larger piece of work before the child was scheduled, the possibility of things going wrong would be greater. Trying to debug such errors in a complex program can be difficult.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_526"/><a id="ch24ex5"/><strong>Listing 24-5:</strong> Parent and child race to write a message after <em>fork()</em></p>
<p class="programsli">______________________________________________ <span class="codestrong">procexec/fork_whos_on_first.c</span><br/><br/>#include &lt;sys/wait.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int numChildren, j;<br/>&#160;&#160;&#160;&#160;pid_t childPid;<br/><br/>&#160;&#160;&#160;&#160;if (argc &gt; 1 &#38;&#38; strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s [num-children]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;numChildren = (argc &gt; 1) ? getInt(argv[1], GN_GT_0, "num-children") : 1;<br/><br/>&#160;&#160;&#160;&#160;setbuf(stdout, NULL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Make stdout unbuffered */<br/><br/>&#160;&#160;&#160;&#160;for (j = 0; j &lt; numChildren; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (childPid = fork()) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case -1:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 0:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%d child\n", j);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_exit(EXIT_SUCCESS);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%d parent\n", j);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;wait(NULL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for child to terminate */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>______________________________________________ <span class="codestrong">procexec/fork_whos_on_first.c</span></p>
<p class="noindent">Although Linux 2.2.19 always continues execution with the parent after a <em>fork()</em>, we can&#8217;t rely on this being the case on other UNIX implementations, or even across different versions of the Linux kernel. During the 2.4 stable kernel series, experiments were briefly made with a &#8220;child first after <em>fork()</em>&#8221; patch, which completely reverses the results obtained from 2.2.19. Although this change was later dropped from the 2.4 kernel series, it was subsequently adopted in Linux 2.6. Thus, programs that assume the 2.2.19 behavior would be broken by the 2.6 kernel.</p>
<p class="indent">Some more recent experiments reversed the kernel developers&#8217; assessment of whether it was better to run the child or the parent first after <em>fork()</em>, and, since Linux 2.6.32, it is once more the parent that is, by default, run first after a <em>fork()</em>. This default can be changed by assigning a nonzero value to the Linux-specific <span class="literal">/proc/sys/kernel/sched_child_runs_first</span> file.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_527"/>To see the argument for the &#8220;children first after <em>fork()</em>&#8221; behavior, consider what happens with copy-on-write semantics when the child of a <em>fork()</em> performs an immediate <em>exec()</em>. In this case, as the parent carries on after the <em>fork()</em> to modify data and stack pages, the kernel duplicates the to-be-modified pages for the child. Since the child performs an <em>exec()</em> as soon as it is scheduled to run, this duplication is wasted. According to this argument, it is better to schedule the child first, so that by the time the parent is next scheduled, no page copying is required. Using the program in <a href="ch24.xhtml#ch24ex5">Listing 24-5</a> to create 1 million child processes on one busy Linux/x86-32 system running kernel 2.6.30 showed that, in 99.98% of cases, the child process displayed its message first. (The precise percentage depends on factors such as system load.) Testing this program on other UNIX implementations showed wide variation in the rules that govern which process runs first after <em>fork()</em>.</p>
<p class="indent">The argument for switching back to &#8220;parent first after <em>fork()</em>&#8221; in Linux 2.6.32 was based on the observation that, after a <em>fork()</em>, the parent&#8217;s state is already active in the CPU and its memory-management information is already cached in the hardware memory management unit&#8217;s translation look-aside buffer (TLB). Therefore, running the parent first should result in better performance. This was informally verified by measuring the time required for kernel builds under the two behaviors.</p>
<p class="indent">In conclusion, it is worth noting that the performance differences between the two behaviors are rather small, and won&#8217;t affect most applications.</p>
</div>
<p class="noindent">From the preceding discussion, it is clear that we can&#8217;t assume a particular order of execution for the parent and child after a <em>fork()</em>. If we need to guarantee a particular order, we must use some kind of synchronization technique. We describe several synchronization techniques in later chapters, including semaphores, file locks, and sending messages between processes using pipes. One other method, which we describe next, is to use signals.</p>
<h3 class="h3" id="ch24lev1sec05"><strong>24.5 Avoiding Race Conditions by Synchronizing with Signals</strong></h3>
<p class="noindenta">After a <em>fork()</em>, if either process needs to wait for the other to complete an action, then the active process can send a signal after completing the action; the other process waits for the signal.</p>
<p class="indent"><a href="ch24.xhtml#ch24ex6">Listing 24-6</a> demonstrates this technique. In this program, we assume that it is the parent that must wait on the child to carry out some action. The signal-related calls in the parent and child can be swapped if the child must wait on the parent. It is even possible for both parent and child to signal each other multiple times in order to coordinate their actions, although, in practice, such coordination is more likely to be done using semaphores, file locks, or message passing.</p>
<div class="block">
<p class="noindent">[<a href="bib.xhtml#bib94">Stevens &#38; Rago, 2005</a>] suggests encapsulating such synchronization steps (block signal, send signal, catch signal) into a standard set of functions for process synchronization. The advantage of such encapsulation is that we can then later replace the use of signals by another IPC mechanism, if desired.</p>
</div>
<p class="noindent">Note that we block the synchronization signal (<span class="literal">SIGUSR1</span>) before the <em>fork()</em> call in <a href="ch24.xhtml#ch24ex6">Listing 24-6</a>. If the parent tried blocking the signal after the <em>fork()</em>, it would remain vulnerable to the very race condition we are trying to avoid. (In this program, we <span epub:type="pagebreak" id="page_528"/>assume that the state of the signal mask in the child is irrelevant; if necessary, we can unblock <span class="literal">SIGUSR1</span> in the child after the <em>fork()</em>.)</p>
<p class="indent">The following shell session log shows what happens when we run the program in <a href="ch24.xhtml#ch24ex6">Listing 24-6</a>:</p>
<p class="programs">$ <span class="codestrong">./fork_sig_sync</span><br/>[17:59:02 5173] Child started - doing some work<br/>[17:59:02 5172] Parent about to wait for signal<br/>[17:59:04 5173] Child about to signal parent<br/>[17:59:04 5172] Parent got signal</p>
<p class="examplet"><a id="ch24ex6"/><strong>Listing 24-6:</strong> Using signals to synchronize process actions</p>
<p class="programsli">__________________________________________________ <span class="codestrong">procexec/fork_sig_sync.c</span><br/><br/>#include &lt;signal.h&gt;<br/>#include "curr_time.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declaration of currTime() */<br/>#include "tlpi_hdr.h"<br/><br/>#define SYNC_SIG SIGUSR1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Synchronization signal */<br/><br/>static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Signal handler - does nothing but return */<br/>handler(int sig)<br/>{<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;pid_t childPid;<br/>&#160;&#160;&#160;&#160;sigset_t blockMask, origMask, emptyMask;<br/>&#160;&#160;&#160;&#160;struct sigaction sa;<br/><br/>&#160;&#160;&#160;&#160;setbuf(stdout, NULL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Disable buffering of stdout */<br/><br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;blockMask);<br/>&#160;&#160;&#160;&#160;sigaddset(&#38;blockMask, SYNC_SIG);&#160;&#160;&#160;&#160;/* Block signal */<br/>&#160;&#160;&#160;&#160;if (sigprocmask(SIG_BLOCK, &#38;blockMask, &#38;origMask) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask");<br/><br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;sa.sa_flags = SA_RESTART;<br/>&#160;&#160;&#160;&#160;sa.sa_handler = handler;<br/>&#160;&#160;&#160;&#160;if (sigaction(SYNC_SIG, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;switch (childPid = fork()) {<br/>&#160;&#160;&#160;&#160;case -1:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;case 0: /* Child */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child does some required action here... */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("[%s %ld] Child started - doing some work\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;currTime("%T"), (long) getpid());<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep(2);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Simulate time spent doing some work */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* And then signals parent that it's done */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("[%s %ld] Child about to signal parent\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;currTime("%T"), (long) getpid());<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (kill(getppid(), SYNC_SIG) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("kill");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Now child can do other things... */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_exit(EXIT_SUCCESS);<br/><br/>&#160;&#160;&#160;&#160;default: /* Parent */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent may do some work here, and then waits for child to<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;complete the required action */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("[%s %ld] Parent about to wait for signal\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;currTime("%T"), (long) getpid());<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;emptyMask);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigsuspend(&#38;emptyMask) == -1 &#38;&#38; errno != EINTR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigsuspend");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("[%s %ld] Parent got signal\n", currTime("%T"), (long) getpid());<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If required, return signal mask to its original state */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigprocmask(SIG_SETMASK, &#38;origMask, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent carries on to do other things... */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>__________________________________________________ <span class="codestrong">procexec/fork_sig_sync.c</span></p>
<h3 class="h3" id="ch24lev1sec06"><span epub:type="pagebreak" id="page_529"/><strong>24.6 Summary</strong></h3>
<p class="noindenta">The <em>fork()</em> system call creates a new process (the child) by making an almost exact duplicate of the calling process (the parent). The <em>vfork()</em> system call is a more efficient version of <em>fork()</em>, but is usually best avoided because of its unusual semantics, whereby the child uses the parent&#8217;s memory until it either performs an <em>exec()</em> or terminates; in the meantime, execution of the parent process is suspended.</p>
<p class="indent">After a <em>fork()</em> call, we can&#8217;t rely on the order in which the parent and the child are next scheduled to use the CPU(s). Programs that make assumptions about the order of execution are susceptible to errors known as race conditions. Because the occurrence of such errors depends on external factors such as system load, they can be difficult to find and debug.</p>
<h5 class="h5" id="ch24lev3sec02"><span epub:type="pagebreak" id="page_530"/><strong>Further information</strong></h5>
<p class="noindenta">[<a href="bib.xhtml#bib04">Bach, 1986</a>] and [<a href="bib.xhtml#bib35">Goodheart &#38; Cox, 1994</a>] provide details of the implementation of <em>fork()</em>, <em>execve()</em>, <em>wait()</em>, and <em>exit()</em> on UNIX systems. [<a href="bib.xhtml#bib09">Bovet &#38; Cesati, 2005</a>] and [<a href="bib.xhtml#bib59">Love, 2010</a>] provide Linux-specific implementation details of process creation and termination.</p>
<h3 class="h3" id="ch24lev1sec07"><strong>24.7 Exercises</strong></h3>
<p class="exer"><a id="ch24exe1"/><strong>24-1.</strong>&#160;&#160;&#160;After a program executes the following series of <em>fork()</em> calls, how many new processes will result (assuming that none of the calls fails)?</p>
<p class="programs1">fork();<br/>fork();<br/>fork();</p>
<p class="exer"><a id="ch24exe2"/><strong>24-2.</strong>&#160;&#160;&#160;Write a program to demonstrate that after a <em>vfork()</em>, the child process can close a file descriptor (e.g., descriptor 0) without affecting the corresponding file descriptor in the parent.</p>
<p class="exer"><a id="ch24exe3"/><strong>24-3.</strong>&#160;&#160;&#160;Assuming that we can modify the program source code, how could we get a core dump of a process at a given point in the program, while letting the process continue execution?</p>
<p class="exer"><a id="ch24exe4"/><strong>24-4.</strong>&#160;&#160;&#160;Experiment with the program in <a href="ch24.xhtml#ch24ex5">Listing 24-5</a> (<span class="literal">fork_whos_on_first.c</span>) on other UNIX implementations to determine how these implementations schedule the parent and child processes after a <em>fork()</em>.</p>
<p class="exer"><a id="ch24exe5"/><strong>24-5.</strong>&#160;&#160;&#160;Suppose that in the program in <a href="ch24.xhtml#ch24ex6">Listing 24-6</a>, the child process also needed to wait on the parent to complete some actions. What changes to the program would be required in order to enforce this?</p>
</body>
</html>
