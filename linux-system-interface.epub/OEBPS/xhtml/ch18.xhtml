<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch18"><span epub:type="pagebreak" id="page_339"/><strong><span class="big">18</span></strong><br/><strong>DIRECTORIES AND LINKS</strong></h2>
<p class="noindenta">In this chapter, we conclude our discussion of file-related topics by looking at directories and links. After an overview of their implementation, we describe the system calls used to create and remove directories and links. We then look at library functions that allow a program to scan the contents of a single directory and to walk through (i.e., examine each file in) a directory tree.</p>
<p class="indent">Each process has two directory-related attributes: a root directory, which determines the point from which absolute pathnames are interpreted, and a current working directory, which determines the point from which relative pathnames are interpreted. We look at the system calls that allow a process to change both of these attributes.</p>
<p class="indent">We finish the chapter with a discussion of library functions that are used to resolve pathnames and to parse them into directory and filename components.</p>
<h3 class="h3" id="ch18lev1sec01"><strong>18.1 Directories and (Hard) Links</strong></h3>
<p class="noindentab">A <em>directory</em> is stored in the file system in a similar way to a regular file. Two things distinguish a directory from a regular file:</p>
<p class="bull">&#8226; A directory is marked with a different file type in its i-node entry (<a href="ch14.xhtml#ch14lev1sec04">Section 14.4</a>).</p>
<p class="bull">&#8226; A directory is a file with a special organization. Essentially, it is a table consisting of filenames and i-node numbers.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_340"/>On most native Linux file systems, filenames can be up to 255 characters long. The relationship between directories and i-nodes is illustrated in <a href="ch18.xhtml#ch18fig1">Figure 18-1</a>, which shows the partial contents of the file system i-node table and relevant directory files that are maintained for an example file (<span class="literal">/etc/passwd</span>).</p>
<div class="block">
<p class="noindent">Although a process can open a directory, it can&#8217;t use <em>read()</em> to read the contents of a directory. To retrieve the contents of a directory, a process must instead use the system calls and library functions discussed later in this chapter. (On some UNIX implementations, it is possible to perform a <em>read()</em> on a directory, but this is not portable.) Nor can a process directly change a directory&#8217;s contents with <em>write()</em>; it can only indirectly (i.e., request the kernel to) change the contents using system calls such as <em>open()</em> (to create a new file), <em>link()</em>, <em>mkdir()</em>, <em>symlink()</em>, <em>unlink()</em>, and <em>rmdir()</em>. (All of these system calls are described later in this chapter, except <em>open()</em>, which was described in <a href="ch04.xhtml#ch04lev1sec03">Section 4.3</a>.)</p>
<p class="indent">The i-node table is numbered starting at 1, rather than 0, because 0 in the i-node field of a directory entry indicates that the entry is unused. I-node 1 is used to record bad blocks in the file system. The root directory (<span class="literal">/</span>) of a file system is always stored in i-node entry 2 (as shown in <a href="ch18.xhtml#ch18fig1">Figure 18-1</a>), so that the kernel knows where to start when resolving a pathname.</p>
</div>
<div class="image"><img src="../images/f18-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch18fig1"/><strong>Figure 18-1:</strong> Relationship between i-node and directory structures for the file <span class="literal">/etc/passwd</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_341"/>If we review the list of information stored in a file i-node (<a href="ch14.xhtml#ch14lev1sec04">Section 14.4</a>), we see that the i-node doesn&#8217;t contain a filename; it is only the mapping within a directory list that defines the name of a file. This has a useful consequence: we can create multiple names&#8212;in the same or in different directories&#8212;each of which refers to the same i-node. These multiple names are known as <em>links</em>, or sometimes as <em>hard links</em> to distinguish them from symbolic links, which we discuss shortly.</p>
<div class="block">
<p class="noindent">All native Linux and UNIX file systems support hard links. However, many non-UNIX file systems (e.g., Microsoft&#8217;s VFAT) do not. (Microsoft&#8217;s NTFS file system does support hard links.)</p>
</div>
<p class="noindent">From the shell, we can create new hard links to an existing file using the <em>ln</em> command, as shown in the following shell session log:</p>
<p class="programs">$ <span class="codestrong">echo -n 'It is good to collect things,' &gt; abc</span><br/>$ <span class="codestrong">ls -li abc</span><br/>&#160;122232 -rw-r--r--&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;29 Jun 15 17:07 abc<br/>$ <span class="codestrong">ln abc xyz</span><br/>$ <span class="codestrong">echo ' but it is better to go on walks.' &gt;&gt; xyz</span><br/>$ <span class="codestrong">cat abc</span><br/>It is good to collect things, but it is better to go on walks.<br/>$ <span class="codestrong">ls -li abc xyz</span><br/>&#160;122232 -rw-r--r--&#160;&#160;&#160;2 mtk&#160;&#160;&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;63 Jun 15 17:07 abc<br/>&#160;122232 -rw-r--r--&#160;&#160;&#160;2 mtk&#160;&#160;&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;63 Jun 15 17:07 xyz</p>
<p class="noindent">The i-node numbers displayed (as the first column) by <em>ls &#8211;li</em> confirm what was already clear from the output of the <em>cat</em> command: the names <span class="literal">abc</span> and <span class="literal">xyz</span> refer to the same i-node entry, and hence to the same file. In the third field displayed by <em>ls &#8211;li</em>, we can see the link count for the i-node. After the <em>ln abc xyz</em> command, the link count of the i-node referred to by <span class="literal">abc</span> has risen to 2, since there are now two names referring to the file. (The same link count is displayed for the file <span class="literal">xyz</span>, since it refers to the same i-node.)</p>
<p class="indent">If one of these filenames is removed, the other name, and the file itself, continue to exist:</p>
<p class="programs">$ <span class="codestrong">rm abc</span><br/>$ <span class="codestrong">ls -li xyz</span><br/>&#160;122232 -rw-r--r--&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;63 Jun 15 17:07 xyz</p>
<p class="noindent">The i-node entry and data blocks for the file are removed (deallocated) only when the i-node&#8217;s link count falls to 0&#8212;that is, when all of the names for the file have been removed. To summarize: the <em>rm</em> command removes a filename from a directory list, decrements the link count of the corresponding i-node by 1, and, if the link count thereby falls to 0, deallocates the i-node and the data blocks to which it refers.</p>
<p class="indent">All of the names (links) for a file are equivalent&#8212;none of the names (e.g., the first) has priority over any of the others. As we saw in the above example, after the first name associated with the file was removed, the physical file continued to exist, but it was then accessible only by the other name.</p>
<p class="indent">A question often asked in online forums is &#8220;How can I find the filename associated with the file descriptor X in my program?&#8221; The short answer is that we can&#8217;t&#8212;at <span epub:type="pagebreak" id="page_342"/>least not portably and unambiguously&#8212;since a file descriptor refers to an i-node, and multiple filenames (or even, as described in <a href="ch18.xhtml#ch18lev1sec03">Section 18.3</a>, none at all) may refer to this i-node.</p>
<div class="block">
<p class="noindent">On Linux, we can see which files a process currently has open by using <em>readdir()</em> (<a href="ch18.xhtml#ch18lev1sec08">Section 18.8</a>) to scan the contents of the Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/fd</span> directory, which contains symbolic links for each of the file descriptors currently opened by the process. The <em>lsof(1)</em> and <em>fuser(1)</em> tools, which have been ported to many UNIX systems, can also be useful in this regard.</p>
</div>
<p class="noindentb">Hard links have two limitations, both of which can be circumvented by the use of symbolic links:</p>
<p class="bull">&#8226; Because directory entries (hard links) refer to files using just an i-node number, and i-node numbers are unique only within a file system, a hard link must reside on the same file system as the file to which it refers.</p>
<p class="bull">&#8226; A hard link can&#8217;t be made to a directory. This prevents the creation of circular links, which would confuse many system programs.</p>
<div class="block">
<p class="noindent">Early UNIX implementations permitted the superuser to create hard links to directories. This was necessary because these implementations did not provide a <em>mkdir()</em> system call. Instead, a directory was created using <em>mknod()</em>, and then links for the <span class="literal">.</span> and <span class="literal">..</span> entries were created ([<a href="bib.xhtml#bib104">Vahalia, 1996</a>]). Although this feature is no longer needed, some modern UNIX implementations retain it for backward compatibility.</p>
<p class="indent">An effect similar to hard links on directories can be achieved using bind mounts (<a href="ch14.xhtml#ch14lev2sec06">Section 14.9.4</a>).</p>
</div>
<h3 class="h3" id="ch18lev1sec02"><strong>18.2 Symbolic (Soft) Links</strong></h3>
<p class="noindenta">A <em>symbolic link</em>, also sometimes called a <em>soft link</em>, is a special file type whose data is the name of another file. <a href="ch18.xhtml#ch18fig2">Figure 18-2</a> illustrates the situation where two hard links, <span class="literal">/home/erena/this</span> and <span class="literal">/home/allyn/that</span>, refer to the same file, and a symbolic link, <span class="literal">/home/kiran/other</span>, refers to the name <span class="literal">/home/erena/this</span>.</p>
<p class="indent">From the shell, symbolic links are created using the <em>ln &#8211;s</em> command. The <em>ls &#8211;F</em> command displays a trailing <span class="literal">@</span> character at the end of symbolic links.</p>
<p class="indent">The pathname to which a symbolic link refers may be either absolute or relative. A relative symbolic link is interpreted relative to the location of the link itself.</p>
<p class="indent">Symbolic links don&#8217;t have the same status as hard links. In particular, a symbolic link is not included in the link count of the file to which it refers. (Thus, the link count of i-node 61 in <a href="ch18.xhtml#ch18fig2">Figure 18-2</a> is 2, not 3.) Therefore, if the filename to which the symbolic link refers is removed, the symbolic link itself continues to exist, even though it can no longer be dereferenced (followed). We say that it has become a <em>dangling link</em>. It is even possible to create a symbolic link to a filename that doesn&#8217;t exist at the time the link is created.</p>
<div class="block">
<p class="noindent">Symbolic links were introduced by 4.2BSD. Although they were not included in POSIX.1-1990, they were subsequently incorporated into SUSv1, and thus are in SUSv3.</p>
</div>
<div class="image"><span epub:type="pagebreak" id="page_343"/><img src="../images/f18-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch18fig2"/><strong>Figure 18-2:</strong> Representation of hard and symbolic links</p>
<p class="noindent">Since a symbolic link refers to a filename, rather than an i-node number, it can be used to link to a file in a different file system. Symbolic links also do not suffer the other limitation of hard links: we can create symbolic links to directories. Tools such as <em>find</em> and <em>tar</em> can tell the difference between hard and symbolic links, and either don&#8217;t follow symbolic links by default, or avoid getting trapped in circular references created using symbolic links.</p>
<p class="indent">It is possible to chain symbolic links (e.g., <span class="literal">a</span> is a symbolic link to <span class="literal">b</span>, which is a symbolic link to <span class="literal">c</span>). When a symbolic link is specified in various file-related system calls, the kernel dereferences the series of links to arrive at the final file.</p>
<p class="indent">SUSv3 requires that an implementation allow at least <span class="literal">_POSIX_SYMLOOP_MAX</span> dereferences of each symbolic link component of a pathname. The specified value for <span class="literal">_POSIX_SYMLOOP_MAX</span> is 8. However, before kernel 2.6.18, Linux imposed a limit of 5 dereferences when following a chain of symbolic links. Starting with kernel 2.6.18, Linux implements the SUSv3-specified minimum of 8 dereferences. Linux also imposes a total of 40 dereferences for an entire pathname. These limits are required to prevent extremely long symbolic link chains, as well as symbolic link loops, from causing stack overflows in the kernel code that resolves symbolic links.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_344"/>Some UNIX file systems perform an optimization not mentioned in the main text nor shown in <a href="ch18.xhtml#ch18fig2">Figure 18-2</a>. When the total length of the string forming the symbolic link&#8217;s contents is small enough to fit in the part of the i-node that would normally be used for data pointers, the link string is instead stored there. This saves allocating a disk block and also speeds access to the symbolic link information, since it is retrieved along with the file i-node. For example, <em>ext2</em>, <em>ext3</em>, and <em>ext4</em> employ this technique to fit short symbolic strings into the 60 bytes normally used for data block pointers. In practice, this can be a very effective optimization. Of the 20,700 symbolic links on one system checked by the author, 97% were 60 bytes or smaller.</p>
</div>
<h5 class="h5" id="ch18lev3sec01"><strong>Interpretation of symbolic links by system calls</strong></h5>
<p class="noindenta">Many system calls dereference (follow) symbolic links and thus work on the file to which the link refers. Some system calls don&#8217;t dereference symbolic links, but instead operate directly on the link file itself. As each system call is covered, we describe its behavior with respect to symbolic links. This behavior is also summarized in <a href="ch18.xhtml#ch18table1">Table 18-1</a>.</p>
<p class="indent">In a few cases where it is necessary to have similar functionality for both the file to which a symbolic link refers and for the symbolic link itself, alternative system calls are provided: one that dereferences the link and another that does not, with the latter prefixed by the letter <em>l</em>; for example, <em>stat()</em> and <em>lstat()</em>.</p>
<p class="indent">One point generally applies: symbolic links in the directory part of a pathname (i.e., all of the components preceding the final slash) are always dereferenced. Thus, in the pathname <span class="literal">/somedir/somesubdir/file</span>, <span class="literal">somedir</span> and <span class="literal">somesubdir</span> will always be dereferenced if they are symbolic links, and <span class="literal">file</span> may be dereferenced, depending on the system call to which the pathname is passed.</p>
<div class="block">
<p class="noindent">In <a href="ch18.xhtml#ch18lev1sec11">Section 18.11</a>, we describe a set of system calls, added in Linux 2.6.16, that extend the functionality of some of the interfaces shown in <a href="ch18.xhtml#ch18table1">Table 18-1</a>. For some of these system calls, the behavior with respect to following symbolic links can be controlled by the <em>flags</em> argument to the call.</p>
</div>
<h5 class="h5" id="ch18lev3sec02"><strong>File permissions and ownership for symbolic links</strong></h5>
<p class="noindenta">The ownership and permissions of a symbolic link are ignored for most operations (symbolic links are always created with all permissions enabled). Instead, the ownership and permissions of the file to which the link refers are used in determining whether an operation is permitted. The ownership of a symbolic link is relevant only when the link itself is being removed or renamed in a directory with the sticky permission bit set (<a href="ch15.xhtml#ch15lev2sec09">Section 15.4.5</a>).</p>
<h3 class="h3" id="ch18lev1sec03"><strong>18.3 Creating and Removing (Hard) Links: <em>link()</em> and <em>unlink()</em></strong></h3>
<p class="noindenta">The <em>link()</em> and <em>unlink()</em> system calls create and remove hard links.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">link</span>(const char *<span class="font1">oldpath</span>, const char *<span class="font1">newpath</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="tablecap"><span epub:type="pagebreak" id="page_345"/><a id="ch18table1"/><strong>Table 18-1:</strong> Interpretation of symbolic links by various functions</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Function</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Follows links?</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Notes</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>access()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>acct()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>bind()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">UNIX domain sockets have pathnames</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>chdir()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>chmod()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>chown()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>chroot()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>creat()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>exec()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>getxattr()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>lchown()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>lgetxattr()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>link()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">See <a href="ch18.xhtml#ch18lev1sec03">Section 18.3</a></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>listxattr()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>llistxattr()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>lremovexattr()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>lsetxattr()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>lstat()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>lutimes()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>open()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Unless <span class="literal">O_NOFOLLOW</span> or <span class="literal">O_EXCL | O_CREAT</span> specified</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>opendir()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>pathconf()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>pivot_root()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>quotactl()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>readlink()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>removexattr()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>rename()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Links are not followed in either argument <em>rmdir()</em> Fails with <span class="literal">ENOTDIR</span> if argument is a symbolic link</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>setxattr()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>stat()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>statfs()</em>, <em>statvfs()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>swapon()</em>, <em>swapoff()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>truncate()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>unlink() uselib()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><em>utime()</em>, <em>utimes()</em></p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">&#160;</p></td>
</tr>
</tbody>
</table>
<p class="noindent">Given the pathname of an existing file in <em>oldpath</em>, the <em>link()</em> system call creates a new link, using the pathname specified in <em>newpath</em>. If <em>newpath</em> already exists, it is not overwritten; instead, an error (<span class="literal">EEXIST</span>) results.</p>
<p class="indent">On Linux, the <em>link()</em> system call doesn&#8217;t dereference symbolic links. If <em>oldpath</em> is a symbolic link, then <em>newpath</em> is created as a new hard link to the same symbolic link file. (In other words, <em>newpath</em> is also a symbolic link to the same file to which <em>oldpath</em> refers.) This behavior doesn&#8217;t conform to SUSv3, which says that all functions that perform pathname resolution should dereference symbolic links unless otherwise specified (and there is no exception specified for <em>link()</em>). Most other UNIX <span epub:type="pagebreak" id="page_346"/>implementations behave in the manner specified by SUSv3. One notable exception is Solaris, which provides the same behavior as Linux by default, but provides SUSv3-conformant behavior if appropriate compiler options are used. The upshot of this inconsistency across implementations is that portable applications should avoid specifying a symbolic link for the <em>oldpath</em> argument.</p>
<div class="block">
<p class="noindent">SUSv4 recognizes the inconsistency across existing implementations and specifies that the choice of whether or not <em>link()</em> dereferences symbolic links is implementation-defined. SUSv4 also adds the specification of <em>linkat()</em>, which performs the same task as <em>link()</em>, but has a <em>flags</em> argument that can be used to control whether the call dereferences symbolic links. See <a href="ch18.xhtml#ch18lev1sec11">Section 18.11</a> for further details.</p>
</div>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">unlink</span>(const char *<span class="font1">pathname</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>unlink()</em> system call removes a link (deletes a filename) and, if that is the last link to the file, also removes the file itself. If the link specified in <em>pathname</em> doesn&#8217;t exist, then <em>unlink()</em> fails with the error <span class="literal">ENOENT</span>.</p>
<p class="indent">We can&#8217;t use <em>unlink()</em> to remove a directory; that task requires <em>rmdir()</em> or <em>remove()</em>, which we look at in <a href="ch18.xhtml#ch18lev1sec06">Section 18.6</a>.</p>
<div class="block">
<p class="noindent">SUSv3 says that if <em>pathname</em> specifies a directory, then <em>unlink()</em> should fail with the error <span class="literal">EPERM</span>. However, on Linux, <em>unlink()</em> fails with the error <span class="literal">EISDIR</span> in this case. (LSB explicitly permits this deviation from SUSv3.) A portable application should be prepared to handle either value if checking for this case.</p>
</div>
<p class="noindent">The <em>unlink()</em> system call doesn&#8217;t dereference symbolic links. If <em>pathname</em> is a symbolic link, the link itself is removed, rather than the name to which it points.</p>
<h5 class="h5" id="ch18lev3sec03"><strong>An open file is deleted only when all file descriptors are closed</strong></h5>
<p class="noindenta">In addition to maintaining a link count for each i-node, the kernel also counts open file descriptions for the file (see <a href="ch05.xhtml#ch5fig2">Figure 5-2</a>, on <a href="ch05.xhtml#page_95">page 95</a>). If the last link to a file is removed and any processes hold open descriptors referring to the file, the file won&#8217;t actually be deleted until all of the descriptors are closed. This is a useful feature, because it permits us to unlink a file without needing to worry about whether some other process has it open. (However, we can&#8217;t reattach a name to an open file whose link count has fallen to 0.) In addition, we can perform tricks such as creating and opening a temporary file, unlinking it immediately, and then continuing to use it within our program, relying on the fact that the file is destroyed only when we close the file descriptor&#8212;either explicitly, or implicitly when the program exits. (This is what the <em>tmpfile()</em> function described in <a href="ch05.xhtml#ch05lev1sec12">Section 5.12</a> does.)</p>
<p class="indent">The program in <a href="ch18.xhtml#ch18ex1">Listing 18-1</a> demonstrates that even when the last link to a file is removed, the file is deleted only when all open file descriptors that refer to it are closed.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_347"/><a id="ch18ex1"/><strong>Listing 18-1:</strong> Removing a link with <em>unlink()</em></p>
<p class="programsli">_____________________________________________________ <span class="codestrong">dirs_links/t_unlink.c</span><br/><br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>#define CMD_SIZE 200<br/>#define BUF_SIZE 1024<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int fd, j, numBlocks;<br/>&#160;&#160;&#160;&#160;char shellCmd[CMD_SIZE];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Command to be passed to system() */<br/>&#160;&#160;&#160;&#160;char buf[BUF_SIZE];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Random bytes to write to file */<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s temp-file [num-1kB-blocks] \n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;numBlocks = (argc &gt; 2) ? getInt(argv[2], GN_GT_0, "num-1kB-blocks")<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: 100000;<br/><br/>&#160;&#160;&#160;&#160;fd = open(argv[1], O_WRONLY | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open");<br/><br/>&#160;&#160;&#160;&#160;if (unlink(argv[1]) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Remove filename */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("unlink");<br/><br/>&#160;&#160;&#160;&#160;for (j = 0; j &lt; numBlocks; j++)&#160;&#160;&#160;&#160;&#160;/* Write lots of junk to file */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (write(fd, buf, BUF_SIZE) != BUF_SIZE)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("partial/failed write");<br/><br/>&#160;&#160;&#160;&#160;snprintf(shellCmd, CMD_SIZE, "df -k `dirname %s`", argv[1]);<br/>&#160;&#160;&#160;&#160;system(shellCmd);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* View space used in file system */<br/><br/>&#160;&#160;&#160;&#160;if (close(fd) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* File is now destroyed */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close");<br/>&#160;&#160;&#160;&#160;printf("********** Closed file descriptor\n");<br/><br/>&#160;&#160;&#160;&#160;system(shellCmd);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Review space used in file system */<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_____________________________________________________ <span class="codestrong">dirs_links/t_unlink.c</span></p>
<p class="noindent">The program in <a href="ch18.xhtml#ch18ex1">Listing 18-1</a> accepts two command-line arguments. The first argument identifies the name of a file that the program should create. The program opens this file and then immediately unlinks the filename. Although the filename disappears, the file itself continues to exist. The program then writes random blocks of data to the file. The number of these blocks is specified in the optional second command-line argument of the program. At this point, the program employs the <em>df(1)</em> command to display the amount of space used on the file system. <span epub:type="pagebreak" id="page_348"/>The program then closes the file descriptor, at which the point the file is removed, and uses <em>df(1)</em> once more to show that the amount of disk space in use has decreased. The following shell session demonstrates the use of the program in <a href="ch18.xhtml#ch18ex1">Listing 18-1</a>:</p>
<p class="programs">$ <span class="codestrong">./t_unlink /tmp/tfile 1000000</span><br/>Filesystem&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1K-blocks&#160;&#160;&#160;&#160;&#160;&#160;Used Available Use% Mounted on<br/>/dev/sda10&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5245020&#160;&#160;&#160;3204044&#160;&#160;&#160;2040976&#160;&#160;62% /<br/>********** Closed file descriptor<br/>Filesystem&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1K-blocks&#160;&#160;&#160;&#160;&#160;&#160;Used Available Use% Mounted on<br/>/dev/sda10&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5245020&#160;&#160;&#160;2201128&#160;&#160;&#160;3043892&#160;&#160;42% /</p>
<div class="block">
<p class="noindent">In <a href="ch18.xhtml#ch18ex1">Listing 18-1</a>, we use the <em>system()</em> function to execute a shell command. We describe <em>system()</em> in detail in <a href="ch27.xhtml#ch27lev1sec06">Section 27.6</a>.</p>
</div>
<h3 class="h3" id="ch18lev1sec04"><strong>18.4 Changing the Name of a File: <em>rename()</em></strong></h3>
<p class="noindenta">The <em>rename()</em> system call can be used both to rename a file and to move it into another directory on the same file system.</p>
<div class="box">
<p class="programsa">#include &lt;stdio.h&gt;<br/><br/>int <span class="codestrong">rename</span>(const char *<span class="font1">oldpath</span>, const char *<span class="font1">newpath</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>oldpath</em> argument is an existing pathname, which is renamed to the pathname given in <em>newpath</em>.</p>
<p class="indent">The <em>rename()</em> call just manipulates directory entries; it doesn&#8217;t move file data. Renaming a file doesn&#8217;t affect other hard links to the file, nor does it affect any processes that hold open descriptors for the file, since these descriptors refer to open file descriptions, which (after the <em>open()</em> call) have no connection with filenames.</p>
<p class="indentb">The following rules apply to the use of <em>rename()</em>:</p>
<p class="bull">&#8226; If <em>newpath</em> already exists, it is overwritten.</p>
<p class="bull">&#8226; If <em>newpath</em> and <em>oldpath</em> refer to the same file, then no changes are made (and the call succeeds). This is rather counterintuitive. Following from the previous point, we normally expect that if two filenames <span class="literal">x</span> and <span class="literal">y</span> exist, then the call <em>rename(&#8220;x&#8221;, &#8220;y&#8221;)</em> would remove the name <span class="literal">x</span>. This is not the case if <span class="literal">x</span> and <span class="literal">y</span> are links to the same file.</p>
<div class="block1">
<p class="noindent">The rationale for this rule, which comes from the original BSD implementation, was probably to simplify the checks that the kernel must perform in order to guarantee that calls such as <em>rename(&#8220;x&#8221;, &#8220;x&#8221;)</em>, <em>rename(&#8220;x&#8221;, &#8220;./x&#8221;)</em>, and <em>rename(&#34;x&#34;, &#34;somedir/../x&#34;)</em> don&#8217;t remove the file.</p>
</div>
<p class="bull">&#8226; The <em>rename()</em> system call doesn&#8217;t dereference symbolic links in either of its arguments. If <em>oldpath</em> is a symbolic link, then the symbolic link is renamed. If <em>newpath</em> is a symbolic link, then it is treated as a normal pathname to which <em>oldpath</em> is to be renamed (i.e., the existing <em>newpath</em> symbolic link is removed).</p>
<p class="bull"><span epub:type="pagebreak" id="page_349"/>&#8226; If <em>oldpath</em> refers to a file other than a directory, then <em>newpath</em> can&#8217;t specify the pathname of a directory (the error is <span class="literal">EISDIR</span>). To rename a file to a location inside a directory (i.e., move the file to another directory), <em>newpath</em> must include the new filename. The following call both moves a file into a different directory and changes its name:</p>
<p class="programsbl">rename("sub1/x", "sub2/y");</p>
<p class="bull">&#8226; Specifying the name of a directory in <em>oldpath</em> allows us to rename that directory. In this case, <em>newpath</em> either must not exist or must be the name of an empty directory. If <em>newpath</em> is an existing file or an existing, nonempty directory, then an error results (respectively, <span class="literal">ENOTDIR</span> and <span class="literal">ENOTEMPTY</span>).</p>
<p class="bull">&#8226; If <em>oldpath</em> is a directory, then <em>newpath</em> can&#8217;t contain a directory prefix that is the same as <em>oldpath</em>. For example, we could not rename <span class="literal">/home/mtk</span> to <span class="literal">/home/mtk/bin</span> (the error is <span class="literal">EINVAL</span>).</p>
<p class="bull">&#8226; The files referred to by <em>oldpath</em> and <em>newpath</em> must be on the same file system. This is required because a directory is a list of hard links that refer to i-nodes in the same file system as the directory. As stated earlier, <em>rename()</em> is merely manipulating the contents of directory lists. Attempting to rename a file into a different file system fails with the error <span class="literal">EXDEV</span>. (To achieve the desired result, we must instead copy the contents of the file from one file system to another and then delete the old file. This is what the <em>mv</em> command does in this case.)</p>
<h3 class="h3" id="ch18lev1sec05"><strong>18.5 Working with Symbolic Links: <em>symlink()</em> and <em>readlink()</em></strong></h3>
<p class="noindenta">We now look at the system calls used to create symbolic links and examine their contents.</p>
<p class="indent">The <em>symlink()</em> system call creates a new symbolic link, <em>linkpath</em>, to the pathname specified in <em>filepath</em>. (To remove a symbolic link, we use <em>unlink()</em>.)</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">symlink</span>(const char *<span class="font1">filepath</span>, const char *<span class="font1">linkpath</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">If the pathname given in <em>linkpath</em> already exists, then the call fails (with <em>errno</em> set to <span class="literal">EEXIST</span>). The pathname specified in <em>filepath</em> may be absolute or relative.</p>
<p class="indent">The file or directory named in <em>filepath</em> doesn&#8217;t need to exist at the time of the call. Even if it exists at that time, there is nothing to prevent it from being removed later. In this case, <em>linkpath</em> becomes a <em>dangling link</em>, and attempts to dereference it in other system calls yield an error (usually <span class="literal">ENOENT</span>).</p>
<p class="indent">If we specify a symbolic link as the <em>pathname</em> argument to <em>open()</em>, it opens the file to which the link refers. Sometimes, we would rather retrieve the content of the link itself&#8212;that is, the pathname to which it refers. The <em>readlink()</em> system call performs this task, placing a copy of the symbolic link string in the character array pointed to by <em>buffer</em>.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_350"/>#include &lt;unistd.h&gt;<br/><br/>ssize_t <span class="codestrong">readlink</span>(const char *<span class="font1">pathname</span>, char *<span class="font1">buffer</span>, size_t <span class="font1">bufsiz</span>);</p>
<p class="right">Returns number of bytes placed in <em>buffer</em> on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>bufsiz</em> argument is an integer used to tell <em>readlink()</em> the number of bytes available in <em>buffer</em>.</p>
<p class="indent">If no errors occur, then <em>readlink()</em> returns the number of bytes actually placed in <em>buffer</em>. If the length of the link exceeds <em>bufsiz</em>, then a truncated string is placed in <em>buffer</em> (and <em>readlink()</em> returns the size of that string&#8212;that is, <em>bufsiz</em>).</p>
<p class="indent">Because a terminating null byte is not placed at the end of <em>buffer</em>, there is no way to distinguish the case where <em>readlink()</em> returns a truncated string from that where it returns a string that exactly fills <em>buffer</em>. One way of checking if the latter has occurred is to reallocate a larger <em>buffer</em> array and call <em>readlink()</em> again. Alternatively, we can size <em>buffer</em> using the <span class="literal">PATH_MAX</span> constant (described in <a href="ch11.xhtml#ch11lev1sec01">Section 11.1</a>), which defines the length of the longest pathname that a program should have to accommodate.</p>
<p class="indent">We demonstrate the use of <em>readlink()</em> in <a href="ch18.xhtml#ch18ex4">Listing 18-4</a>.</p>
<div class="block">
<p class="noindent">SUSv3 defined a new limit, <span class="literal">SYMLINK_MAX</span>, that an implementation should define to indicate the maximum number of bytes that can be stored in a symbolic link. This limit is required to be at least 255 bytes. At the time of writing, Linux doesn&#8217;t define this limit. In the main text, we suggest the use of <span class="literal">PATH_MAX</span> because that limit should be at least as large as <span class="literal">SYMLINK_MAX</span>.</p>
<p class="indent">In SUSv2, the return type of <em>readlink()</em> was specified as <em>int</em>, and many current implementations (as well as older <em>glibc</em> versions on Linux) follow that specification. SUSv3 changed the return type to <em>ssize_t</em>.</p>
</div>
<h3 class="h3" id="ch18lev1sec06"><strong>18.6 Creating and Removing Directories: <em>mkdir()</em> and <em>rmdir()</em></strong></h3>
<p class="noindenta">The <em>mkdir()</em> system call creates a new directory.</p>
<div class="box">
<p class="programsa">#include &lt;sys/stat.h&gt;<br/><br/>int <span class="codestrong">mkdir</span>(const char *<span class="font1">pathname</span>, mode_t <span class="font1">mode</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>pathname</em> argument specifies the pathname of the new directory. This pathname may be relative or absolute. If a file with this pathname already exists, then the call fails with the error <span class="literal">EEXIST</span>.</p>
<p class="indent">The ownership of the new directory is set according to the rules described in <a href="ch15.xhtml#ch15lev2sec03">Section 15.3.1</a>.</p>
<p class="indent">The <em>mode</em> argument specifies the permissions for the new directory. (We describe the meanings of the permission bits for directories in <a href="ch15.xhtml#ch15lev2sec03">Sections 15.3.1</a>, <a href="ch15.xhtml#ch15lev2sec04">15.3.2</a>, and <a href="ch15.xhtml#ch15lev2sec09">15.4.5</a>.) This bit-mask value may be specified by ORing (<span class="literal">|</span>) together constants from <a href="ch15.xhtml#ch15table4">Table 15-4</a>, on <a href="ch15.xhtml#page_295">page 295</a>, but, as with <em>open()</em>, it may also be specified as <span epub:type="pagebreak" id="page_351"/>an octal number. The value given in <em>mode</em> is ANDed against the process umask (<a href="ch15.xhtml#ch15lev2sec10">Section 15.4.6</a>). In addition, the set-user-ID bit (<span class="literal">S_ISUID</span>) is always turned off, since it has no meaning for directories.</p>
<p class="indent">If the sticky bit (<span class="literal">S_ISVTX</span>) is set in <em>mode</em>, then it will be set on the new directory.</p>
<p class="indent">The setting of the set-group-ID bit (<span class="literal">S_ISGID</span>) in <em>mode</em> is ignored. Instead, if the set-group-ID bit is set on the parent directory, then it will also be set on the newly created directory. In <a href="ch15.xhtml#ch15lev2sec03">Section 15.3.1</a>, we noted that setting the set-group-ID permission bit on a directory causes new files created in the directory to take their group ID from the directory&#8217;s group ID, rather than the process&#8217;s effective group ID. The <em>mkdir()</em> system call propagates the set-group-ID permission bit in the manner described here so that all subdirectories under a directory will share the same behavior.</p>
<p class="indent">SUSv3 explicitly notes that the manner in which <em>mkdir()</em> treats the set-user-ID, set-group-ID, and sticky bits is implementation-defined. On some UNIX implementations, these 3 bits are always turned off on a new directory.</p>
<p class="indent">The newly created directory contains two entries: <span class="literal">.</span> (dot), which is a link to the directory itself, and <span class="literal">..</span> (dot-dot), which is a link to the parent directory.</p>
<div class="block">
<p class="noindent">SUSv3 doesn&#8217;t require directories to contain <span class="literal">.</span> and <span class="literal">..</span> entries. It requires only that an implementation correctly interpret <span class="literal">.</span> and <span class="literal">..</span> when they appear in pathnames. A portable application should not rely on the existence of these entries in a directory.</p>
</div>
<p class="noindent">The <em>mkdir()</em> system call creates only the last component of <em>pathname</em>. In other words, the call <em>mkdir(&#8220;aaa/bbb/ccc&#8221;, mode)</em> will succeed only if the directories <span class="literal">aaa</span> and <span class="literal">aaa/bbb</span> already exist. (This corresponds to the default operation of the <em>mkdir(1)</em> command, but <em>mkdir(1)</em> also provides the <em>&#8211;p</em> option to create all of the intervening directory names if they don&#8217;t exist.)</p>
<div class="block">
<p class="noindent">The GNU C library provides the <em>mkdtemp(template)</em> function, which is the directory analog of the <em>mkstemp()</em> function. It creates a uniquely named directory with read, write, and execute permissions enabled for the owner, and no permissions allowed for any other users. Instead of returning a file descriptor as its result, <em>mkdtemp()</em> returns a pointer to a modified string containing the actual directory name in <em>template</em>. SUSv3 doesn&#8217;t specify this function, and it is not available on all UNIX implementations; it is specified in SUSv4.</p>
</div>
<p class="noindent">The <em>rmdir()</em> system call removes the directory specified in <em>pathname</em>, which may be an absolute or a relative pathname.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">rmdir</span>(const char *<span class="font1">pathname</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">In order for <em>rmdir()</em> to succeed, the directory must be empty. If the final component of <em>pathname</em> is a symbolic link, it is not dereferenced; instead, the error <span class="literal">ENOTDIR</span> results.</p>
<h3 class="h3" id="ch18lev1sec07"><span epub:type="pagebreak" id="page_352"/><strong>18.7 Removing a File or Directory: <em>remove()</em></strong></h3>
<p class="noindenta">The <em>remove()</em> library function removes a file or an empty directory.</p>
<div class="box">
<p class="programsa">#include &lt;stdio.h&gt;<br/><br/>int <span class="codestrong">remove</span>(const char *<span class="font1">pathname</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">If <em>pathname</em> is a file, <em>remove()</em> calls <em>unlink()</em>; if <em>pathname</em> is a directory, <em>remove()</em> calls <em>rmdir()</em>.</p>
<p class="indent">Like <em>unlink()</em> and <em>rmdir()</em>, <em>remove()</em> doesn&#8217;t dereference symbolic links. If <em>pathname</em> is a symbolic link, <em>remove()</em> removes the link itself, rather than the file to which it refers.</p>
<p class="indent">If we want to remove a file in preparation for creating a new file with the same name, then using <em>remove()</em> is simpler than code that checks whether a pathname refers to a file or directory and calls <em>unlink()</em> or <em>rmdir()</em>.</p>
<div class="block">
<p class="noindent">The <em>remove()</em> function was invented for the standard C library, which is implemented on both UNIX and non-UNIX systems. Most non-UNIX systems don&#8217;t support hard links, so removing files with a function named <em>unlink()</em> would not make sense.</p>
</div>
<h3 class="h3" id="ch18lev1sec08"><strong>18.8 Reading Directories: <em>opendir()</em> and <em>readdir()</em></strong></h3>
<p class="noindenta">The library functions described in this section can be used to open a directory and retrieve the names of the files it contains one by one.</p>
<div class="block">
<p class="noindent">The library functions for reading directories are layered on top of the <em>getdents()</em> system call (which is not part of SUSv3), but provide an interface that is easier to use. Linux also provides a <em>readdir(2)</em> system call (as opposed to the <em>readdir(3)</em> library function described here), which performs a similar task to, but is made obsolete by, <em>getdents()</em>.</p>
</div>
<p class="noindent">The <em>opendir()</em> function opens a directory and returns a handle that can be used to refer to the directory in later calls.</p>
<div class="box">
<p class="programsa">#include &lt;dirent.h&gt;<br/><br/>DIR *<span class="codestrong">opendir</span>(const char *<span class="font1">dirpath</span>);</p>
<p class="right">Returns directory stream handle, or <span class="literal">NULL</span> on error</p>
</div>
<p class="noindent">The <em>opendir()</em> function opens the directory specified by <em>dirpath</em> and returns a pointer to a structure of type <em>DIR</em>. This structure is a so-called <em>directory stream</em>, which is a handle that the caller passes to the other functions described below. Upon return from <em>opendir()</em>, the directory stream is positioned at the first entry in the directory list.</p>
<p class="indent"><span epub:type="pagebreak" id="page_353"/>The <em>fdopendir()</em> function is like <em>opendir()</em>, except that the directory for which a stream is to be created is specified via the open file descriptor <em>fd</em>.</p>
<div class="box">
<p class="programsa">#include &lt;dirent.h&gt;<br/><br/>DIR *<span class="codestrong">fdopendir</span>(int <span class="font1">fd</span>);</p>
<p class="right">Returns directory stream handle, or <span class="literal">NULL</span> on error</p>
</div>
<p class="noindent">The <em>fdopendir()</em> function is provided so that applications can avoid the kinds of race conditions described in <a href="ch18.xhtml#ch18lev1sec11">Section 18.11</a>.</p>
<p class="indent">After a successful call to <em>fdopendir()</em>, this file descriptor is under the control of the system, and the program should not access it in any way other than by using the functions described in the remainder of this section.</p>
<p class="indent">The <em>fdopendir()</em> function is specified in SUSv4 (but not in SUSv3).</p>
<p class="indent">The <em>readdir()</em> function reads successive entries from a directory stream.</p>
<div class="box">
<p class="programsa">#include &lt;dirent.h&gt;<br/><br/>struct dirent *<span class="codestrong">readdir</span>(DIR *<span class="font1">dirp</span>);</p>
<p class="right">Returns pointer to a statically allocated structure describing next directory entry, or <span class="literal">NULL</span> on end-of-directory or error</p>
</div>
<p class="noindent">Each call to <em>readdir()</em> reads the next directory entry from the directory stream referred to by <em>dirp</em> and returns a pointer to a statically allocated structure of type <em>dirent</em>, containing the following information about the entry:</p>
<p class="programs">struct dirent {<br/>&#160;&#160;&#160;&#160;ino_t d_ino;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* File i-node number */<br/>&#160;&#160;&#160;&#160;char d_name[];&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Null-terminated name of file */<br/>};</p>
<p class="noindent">This structure is overwritten on each call to <em>readdir()</em>.</p>
<div class="block">
<p class="noindent">We have omitted various nonstandard fields in the Linux <em>dirent</em> structure from the above definition, since their use renders an application nonportable. The most interesting of these nonstandard fields is <em>d_type</em>, which is also present on BSD derivatives, but not on other UNIX implementations. This field holds a value indicating the type of the file named in <em>d_name</em>, such as <span class="literal">DT_REG</span> (regular file), <span class="literal">DT_DIR</span> (directory), <span class="literal">DT_LNK</span> (symbolic link), or <span class="literal">DT_FIFO</span> (FIFO). (These names are analogous to the macros in <a href="ch15.xhtml#ch15table1">Table 15-1</a>, on <a href="ch15.xhtml#page_282">page 282</a>.) Using the information in this field saves the cost of calling <em>lstat()</em> in order to discover the file type. Note, however, that, at the time of writing, this field is fully supported only on <em>Btrfs</em>, <em>ext2</em>, <em>ext3</em>, and <em>ext4</em>.</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_354"/>Further information about the file referred to by <em>d_name</em> can be obtained by calling <em>lstat()</em> (or <em>stat()</em>, if a symbolic link should be dereferenced) on the pathname constructed using the <em>dirpath</em> argument that was specified to <em>opendir()</em> concatenated with (a slash and) the value returned in the <em>d_name</em> field.</p>
<p class="indent">The filenames returned by <em>readdir()</em> are not in sorted order, but rather in the order in which they happen to occur in the directory (this depends on the order in which the file system adds files to the directory and how it fills gaps in the directory list after files are removed). (The command <em>ls &#8211;f</em> lists files in the same unsorted order that they would be retrieved by <em>readdir()</em>.)</p>
<div class="block">
<p class="noindent">We can use the function <em>scandir(3)</em> to retrieve a sorted list of files matching programmer-defined criteria; see the manual page for details. Although not specified in SUSv3, <em>scandir()</em> is provided on most UNIX implementations. SUSv4 added a specification for <em>scandir()</em>.</p>
</div>
<p class="noindent">On end-of-directory or error, <em>readdir()</em> returns <span class="literal">NULL</span>, in the latter case setting <em>errno</em> to indicate the error. To distinguish these two cases, we can write the following:</p>
<p class="programs">errno = 0;<br/>direntp = readdir(dirp);<br/>if (direntp == NULL) {<br/>&#160;&#160;&#160;&#160;if (errno != 0) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Handle error */<br/>&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* We reached end-of-directory */<br/>&#160;&#160;&#160;&#160;}<br/>}</p>
<p class="noindent">If the contents of a directory change while a program is scanning it with <em>readdir()</em>, the program might not see the changes. SUSv3 explicitly notes that it is unspecified whether <em>readdir()</em> will return a filename that has been added to or removed from the directory since the last call to <em>opendir()</em> or <em>rewinddir()</em>. All filenames that have been neither added nor removed since the last such call are guaranteed to be returned.</p>
<p class="indent">The <em>rewinddir()</em> function moves the directory stream back to the beginning so that the next call to <em>readdir()</em> will begin again with the first file in the directory.</p>
<div class="box">
<p class="programsa">#include &lt;dirent.h&gt;<br/><br/>void <span class="codestrong">rewinddir</span>(DIR *<span class="font1">dirp</span>);</p>
</div>
<p class="noindent">The <em>closedir()</em> function closes the open directory stream referred to by <em>dirp</em>, freeing the resources used by the stream.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_355"/>#include &lt;dirent.h&gt;<br/><br/>int <span class="codestrong">closedir</span>(DIR *<span class="font1">dirp</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">Two further functions, <em>telldir()</em> and <em>seekdir()</em>, which are also specified in SUSv3, allow random access within a directory stream. Refer to the manual pages for further information about these functions.</p>
<h5 class="h5" id="ch18lev3sec04"><strong>Directory streams and file descriptors</strong></h5>
<p class="noindenta">A directory stream has an associated file descriptor. The <em>dirfd()</em> function returns the file descriptor associated with the directory stream referred to by <em>dirp</em>.</p>
<div class="box">
<p class="programsa">#define _BSD_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Or: #define _SVID_SOURCE */<br/>#include &lt;dirent.h&gt;<br/><br/>int <span class="codestrong">dirfd</span>(DIR *<span class="font1">dirp</span>);</p>
<p class="right">Returns file descriptor on success, or &#8211;1 on error</p>
</div>
<p class="noindent">We might, for example, pass the file descriptor returned by <em>dirfd()</em> to <em>fchdir()</em> (<a href="ch18.xhtml#ch18lev1sec10">Section 18.10</a>) in order to change the current working directory of the process to the corresponding directory. Alternatively, we might pass the file descriptor as the <em>dirfd</em> argument of one of the functions described in <a href="ch18.xhtml#ch18lev1sec11">Section 18.11</a>.</p>
<p class="indent">The <em>dirfd()</em> function also appears on the BSDs, but is present on few other implementations. It is not specified in SUSv3, but is specified in SUSv4.</p>
<p class="indent">At this point, it is worth mentioning that <em>opendir()</em> automatically sets the close-on-exec flag (<span class="literal">FD_CLOEXEC</span>) for the file descriptor associated with the directory stream. This ensures that the file descriptor is automatically closed when an <em>exec()</em> is performed. (SUSv3 requires this behavior.) We describe the close-on-exec flag in <a href="ch27.xhtml#ch27lev1sec04">Section 27.4</a>.</p>
<h5 class="h5" id="ch18lev3sec05"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch18.xhtml#ch18ex2">Listing 18-2</a> uses <em>opendir()</em>, <em>readdir()</em>, and <em>closedir()</em> to list the contents of each of the directories specified in its command line (or in the current working directory if no arguments are supplied). Here is an example of the use of this program:</p>
<p class="programs">$ <span class="codestrong">mkdir sub</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create a test directory</span><br/>$ <span class="codestrong">touch sub/a sub/b</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Make some files in the test directory</span><br/>$ <span class="codestrong">./list_files sub</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">List contents of directory</span><br/>sub/a<br/>sub/b</p>
<p class="examplet"><span epub:type="pagebreak" id="page_356"/><a id="ch18ex2"/><strong>Listing 18-2:</strong> Scanning a directory</p>
<p class="programsli">___________________________________________________ <span class="codestrong">dirs_links/list_files.c</span><br/><br/>#include &lt;dirent.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* List all files in directory 'dirPath' */<br/>listFiles(const char *dirpath)<br/>{<br/>&#160;&#160;&#160;&#160;DIR *dirp;<br/>&#160;&#160;&#160;&#160;struct dirent *dp;<br/>&#160;&#160;&#160;&#160;Boolean isCurrent;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* True if 'dirpath' is "." */<br/><br/>&#160;&#160;&#160;&#160;isCurrent = strcmp(dirpath, ".") == 0;<br/><br/>&#160;&#160;&#160;&#160;dirp = opendir(dirpath);<br/>&#160;&#160;&#160;&#160;if (dirp == NULL) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("opendir failed on '%s'", dirpath);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;/* For each entry in this directory, print directory + filename */<br/><br/>&#160;&#160;&#160;&#160;for (;;) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errno = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* To distinguish error from end-of-directory */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dp = readdir(dirp);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (dp == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (strcmp(dp-&gt;d_name, ".") == 0 || strcmp(dp-&gt;d_name, "..") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Skip . and .. */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (!isCurrent)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s/", dirpath);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s\n", dp-&gt;d_name);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (errno != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("readdir");<br/><br/>&#160;&#160;&#160;&#160;if (closedir(dirp) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("closedir");<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;if (argc &gt; 1 &#38;&#38; strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s [dir...]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;if (argc == 1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* No arguments - use current directory */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;listFiles(".");<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (argv++; *argv; argv++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;listFiles(*argv);<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>___________________________________________________ <span class="codestrong">dirs_links/list_files.c</span></p>
<h5 class="h5" id="ch18lev3sec06"><span epub:type="pagebreak" id="page_357"/><strong>The <em>readdir_r()</em> function</strong></h5>
<p class="noindenta">The <em>readdir_r()</em> function is a variation on <em>readdir()</em>. The key semantic difference between <em>readdir_r()</em> and <em>readdir()</em> is that the former is reentrant, while the latter is not. This is because <em>readdir_r()</em> returns the file entry via the caller-allocated <em>entry</em> argument, while <em>readdir()</em> returns information via a pointer to a statically allocated structure. We discuss reentrancy in <a href="ch21.xhtml#ch21lev2sec02">Sections 21.1.2</a> and <a href="ch31.xhtml#ch31lev1sec01">31.1</a>.</p>
<div class="box">
<p class="programsa">#include &lt;dirent.h&gt;<br/><br/>int <span class="codestrong">readdir_r</span>(DIR *<span class="font1">dirp</span>, struct dirent *<span class="font1">entry</span>, struct dirent **<span class="font1">result</span>);</p>
<p class="right">Returns 0 on success, or a positive error number on error</p>
</div>
<p class="noindent">Given <em>dirp</em>, which is a directory stream previously opened via <em>opendir()</em>, <em>readdir_r()</em> places information about the next directory entry into the <em>dirent</em> structure referred to by <em>entry</em>. In addition, a pointer to this structure is placed in <em>result</em>. If the end of the directory stream is reached, then <span class="literal">NULL</span> is placed in <em>result</em> instead (and <em>readdir_r()</em> returns 0). On error, <em>readdir_r()</em> doesn&#8217;t return &#8211;1, but instead returns a positive integer corresponding to one of the <em>errno</em> values.</p>
<p class="indent">On Linux, the <em>d_name</em> field of the <em>dirent</em> structure is sized as an array of 256 bytes, which is long enough to hold the largest possible filename. Although several other UNIX implementations define the same size for <em>d_name</em>, SUSv3 leaves this point unspecified, and some UNIX implementations instead define the field as a 1-byte array, leaving the calling program with the task of allocating a structure of the correct size. When doing this, we should size the <em>d_name</em> field as one greater (for the terminating null byte) than the value of the constant <span class="literal">NAME_MAX</span>. Portable applications should thus allocate the <em>dirent</em> structure as follows:</p>
<p class="programs">struct dirent *entryp;<br/>size_t len;<br/><br/>len = offsetof(struct dirent, d_name) + NAME_MAX + 1;<br/>entryp = malloc(len);<br/>if (entryp == NULL)<br/>&#160;&#160;&#160;&#160;errExit("malloc");</p>
<p class="noindent">Using the <span class="literal">offsetof()</span> macro (defined in <span class="literal">&lt;stddef.h&gt;</span>) avoids any implementation-specific dependencies on the number and size of fields in the <em>dirent</em> structure preceding the <em>d_name</em> field (which is always the last field in the structure).</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_358"/>The <span class="literal">offsetof()</span> macro takes two arguments&#8212;a structure type and the name of a field within that structure&#8212;and returns a value of type <em>size_t</em> that is the offset in bytes of the field from the beginning of the structure. This macro is necessary because a compiler may insert padding bytes in a structure to satisfy alignment requirements for types such as <em>int</em>, with the result that a field&#8217;s offset within a structure may be greater than the sum of the sizes of the fields that precede it.</p>
</div>
<h3 class="h3" id="ch18lev1sec09"><strong>18.9 File Tree Walking: <em>nftw()</em></strong></h3>
<p class="noindenta">The <em>nftw()</em> function allows a program to recursively walk through an entire directory subtree performing some operation (i.e., calling some programmer-defined function) for each file in the subtree.</p>
<div class="block">
<p class="noindent">The <em>nftw()</em> function is an enhancement of the older <em>ftw()</em> function, which performs a similar task. New applications should use <em>nftw()</em> (<em>new ftw</em>) because it provides more functionality, and predictable handling of symbolic links (SUSv3 permits <em>ftw()</em> either to follow or not follow symbolic links). SUSv3 specifies both <em>nftw()</em> and <em>ftw()</em>, but the latter function is marked obsolete in SUSv4.</p>
<p class="indent">The GNU C library also provides the BSD-derived <em>fts</em> API (<em>fts_open()</em>, <em>fts_read()</em>, <em>fts_children()</em>, <em>fts_set()</em>, and <em>fts_close()</em>). These functions perform a similar task to <em>ftw()</em> and <em>nftw()</em>, but offer greater flexibility to an application walking the tree. However, this API is not standardized and is provided on few UNIX implementations other than BSD descendants, so we omit discussion of it here.</p>
</div>
<p class="noindent">The <em>nftw()</em> function walks through the directory tree specified by <em>dirpath</em> and calls the programmer-defined function <em>func</em> once for each file in the directory tree.</p>
<div class="box">
<p class="programsa">#define _XOPEN_SOURCE 500<br/>#include &lt;ftw.h&gt;<br/><br/>int <span class="codestrong">nftw</span>(const char *<span class="font1">dirpath</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int (*<span class="font1">func</span>) (const char *<span class="font1">pathname</span>, const struct stat *<span class="font1">statbuf</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int <span class="font1">typeflag</span>, struct FTW *<span class="font1">ftwbuf</span>),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int <span class="font1">nopenfd</span>, int <span class="font1">flags</span>);</p>
<p class="right">Returns 0 after successful walk of entire tree, or &#8211;1 on error, or the first nonzero value returned by a call to <em>func</em></p>
</div>
<p class="noindent">By default, <em>nftw()</em> performs an unsorted, preorder traversal of the given tree, processing each directory before processing the files and subdirectories within that directory.</p>
<p class="indent">While traversing the directory tree, <em>nftw()</em> opens at most one file descriptor for each level of the tree. The <em>nopenfd</em> argument specifies the maximum number of file descriptors that <em>nftw()</em> may use. If the depth of the directory tree exceeds this maximum, <em>nftw()</em> does some bookkeeping, and closes and reopens descriptors in order to avoid holding open more than <em>nopenfd</em> descriptors simultaneously (and consequently runs more slowly). The need for this argument was greater under older UNIX implementations, some of which had a limit of 20 open file descriptors per process. Modern UNIX implementations allow a process to open a large number of file descriptors, and thus we can specify a generous number here (say 20 or more).</p>
<p class="indentb"><span epub:type="pagebreak" id="page_359"/>The <em>flags</em> argument to <em>nftw()</em> is created by ORing (<span class="literal">|</span>) zero or more of the following constants, which modify the operation of the function:</p>
<p class="term"><span class="literal">FTW_CHDIR</span></p>
<p class="termlist">Do a <em>chdir()</em> into each directory before processing its contents. This is useful if <em>func</em> is designed to do some work in the directory in which the file specified by its <em>pathname</em> argument resides.</p>
<p class="term"><span class="literal">FTW_DEPTH</span></p>
<p class="termlist">Do a postorder traversal of the directory tree. This means that <em>nftw()</em> calls <em>func</em> on all of the files (and subdirectories) within a directory before executing <em>func</em> on the directory itself. (The name of this flag is somewhat misleading&#8212;<em>nftw()</em> always does a depth-first, rather than a breadth-first, traversal of the directory tree. All that this flag does is convert the traversal from preorder to postorder.)</p>
<p class="term"><span class="literal">FTW_MOUNT</span></p>
<p class="termlist">Don&#8217;t cross over into another file system. Thus, if one of the subdirectories of the tree is a mount point, it is not traversed.</p>
<p class="term"><span class="literal">FTW_PHYS</span></p>
<p class="termlist">By default, <em>nftw()</em> dereferences symbolic links. This flag tells it not to do so. Instead, a symbolic link is passed to <em>func</em> with a <em>typeflag</em> value of <span class="literal">FTW_SL</span>, as described below.</p>
<p class="noindenttb">For each file, <em>nftw()</em> passes four arguments when calling <em>func</em>. The first of these arguments, <em>pathname</em>, is the pathname of the file. This pathname may be absolute, if <em>dirpath</em> was specified as an absolute pathname, or relative to the current working directory of the calling process at the time of the call to <em>ntfw()</em>, if <em>dirpath</em> was expressed as a relative pathname. The second argument, <em>statbuf</em>, is a pointer to a <em>stat</em> structure (<a href="ch15.xhtml#ch15lev1sec01">Section 15.1</a>) containing information about this file. The third argument, <em>typeflag</em>, provides further information about the file, and has one of the following symbolic values:</p>
<p class="term"><span class="literal">FTW_D</span></p>
<p class="termlist">This is a directory.</p>
<p class="term"><span class="literal">FTW_DNR</span></p>
<p class="termlist">This is a directory that can&#8217;t be read (and so <em>nftw()</em> doesn&#8217;t traverse any of its descendants).</p>
<p class="term"><span class="literal">FTW_DP</span></p>
<p class="termlist">We are doing a postorder traversal (<span class="literal">FTW_DEPTH</span>) of a directory, and the current item is a directory whose files and subdirectories have already been processed.</p>
<p class="term"><span class="literal">FTW_F</span></p>
<p class="termlist">This is a file of any type other than a directory or symbolic link.</p>
<p class="term"><span class="literal">FTW_NS</span></p>
<p class="termlist">Calling <em>stat()</em> on this file failed, probably because of permission restrictions. The value in <em>statbuf</em> is undefined.</p>
<p class="term"><span epub:type="pagebreak" id="page_360"/><span class="literal">FTW_SL</span></p>
<p class="termlist">This is a symbolic link. This value is returned only if <em>nftw()</em> is called with the <span class="literal">FTW_PHYS</span> flag.</p>
<p class="term"><span class="literal">FTW_SLN</span></p>
<p class="termlist">This item is a dangling symbolic link. This value occurs only if <span class="literal">FTW_PHYS</span> was not specified in the <em>flags</em> argument.</p>
<p class="noindentt">The fourth argument to <em>func</em>, <em>ftwbuf</em>, is a pointer to a structure defined as follows:</p>
<p class="programs">struct FTW {<br/>&#160;&#160;&#160;&#160;int base;&#160;&#160;&#160;&#160;&#160;&#160;/* Offset to basename part of pathname */<br/>&#160;&#160;&#160;&#160;int level;&#160;&#160;&#160;&#160;&#160;/* Depth of file within tree traversal */<br/>};</p>
<p class="noindent">The <em>base</em> field of this structure is the integer offset of the filename part (the component after the last <span class="literal">/</span>) of the <em>pathname</em> argument of <em>func</em>. The <em>level</em> field is the depth of this item relative to the starting point of the traversal (which is level 0).</p>
<p class="indent">Each time it is called, <em>func</em> must return an integer value, and this value is interpreted by <em>nftw()</em>. Returning 0 tells <em>nftw()</em> to continue the tree walk, and if all calls to <em>func</em> return 0, <em>nftw()</em> itself returns 0 to its caller. Returning a nonzero value tells <em>nftw()</em> to immediately stop the tree walk, in which case <em>nftw()</em> returns the same nonzero value as its return value.</p>
<p class="indent">Because <em>nftw()</em> uses dynamically allocated data structures, the only way that a program should ever prematurely terminate a directory tree walk is by returning a nonzero value from <em>func</em>. Using <em>longjmp()</em> (<a href="ch06.xhtml#ch06lev1sec08">Section 6.8</a>) to exit from <em>func</em> may lead to unpredictable results&#8212;at the very least, memory leaks in a program.</p>
<h5 class="h5" id="ch18lev3sec07"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch18.xhtml#ch18ex3">Listing 18-3</a> demonstrates the use of <em>nftw()</em>.</p>
<p class="examplet"><a id="ch18ex3"/><strong>Listing 18-3:</strong> Using <em>nftw()</em> to walk a directory tree</p>
<p class="programsli">_________________________________________________ <span class="codestrong">dirs_links/nftw_dir_tree.c</span><br/><br/>#define _XOPEN_SOURCE 600&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get nftw() and S_IFSOCK declarations */<br/>#include &lt;ftw.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static void<br/>usageError(const char *progName, const char *msg)<br/>{<br/>&#160;&#160;&#160;&#160;if (msg != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(stderr, "%s\n", msg);<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "Usage: %s [-d] [-m] [-p] [directory-path]\n", progName);<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "\t-d Use FTW_DEPTH flag\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "\t-m Use FTW_MOUNT flag\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "\t-p Use FTW_PHYS flag\n");<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}<br/><br/>static int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Function called by nftw() */<br/>dirTree(const char *pathname, const struct stat *sbuf, int type,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct FTW *ftwb)<br/><span epub:type="pagebreak" id="page_361"/>{<br/>&#160;&#160;&#160;&#160;switch (sbuf-&gt;st_mode &#38; S_IFMT) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Print file type */<br/>&#160;&#160;&#160;&#160;case S_IFREG:&#160;&#160;printf("-"); break;<br/>&#160;&#160;&#160;&#160;case S_IFDIR:&#160;&#160;printf("d"); break;<br/>&#160;&#160;&#160;&#160;case S_IFCHR:&#160;&#160;printf("c"); break;<br/>&#160;&#160;&#160;&#160;case S_IFBLK:&#160;&#160;printf("b"); break;<br/>&#160;&#160;&#160;&#160;case S_IFLNK:&#160;&#160;printf("l"); break;<br/>&#160;&#160;&#160;&#160;case S_IFIFO:&#160;&#160;printf("p"); break;<br/>&#160;&#160;&#160;&#160;case S_IFSOCK: printf("s"); break;<br/>&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("?"); break;&#160;&#160;&#160;&#160;&#160;&#160;/* Should never happen (on Linux) */<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;printf(" %s ",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(type == FTW_D)&#160;&#160;? "D&#160;&#160;" : (type == FTW_DNR) ? "DNR" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(type == FTW_DP) ? "DP " : (type == FTW_F)&#160;&#160;&#160;? "F&#160;&#160;" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(type == FTW_SL) ? "SL " : (type == FTW_SLN) ? "SLN" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(type == FTW_NS) ? "NS " : "&#160;&#160;");<br/><br/>&#160;&#160;&#160;&#160;if (type != FTW_NS)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%7ld ", (long) sbuf-&gt;st_ino);<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;&#160;&#160;&#160;");<br/><br/>&#160;&#160;&#160;&#160;printf(" %*s", 4 * ftwb-&gt;level, "");&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Indent suitably */<br/>&#160;&#160;&#160;&#160;printf("%s\n",&#160;&#160;&#38;pathname[ftwb-&gt;base]);&#160;&#160;&#160;&#160;/* Print basename */<br/>&#160;&#160;&#160;&#160;return 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Tell nftw() to continue */<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int flags, opt;<br/><br/>&#160;&#160;&#160;&#160;flags = 0;<br/>&#160;&#160;&#160;&#160;while ((opt = getopt(argc, argv, "dmp")) != -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (opt) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'd': flags |= FTW_DEPTH;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'm': flags |= FTW_MOUNT;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'p': flags |= FTW_PHYS;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default:&#160;&#160;usageError(argv[0], NULL);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (argc &gt; optind + 1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0], NULL);<br/><br/>&#160;&#160;&#160;&#160;if (nftw((argc &gt; optind) ? argv[optind] : ".", dirTree, 10, flags) == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;perror("nftw");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________ <span class="codestrong">dirs_links/nftw_dir_tree.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_362"/>The program in <a href="ch18.xhtml#ch18ex3">Listing 18-3</a> displays an indented hierarchy of the filenames in a directory tree, one file per line, as well as the file type and i-node number. Command-line options can be used to specify settings for the <em>flags</em> argument used to call <em>nftw()</em>. The following shell session shows examples of what we see when we run this program. We first create a new empty subdirectory, which we populate with various types of files:</p>
<p class="programs">$ <span class="codestrong">mkdir dir</span><br/>$ <span class="codestrong">touch dir/a dir/b</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create some plain files</span><br/>$ <span class="codestrong">ln -s a dir/sl</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">and a symbolic link</span><br/>$ <span class="codestrong">ln -s x dir/dsl</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">and a dangling symbolic link</span><br/>$ <span class="codestrong">mkdir dir/sub</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">and a subdirectory</span><br/>$ <span class="codestrong">touch dir/sub/x</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">with a file of its own</span><br/>$ <span class="codestrong">mkdir dir/sub2</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">and another subdirectory</span><br/>$ <span class="codestrong">chmod 0 dir/sub2</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">that is not readable</span></p>
<p class="noindent">We then use our program to invoke <em>nftw()</em> with a <em>flags</em> argument of 0:</p>
<p class="programs">$ <span class="codestrong">./nftw_dir_tree dir</span><br/>d D&#160;&#160;&#160;&#160;2327983&#160;&#160;dir<br/>- F&#160;&#160;&#160;&#160;2327984&#160;&#160;&#160;&#160;&#160;&#160;a<br/>- F&#160;&#160;&#160;&#160;2327985&#160;&#160;&#160;&#160;&#160;&#160;b<br/>- F&#160;&#160;&#160;&#160;2327984&#160;&#160;&#160;&#160;&#160;&#160;sl&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">The symbolic link</span> sl <span class="font1">was resolved to</span> a<br/>l SLN&#160;&#160;2327987&#160;&#160;&#160;&#160;&#160;&#160;dsl<br/>d D&#160;&#160;&#160;&#160;2327988&#160;&#160;&#160;&#160;&#160;&#160;sub<br/>- F&#160;&#160;&#160;&#160;2327989&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x<br/>d DNR&#160;&#160;2327994&#160;&#160;&#160;&#160;&#160;&#160;sub2</p>
<p class="noindent">In the above output, we can see that the symbolic link <span class="literal">sl</span> was resolved.</p>
<p class="indent">We then use our program to invoke <em>nftw()</em> with a <em>flags</em> argument containing <span class="literal">FTW_PHYS</span> and <span class="literal">FTW_DEPTH</span>:</p>
<p class="programs">$ <span class="codestrong">./nftw_dir_tree -p -d dir</span><br/>- F&#160;&#160;&#160;&#160;2327984&#160;&#160;&#160;&#160;&#160;&#160;a<br/>- F&#160;&#160;&#160;&#160;2327985&#160;&#160;&#160;&#160;&#160;&#160;b<br/>l SL&#160;&#160;&#160;2327986&#160;&#160;&#160;&#160;&#160;&#160;sl&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">The symbolic link</span> sl <span class="font1">was not resolved</span><br/>l SL&#160;&#160;&#160;2327987&#160;&#160;&#160;&#160;&#160;&#160;dsl<br/>- F&#160;&#160;&#160;&#160;2327989&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x<br/>d DP&#160;&#160;&#160;2327988&#160;&#160;&#160;&#160;&#160;&#160;sub<br/>d DNR&#160;&#160;2327994&#160;&#160;&#160;&#160;&#160;&#160;sub2<br/>d DP&#160;&#160;&#160;2327983&#160;&#160;dir</p>
<p class="noindent">From the above output, we can see that the symbolic link <span class="literal">sl</span> was not resolved.</p>
<h5 class="h5" id="ch18lev3sec08"><strong>The <em>nftw()</em></strong> <span class="literal"><span class="codestrong">FTW_ACTIONRETVAL</span></span> <strong>flag</strong></h5>
<p class="noindentab">Starting with version 2.3.3, <em>glibc</em> permits an additional, nonstandard flag to be specified in <em>flags</em>. This flag, <span class="literal">FTW_ACTIONRETVAL</span>, changes the way that <em>nftw()</em> interprets the return value from calls to <em>func()</em>. When this flag is specified, <em>func()</em> should return one of the following values:</p>
<p class="term"><span class="literal">FTW_CONTINUE</span></p>
<p class="termlist">Continue processing entries in the directory tree, as with the traditional 0 return from <em>func()</em>.</p>
<p class="term"><span epub:type="pagebreak" id="page_363"/><span class="literal">FTW_SKIP_SIBLINGS</span></p>
<p class="termlist">Don&#8217;t process any further entries in the current directory; resume processing in the parent directory.</p>
<p class="term"><span class="literal">FTW_SKIP_SUBTREE</span></p>
<p class="termlist">If <em>pathname</em> is a directory (i.e., <em>typeflag</em> is <span class="literal">FTW_D</span>), then don&#8217;t call <em>func()</em> for entries under that directory. Processing resumes with the next sibling of this directory.</p>
<p class="term"><span class="literal">FTW_STOP</span></p>
<p class="termlist">Don&#8217;t process any further entries in the directory tree, as with the traditional nonzero return from <em>func()</em>. The value <span class="literal">FTW_STOP</span> is returned to the caller of <em>nftw()</em>.</p>
<p class="noindentt">The <span class="literal">_GNU_SOURCE</span> feature test macro must be defined in order to obtain the definition of <span class="literal">FTW_ACTIONRETVAL</span> from <span class="literal">&lt;ftw.h&gt;</span>.</p>
<h3 class="h3" id="ch18lev1sec10"><strong>18.10 The Current Working Directory of a Process</strong></h3>
<p class="noindenta">A process&#8217;s <em>current working directory</em> defines the starting point for the resolution of relative pathnames referred to by the process. A new process inherits its current working directory from its parent.</p>
<h5 class="h5" id="ch18lev3sec09"><strong>Retrieving the current working directory</strong></h5>
<p class="noindenta">A process can retrieve its current working directory using <em>getcwd()</em>.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>char *<span class="codestrong">getcwd</span>(char *<span class="font1">cwdbuf</span>, size_t <span class="font1">size</span>);</p>
<p class="right">Returns <em>cwdbuf</em> on success, or <span class="literal">NULL</span> on error</p>
</div>
<p class="noindent">The <em>getcwd()</em> function places a null-terminated string containing the absolute pathname of the current working directory into the allocated buffer pointed to by <em>cwdbuf</em>. The caller must allocate the <em>cwdbuf</em> buffer to be at least <em>size</em> bytes in length. (Normally, we would size <em>cwdbuf</em> using the <span class="literal">PATH_MAX</span> constant.)</p>
<p class="indent">On success, <em>getcwd()</em> returns a pointer to <em>cwdbuf</em> as its function result. If the pathname for the current working directory exceeds <em>size</em> bytes, then <em>getcwd()</em> returns <span class="literal">NULL</span>, with <em>errno</em> set to <span class="literal">ERANGE</span>.</p>
<p class="indent">On Linux/x86-32, <em>getcwd()</em> returns a maximum of 4096 (<span class="literal">PATH_MAX</span>) bytes. If the current working directory (and <em>cwdbuf</em> and <em>size</em>) exceeds this limit, then the pathname is silently truncated, removing complete directory prefixes from the <em>beginning</em> of the string (which is still null-terminated). In other words, we can&#8217;t use <em>getcwd()</em> reliably when the length of the absolute pathname for the current working directory exceeds this limit.</p>
<div class="block">
<p class="noindent">In fact, the Linux <em>getcwd()</em> system call internally allocates a virtual memory page for the returned pathname. On the x86-32 architecture, the page size is 4096 bytes, but on architectures with larger page sizes (e.g., Alpha with a page size of 8192 bytes), <em>getcwd()</em> can return larger pathnames.</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_364"/>If the <em>cwdbuf</em> argument is <span class="literal">NULL</span> and <em>size</em> is 0, then the <em>glibc</em> wrapper function for <em>getcwd()</em> allocates a buffer as large as required and returns a pointer to that buffer as its function result. To avoid memory leaks, the caller must later deallocate this buffer with <em>free()</em>. Reliance on this feature should be avoided in portable applications. Most other implementations provide a simpler extension of the SUSv3 specification: if <em>cwdbuf</em> is <span class="literal">NULL</span>, then <em>getcwd()</em> allocates <em>size</em> bytes and uses this buffer to return the result to the caller. The <em>glibc getcwd()</em> implementation also provides this feature.</p>
<div class="block">
<p class="noindent">The GNU C library also provides two other functions for obtaining the current working directory. The BSD-derived <em>getwd(path)</em> function is vulnerable to buffer overruns, since it provides no method of specifying an upper limit for the size of the returned pathname. The <em>get_current_dir_name()</em> function returns a string containing the current working directory name as its function result. This function is easy to use, but it is not portable. For security and portability, <em>getcwd()</em> is preferred over these two functions (as long as we avoid using the GNU extensions).</p>
</div>
<p class="noindent">With suitable permissions (roughly, we own the process or have the <span class="literal">CAP_SYS_PTRACE</span> capability), we can determine the current working directory of any process by reading (<em>readlink()</em>) the contents of the Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/cwd</span> symbolic link.</p>
<h5 class="h5" id="ch18lev3sec10"><strong>Changing the current working directory</strong></h5>
<p class="noindenta">The <em>chdir()</em> system call changes the calling process&#8217;s current working directory to the relative or absolute pathname specified in <em>pathname</em> (which is dereferenced if it is a symbolic link).</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">chdir</span>(const char *<span class="font1">pathname</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>fchdir()</em> system call does the same as <em>chdir()</em>, except that the directory is specified via a file descriptor previously obtained by opening the directory with <em>open()</em>.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">fchdir</span>(int <span class="font1">fd</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">We can use <em>fchdir()</em> to change the process&#8217;s current working directory to another location, and then later return to the original location, as follows:</p>
<p class="programs">int fd;<br/><br/>fd = open(".", O_RDONLY);&#160;&#160;&#160;&#160;&#160;/* Remember where we are */<br/>chdir(somepath);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Go somewhere else */<br/>fchdir(fd);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Return to original directory */<br/>close(fd);</p>
<p class="noindent"><span epub:type="pagebreak" id="page_365"/>The equivalent using <em>chdir()</em> is as follows:</p>
<p class="programs">char buf[PATH_MAX];<br/><br/>getcwd(buf, PATH_MAX);&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Remember where we are */<br/>chdir(somepath);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Go somewhere else */<br/>chdir(buf);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Return to original directory */</p>
<h3 class="h3" id="ch18lev1sec11"><strong>18.11 Operating Relative to a Directory File Descriptor</strong></h3>
<p class="noindenta">Starting with kernel 2.6.16, Linux provides a range of new system calls that perform similar tasks to various traditional system calls, but provide additional functionality that is useful to some applications. These system calls are summarized in <a href="ch18.xhtml#ch18table2">Table 18-2</a>. We describe these system calls in this chapter because they provide variations on the traditional semantics of the process&#8217;s current working directory.</p>
<p class="tablecap"><a id="ch18table2"/><strong>Table 18-2:</strong> System calls that use a directory file descriptor to interpret relative pathnames</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>New interface</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Traditional analog</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Notes</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>faccessat()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>access()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Supports <span class="literal">AT_EACCESS</span> and <span class="literal">AT_SYMLINK_NOFOLLOW</span> flags</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>fchmodat()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>chmod()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>fchownat()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>chown()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Supports <span class="literal">AT_SYMLINK_NOFOLLOW</span> flag</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>fstatat()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>stat()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Supports <span class="literal">AT_SYMLINK_NOFOLLOW</span> flag</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>linkat()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>link()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Supports (since Linux 2.6.18) <span class="literal">AT_SYMLINK_FOLLOW</span> flag</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>mkdirat()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>mkdir()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>mkfifoat()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>mkfifo()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Library function layered on top of <em>mknodat()</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>mknodat()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>mknod()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>openat()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>open()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>readlinkat()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>readlink()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>renameat()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>rename()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>symlinkat()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>symlink()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>unlinkat()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>unlink()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Supports <span class="literal">AT_REMOVEDIR</span> flag</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><em>utimensat()</em></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><em>utimes()</em></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Supports <span class="literal">AT_SYMLINK_NOFOLLOW</span> flag</p></td>
</tr>
</tbody>
</table>
<p class="noindent">In order to describe these system calls, we&#8217;ll use a specific example: <em>openat()</em>.</p>
<div class="box">
<p class="programsa">#define _XOPEN_SOURCE 700&#160;&#160;&#160;&#160;/* Or define _POSIX_C_SOURCE &gt;= 200809 */<br/>#include &lt;fcntl.h&gt;<br/><br/>int <span class="codestrong">openat</span>(int <span class="font1">dirfd</span>, const char *<span class="font1">pathname</span>, int <span class="font1">flags</span>, ... /* mode_t <span class="font1">mode</span> */);</p>
<p class="right">Returns file descriptor on success, or &#8211;1 on error</p>
</div>
<p class="noindentb"><span epub:type="pagebreak" id="page_366"/>The <em>openat()</em> system call is similar to the traditional <em>open()</em> system call, but adds an argument, <em>dirfd</em>, that is used as follows:</p>
<p class="bull">&#8226; If <em>pathname</em> specifies a relative pathname, then it is interpreted relative to the directory referred to by the open file descriptor <em>dirfd</em>, rather than relative to the process&#8217;s current working directory.</p>
<p class="bull">&#8226; If <em>pathname</em> specifies a relative pathname, and <em>dirfd</em> contains the special value <span class="literal">AT_FDCWD</span>, then <em>pathname</em> is interpreted relative to the process&#8217;s current working directory (i.e., the same behavior as <em>open(2)</em>).</p>
<p class="bull">&#8226; If <em>pathname</em> specifies an absolute pathname, then <em>dirfd</em> is ignored.</p>
<p class="noindentt">The <em>flags</em> argument of <em>openat()</em> serves the same purpose as for <em>open()</em>. However, some of the system calls listed in <a href="ch18.xhtml#ch18table2">Table 18-2</a> support a <em>flags</em> argument that is not provided by the corresponding traditional system call, and the purpose of this argument is to modify the semantics of the call. The most frequently provided flag is <span class="literal">AT_SYMLINK_NOFOLLOW</span>, which specifies that if <em>pathname</em> is a symbolic link, then the system call should operate on the link, rather than the file to which it refers. (The <em>linkat()</em> system call provides the <span class="literal">AT_SYMLINK_FOLLOW</span> flag, which performs the converse action, changing the default behavior of <em>linkat()</em> so that it dereferences <em>oldpath</em> if it is a symbolic link.) For details of the other flags, refer to the corresponding manual pages.</p>
<p class="indentb">The system calls listed in <a href="ch18.xhtml#ch18table2">Table 18-2</a> are supported for two reasons (again, we explain using the example of <em>openat()</em>):</p>
<p class="bull">&#8226; Using <em>openat()</em> allows an application to avoid certain race conditions that can occur when <em>open()</em> is used to open files in locations other than the current working directory. These races can occur because some component of the directory prefix of <em>pathname</em> could be changed in parallel with the <em>open()</em> call. By opening a file descriptor for the target directory, and passing that descriptor to <em>openat()</em>, such races can be avoided.</p>
<p class="bull">&#8226; In <a href="ch29.xhtml#ch29">Chapter 29</a>, we&#8217;ll see that the working directory is a process attribute that is shared by all threads of the process. For some applications, it is useful for different threads to have different &#8220;virtual&#8221; working directories. An application can emulate this functionality using <em>openat()</em> in conjunction with directory file descriptors maintained by the application.</p>
<p class="noindentt">These system calls are not standardized in SUSv3, but are included in SUSv4. In order to expose the declaration of each of these system calls, the <span class="literal">_XOPEN_SOURCE</span> feature test macro must be defined with a value greater than or equal to 700 before including the appropriate header file (e.g., <span class="literal">&lt;fcntl.h&gt;</span> for <em>open()</em>). Alternatively, the <span class="literal">_POSIX_C_SOURCE</span> macro can be defined with a value greater than or equal to 200809. (Before <em>glibc</em> 2.10, the <span class="literal">_ATFILE_SOURCE</span> macro needed to be defined to expose the declarations of these system calls.)</p>
<div class="block">
<p class="noindent">Solaris 9 and later provide versions of some of the interfaces listed in <a href="ch18.xhtml#ch18table2">Table 18-2</a>, with slightly different semantics.</p>
</div>
<h3 class="h3" id="ch18lev1sec12"><span epub:type="pagebreak" id="page_367"/><strong>18.12 Changing the Root Directory of a Process: <em>chroot()</em></strong></h3>
<p class="noindenta">Every process has a <em>root directory</em>, which is the point from which absolute pathnames (i.e., those beginning with <span class="literal">/</span>) are interpreted. By default, this is the real root directory of the file system. (A new process inherits its parent&#8217;s root directory.) On occasion, it is useful for a process to change its root directory, and a privileged (<span class="literal">CAP_SYS_CHROOT</span>) process can do this using the <em>chroot()</em> system call.</p>
<div class="box">
<p class="programsa">#define _BSD_SOURCE<br/>#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">chroot</span>(const char *<span class="font1">pathname</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>chroot()</em> system call changes the process&#8217;s root directory to the directory specified by <em>pathname</em> (which is dereferenced if it is a symbolic link). Thereafter, all absolute pathnames are interpreted as starting from that location in the file system. This is sometimes referred to as setting up a <em>chroot</em> jail, since the program is then confined to a particular area of the file system.</p>
<p class="indent">SUSv2 contained a specification for <em>chroot()</em> (marked LEGACY), but this was removed in SUSv3. Nevertheless, <em>chroot()</em> appears on most UNIX implementations.</p>
<div class="block">
<p class="noindent">The <em>chroot()</em> system call is employed by the <em>chroot</em> command, which enables us to execute shell commands in a <em>chroot</em> jail.</p>
<p class="indent">The root directory of any process can be found by reading (<em>readlink()</em>) the contents of the Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/root</span> symbolic link.</p>
</div>
<p class="noindent">The classic example of the use of <em>chroot()</em> is in the <em>ftpd</em> program (the FTP server daemon). As a security measure, when a user logs in anonymously under FTP, the <em>ftpd</em> program uses <em>chroot()</em> to set the root directory for the new process to the directory specifically reserved for anonymous logins. After the <em>chroot()</em> call, the user is limited to the file-system subtree under their new root directory, so they can&#8217;t roam around the entire file system. (This relies on the fact that the root directory is its own parent; that is, <span class="literal">/..</span> is a link to <span class="literal">/</span>, so that changing directory to <span class="literal">/</span> and then attempting a <em>cd ..</em> leaves the user in the same directory.)</p>
<div class="block">
<p class="noindent">Some UNIX implementations (but not Linux) allow multiple hard links to a directory, so that it is possible to create a hard link within a subdirectory to its parent (or a further removed ancestor). On implementations permitting this, the presence of a hard link that reaches outside the jail directory tree compromises the jail. Symbolic links to directories outside the jail don&#8217;t pose a problem&#8212;because they are interpreted within the framework of the process&#8217;s new root directory, they can&#8217;t reach outside the <em>chroot</em> jail.</p>
</div>
<p class="noindent">Normally, we can&#8217;t execute arbitrary programs within a <em>chroot</em> jail. This is because most programs are dynamically linked against shared libraries. Therefore, we must either limit ourselves to executing statically linked programs, or replicate a standard set of system directories containing shared libraries (including, for example, <span class="literal">/lib</span> and <span class="literal">/usr/lib</span>) within the jail (in this regard, the bind mount feature described in <a href="ch14.xhtml#ch14lev2sec06">Section 14.9.4</a> can be useful).</p>
<p class="indent"><span epub:type="pagebreak" id="page_368"/>The <em>chroot()</em> system call was not conceived as a completely secure jail mechanism. To begin with, there are various ways in which a privileged program can subsequently use a further <em>chroot()</em> call to break out of the jail. For example, a privileged (<span class="literal">CAP_MKNOD</span>) program can use <em>mknod()</em> to create a memory device file (similar to <span class="literal">/dev/mem</span>) giving access to the contents of RAM, and, from that point, anything is possible. In general, it is advisable not to include set-user-ID-<em>root</em> programs within a <em>chroot</em> jail file system.</p>
<p class="indentb">Even with unprivileged programs, we must take care to prevent the following possible routes for breaking out of a <em>chroot</em> jail:</p>
<p class="bull">&#8226; Calling <em>chroot()</em> doesn&#8217;t change the process&#8217;s current working directory. Thus, a call to <em>chroot()</em> is typically preceded or followed by a call to <em>chdir()</em> (e.g., <em>chdir(&#8220;/&#8221;)</em> after the <em>chroot()</em> call). If this is not done, then a process can use relative pathnames to access files and directories outside the jail. (Some BSD derivatives prevent this possibility&#8212;if the current working directory lies outside the new root directory tree, then it is changed by the <em>chroot()</em> call to be the same as the root directory.)</p>
<p class="bull">&#8226; If a process holds an open file descriptor for a directory outside the jail, then the combination of <em>fchdir()</em> plus <em>chroot()</em> can be used to break out of the jail, as shown in the following code sample:</p>
<p class="programsbl">int fd;<br/><br/>fd = open("/", O_RDONLY);<br/>chroot("/home/mtk");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Jailed */<br/>fchdir(fd);<br/>chroot(".");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Out of jail */</p>
<p class="bullp">To prevent this possibility, we must close all open file descriptors referring to directories outside the jail. (Some other UNIX implementations provide the <em>fchroot()</em> system call, which can be used to achieve a similar result to the above code snippet.)</p>
<p class="bull">&#8226; Even preventing the preceding possibilities is insufficient to stop an arbitrary unprivileged program (i.e., one whose operation we don&#8217;t have control over) from breaking out of the jail. The jailed process can still use a UNIX domain socket to receive a file descriptor (from another process) referring to a directory outside the jail. (We briefly explain the concept of passing file descriptors between processes via a socket in <a href="ch61.xhtml#ch61lev2sec10">Section 61.13.3</a>.) By specifying this file descriptor in a call to <em>fchdir()</em>, the program can set its current working directory outside the jail and then access arbitrary files and directories using relative pathnames.</p>
<div class="block1">
<p class="noindent">Some BSD derivatives provide a <em>jail()</em> system call, which addresses the points described above, as well as several others, to create a jail that is secure even for a privileged process.</p>
</div>
<h3 class="h3" id="ch18lev1sec13"><span epub:type="pagebreak" id="page_369"/><strong>18.13 Resolving a Pathname: <em>realpath()</em></strong></h3>
<p class="noindenta">The <em>realpath()</em> library function dereferences all symbolic links in <em>pathname</em> (a null-terminated string) and resolves all references to <span class="literal">/.</span> and <span class="literal">/..</span> to produce a null-terminated string containing the corresponding absolute pathname.</p>
<div class="box">
<p class="programsa">#include &lt;stdlib.h&gt;<br/><br/>char *<span class="codestrong">realpath</span>(const char *<span class="font1">pathname</span>, char *<span class="font1">resolved_path</span>);</p>
<p class="right">Returns pointer to resolved pathname on success, or <span class="literal">NULL</span> on error</p>
</div>
<p class="noindent">The resulting string is placed in the buffer pointed to by <em>resolved_path</em>, which should be a character array of at least <span class="literal">PATH_MAX</span> bytes. On success, <em>realpath()</em> also returns a pointer to this resolved string.</p>
<p class="indent">The <em>glibc</em> implementation of <em>realpath()</em> allows the caller to specify <em>resolved_path</em> as <span class="literal">NULL</span>. In this case, <em>realpath()</em> allocates a buffer of up to <span class="literal">PATH_MAX</span> bytes for the resolved pathname and returns a pointer to that buffer as the function result. (The caller must deallocate this buffer using <em>free()</em>.) SUSv3 doesn&#8217;t specify this extension, but it is specified in SUSv4.</p>
<p class="indent">The program in <a href="ch18.xhtml#ch18ex4">Listing 18-4</a> uses <em>readlink()</em> and <em>realpath()</em> to read the contents of a symbolic link and to resolve the link to an absolute pathname. Here is an example of the use of this program:</p>
<p class="programs">$ <span class="codestrong">pwd</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Where are we?</span><br/>/home/mtk<br/>$ <span class="codestrong">touch x</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Make a file</span><br/>$ <span class="codestrong">ln -s x y</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">and a symbolic link to it</span><br/>$ <span class="codestrong">./view_symlink y</span><br/>readlink: y --&gt; x<br/>realpath: y --&gt; /home/mtk/x</p>
<p class="examplet"><a id="ch18ex4"/><strong>Listing 18-4:</strong> Read and resolve a symbolic link</p>
<p class="programsli">__________________________________________________<span class="codestrong">dirs_links/view_symlink.c</span><br/><br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;limits.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* For definition of PATH_MAX */<br/>#include "tlpi_hdr.h"<br/><br/>#define BUF_SIZE PATH_MAX<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct stat statbuf;<br/>&#160;&#160;&#160;&#160;char buf[BUF_SIZE];<br/>&#160;&#160;&#160;&#160;ssize_t numBytes;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s pathname\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;if (lstat(argv[1], &#38;statbuf) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("lstat");<br/><br/>&#160;&#160;&#160;&#160;if (!S_ISLNK(statbuf.st_mode))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("%s is not a symbolic link", argv[1]);<br/><br/>&#160;&#160;&#160;&#160;numBytes = readlink(argv[1], buf, BUF_SIZE - 1);<br/>&#160;&#160;&#160;&#160;if (numBytes == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("readlink");<br/>&#160;&#160;&#160;&#160;buf[numBytes] = '\0';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Add terminating null byte */<br/>&#160;&#160;&#160;&#160;printf("readlink: %s --&gt; %s\n", argv[1], buf);<br/><br/>&#160;&#160;&#160;&#160;if (realpath(argv[1], buf) == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("realpath");<br/>&#160;&#160;&#160;&#160;printf("realpath: %s --&gt; %s\n", argv[1], buf);<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>__________________________________________________<span class="codestrong">dirs_links/view_symlink.c</span></p>
<h3 class="h3" id="ch18lev1sec14"><span epub:type="pagebreak" id="page_370"/><strong>18.14 Parsing Pathname Strings: <em>dirname()</em> and <em>basename()</em></strong></h3>
<p class="noindenta">The <em>dirname()</em> and <em>basename()</em> functions break a pathname string into directory and filename parts. (These functions perform a similar task to the <em>dirname(1)</em> and <em>basename(1)</em> commands.)</p>
<div class="box">
<p class="programsa">#include &lt;libgen.h&gt;<br/><br/>char *<span class="codestrong">dirname</span>(char *<span class="font1">pathname</span>);<br/>char *<span class="codestrong">basename</span>(char *<span class="font1">pathname</span>);</p>
<p class="right">Both return a pointer to a null-terminated (and possibly statically allocated) string</p>
</div>
<p class="noindent">For example, given the pathname <span class="literal">/home/britta/prog.c</span>, <em>dirname()</em> returns <span class="literal">/home/britta</span> and <em>basename()</em> returns <span class="literal">prog.c</span>. Concatenating the string returned by <em>dirname()</em>, a slash (<span class="literal">/</span>), and the string returned by <em>basename()</em> yields a complete pathname.</p>
<p class="indentb">Note the following points regarding the operation of <em>dirname()</em> and <em>basename()</em>:</p>
<p class="bull">&#8226; Trailing slash characters in <em>pathname</em> are ignored.</p>
<p class="bull">&#8226; If <em>pathname</em> doesn&#8217;t contain a slash, then <em>dirname()</em> returns the string <span class="literal">.</span> (dot) and <em>basename()</em> returns <em>pathname</em>.</p>
<p class="bull">&#8226; If <em>pathname</em> consists of just a slash, then both <em>dirname()</em> and <em>basename()</em> return the string <span class="literal">/</span>. Applying the concatenation rule above to create a pathname from these returned strings would yield the string <span class="literal">///</span>. This <em>is</em> a valid pathname. Because multiple consecutive slashes are equivalent to a single slash, the pathname <span class="literal">///</span> is equivalent to the pathname <span class="literal">/</span>.</p>
<p class="bull"><span epub:type="pagebreak" id="page_371"/>&#8226; If <em>pathname</em> is a <span class="literal">NULL</span> pointer or an empty string, then both <em>dirname()</em> and <em>basename()</em> return the string <span class="literal">.</span> (dot). (Concatenating these strings yields the pathname <span class="literal">./.</span>, which is equivalent to <span class="literal">.</span>, the current directory.)</p>
<p class="noindentt"><a href="ch18.xhtml#ch18table3">Table 18-3</a> shows the strings returned by <em>dirname()</em> and <em>basename()</em> for various example pathnames.</p>
<p class="tablecap"><a id="ch18table3"/><strong>Table 18-3:</strong> Examples of strings returned by <em>dirname()</em> and <em>basename()</em></p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Pathname string</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><em>dirname()</em></strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong><em>basename()</em></strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">/</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">/</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">/</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">/usr/bin/zip</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">/usr/bin</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">zip</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">/etc/passwd////</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">/etc</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">passwd</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">/etc////passwd</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">/etc</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">passwd</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">etc/passwd</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">etc</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">passwd</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">passwd</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">.</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">passwd</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">passwd/</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">.</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">passwd</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">..</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">.</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">..</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">NULL</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">.</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table"><span class="literal">.</span></p></td>
</tr>
</tbody>
</table>
<p class="examplet"><a id="ch18ex5"/><strong>Listing 18-5:</strong> Using <em>dirname()</em> and <em>basename()</em></p>
<p class="programsli">_________________________________________________ <span class="codestrong">dirs_links/t_dirbasename.c</span><br/><br/>#include &lt;libgen.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;char *t1, *t2;<br/>&#160;&#160;&#160;&#160;int j;<br/><br/>&#160;&#160;&#160;&#160;for (j = 1; j &lt; argc; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t1 = strdup(argv[j]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (t1 == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("strdup");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t2 = strdup(argv[j]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (t2 == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("strdup");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s ==&gt; %s + %s\n", argv[j], dirname(t1), basename(t2));<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;free(t1);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;free(t2);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________ <span class="codestrong">dirs_links/t_dirbasename.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_372"/>Both <em>dirname()</em> and <em>basename()</em> may modify the string pointed to by <em>pathname</em>. Therefore, if we wish to preserve a pathname string, we must pass copies of it to <em>dirname()</em> and <em>basename()</em>, as shown in <a href="ch18.xhtml#ch18ex5">Listing 18-5</a> (<a href="ch18.xhtml#page_371">page 371</a>). This program uses <em>strdup()</em> (which calls <em>malloc()</em>) to make copies of the strings to be passed to <em>dirname()</em> and <em>basename()</em>, and then uses <em>free()</em> to deallocate the duplicate strings.</p>
<p class="indent">Finally, note that both <em>dirname()</em> and <em>basename()</em> can return pointers to statically allocated strings that may be modified by future calls to the same functions.</p>
<h3 class="h3" id="ch18lev1sec15"><strong>18.15 Summary</strong></h3>
<p class="noindenta">An i-node doesn&#8217;t contain a file&#8217;s name. Instead, files are assigned names via entries in directories, which are tables listing filename and i-node number correspondences. These directory entries are called (hard) links. A file may have multiple links, all of which enjoy equal status. Links are created and removed using <em>link()</em> and <em>unlink()</em>. A file can be renamed using the <em>rename()</em> system call.</p>
<p class="indent">A symbolic (or soft) link is created using <em>symlink()</em>. Symbolic links are similar to hard links in some respects, with the differences that symbolic links can cross file-system boundaries and can refer to directories. A symbolic link is just a file containing the name of another file; this name may be retrieved using <em>readlink()</em>. A symbolic link is not included in the (target) i-node&#8217;s link count, and it may be left dangling if the filename to which it refers is removed. Some system calls automatically dereference (follow) symbolic links; others do not. In some cases, two versions of a system call are provided: one that dereferences symbolic links and another that does not. Examples are <em>stat()</em> and <em>lstat()</em>.</p>
<p class="indent">Directories are created with <em>mkdir()</em> and removed using <em>rmdir()</em>. To scan the contents of a directory, we can use <em>opendir()</em>, <em>readdir()</em>, and related functions. The <em>nftw()</em> function allows a program to walk an entire directory tree, calling a programmer-defined function to operate on each file in the tree.</p>
<p class="indent">The <em>remove()</em> function can be used to remove a file (i.e., a link) or an empty directory.</p>
<p class="indent">Each process has a root directory, which determines the point from which absolute pathnames are interpreted, and a current working directory, which determines the point from which relative pathnames are interpreted. The <em>chroot()</em> and <em>chdir()</em> system calls are used to change these attributes. The <em>getcwd()</em> function returns a process&#8217;s current working directory.</p>
<p class="indent">Linux provides a set of system calls (e.g., <em>openat()</em>) that behave like their traditional counterparts (e.g., <em>open()</em>), except that relative pathnames can be interpreted with respect to the directory specified by a file descriptor supplied to the call (instead of using the process&#8217;s current working directory). This is useful for avoiding certain types of race conditions and for implementing per-thread virtual working directories.</p>
<p class="indent">The <em>realpath()</em> function resolves a pathname&#8212;dereferencing all symbolic links and resolving all references to <span class="literal">.</span> and <span class="literal">..</span> to corresponding directories&#8212;to yield a corresponding absolute pathname. The <em>dirname()</em> and <em>basename()</em> functions can be used to parse a pathname into directory and filename components.</p>
<h3 class="h3" id="ch18lev1sec16"><span epub:type="pagebreak" id="page_373"/><strong>18.16 Exercises</strong></h3>
<p class="exer"><a id="ch18exe1"/><strong>18-1.</strong>&#160;&#160;&#160;In <a href="ch04.xhtml#ch04lev2sec02">Section 4.3.2</a>, we noted that it is not possible to open a file for writing if it is currently being executed (<em>open()</em> returns &#8211;1, with <em>errno</em> set to <span class="literal">ETXTBSY</span>). Nevertheless, it is possible to do the following from the shell:</p>
<p class="programs1">$ <span class="codestrong">cc -o longrunner longrunner.c</span><br/>$ <span class="codestrong">./longrunner &#38;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Leave running in background</span><br/>$ <span class="codestrong">vi longrunner.c</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Make some changes to the source code</span><br/>$ <span class="codestrong">cc -o longrunner longrunner.c</span></p>
<p class="exerp">The last command overwrites the existing executable of the same name. How is this possible? (For a clue, use <em>ls &#8211;li</em> to look at the i-node number of the executable file after each compilation.)</p>
<p class="exer"><a id="ch18exe2"/><strong>18-2.</strong>&#160;&#160;&#160;Why does the call to <em>chmod()</em> in the following code fail?</p>
<p class="programs1">mkdir("test", S_IRUSR | S_IWUSR | S_IXUSR);<br/>chdir("test");<br/>fd = open("myfile", O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);<br/>symlink("myfile", "../mylink");<br/>chmod("../mylink", S_IRUSR);</p>
<p class="exer"><a id="ch18exe3"/><strong>18-3.</strong>&#160;&#160;&#160;Implement <em>realpath()</em>.</p>
<p class="exer"><a id="ch18exe4"/><strong>18-4.</strong>&#160;&#160;&#160;Modify the program in <a href="ch18.xhtml#ch18ex2">Listing 18-2</a> (<span class="literal">list_files.c</span>) to use <em>readdir_r()</em> instead of <em>readdir()</em>.</p>
<p class="exer"><a id="ch18exe5"/><strong>18-5.</strong>&#160;&#160;&#160;Implement a function that performs the equivalent of <em>getcwd()</em>. A useful tip for solving this problem is that you can find the name of the current working directory by using <em>opendir()</em> and <em>readdir()</em> to walk through each of the entries in the parent directory (<span class="literal">..</span>) to find an entry with the same i-node and device number as the current working directory (i.e., respectively, the <em>st_ino</em> and <em>st_dev</em> fields in the <em>stat</em> structure returned by <em>stat()</em> and <em>lstat()</em>). Thus, it is possible to construct the directory path by walking up the directory tree (<em>chdir(&#8220;..&#8221;)</em>) one step at a time and performing such scans. The walk can be finished when the parent directory is the same as the current working directory (recall that <span class="literal">/..</span> is the same as <span class="literal">/</span>). The caller should be left in the same directory in which it started, regardless of whether your <em>getcwd()</em> function succeeds or fails (<em>open()</em> plus <em>fchdir()</em> are handy for this purpose).</p>
<p class="exer"><a id="ch18exe6"/><strong>18-6.</strong>&#160;&#160;&#160;Modify the program in <a href="ch18.xhtml#ch18ex3">Listing 18-3</a> (<span class="literal">nftw_dir_tree.c</span>) to use the <span class="literal">FTW_DEPTH</span> flag. Note the difference in the order in which the directory tree is traversed.</p>
<p class="exer"><a id="ch18exe7"/><strong>18-7.</strong>&#160;&#160;&#160;Write a program that uses <em>nftw()</em> to traverse a directory tree and finishes by printing out counts and percentages of the various types (regular, directory, symbolic link, and so on) of files in the tree.</p>
<p class="exer"><a id="ch18exe8"/><strong>18-8.</strong>&#160;&#160;&#160;Implement <em>nftw()</em>. (This will require the use of the <em>opendir()</em>, <em>readdir()</em>, <em>closedir()</em>, and <em>stat()</em> system calls, among others.)</p>
<p class="exer"><a id="ch18exe9"/><strong>18-9.</strong>&#160;&#160;&#160;In <a href="ch18.xhtml#ch18lev1sec10">Section 18.10</a>, we showed two different techniques (using <em>fchdir()</em> and <em>chdir()</em>, respectively) to return to the previous current working directory after changing the current working directory to another location. Suppose we are performing such an operation repeatedly. Which method do you expect to be more efficient? Why? Write a program to confirm your answer.<span epub:type="pagebreak" id="page_374"/></p>
</body>
</html>
