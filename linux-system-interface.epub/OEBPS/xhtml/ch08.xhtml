<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_153"/><strong><span class="big">8</span></strong><br/><strong>USERS AND GROUPS</strong></h2>
<p class="noindenta">Every user has a unique login name and an associated numeric user identifier (UID). Users can belong to one or more groups. Each group also has a unique name and a group identifier (GID).</p>
<p class="indent">The primary purpose of user and group IDs is to determine ownership of various system resources and to control the permissions granted to processes accessing those resources. For example, each file belongs to a particular user and group, and each process has a number of user and group IDs that determine who owns the process and what permissions it has when accessing a file (see <a href="ch09.xhtml#ch09">Chapter 9</a> for details).</p>
<p class="indent">In this chapter, we look at the system files that are used to define the users and groups on the system, and then describe the library functions used to retrieve information from these files. We conclude with a discussion of the <em>crypt()</em> function, which is used to encrypt and authenticate login passwords.</p>
<h3 class="h3" id="ch08lev1sec01"><strong>8.1 The Password File:</strong> <span class="literal"><span class="codestrong">/etc/passwd</span></span></h3>
<p class="noindenta">The system <em>password file</em>, <span class="literal">/etc/passwd</span>, contains one line for each user account on the system. Each line is composed of seven fields separated by colons (<span class="literal">:</span>), as in the following example:</p>
<p class="programs">mtk:x:1000:100:Michael Kerrisk:/home/mtk:/bin/bash</p>
<p class="noindentb"><span epub:type="pagebreak" id="page_154"/>In order, these fields are as follows:</p>
<p class="bull">&#8226; <em>Login name</em>: This is the unique name that the user must enter in order to log in. Often, this is also called the username. We can also consider the login name to be the human-readable (symbolic) identifier corresponding to the numeric user identifier (described in a moment). Programs such as <em>ls(1)</em> display this name, rather than the numeric user ID associated with the file, when asked to show the ownership of a file (as in <em>ls &#8211;l</em>).</p>
<p class="bull">&#8226; <em>Encrypted password</em>: This field contains a 13-character encrypted password, which we describe in more detail in <a href="ch08.xhtml#ch08lev1sec05">Section 8.5</a>. If the password field contains any other string&#8212;in particular, a string of other than 13 characters&#8212;then logins to this account are disabled, since such a string can&#8217;t represent a valid encrypted password. Note, however, that this field is ignored if shadow passwords have been enabled (which is typical). In this case, the password field in <span class="literal">/etc/passwd</span> contains the letter <em>x</em>, and the encrypted password is instead stored in the shadow password file (<a href="ch08.xhtml#ch08lev1sec02">Section 8.2</a>). If the password field in <span class="literal">/etc/passwd</span> is empty, then no password is required to log in to this account (this is true even if shadow passwords are enabled).</p>
<div class="block1">
<p class="noindent">Here, we assume that passwords are encrypted using Data Encryption Standard (DES), the historical and still widely used UNIX password-encryption scheme. It is possible to replace DES with other schemes, such as MD5, which produces a 128-bit <em>message digest</em> (a kind of hash) of its input. This value is stored as a 34-character string in the password (or shadow password) file.</p>
</div>
<p class="bull">&#8226; <em>User ID</em> (UID): This is the numeric ID for this user. If this field has the value 0, then this account has superuser privileges. There is normally one such account, with the login name <em>root</em>. On Linux 2.2 and earlier, user IDs are maintained as 16-bit values, allowing the range 0 through to 65,535; on Linux 2.4 and later, they are stored using 32 bits, allowing a much larger range.</p>
<div class="block1">
<p class="noindent">It is possible (but unusual) to have more than one record in the password file with the same user ID, thus permitting multiple login names for the same user ID. This allows multiple users to access the same resources (e.g., files) using different passwords. The different login names can be associated with different sets of group IDs.</p>
</div>
<p class="bull">&#8226; <em>Group ID</em> (GID): This is the numeric ID of the first of the groups of which this user is a member. Further group memberships for this user are defined in the system group file.</p>
<p class="bull">&#8226; <em>Comment</em>: This field holds text about the user. This text is displayed by various programs, such as <em>finger(1)</em>.</p>
<p class="bull">&#8226; <em>Home directory</em>: This is the initial directory into which the user is placed after logging in. This field becomes the value of the <span class="literal">HOME</span> environment variable.</p>
<p class="bull">&#8226; <em>Login shell</em>: This is the program to which control is transferred once the user is logged in. Usually, this is one of the shells, such as <em>bash</em>, but it can be any program. If this field is empty, then the login shell defaults to <span class="literal">/bin/sh</span>, the Bourne shell. This field becomes the value of the <span class="literal">SHELL</span> environment variable.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_155"/>On a stand-alone system, all the password information resides in the file <span class="literal">/etc/passwd</span>. However, if we are using a system such as Network Information System (NIS) or Lightweight Directory Access Protocol (LDAP) to distribute passwords in a network environment, part or all of this information resides on a remote system. As long as programs accessing password information employ the functions described later in this chapter (<em>getpwnam()</em>, <em>getpwuid()</em>, and so on), the use of NIS or LDAP is transparent to applications. Similar comments apply regarding the shadow password and group files discussed in the following sections.</p>
<h3 class="h3" id="ch08lev1sec02"><strong>8.2 The Shadow Password File:</strong> <span class="literal"><span class="codestrong">/etc/shadow</span></span></h3>
<p class="noindenta">Historically, UNIX systems maintained all user information, including the encrypted password, in <span class="literal">/etc/passwd</span>. This presented a security problem. Since various unprivileged system utilities needed to have read access to other information in the password file, it had to be made readable to all users. This opened the door for password-cracking programs, which try encrypting large lists of likely passwords (e.g., standard dictionary words or people&#8217;s names) to see if they match the encrypted password of a user. The <em>shadow password file</em>, <span class="literal">/etc/shadow</span>, was devised as a method of preventing such attacks. The idea is that all of the nonsensitive user information resides in the publicly readable password file, while encrypted passwords are maintained in the shadow password file, which is readable only by privileged programs.</p>
<p class="indent">In addition to the login name, which provides the match to the corresponding record in the password file, and the encrypted password, the shadow password file also contains a number of other security-related fields. Further details on these fields can be found in the <em>shadow(5)</em> manual page. We&#8217;ll concern ourselves mainly with the encrypted password field, which we discuss in greater detail when looking at the <em>crypt()</em> library function later in <a href="ch08.xhtml#ch08lev1sec05">Section 8.5</a>.</p>
<p class="indent">SUSv3 doesn&#8217;t specify shadow passwords. Not all UNIX implementations provide this feature, and on implementations where it is provided the details of locations and APIs vary.</p>
<h3 class="h3" id="ch08lev1sec03"><strong>8.3 The Group File:</strong> <span class="literal"><span class="codestrong">/etc/group</span></span></h3>
<p class="noindenta">For various administrative purposes, in particular, controlling access to files and other system resources, it is useful to organize users into <em>groups</em>.</p>
<p class="indent">The set of groups to which a user belongs is defined by the combination of the group ID field in the user&#8217;s password entry and the groups under which the user is listed in the group file. This strange split of information across two files is historical in origin. In early UNIX implementations, a user could be a member of only one group at a time. A user&#8217;s initial group membership at login was determined by the group ID field of the password file and could be changed thereafter using the <em>newgrp(1)</em> command, which required the user to supply the group password (if the group was password protected). 4.2BSD introduced the concept of multiple simultaneous group memberships, which was later standardized in POSIX.1-1990. Under this scheme, the group file listed the extra group memberships of each user. (The <em>groups(1)</em> command displays the groups of which the shell process is a member, <span epub:type="pagebreak" id="page_156"/>or, if one or more usernames are supplied as command-line arguments, then the group memberships of those users.)</p>
<p class="indent">The <em>group file</em>, <span class="literal">/etc/group</span>, contains one line for each group in the system. Each line consists of four colon-separated fields, as in the following examples:</p>
<p class="programs">users:x:100:<br/>jambit:x:106:claus,felli,frank,harti,markus,martin,mtk,paul</p>
<p class="noindentb">In order, these fields are as follows:</p>
<p class="bull">&#8226; <em>Group name</em>: This is the name of the group. Like the login name in the password file, we can consider this to be the human-readable (symbolic) identifier corresponding to the numeric group identifier.</p>
<p class="bull">&#8226; <em>Encrypted password</em>: This field contains an optional password for the group. With the advent of multiple group memberships, group passwords are nowadays rarely used on UNIX systems. Nevertheless, it is possible to place a password on a group (a privileged user can do this using the <em>gpasswd</em> command). If a user is not a member of the group, <em>newgrp(1)</em> requests this password before starting a new shell whose group memberships include that group. If password shadowing is enabled, then this field is ignored (in this case, conventionally it contains just the letter <em>x</em>, but any string, including an empty string, may appear) and the encrypted passwords are actually kept in the <em>shadow group file</em>, <span class="literal">/etc/gshadow</span>, which can be accessed only by privileged users and programs. Group passwords are encrypted in a similar fashion to user passwords (<a href="ch08.xhtml#ch08lev1sec05">Section 8.5</a>).</p>
<p class="bull">&#8226; <em>Group ID</em> (GID): This is the numeric ID for this group. There is normally one group defined with the group ID 0, named <em>root</em> (like the <span class="literal">/etc/passwd</span> record with user ID of 0, but unlike the user ID 0, this group has no special privileges). On Linux 2.2 and earlier, group IDs are maintained as 16-bit values, allowing the range 0 through to 65,535; on Linux 2.4 and later, they are stored using 32 bits.</p>
<p class="bull">&#8226; <em>User list</em>: This is a comma-separated list of names of users who are members of this group. (This list consists of usernames rather than user IDs, since, as noted earlier, user IDs are not necessarily unique in the password file.)</p>
<p class="noindentt">To record that the user <em>avr</em> is a member of the groups <em>users</em>, <em>staff</em>, and <em>teach</em>, we would see the following record in the password file:</p>
<p class="programs">avr:x:1001:100:Anthony Robins:/home/avr:/bin/bash</p>
<p class="noindent">And the following records would appear in the group file:</p>
<p class="programs">users:x:100:<br/>staff:x:101:mtk,avr,martinl<br/>teach:x:104:avr,rlb,alc</p>
<p class="noindent">The fourth field of the password record, containing the group ID 100, specifies membership of the group <em>users</em>. The remaining group memberships are indicated by listing <em>avr</em> once in each of the relevant records in the group file.</p>
<h3 class="h3" id="ch08lev1sec04"><span epub:type="pagebreak" id="page_157"/><strong>8.4 Retrieving User and Group Information</strong></h3>
<p class="noindenta">In this section, we look at library functions that permit us to retrieve individual records from the password, shadow password, and group files, and to scan all of the records in each of these files.</p>
<h5 class="h5" id="ch08lev3sec01"><strong>Retrieving records from the password file</strong></h5>
<p class="noindenta">The <em>getpwnam()</em> and <em>getpwuid()</em> functions retrieve records from the password file.</p>
<div class="box">
<p class="programsa">#include &lt;pwd.h&gt;<br/><br/>struct passwd *<span class="codestrong">getpwnam</span>(const char *<span class="font1">name</span>);<br/>struct passwd *<span class="codestrong">getpwuid</span>(uid_t <span class="font1">uid</span>);</p>
<p class="right">Both return a pointer on success, or <span class="literal">NULL</span> on error; see main text for description of the &#8220;not found&#8221; case</p>
</div>
<p class="noindent">Given a login name in <em>name</em>, the <em>getpwnam()</em> function returns a pointer to a structure of the following type, containing the corresponding information from the password record:</p>
<p class="programs">struct passwd {<br/>&#160;&#160;&#160;&#160;char *pw_name;&#160;&#160;&#160;&#160;&#160;&#160;/* Login name (username) */<br/>&#160;&#160;&#160;&#160;char *pw_passwd;&#160;&#160;&#160;&#160;/* Encrypted password */<br/>&#160;&#160;&#160;&#160;uid_t pw_uid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* User ID */<br/>&#160;&#160;&#160;&#160;gid_t pw_gid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Group ID */<br/>&#160;&#160;&#160;&#160;char *pw_gecos;&#160;&#160;&#160;&#160;&#160;/* Comment (user information) */<br/>&#160;&#160;&#160;&#160;char *pw_dir;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Initial working (home) directory */<br/>&#160;&#160;&#160;&#160;char *pw_shell;&#160;&#160;&#160;&#160;&#160;/* Login shell */<br/>};</p>
<p class="noindent">The <em>pw_gecos</em> and <em>pw_passwd</em> fields of the <em>passwd</em> structure are not defined in SUSv3, but are available on all UNIX implementations. The <em>pw_passwd</em> field contains valid information only if password shadowing is not enabled. (Programmatically, the simplest way to determine whether password shadowing is enabled is to follow a successful <em>getpwnam()</em> call with a call to <em>getspnam()</em>, described shortly, to see if it returns a shadow password record for the same username.) Some other implementations provide additional, nonstandard fields in this structure.</p>
<div class="block">
<p class="noindent">The <em>pw_gecos</em> field derives its name from early UNIX implementations, where this field contained information that was used for communicating with a machine running the General Electric Comprehensive Operating System (GECOS). Although this usage has long since become obsolete, the field name has survived, and the field is used for recording information about the user.</p>
</div>
<p class="noindent">The <em>getpwuid()</em> function returns exactly the same information as <em>getpwnam()</em>, but does a lookup using the numeric user ID supplied in the argument <em>uid</em>.</p>
<p class="indent">Both <em>getpwnam()</em> and <em>getpwuid()</em> return a pointer to a statically allocated structure. This structure is overwritten on each call to either of these functions (or to the <em>getpwent()</em> function described below).</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_158"/>Because they return a pointer to statically allocated memory, <em>getpwnam()</em> and <em>getpwuid()</em> are not reentrant. In fact, the situation is even more complex, since the returned <em>passwd</em> structure contains pointers to other information (e.g., the <em>pw_name</em> field) that is also statically allocated. (We explain reentrancy in <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>.) Similar statements apply to the <em>getgrnam()</em> and <em>getgrgid()</em> functions (described shortly).</p>
<p class="indent">SUSv3 specifies an equivalent set of reentrant functions&#8212;<em>getpwnam_r()</em>, <em>getpwuid_r()</em>, <em>getgrnam_r()</em>, and <em>getgrgid_r()</em>&#8212;that include as arguments both a <em>passwd</em> (or <em>group</em>) structure and a buffer area to hold the other structures to which the fields of the <em>passwd</em> (<em>group</em>) structure point. The number of bytes required for this additional buffer can be obtained using the call <em>sysconf(_SC_GETPW_R_SIZE_MAX)</em> (or <em>sysconf(_SC_GETGR_R_SIZE_MAX)</em> in the case of the group-related functions). See the manual pages for details of these functions.</p>
</div>
<p class="noindent">According to SUSv3, if a matching <em>passwd</em> record can&#8217;t be found, then <em>getpwnam()</em> and <em>getpwuid()</em> should return <span class="literal">NULL</span> and leave <em>errno</em> unchanged. This means that we should be able to distinguish the error and the &#8220;not found&#8221; cases using code such as the following:</p>
<p class="programs">struct passwd *pwd;<br/><br/>errno = 0;<br/>pwd = getpwnam(name);<br/>if (pwd == NULL) {<br/>&#160;&#160;&#160;&#160;if (errno == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Not found */;<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Error */;<br/>}</p>
<p class="noindent">However, a number of UNIX implementations don&#8217;t conform to SUSv3 on this point. If a matching <em>passwd</em> record is not found, then these functions return <span class="literal">NULL</span> and set <em>errno</em> to a nonzero value, such as <span class="literal">ENOENT</span> or <span class="literal">ESRCH</span>. Before version 2.7, <em>glibc</em> produced the error <span class="literal">ENOENT</span> for this case, but since version 2.7, <em>glibc</em> conforms to the SUSv3 requirements. This variation across implementations arises in part because POSIX.1-1990 did not require these functions to set <em>errno</em> on error and allowed them to set <em>errno</em> for the &#8220;not found&#8221; case. The upshot of all of this is that it isn&#8217;t really possible to portably distinguish the error and &#8220;not found&#8221; cases when using these functions.</p>
<h5 class="h5" id="ch08lev3sec02"><strong>Retrieving records from the group file</strong></h5>
<p class="noindenta">The <em>getgrnam()</em> and <em>getgrgid()</em> functions retrieve records from the group file.</p>
<div class="box">
<p class="programsa">#include &lt;grp.h&gt;<br/><br/>struct group *<span class="codestrong">getgrnam</span>(const char *<span class="font1">name</span>);<br/>struct group *<span class="codestrong">getgrgid</span>(gid_t <span class="font1">gid</span>);</p>
<p class="right">Both return a pointer on success, or <span class="literal">NULL</span> on error; see main text for description of the &#8220;not found&#8221; case</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_159"/>The <em>getgrnam()</em> function looks up group information by group name, and the <em>getgrgid()</em> function performs lookups by group ID. Both functions return a pointer to a structure of the following type:</p>
<p class="programs">struct group {<br/>&#160;&#160;&#160;&#160;char&#160;&#160;*gr_name;&#160;&#160;&#160;&#160;&#160;/* Group name */<br/>&#160;&#160;&#160;&#160;char&#160;&#160;*gr_passwd;&#160;&#160;&#160;/* Encrypted password (if not password shadowing) */<br/>&#160;&#160;&#160;&#160;gid_t&#160;&#160;gr_gid;&#160;&#160;&#160;&#160;&#160;&#160;/* Group ID */<br/>&#160;&#160;&#160;&#160;char **gr_mem ;&#160;&#160;&#160;&#160;&#160;/* NULL-terminated array of pointers to names<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;of members listed in /etc/group */<br/>};</p>
<div class="block">
<p class="noindent">The <em>gr_passwd</em> field of the <em>group</em> structure is not specified in SUSv3, but is available on most UNIX implementations.</p>
</div>
<p class="noindent">As with the corresponding password functions described above, this structure is overwritten on each call to one of these functions.</p>
<p class="indent">If these functions can&#8217;t find a matching <em>group</em> record, then they show the same variations in behavior that we described for <em>getpwnam()</em> and <em>getpwuid()</em>.</p>
<h5 class="h5" id="ch08lev3sec03"><strong>Example program</strong></h5>
<p class="noindenta">One common use of the functions that we have already described in this section is to convert symbolic user and group names into numeric IDs and vice versa. <a href="ch08.xhtml#ch8ex1">Listing 8-1</a> demonstrates these conversions, in the form of four functions: <em>userNameFromId()</em>, <em>userIdFromName()</em>, <em>groupNameFromId()</em>, and <em>groupIdFromName()</em>. As a convenience to the caller, <em>userIdFromName()</em> and <em>groupIdFromName()</em> also allow the <em>name</em> argument to be a (purely) numeric string; in that case, the string is converted directly to a number and returned to the caller. We employ these functions in some example programs later in this book.</p>
<p class="examplet"><a id="ch8ex1"/><strong>Listing 8-1:</strong> Functions to convert user and group IDs to and from user and group names</p>
<p class="programsli">______________________________________________ <span class="codestrong">users_groups/ugid_functions.c</span><br/><br/>#include &lt;pwd.h&gt;<br/>#include &lt;grp.h&gt;<br/>#include &lt;ctype.h&gt;<br/>#include "ugid_functions.h"&#160;&#160;&#160;&#160;&#160;/* Declares functions defined here */<br/><br/>char *&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Return name corresponding to 'uid', or NULL on error */<br/>userNameFromId(uid_t uid)<br/>{<br/>&#160;&#160;&#160;&#160;struct passwd *pwd;<br/><br/>&#160;&#160;&#160;&#160;pwd = getpwuid(uid);<br/>&#160;&#160;&#160;&#160;return (pwd == NULL) ? NULL : pwd-&gt;pw_name;<br/>}<br/><br/>uid_t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Return UID corresponding to 'name', or -1 on error */<br/>userIdFromName(const char *name)<br/>{<br/>&#160;&#160;&#160;&#160;struct passwd *pwd;<br/>&#160;&#160;&#160;&#160;uid_t u;<br/>&#160;&#160;&#160;&#160;char *endptr;<br/><br/>&#160;&#160;&#160;&#160;if (name == NULL || *name == '\0')&#160;&#160;/* On NULL or empty string */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* return an error */<br/><br/>&#160;&#160;&#160;&#160;u = strtol(name, &#38;endptr, 10);&#160;&#160;&#160;&#160;&#160;&#160;/* As a convenience to caller */<br/>&#160;&#160;&#160;&#160;if (*endptr == '\0')&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* allow a numeric string */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return u;<br/><br/>&#160;&#160;&#160;&#160;pwd = getpwnam(name);<br/>&#160;&#160;&#160;&#160;if (pwd == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/>&#160;&#160;&#160;&#160;return pwd-&gt;pw_uid;<br/>}<br/><br/>char *&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Return name corresponding to 'gid', or NULL on error */<br/>groupNameFromId(gid_t gid)<br/>{<br/>&#160;&#160;&#160;&#160;struct group *grp;<br/><br/>&#160;&#160;&#160;&#160;grp = getgrgid(gid);<br/>&#160;&#160;&#160;&#160;return (grp == NULL) ? NULL : grp-&gt;gr_name;<br/>}<br/><br/>gid_t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Return GID corresponding to 'name', or -1 on error */<br/>groupIdFromName(const char *name)<br/>{<br/>&#160;&#160;&#160;&#160;struct group *grp;<br/>&#160;&#160;&#160;&#160;gid_t g;<br/>&#160;&#160;&#160;&#160;char *endptr;<br/><br/>&#160;&#160;&#160;&#160;if (name == NULL || *name == '\0')&#160;&#160;/* On NULL or empty string */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* return an error */<br/><br/>&#160;&#160;&#160;&#160;g = strtol(name, &#38;endptr, 10);&#160;&#160;&#160;&#160;&#160;&#160;/* As a convenience to caller */<br/>&#160;&#160;&#160;&#160;if (*endptr == '\0')&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* allow a numeric string */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return g;<br/><br/>&#160;&#160;&#160;&#160;grp = getgrnam(name);<br/>&#160;&#160;&#160;&#160;if (grp == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/>&#160;&#160;&#160;&#160;return grp-&gt;gr_gid;<br/>}<br/>______________________________________________ <span class="codestrong">users_groups/ugid_functions.c</span></p>
<h5 class="h5" id="ch08lev3sec04"><span epub:type="pagebreak" id="page_160"/><strong>Scanning all records in the password and group files</strong></h5>
<p class="noindenta">The <em>setpwent()</em>, <em>getpwent()</em>, and <em>endpwent()</em> functions are used to perform sequential scans of the records in the password file.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_161"/>#include &lt;pwd.h&gt;<br/><br/>struct passwd *<span class="codestrong">getpwent</span>(void);</p>
<p class="right">Returns pointer on success, or <span class="literal">NULL</span> on end of stream or error</p>
<p class="programsat">void <span class="codestrong">setpwent</span>(void);<br/>void <span class="codestrong">endpwent</span>(void);</p>
</div>
<p class="noindent">The <em>getpwent()</em> function returns records from the password file one by one, returning <span class="literal">NULL</span> when there are no more records (or an error occurs). On the first call, <em>getpwent()</em> automatically opens the password file. When we have finished with the file, we call <em>endpwent()</em> to close it.</p>
<p class="indent">We can walk through the entire password file printing login names and user IDs with the following code:</p>
<p class="programs">struct passwd *pwd;<br/><br/>while ((pwd = getpwent()) != NULL)<br/>&#160;&#160;&#160;&#160;printf("%-8s %5ld\n", pwd-&gt;pw_name, (long) pwd-&gt;pw_uid);<br/><br/>endpwent();</p>
<p class="noindent">The <em>endpwent()</em> call is necessary so that any subsequent <em>getpwent()</em> call (perhaps in some other part of our program or in some library function that we call) will reopen the password file and start from the beginning. On the other hand, if we are part-way through the file, we can use the <em>setpwent()</em> function to restart from the beginning.</p>
<p class="indent">The <em>getgrent()</em>, <em>setgrent()</em>, and <em>endgrent()</em> functions perform analogous tasks for the group file. We omit the prototypes for these functions because they are similar to those of the password file functions described above; see the manual pages for details.</p>
<h5 class="h5" id="ch08lev3sec05"><strong>Retrieving records from the shadow password file</strong></h5>
<p class="noindenta">The following functions are used to retrieve individual records from the shadow password file and to scan all records in that file.</p>
<div class="box">
<p class="programsa">#include &lt;shadow.h&gt;<br/><br/>struct spwd *<span class="codestrong">getspnam</span>(const char *<span class="font1">name</span>);</p>
<p class="right">Returns pointer on success, or <span class="literal">NULL</span> on not found or error</p>
<p class="programsat">struct spwd *<span class="codestrong">getspent</span>(void);</p>
<p class="right">Returns pointer on success, or <span class="literal">NULL</span> on end of stream or error</p>
<p class="programsat">void <span class="codestrong">setspent</span>(void);<br/>void <span class="codestrong">endspent</span>(void);</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_162"/>We won&#8217;t describe these functions in detail, since their operation is similar to the corresponding password file functions. (These functions aren&#8217;t specified in SUSv3, and aren&#8217;t present on all UNIX implementations.)</p>
<p class="indent">The <em>getspnam()</em> and <em>getspent()</em> functions return pointers to a structure of type <em>spwd</em>. This structure has the following form:</p>
<p class="programs">struct spwd {<br/>&#160;&#160;&#160;&#160;char *sp_namp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Login name (username) */<br/>&#160;&#160;&#160;&#160;char *sp_pwdp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Encrypted password */<br/><br/>&#160;&#160;&#160;&#160;/* Remaining fields support "password aging", an optional<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;feature that forces users to regularly change their<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;passwords, so that even if an attacker manages to obtain<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;a password, it will eventually cease to be usable. */<br/><br/>&#160;&#160;&#160;&#160;long sp_lstchg;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Time of last password change<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(days since 1 Jan 1970) */<br/>&#160;&#160;&#160;&#160;long sp_min;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Min. number of days between password changes */<br/>&#160;&#160;&#160;&#160;long sp_max;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Max. number of days before change required */<br/>&#160;&#160;&#160;&#160;long sp_warn;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of days beforehand that user is<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;warned of upcoming password expiration */<br/>&#160;&#160;&#160;&#160;long sp_inact;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of days after expiration that account<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;is considered inactive and locked */<br/>&#160;&#160;&#160;&#160;long sp_expire;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Date when account expires<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(days since 1 Jan 1970) */<br/>&#160;&#160;&#160;&#160;unsigned long sp_flag;&#160;&#160;/* Reserved for future use */<br/>};</p>
<p class="noindent">We demonstrate the use of <em>getspnam()</em> in <a href="ch08.xhtml#ch8ex2">Listing 8-2</a>.</p>
<h3 class="h3" id="ch08lev1sec05"><strong>8.5 Password Encryption and User Authentication</strong></h3>
<p class="noindenta">Some applications require that users authenticate themselves. Authentication typically takes the form of a username (login name) and password. An application may maintain its own database of usernames and passwords for this purpose. Sometimes, however, it is necessary or convenient to allow users to enter their standard username and password as defined in <span class="literal">/etc/passwd</span> and <span class="literal">/etc/shadow</span>. (For the remainder of this section, we assume a system where password shadowing is enabled, and thus that the encrypted password is stored in <span class="literal">/etc/shadow</span>.) Network applications that provide some form of login to a remote system, such as <em>ssh</em> and <em>ftp</em>, are typical examples of such programs. These applications must validate a username and password in the same way that the standard <em>login</em> program does.</p>
<p class="indent">For security reasons, UNIX systems encrypt passwords using a <em>one-way encryption</em> algorithm, which means that there is no method of re-creating the original password from its encrypted form. Therefore, the only way of validating a candidate password is to encrypt it using the same method and see if the encrypted result matches the value stored in <span class="literal">/etc/shadow</span>. The encryption algorithm is encapsulated in the <em>crypt()</em> function.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_163"/>#define _XOPEN_SOURCE<br/>#include &lt;unistd.h&gt;<br/><br/>char *<span class="codestrong">crypt</span>(const char *<span class="font1">key</span>, const char *<span class="font1">salt</span>);</p>
<p class="right">Returns pointer to statically allocated string containing encrypted password on success, or <span class="literal">NULL</span> on error</p>
</div>
<p class="noindent">The <em>crypt()</em> algorithm takes a <em>key</em> (i.e., a password) of up to 8 characters, and applies a variation of the Data Encryption Standard (DES) algorithm to it. The <em>salt</em> argument is a 2-character string whose value is used to perturb (vary) the algorithm, a technique designed to make it more difficult to crack the encrypted password. The function returns a pointer to a statically allocated 13-character string that is the encrypted password.</p>
<div class="block">
<p class="noindent">Details of DES can be found at <em><a href="http://www.itl.nist.gov/fipspubs/fip46-2.htm">http://www.itl.nist.gov/fipspubs/fip46-2.htm</a></em>. As noted earlier, other algorithms may be used instead of DES. For example, MD5 yields a 34-character string starting with a dollar sign (<span class="literal">$</span>), which allows <em>crypt()</em> to distinguish DES-encrypted passwords from MD5-encrypted passwords.</p>
<p class="indent">In our discussion of password encryption, we are using the word &#8220;encryption&#8221; somewhat loosely. Accurately, DES uses the given password string as an encryption key to encode a fixed bit string, while MD5 is a complex type of hashing function. The result in both cases is the same: an undecipherable and irreversible transformation of the input password.</p>
</div>
<p class="noindent">Both the <em>salt</em> argument and the encrypted password are composed of characters selected from the 64-character set <span class="literal">[a-zA-Z0-9/.]</span>. Thus, the 2-character <em>salt</em> argument can cause the encryption algorithm to vary in any of 64 * 64 = 4096 different ways. This means that instead of preencrypting an entire dictionary and checking the encrypted password against all words in the dictionary, a cracker would need to check the password against 4096 encrypted versions of the dictionary.</p>
<p class="indent">The encrypted password returned by <em>crypt()</em> contains a copy of the original <em>salt</em> value as its first two characters. This means that when encrypting a candidate password, we can obtain the appropriate <em>salt</em> value from the encrypted password value already stored in <span class="literal">/etc/shadow</span>. (Programs such as <em>passwd(1)</em> generate a random <em>salt</em> value when encrypting a new password.) In fact, the <em>crypt()</em> function ignores any characters in the <em>salt</em> string beyond the first two. Therefore, we can specify the encrypted password itself as the <em>salt</em> argument.</p>
<p class="indent">In order to use <em>crypt()</em> on Linux, we must compile programs with the <em>&#8211;lcrypt</em> option, so that they are linked against the <em>crypt</em> library.</p>
<h5 class="h5" id="ch08lev3sec06"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch08.xhtml#ch8ex2">Listing 8-2</a> demonstrates how to use <em>crypt()</em> to authenticate a user. This program first reads a username and then retrieves the corresponding password record and (if it exists) shadow password record. The program prints an error message and exits if no password record is found, or if the program doesn&#8217;t have permission to read from the shadow password file (this requires either superuser privilege or membership of the <em>shadow</em> group). The program then reads the user&#8217;s password, using the <em>getpass()</em> function.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_164"/>#define _BSD_SOURCE<br/>#include &lt;unistd.h&gt;<br/><br/>char *<span class="codestrong">getpass</span>(const char *<span class="font1">prompt</span>);</p>
<p class="right">Returns pointer to statically allocated input password string on success, or <span class="literal">NULL</span> on error</p>
</div>
<p class="noindent">The <em>getpass()</em> function first disables echoing and all processing of terminal special characters (such as the <em>interrupt</em> character, normally <em>Control-C</em>). (We explain how to change these terminal settings in <a href="ch62.xhtml#ch62">Chapter 62</a>.) It then prints the string pointed to by <em>prompt</em>, and reads a line of input, returning the null-terminated input string with the trailing newline stripped, as its function result. (This string is statically allocated, and so will be overwritten on a subsequent call to <em>getpass()</em>.) Before returning, <em>getpass()</em> restores the terminal settings to their original states.</p>
<p class="indent">Having read a password with <em>getpass()</em>, the program in <a href="ch08.xhtml#ch8ex2">Listing 8-2</a> then validates that password by using <em>crypt()</em> to encrypt it and checking that the resulting string matches the encrypted password recorded in the shadow password file. If the password matches, then the ID of the user is displayed, as in the following example:</p>
<p class="programs">$ <span class="codestrong">su</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Need privilege to read shadow password file</span><br/>Password:<br/># <span class="codestrong">./check_password</span><br/>Username: <span class="codestrong">mtk</span><br/>Password:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">We type in password, which is not echoed</span><br/>Successfully authenticated: UID=1000</p>
<div class="block">
<p class="noindent">The program in <a href="ch08.xhtml#ch8ex2">Listing 8-2</a> sizes the character array holding a username using the value returned by <em>sysconf(_SC_LOGIN_NAME_MAX)</em>, which yields the maximum size of a username on the host system. We explain the use of <em>sysconf()</em> in <a href="ch11.xhtml#ch11lev1sec02">Section 11.2</a>.</p>
</div>
<p class="examplet"><a id="ch8ex2"/><strong>Listing 8-2:</strong> Authenticating a user against the shadow password file</p>
<p class="programsli">______________________________________________ <span class="codestrong">users_groups/check_password.c</span><br/><br/>#define _BSD_SOURCE&#160;&#160;&#160;&#160;&#160;/* Get getpass() declaration from &lt;unistd.h&gt; */<br/>#define _XOPEN_SOURCE&#160;&#160;&#160;/* Get crypt() declaration from &lt;unistd.h&gt; */<br/>#include &lt;unistd.h&gt;<br/>#include &lt;limits.h&gt;<br/>#include &lt;pwd.h&gt;<br/>#include &lt;shadow.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;char *username, *password, *encrypted, *p;<br/>&#160;&#160;&#160;&#160;struct passwd *pwd;<br/>&#160;&#160;&#160;&#160;struct spwd *spwd;<br/>&#160;&#160;&#160;&#160;Boolean authOk;<br/>&#160;&#160;&#160;&#160;size_t len;<br/>&#160;&#160;&#160;&#160;long lnmax;<br/><br/>&#160;&#160;&#160;&#160;lnmax = sysconf(_SC_LOGIN_NAME_MAX);<br/>&#160;&#160;&#160;&#160;if (lnmax == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If limit is indeterminate */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lnmax = 256;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* make a guess */<br/><br/>&#160;&#160;&#160;&#160;username = malloc(lnmax);<br/>&#160;&#160;&#160;&#160;if (username == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("malloc");<br/><br/>&#160;&#160;&#160;&#160;printf("Username: ");<br/>&#160;&#160;&#160;&#160;fflush(stdout);<br/>&#160;&#160;&#160;&#160;if (fgets(username, lnmax, stdin) == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Exit on EOF */<br/><br/>&#160;&#160;&#160;&#160;len = strlen(username);<br/>&#160;&#160;&#160;&#160;if (username[len - 1] == '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;username[len - 1] = '\0';&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Remove trailing '\n' */<br/><br/>&#160;&#160;&#160;&#160;pwd = getpwnam(username);<br/>&#160;&#160;&#160;&#160;if (pwd == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("couldn't get password record");<br/>&#160;&#160;&#160;&#160;spwd = getspnam(username);<br/>&#160;&#160;&#160;&#160;if (spwd == NULL &#38;&#38; errno == EACCES)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("no permission to read shadow password file");<br/><br/>&#160;&#160;&#160;&#160;if (spwd != NULL)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If there is a shadow password record */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pwd-&gt;pw_passwd = spwd-&gt;sp_pwdp;&#160;&#160;&#160;&#160;&#160;/* Use the shadow password */<br/><br/>&#160;&#160;&#160;&#160;password = getpass("Password: ");<br/><br/>&#160;&#160;&#160;&#160;/* Encrypt password and erase cleartext version immediately */<br/><br/>&#160;&#160;&#160;&#160;encrypted = crypt(password, pwd-&gt;pw_passwd);<br/>&#160;&#160;&#160;&#160;for (p = password; *p != '\0'; )<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*p++ = '\0';<br/><br/>&#160;&#160;&#160;&#160;if (encrypted == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("crypt");<br/><br/>&#160;&#160;&#160;&#160;authOk = strcmp(encrypted, pwd-&gt;pw_passwd) == 0;<br/>&#160;&#160;&#160;&#160;if (!authOk) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Incorrect password\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;printf("Successfully authenticated: UID=%ld\n", (long) pwd-&gt;pw_uid);<br/><br/>&#160;&#160;&#160;&#160;/* Now do authenticated work... */<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>______________________________________________ <span class="codestrong">users_groups/check_password.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_165"/><a href="ch08.xhtml#ch8ex2">Listing 8-2</a> illustrates an important security point. Programs that read a password should immediately encrypt that password and erase the unencrypted version from <span epub:type="pagebreak" id="page_166"/>memory. This minimizes the possibility of a program crash producing a core dump file that could be read to discover the password.</p>
<div class="block">
<p class="noindent">There are other possible ways in which the unencrypted password could be exposed. For example, the password could be read from the swap file by a privileged program if the virtual memory page containing the password is swapped out. Alternatively, a process with sufficient privilege could read <span class="literal">/dev/mem</span> (a virtual device that presents the physical memory of a computer as a sequential stream of bytes) in an attempt to discover the password.</p>
<p class="indent">The <em>getpass()</em> function appeared in SUSv2, which marked it LEGACY, noting that the name was misleading and the function provided functionality that was in any case easy to implement. The specification of <em>getpass()</em> was removed in SUSv3. It nevertheless appears on most UNIX implementations.</p>
</div>
<h3 class="h3" id="ch08lev1sec06"><strong>8.6 Summary</strong></h3>
<p class="noindenta">Each user has a unique login name and an associated numeric user ID. Users can belong to one or more groups, each of which also has a unique name and an associated numeric identifier. The primary purpose of these identifiers is to establish ownership of various system resources (e.g., files) and permissions for accessing them.</p>
<p class="indent">A user&#8217;s name and ID are defined in the <span class="literal">/etc/passwd</span> file, which also contains other information about the user. A user&#8217;s group memberships are defined by fields in the <span class="literal">/etc/passwd</span> and <span class="literal">/etc/group</span> files. A further file, <span class="literal">/etc/shadow</span>, which can be read only by privileged processes, is used to separate the sensitive password information from the publicly available user information in <span class="literal">/etc/passwd</span>. Various library functions are provided for retrieving information from each of these files.</p>
<p class="indent">The <em>crypt()</em> function encrypts a password in the same manner as the standard <em>login</em> program, which is useful for programs that need to authenticate users.</p>
<h3 class="h3" id="ch08lev1sec07"><strong>8.7 Exercises</strong></h3>
<p class="exer"><a id="ch8exe1"/><strong>8-1.</strong>&#160;&#160;&#160;&#160;&#160;When we execute the following code, which attempts to display the usernames for two different user IDs, we find that it displays the same username twice. Why is this?</p>
<p class="programs1">printf("%s %s\n", getpwuid(uid1)-&gt;pw_name,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;getpwuid(uid2)-&gt;pw_name);</p>
<p class="exer"><a id="ch8exe2"/><strong>8-2.</strong>&#160;&#160;&#160;&#160;&#160;Implement <em>getpwnam()</em> using <em>setpwent()</em>, <em>getpwent()</em>, and <em>endpwent()</em>.</p>
</body>
</html>
