<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch48"><span epub:type="pagebreak" id="page_997"/><strong><span class="big">48</span></strong><br/><strong>SYSTEM V SHARED MEMORY</strong></h2>
<p class="noindenta">This chapter describes System V shared memory. Shared memory allows two or more processes to share the same region (usually referred to as a <em>segment</em>) of physical memory. Since a shared memory segment becomes part of a process&#8217;s user-space memory, no kernel intervention is required for IPC. All that is required is that one process copies data into the shared memory; that data is immediately available to all other processes sharing the same segment. This provides fast IPC by comparison with techniques such as pipes or message queues, where the sending process copies data from a buffer in user space into kernel memory and the receiving process copies in the reverse direction. (Each process also incurs the overhead of a system call to perform the copy operation.)</p>
<p class="indent">On the other hand, the fact that IPC using shared memory is not mediated by the kernel means that, typically, some method of synchronization is required so that processes don&#8217;t simultaneously access the shared memory (e.g., two processes performing simultaneous updates, or one process fetching data from the shared memory while another process is in the middle of updating it). System V semaphores are a natural method for such synchronization. Other methods, such as POSIX semaphores (<a href="ch53.xhtml#ch53">Chapter 53</a>) and file locks (<a href="ch55.xhtml#ch55">Chapter 55</a>), are also possible.</p>
<div class="block">
<p class="noindent">In <em>mmap()</em> terminology, a memory region is <em>mapped</em> at an address, while in System V terminology, a shared memory segment is <em>attached</em> at an address. These terms are equivalent; the terminology differences are a consequence of the separate origins of these two APIs.</p>
</div>
<h3 class="h3" id="ch48lev1sec01"><span epub:type="pagebreak" id="page_998"/><strong>48.1 Overview</strong></h3>
<p class="noindentab">In order to use a shared memory segment, we typically perform the following steps:</p>
<p class="bull">&#8226; Call <em>shmget()</em> to create a new shared memory segment or obtain the identifier of an existing segment (i.e., one created by another process). This call returns a shared memory identifier for use in later calls.</p>
<p class="bull">&#8226; Use <em>shmat()</em> to <em>attach</em> the shared memory segment; that is, make the segment part of the virtual memory of the calling process.</p>
<p class="bull">&#8226; At this point, the shared memory segment can be treated just like any other memory available to the program. In order to refer to the shared memory, the program uses the <em>addr</em> value returned by the <em>shmat()</em> call, which is a pointer to the start of the shared memory segment in the process&#8217;s virtual address space.</p>
<p class="bull">&#8226; Call <em>shmdt()</em> to detach the shared memory segment. After this call, the process can no longer refer to the shared memory. This step is optional, and happens automatically on process termination.</p>
<p class="bull">&#8226; Call <em>shmctl()</em> to delete the shared memory segment. The segment will be destroyed only after all currently attached processes have detached it. Only one process needs to perform this step.</p>
<h3 class="h3" id="ch48lev1sec02"><strong>48.2 Creating or Opening a Shared Memory Segment</strong></h3>
<p class="noindenta">The <em>shmget()</em> system call creates a new shared memory segment or obtains the identifier of an existing segment. The contents of a newly created shared memory segment are initialized to 0.</p>
<div class="box">
<p class="programsa">#include &lt;sys/types.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* For portability */<br/>#include &lt;sys/shm.h&gt;<br/><br/>int <span class="codestrong">shmget</span>(key_t <span class="font1">key</span>, size_t <span class="font1">size</span>, int <span class="font1">shmflg</span>);</p>
<p class="right">Returns shared memory segment identifier on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>key</em> argument is a key generated using one of the methods described in <a href="ch45.xhtml#ch45lev1sec02">Section 45.2</a> (i.e., usually the value <span class="literal">IPC_PRIVATE</span> or a key returned by <em>ftok()</em>).</p>
<p class="indent">When we use <em>shmget()</em> to create a new shared memory segment, <em>size</em> specifies a positive integer that indicates the desired size of the segment, in bytes. The kernel allocates shared memory in multiples of the system page size, so <em>size</em> is effectively rounded up to the next multiple of the system page size. If we are using <em>shmget()</em> to obtain the identifier of an existing segment, then <em>size</em> has no effect on the segment, but it must be less than or equal to the size of the segment.</p>
<p class="indentb">The <em>shmflg</em> argument performs the same task as for the other IPC <em>get</em> calls, specifying the permissions (<a href="ch15.xhtml#ch15table4">Table 15-4</a>, on <a href="ch15.xhtml#page_295">page 295</a>) to be placed on a new shared memory segment or checked against an existing segment. In addition, zero or more of the following flags can be ORed (<span class="literal">|</span>) in <em>shmflg</em> to control the operation of <em>shmget()</em>:</p>
<p class="term"><span class="literal">IPC_CREAT</span></p>
<p class="termlist">If no segment with the specified <em>key</em> exists, create a new segment.</p>
<p class="term"><span epub:type="pagebreak" id="page_999"/><span class="literal">IPC_EXCL</span></p>
<p class="termlist">If <span class="literal">IPC_CREAT</span> was also specified, and a segment with the specified <em>key</em> already exists, fail with the error <span class="literal">EEXIST</span>.</p>
<p class="noindenttb">The above flags are described in more detail in <a href="ch45.xhtml#ch45lev1sec01">Section 45.1</a>. In addition, Linux permits the following nonstandard flags:</p>
<p class="term"><span class="literal">SHM_HUGETLB</span> (since Linux 2.6)</p>
<p class="termlist">A privileged (<span class="literal">CAP_IPC_LOCK</span>) process can use this flag to create a shared memory segment that uses <em>huge pages</em>. Huge pages are a feature provided by many modern hardware architectures to manage memory using very large page sizes. (For example, x86-32 allows 4-MB pages as an alternative to 4-kB pages.) On systems that have large amounts of memory, and where applications require large blocks of memory, using huge pages reduces the number of entries required in the hardware memory management unit&#8217;s translation look-aside buffer (TLB). This is beneficial because entries in the TLB are usually a scarce resource. See the kernel source file <span class="literal">Documentation/vm/hugetlbpage.txt</span> for further information.</p>
<p class="term"><span class="literal">SHM_NORESERVE</span> (since Linux 2.6.15)</p>
<p class="termlist">This flag serves the same purpose for <em>shmget()</em> as the <span class="literal">MAP_NORESERVE</span> flag serves for <em>mmap()</em>. See <a href="ch49.xhtml#ch49lev1sec09">Section 49.9</a>.</p>
<p class="noindentt">On success, <em>shmget()</em> returns the identifier for the new or existing shared memory segment.</p>
<h3 class="h3" id="ch48lev1sec03"><strong>48.3 Using Shared Memory</strong></h3>
<p class="noindenta">The <em>shmat()</em> system call attaches the shared memory segment identified by <em>shmid</em> to the calling process&#8217;s virtual address space.</p>
<div class="box">
<p class="programsa">#include &lt;sys/types.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;/* For portability */<br/>#include &lt;sys/shm.h&gt;<br/><br/>void *<span class="codestrong">shmat</span>(int <span class="font1">shmid</span>, const void *<span class="font1">shmaddr</span>, int <span class="font1">shmflg</span>);</p>
<p class="right">Returns address at which shared memory is attached on success, or <em>(void *)</em> &#8211;1 on error</p>
</div>
<p class="noindentb">The <em>shmaddr</em> argument and the setting of the <span class="literal">SHM_RND</span> bit in the <em>shmflg</em> bit-mask argument control how the segment is attached:</p>
<p class="bull">&#8226; If <em>shmaddr</em> is <span class="literal">NULL</span>, then the segment is attached at a suitable address selected by the kernel. This is the preferred method of attaching a segment.</p>
<p class="bull">&#8226; If <em>shmaddr</em> is not <span class="literal">NULL</span>, and <span class="literal">SHM_RND</span> is not set, then the segment is attached at the address specified by <em>shmaddr</em>, which must be a multiple of the system page size (or the error <span class="literal">EINVAL</span> results).</p>
<p class="bull">&#8226; If <em>shmaddr</em> is not <span class="literal">NULL</span>, and <span class="literal">SHM_RND</span> is set, then the segment is mapped at the address provided in <em>shmaddr</em>, rounded down to the nearest multiple of the constant <span class="literal">SHMLBA</span> (<em>shared memory low boundary address</em>). This constant is equal to some <span epub:type="pagebreak" id="page_1000"/>multiple of the system page size. Attaching a segment at an address that is a multiple of <span class="literal">SHMLBA</span> is necessary on some architectures in order to improve CPU cache performance and to prevent the possibility that different attaches of the same segment have inconsistent views within the CPU cache.</p>
<div class="block2">
<p class="noindent">On the x86 architectures, <span class="literal">SHMLBA</span> is the same as the system page size, reflecting the fact that such caching inconsistencies can&#8217;t arise on those architectures.</p>
</div>
<p class="noindentb">Specifying a non-<span class="literal">NULL</span> value for <em>shmaddr</em> (i.e., either the second or third option listed above) is not recommended, for the following reasons:</p>
<p class="bull">&#8226; It reduces the portability of an application. An address valid on one UNIX implementation may be invalid on another.</p>
<p class="bull">&#8226; An attempt to attach a shared memory segment at a particular address will fail if that address is already in use. This could happen if, for example, the application (perhaps inside a library function) had already attached another segment or created a memory mapping at that address.</p>
<p class="noindentt">As its function result, <em>shmat()</em> returns the address at which the shared memory segment is attached. This value can be treated like a normal C pointer; the segment looks just like any other part of the process&#8217;s virtual memory. Typically, we assign the return value from <em>shmat()</em> to a pointer to some programmer-defined structure, in order to impose that structure on the segment (see, for example, <a href="ch48.xhtml#ch48ex2">Listing 48-2</a>).</p>
<p class="indent">To attach a shared memory segment for read-only access, we specify the flag <span class="literal">SHM_RDONLY</span> in <em>shmflg</em>. Attempts to update the contents of a read-only segment result in a segmentation fault (the <span class="literal">SIGSEGV</span> signal). If <span class="literal">SHM_RDONLY</span> is not specified, the memory can be both read and modified.</p>
<p class="indent">To attach a shared memory segment, a process requires read and write permissions on the segment, unless <span class="literal">SHM_RDONLY</span> is specified, in which case only read permission is required.</p>
<div class="block">
<p class="noindent">It is possible to attach the same shared memory segment multiple times within a process, and even to make one attach read-only while another is read-write. The contents of the memory at each attachment point are the same, since the different entries of the process virtual memory page tables are referring to the same physical pages of memory.</p>
</div>
<p class="noindent">One final value that may be specified in <em>shmflg</em> is <span class="literal">SHM_REMAP</span>. In this case, <em>shmaddr</em> must be non-<span class="literal">NULL</span>. This flag requests that the <em>shmat()</em> call replace any existing shared memory attachment or memory mapping in the range starting at <em>shmaddr</em> and continuing for the length of the shared memory segment. Normally, if we try to attach a shared memory segment at an address range that is already in use, the error <span class="literal">EINVAL</span> results. <span class="literal">SHM_REMAP</span> is a nonstandard Linux extension.</p>
<p class="indent"><a href="ch48.xhtml#ch48table1">Table 48-1</a> summarizes the constants that can be ORed in the <em>shmflg</em> argument of <em>shmat()</em>.</p>
<p class="indent">When a process no longer needs to access a shared memory segment, it can call <em>shmdt()</em> to detach the segment from its virtual address space. The <em>shmaddr</em> argument identifies the segment to be detached. It should be a value returned by a previous call to <em>shmat()</em>.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_1001"/>#include &lt;sys/types.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;/* For portability */<br/>#include &lt;sys/shm.h&gt;<br/><br/>int <span class="codestrong">shmdt</span>(const void *<span class="font1">shmaddr</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">Detaching a shared memory segment is not the same as deleting it. Deletion is performed using the <em>shmctl()</em> <span class="literal">IPC_RMID</span> operation, as described in <a href="ch48.xhtml#ch48lev1sec07">Section 48.7</a>.</p>
<p class="indent">A child created by <em>fork()</em> inherits its parent&#8217;s attached shared memory segments. Thus, shared memory provides an easy method of IPC between parent and child.</p>
<p class="indent">During an <em>exec()</em>, all attached shared memory segments are detached. Shared memory segments are also automatically detached on process termination.</p>
<p class="tablecap"><a id="ch48table1"/><strong>Table 48-1:</strong> <em>shmflg</em> bit-mask values for <em>shmat()</em></p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Value</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SHM_RDONLY</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Attach segment read-only</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SHM_REMAP</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Replace any existing mapping at <em>shmaddr</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">SHM_RND</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Round <em>shmaddr</em> down to multiple of <span class="literal">SHMLBA</span> bytes</p></td>
</tr>
</tbody>
</table>
<h3 class="h3" id="ch48lev1sec04"><strong>48.4 Example: Transferring Data via Shared Memory</strong></h3>
<p class="noindenta">We now look at an example application that uses System V shared memory and semaphores. The application consists of two programs: the <em>writer</em> and the <em>reader</em>. The writer reads blocks of data from standard input and copies (&#8220;writes&#8221;) them into a shared memory segment. The reader copies (&#8220;reads&#8221;) blocks of data from the shared memory segment to standard output. In effect, the programs treat the shared memory somewhat like a pipe.</p>
<p class="indentb">The two programs employ a pair of System V semaphores in a binary semaphore protocol (the <em>initSemAvailable()</em>, <em>initSemInUse()</em>, <em>reserveSem()</em>, and <em>releaseSem()</em> functions defined in <a href="ch47.xhtml#ch47lev1sec09">Section 47.9</a>) to ensure that:</p>
<p class="bull">&#8226; only one process accesses the shared memory segment at a time; and</p>
<p class="bull">&#8226; the processes alternate in accessing the segment (i.e., the writer writes some data, then the reader reads the data, then the writer writes again, and so on).</p>
<p class="noindentt"><a href="ch48.xhtml#ch48fig1">Figure 48-1</a> provides an overview of the use of these two semaphores. Note that the writer initializes the two semaphores so that it is the first of the two programs to be able to access the shared memory segment; that is, the writer&#8217;s semaphore is initially available, and the reader&#8217;s semaphore is initially in use.</p>
<p class="indent">The source code for the application consists of three files. The first of these, <a href="ch48.xhtml#ch48ex1">Listing 48-1</a>, is a header file shared by the reader and writer programs. This header defines the <em>shmseg</em> structure that we use to declare pointers to the shared memory segment. Doing this allows us to impose a structure on the bytes of the shared memory segment.</p>
<div class="image"><span epub:type="pagebreak" id="page_1002"/><img src="../images/f48-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch48fig1"/><strong>Figure 48-1:</strong> Using semaphores to ensure exclusive, alternating access to shared memory</p>
<p class="examplet"><a id="ch48ex1"/><strong>Listing 48-1:</strong> Header file for <span class="literal">svshm_xfr_writer.c</span> and <span class="literal">svshm_xfr_reader.c</span></p>
<p class="programsli">________________________________________________________ <span class="codestrong">svshm/svshm_xfr.h</span><br/><br/>#include &lt;sys/types.h&gt;<br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;sys/sem.h&gt;<br/>#include &lt;sys/shm.h&gt;<br/>#include "binary_sems.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declares our binary semaphore functions */<br/>#include "tlpi_hdr.h"<br/><br/>#define SHM_KEY 0x1234&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Key for shared memory segment */<br/>#define SEM_KEY 0x5678&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Key for semaphore set */<br/><br/>#define OBJ_PERMS (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Permissions for our IPC objects */<br/><br/>#define WRITE_SEM 0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Writer has access to shared memory */<br/>#define READ_SEM 1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Reader has access to shared memory */<br/><br/>#ifndef BUF_SIZE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allow "cc -D" to override definition */<br/>#define BUF_SIZE 1024&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Size of transfer buffer */<br/>#endif<br/><br/>struct shmseg {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Defines structure of shared memory segment */<br/>&#160;&#160;&#160;&#160;int cnt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of bytes used in 'buf' */<br/>&#160;&#160;&#160;&#160;char buf[BUF_SIZE];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Data being transferred */<br/>};<br/>________________________________________________________ <span class="codestrong">svshm/svshm_xfr.h</span></p>
<p class="noindentb"><a href="ch48.xhtml#ch48ex2">Listing 48-2</a> is the writer program. This program performs the following steps:</p>
<p class="bull">&#8226; Create a set containing the two semaphores that are used by the writer and reader program to ensure that they alternate in accessing the shared memory segment <span class="ent">&#x2460;</span>. The semaphores are initialized so that the writer has first access to the shared memory segment. Since the writer creates the semaphore set, it must be started before the reader.</p>
<p class="bull"><span epub:type="pagebreak" id="page_1003"/>&#8226; Create the shared memory segment and attach it to the writer&#8217;s virtual address space at an address chosen by the system <span class="ent">&#x2461;</span>.</p>
<p class="bull">&#8226; Enter a loop that transfers data from standard input to the shared memory segment <span class="ent">&#x2462;</span>. The following steps are performed in each loop iteration:</p>
<p class="dash1">&#8211; Reserve (decrement) the writer semaphore <span class="ent">&#x2463;</span>.</p>
<p class="dash1">&#8211; Read data from standard input into the shared memory segment <span class="ent">&#x2464;</span>.</p>
<p class="dash1">&#8211; Release (increment) the reader semaphore <span class="ent">&#x2465;</span>.</p>
<p class="bull">&#8226; The loop terminates when no further data is available from standard input <span class="ent">&#x2466;</span>. On the last pass through the loop, the writer indicates to the reader that there is no more data by passing a block of data of length 0 (<em>shmp&#8211;&gt;cnt</em> is 0).</p>
<p class="bull">&#8226; Upon exiting the loop, the writer once more reserves its semaphore, so that it knows that the reader has completed the final access to the shared memory <span class="ent">&#x2467;</span>. The writer then removes the shared memory segment and semaphore set <span class="ent">&#x2468;</span>.</p>
<p class="noindenttb"><a href="ch48.xhtml#ch48ex3">Listing 48-3</a> is the reader program. It transfers blocks of data from the shared memory segment to standard output. The reader performs the following steps:</p>
<p class="bull">&#8226; Obtain the IDs of the semaphore set and shared memory segment that were created by the writer program <span class="ent">&#x2460;</span>.</p>
<p class="bull">&#8226; Attach the shared memory segment for read-only access <span class="ent">&#x2461;</span>.</p>
<p class="bull">&#8226; Enter a loop that transfers data from the shared memory segment <span class="ent">&#x2462;</span>. The following steps are performed in each loop iteration:</p>
<p class="dash1">&#8211; Reserve (decrement) the reader semaphore <span class="ent">&#x2463;</span>.</p>
<p class="dash1">&#8211; Check whether <em>shmp&#8211;&gt;cnt</em> is 0; if so, exit this loop <span class="ent">&#x2464;</span>.</p>
<p class="dash1">&#8211; Write the block of data in the shared memory segment to standard output <span class="ent">&#x2465;</span>.</p>
<p class="dash1">&#8211; Release (increment) the writer semaphore <span class="ent">&#x2466;</span>.</p>
<p class="bull">&#8226; After exiting the loop, detach the shared memory segment <span class="ent">&#x2467;</span> and releases the writer semaphore <span class="ent">&#x2468;</span>, so that the writer program can remove the IPC objects.</p>
<p class="examplet"><a id="ch48ex2"/><strong>Listing 48-2:</strong> Transfer blocks of data from <em>stdin</em> to a System V shared memory segment</p>
<p class="programsli">__________________________________________________ <span class="codestrong">svshm/svshm_xfr_writer.c</span><br/><br/>&#160;&#160;&#160;#include "semun.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Definition of semun union */<br/>&#160;&#160;&#160;#include "svshm_xfr.h"<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int semid, shmid, bytes, xfrs;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct shmseg *shmp;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;union semun dummy;<br/><br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;semid = semget(SEM_KEY, 2, IPC_CREAT | OBJ_PERMS);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (semid == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semget");<br/><span epub:type="pagebreak" id="page_1004"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (initSemAvailable(semid, WRITE_SEM) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("initSemAvailable");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (initSemInUse(semid, READ_SEM) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("initSemInUse");<br/><br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;shmid = shmget(SHM_KEY, sizeof(struct shmseg), IPC_CREAT | OBJ_PERMS);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (shmid == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("shmget");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;shmp = shmat(shmid, NULL, 0);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (shmp == (void *) -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("shmat");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Transfer blocks of data from stdin to shared memory */<br/><br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;for (xfrs = 0, bytes = 0; ; xfrs++, bytes += shmp-&gt;cnt) {<br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (reserveSem(semid, WRITE_SEM) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for our turn */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("reserveSem");<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shmp-&gt;cnt = read(STDIN_FILENO, shmp-&gt;buf, BUF_SIZE);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (shmp-&gt;cnt == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("read");<br/><br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (releaseSem(semid, READ_SEM) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Give reader a turn */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("releaseSem");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Have we reached EOF? We test this after giving the reader<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;a turn so that it can see the 0 value in shmp-&gt;cnt. */<br/><br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (shmp-&gt;cnt == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait until reader has let us have one more turn. We then know<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;reader has finished, and so we can delete the IPC objects. */<br/><br/><span class="ent">&#x2467;</span>&#160;&#160;&#160;&#160;&#160;if (reserveSem(semid, WRITE_SEM) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("reserveSem");<br/><br/><span class="ent">&#x2468;</span>&#160;&#160;&#160;&#160;&#160;if (semctl(semid, 0, IPC_RMID, dummy) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semctl");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (shmdt(shmp) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("shmdt");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (shmctl(shmid, IPC_RMID, 0) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("shmctl");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(stderr, "Sent %d bytes (%d xfrs)\n", bytes, xfrs);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;}<br/>__________________________________________________ <span class="codestrong">svshm/svshm_xfr_writer.c</span></p>
<p class="examplet"><span epub:type="pagebreak" id="page_1005"/><a id="ch48ex3"/><strong>Listing 48-3:</strong> Transfer blocks of data from a System V shared memory segment to <em>stdout</em></p>
<p class="programsli">__________________________________________________ <span class="codestrong">svshm/svshm_xfr_reader.c</span><br/><br/>&#160;&#160;&#160;#include "svshm_xfr.h"<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int semid, shmid, xfrs, bytes;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct shmseg *shmp;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get IDs for semaphore set and shared memory created by writer */<br/><br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;semid = semget(SEM_KEY, 0, 0);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (semid == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("semget");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;shmid = shmget(SHM_KEY, 0, 0);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (shmid == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("shmget");<br/><br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;shmp = shmat(shmid, NULL, SHM_RDONLY);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (shmp == (void *) -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("shmat");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Transfer blocks of data from shared memory to stdout */<br/><br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;for (xfrs = 0, bytes = 0; ; xfrs++) {<br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (reserveSem(semid, READ_SEM) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for our turn */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("reserveSem");<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (shmp-&gt;cnt == 0)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Writer encountered EOF */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bytes += shmp-&gt;cnt;<br/><br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (write(STDOUT_FILENO, shmp-&gt;buf, shmp-&gt;cnt) != shmp-&gt;cnt)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("partial/failed write");<br/><br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (releaseSem(semid, WRITE_SEM) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Give writer a turn */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("releaseSem");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/><span class="ent">&#x2467;</span>&#160;&#160;&#160;&#160;&#160;if (shmdt(shmp) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("shmdt");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Give writer one more turn, so it can clean up */<br/><br/><span class="ent">&#x2468;</span>&#160;&#160;&#160;&#160;&#160;if (releaseSem(semid, WRITE_SEM) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("releaseSem");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(stderr, "Received %d bytes (%d xfrs)\n", bytes, xfrs);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;}<br/>__________________________________________________ <span class="codestrong">svshm/svshm_xfr_reader.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_1006"/>The following shell session demonstrates the use of the programs in <a href="ch48.xhtml#ch48ex2">Listing 48-2</a> and <a href="ch48.xhtml#ch48ex3">Listing 48-3</a>. We invoke the writer, using the file <span class="literal">/etc/services</span> as input, and then invoke the reader, directing its output to another file:</p>
<p class="programs">$ <span class="codestrong">wc -c /etc/services</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Display size of test file</span><br/>764360 /etc/services<br/>$ <span class="codestrong">./svshm_xfr_writer &lt; /etc/services &#38;</span><br/>[1] 9403<br/>$ <span class="codestrong">./svshm_xfr_reader &gt; out.txt</span><br/>Received 764360 bytes (747 xfrs)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Message from reader</span><br/>Sent 764360 bytes (747 xfrs)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Message from writer</span><br/>[1]+&#160;&#160;Done&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;./svshm_xfr_writer &lt; /etc/services<br/>$ <span class="codestrong">diff /etc/services out.txt</span><br/>$</p>
<p class="noindent">The <em>diff</em> command produced no output, indicating that the output file produced by the reader has the same content as the input file used by the writer.</p>
<h3 class="h3" id="ch48lev1sec05"><strong>48.5 Location of Shared Memory in Virtual Memory</strong></h3>
<p class="noindenta">In <a href="ch06.xhtml#ch06lev1sec03">Section 6.3</a>, we considered the layout of the various parts of a process in virtual memory. It is useful to revisit this topic in the context of attaching System V shared memory segments. If we follow the recommended approach of allowing the kernel to choose where to attach a shared memory segment, then (on the x86-32 architecture) the memory layout appears as shown in <a href="ch48.xhtml#ch48fig2">Figure 48-2</a>, with the segment being attached in the unallocated space between the upwardly growing heap and the downwardly growing stack. To allow space for heap and stack growth, shared memory segments are attached starting at the virtual address <span class="literal">0x40000000</span>. Mapped mappings (<a href="ch49.xhtml#ch49">Chapter 49</a>) and shared libraries (<a href="ch41.xhtml#ch41">Chapters 41</a> and <a href="ch42.xhtml#ch42">42</a>) are also placed in this area. (There is some variation in the default location at which shared memory mappings and memory segments are placed, depending on the kernel version and the setting of the process&#8217;s <span class="literal">RLIMIT_STACK</span> resource limit.)</p>
<div class="block">
<p class="noindent">The address <span class="literal">0x40000000</span> is defined as the kernel constant <span class="literal">TASK_UNMAPPED_BASE</span>. It is possible to change this address by defining this constant with a different value and rebuilding the kernel.</p>
<p class="indent">A shared memory segment (or memory mapping) can be placed at an address below <span class="literal">TASK_UNMAPPED_BASE</span>, if we employ the unrecommended approach of explicitly specifying an address when calling <em>shmat()</em> (or <em>mmap()</em>).</p>
</div>
<p class="noindent">Using the Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/maps</span> file, we can see the location of the shared memory segments and shared libraries mapped by a program, as we demonstrate in the shell session below.</p>
<div class="block">
<p class="noindent">Starting with kernel 2.6.14, Linux also provides the <span class="literal">/proc/</span><em>PID</em><span class="literal">/smaps</span> file, which exposes more information about the memory consumption of each of a process&#8217;s mappings. For further details, see the <em>proc(5)</em> manual page.</p>
</div>
<div class="image"><span epub:type="pagebreak" id="page_1007"/><img src="../images/f48-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch48fig2"/><strong>Figure 48-2:</strong> Locations of shared memory, memory mappings, and shared libraries (x86-32)</p>
<p class="noindentb">In the shell session below, we employ three programs that are not shown in this chapter, but are provided in the <span class="literal">svshm</span> subdirectory in the source code distribution for this book. These programs perform the following tasks:</p>
<p class="bull">&#8226; The <span class="literal">svshm_create.c</span> program creates a shared memory segment. This program takes the same command-line options as the corresponding programs that we provide for message queues (<a href="ch46.xhtml#ch46ex1">Listing 46-1</a>, on <a href="ch46.xhtml#page_938">page 938</a>) and semaphores, but includes an additional argument that specifies the size of the segment.</p>
<p class="bull">&#8226; The <span class="literal">svshm_attach.c</span> program attaches the shared memory segments identified by its command-line arguments. Each of these arguments is a colon-separated pair of numbers consisting of a shared memory identifier and an attach address. Specifying 0 for the attach address means that the system should choose the address. The program displays the address at which the memory is actually attached. For informational purposes, the program also displays the value of the <span class="literal">SHMLBA</span> constant and the process ID of the process running the program.</p>
<p class="bull">&#8226; The <span class="literal">svshm_rm.c</span> program deletes the shared memory segments identified by its command-line arguments.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_1008"/>We begin the shell session by creating two shared memory segments (100 kB and 3200 kB in size):</p>
<p class="programs">$ <span class="codestrong">./svshm_create -p 102400</span><br/>9633796<br/>$ <span class="codestrong">./svshm_create -p 3276800</span><br/>9666565</p>
<p class="noindent">We then start a program that attaches these two segments at addresses chosen by the kernel:</p>
<p class="programs">$ <span class="codestrong">./svshm_attach 9633796:0 9666565:0</span><br/>SHMLBA = 4096 (0x1000), PID = 9903<br/>1: 9633796:0 ==&gt; 0xb7f0d000<br/>2: 9666565:0 ==&gt; 0xb7bed000<br/>Sleeping 5 seconds</p>
<p class="noindent">The output above shows the addresses at which the segments were attached. Before the program completes sleeping, we suspend it, and then examine the contents of the corresponding <span class="literal">/proc/</span><em>PID</em><span class="literal">/maps</span> file:</p>
<p class="programs"><span class="font1">Type Control-Z to suspend program</span><br/>[1]+&#160;&#160;Stopped&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;./svshm_attach 9633796:0 9666565:0<br/>$ <span class="codestrong">cat /proc/9903/maps</span></p>
<p class="noindent">The output produced by the <em>cat</em> command is shown in <a href="ch48.xhtml#ch48ex4">Listing 48-4</a>.</p>
<p class="examplet"><a id="ch48ex4"/><strong>Listing 48-4:</strong> Example of contents of <span class="literal">/proc/</span><em>PID</em><span class="literal">/maps</span></p>
<p class="programsli">______________________________________________________________________<br/><br/>&#160;&#160;&#160;$ <span class="codestrong">cat /proc/9903/maps</span><br/><span class="ent">&#x2460;</span> 08048000-0804a000 r-xp 00000000 08:05 5526989&#160;&#160;/home/mtk/svshm_attach<br/>&#160;&#160;&#160;0804a000-0804b000 r--p 00001000 08:05 5526989&#160;&#160;/home/mtk/svshm_attach<br/>&#160;&#160;&#160;0804b000-0804c000 rw-p 00002000 08:05 5526989&#160;&#160;/home/mtk/svshm_attach<br/><span class="ent">&#x2461;</span> b7bed000-b7f0d000 rw-s 00000000 00:09 9666565&#160;&#160;/SYSV00000000 (deleted)<br/>&#160;&#160;&#160;b7f0d000-b7f26000 rw-s 00000000 00:09 9633796&#160;&#160;/SYSV00000000 (deleted)<br/>&#160;&#160;&#160;b7f26000-b7f27000 rw-p b7f26000 00:00 0<br/><span class="ent">&#x2462;</span> b7f27000-b8064000 r-xp 00000000 08:06 122031&#160;&#160;&#160;/lib/libc-2.8.so<br/>&#160;&#160;&#160;b8064000-b8066000 r--p 0013d000 08:06 122031&#160;&#160;&#160;/lib/libc-2.8.so<br/>&#160;&#160;&#160;b8066000-b8067000 rw-p 0013f000 08:06 122031&#160;&#160;&#160;/lib/libc-2.8.so<br/>&#160;&#160;&#160;b8067000-b806b000 rw-p b8067000 00:00 0<br/>&#160;&#160;&#160;b8082000-b8083000 rw-p b8082000 00:00 0<br/><span class="ent">&#x2463;</span> b8083000-b809e000 r-xp 00000000 08:06 122125&#160;&#160;&#160;/lib/ld-2.8.so<br/>&#160;&#160;&#160;b809e000-b809f000 r--p 0001a000 08:06 122125&#160;&#160;&#160;/lib/ld-2.8.so<br/>&#160;&#160;&#160;b809f000-b80a0000 rw-p 0001b000 08:06 122125&#160;&#160;&#160;/lib/ld-2.8.so<br/><span class="ent">&#x2464;</span> bfd8a000-bfda0000 rw-p bffea000 00:00 0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[stack]<br/><span class="ent">&#x2465;</span> ffffe000-fffff000 r-xp 00000000 00:00 0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[vdso]<br/>______________________________________________________________________</p>
<p class="noindentb">In the output from <span class="literal">/proc/</span><em>PID</em><span class="literal">/maps</span> shown in <a href="ch48.xhtml#ch48ex4">Listing 48-4</a>, we can see the following:</p>
<p class="bull">&#8226; Three lines for the main program, <em>shm_attach</em>. These correspond to the text and data segments of the program <span class="ent">&#x2460;</span>. The second of these lines is for a read-only page holding the string constants used by the program.</p>
<p class="bull"><span epub:type="pagebreak" id="page_1009"/>&#8226; Two lines for the attached System V shared memory segments <span class="ent">&#x2461;</span>.</p>
<p class="bull">&#8226; Lines corresponding to the segments for two shared libraries. One of these is the standard C library (<span class="literal">libc-</span><em>version</em><span class="literal">.so</span>) <span class="ent">&#x2462;</span>. The other is the dynamic linker (<span class="literal">ld-</span><em>version</em><span class="literal">.so</span>), which we describe in <a href="ch41.xhtml#ch41lev2sec03">Section 41.4.3</a> <span class="ent">&#x2463;</span>.</p>
<p class="bull">&#8226; A line labeled <span class="literal">[stack]</span>. This corresponds to the process stack <span class="ent">&#x2464;</span>.</p>
<p class="bull">&#8226; A line containing the tag <span class="literal">[vdso]</span> <span class="ent">&#x2465;</span>. This is an entry for the <em>linux-gate</em> virtual dynamic shared object (DSO). This entry appears only in kernels since 2.6.12. See <em><a href="http://www.trilithium.com/johan/2005/08/linux-gate/">http://www.trilithium.com/johan/2005/08/linux-gate/</a></em> for further information about this entry.</p>
<p class="noindentt">The following columns are shown in each line of <span class="literal">/proc/</span><em>PID</em><span class="literal">/maps</span>, in order from left to right:</p>
<ol>
<li class="order"><p class="orderp">A pair of hyphen-separated numbers indicating the virtual address range (in hexadecimal) at which the memory segment is mapped. The second of these numbers is the address of the next byte <em>after</em> the end of the segment.</p></li>
<li class="order"><p class="orderp">Protection and flags for this memory segment. The first three letters indicate the protection of the segment: read (<span class="literal">r</span>), write (<span class="literal">w</span>), and execute (<span class="literal">x</span>). A hyphen (<span class="literal">-</span>) in place of any of these letters indicates that the corresponding protection is disabled. The final letter indicates the mapping flag for the memory segment; it is either private (<span class="literal">p</span>) or shared (<span class="literal">s</span>). For an explanation of these flags, see the description of the <span class="literal">MAP_PRIVATE</span> and <span class="literal">MAP_SHARED</span> flags in <a href="ch49.xhtml#ch49lev1sec02">Section 49.2</a>. (A System V shared memory segment is always marked shared.)</p></li>
<li class="order"><p class="orderp">The hexadecimal offset (in bytes) of the segment within the corresponding mapped file. The meanings of this and the following two columns will become clearer when we describe the <em>mmap()</em> system call in <a href="ch49.xhtml#ch49">Chapter 49</a>. For a System V shared memory segment, the offset is always 0.</p></li>
<li class="order"><p class="orderp">The device number (major and minor IDs) of the device on which the corresponding mapped file is located.</p></li>
<li class="order"><p class="orderp">The i-node number of the mapped file, or, for System V shared memory segments, the identifier for the segment.</p></li>
<li class="order"><p class="orderp">The filename or other identifying tag associated with this memory segment. For a System V shared memory segment, this consists of the string <span class="literal">SYSV</span> concatenated with the <em>shmget() key</em> of the segment (expressed in hexadecimal). In this example, <span class="literal">SYSV</span> is followed by zeros because we created the segments using the key <span class="literal">IPC_PRIVATE</span> (which has the value 0). The string <span class="literal">(deleted)</span> that appears after the <span class="literal">SYSV</span> field for a System V shared memory segment is an artifact of the implementation of shared memory segments. Such segments are created as mapped files in an invisible <em>tmpfs</em> file system (<a href="ch14.xhtml#ch14lev1sec10">Section 14.10</a>), and then later unlinked. Shared anonymous memory mappings are implemented in the same manner. (We describe mapped files and shared anonymous memory mappings in <a href="ch49.xhtml#ch49">Chapter 49</a>.)</p></li>
</ol>
<h3 class="h3" id="ch48lev1sec06"><span epub:type="pagebreak" id="page_1010"/><strong>48.6 Storing Pointers in Shared Memory</strong></h3>
<p class="noindenta">Each process may employ different shared libraries and memory mappings, and may attach different sets of shared memory segments. Therefore, if we follow the recommended practice of letting the kernel choose where to attach a shared memory segment, the segment may be attached at a different address in each process. For this reason, when storing references inside a shared memory segment that point to other addresses within the segment, we should use (relative) offsets, rather than (absolute) pointers.</p>
<p class="indent">For example, suppose we have a shared memory segment whose starting address is pointed to by <em>baseaddr</em> (i.e., <em>baseaddr</em> is the value returned by <em>shmat()</em>). Furthermore, at the location pointed to by <em>p</em>, we want to store a pointer to the same location as is pointed to by <em>target</em>, as shown in <a href="ch48.xhtml#ch48fig3">Figure 48-3</a>. This sort of operation would be typical if we were building a linked list or a binary tree within the segment. The usual C idiom for setting <em>*p</em> would be the following:</p>
<p class="programs">*p = target;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Place pointer in *p (WRONG!) */</p>
<div class="image"><img src="../images/f48-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch48fig3"/><strong>Figure 48-3:</strong> Using pointers in a shared memory segment</p>
<p class="noindent">The problem with this code is that the location pointed to by <em>target</em> may reside at a different virtual address when the shared memory segment is attached in another process, which means that the value stored at <em>*p</em> is meaningless in that process. The correct approach is to store an offset at <em>*p</em>, as in the following:</p>
<p class="programs">*p = target - baseaddr;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Place offset in *p */</p>
<p class="noindent">When dereferencing such pointers, we reverse the above step:</p>
<p class="programs">target = baseaddr + *p;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Interpret offset */</p>
<p class="noindent">Here, we assume that in each process, <em>baseaddr</em> points to the start of the shared memory segment (i.e., it is the value returned by <em>shmat()</em> in each process). Given this assumption, an offset value is correctly interpreted, no matter where the shared memory segment is attached in a process&#8217;s virtual address space.</p>
<p class="indent">Alternatively, if we are linking together a set of fixed-size structures, we can cast the shared memory segment (or a part thereof) as an array, and then use index numbers as the &#8220;pointers&#8221; referring from one structure to another.</p>
<h3 class="h3" id="ch48lev1sec07"><span epub:type="pagebreak" id="page_1011"/><strong>48.7 Shared Memory Control Operations</strong></h3>
<p class="noindenta">The <em>shmctl()</em> system call performs a range of control operations on the shared memory segment identified by <em>shmid</em>.</p>
<div class="box">
<p class="programsa">#include &lt;sys/types.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;/* For portability */<br/>#include &lt;sys/shm.h&gt;<br/><br/>int <span class="codestrong">shmctl</span>(int <span class="font1">shmid</span>, int <span class="font1">cmd</span>, struct shmid_ds *<span class="font1">buf</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>cmd</em> argument specifies the control operation to be performed. The <em>buf</em> argument is required by the <span class="literal">IPC_STAT</span> and <span class="literal">IPC_SET</span> operations (described below), and should be specified as <span class="literal">NULL</span> for the remaining operations.</p>
<p class="indent">In the remainder of this section, we describe the various operations that can be specified for <em>cmd</em>.</p>
<h5 class="h5" id="ch48lev3sec01"><strong>Generic control operations</strong></h5>
<p class="noindentab">The following operations are the same as for other types of System V IPC objects. Further details about these operations, including the privileges and permissions required by the calling process, are described in <a href="ch45.xhtml#ch45lev1sec03">Section 45.3</a>.</p>
<p class="term"><span class="literal">IPC_RMID</span></p>
<p class="termlist">Mark the shared memory segment and its associated <em>shmid_ds</em> data structure for deletion. If no processes currently have the segment attached, deletion is immediate; otherwise, the segment is removed after all processes have detached from it (i.e., when the value of the <em>shm_nattch</em> field in the <em>shmid_ds</em> data structure falls to 0). In some applications, we can make sure that a shared memory segment is tidily cleared away on application termination by marking it for deletion immediately after all processes have attached it to their virtual address space with <em>shmat()</em>. This is analogous to unlinking a file once we&#8217;ve opened it.</p>
<div class="block">
<p class="noindent">On Linux, if a shared segment has been marked for deletion using <span class="literal">IPC_RMID</span>, but has not yet been removed because some process still has it attached, then it is possible for another process to attach that segment. However, this behavior is not portable: most UNIX implementations prevent new attaches to a segment marked for deletion. (SUSv3 is silent on what behavior should occur in this scenario.) A few Linux applications have come to depend on this behavior, which is why Linux has not been changed to match other UNIX implementations.</p>
</div>
<p class="term"><span class="literal">IPC_STAT</span></p>
<p class="termlist">Place a copy of the <em>shmid_ds</em> data structure associated with this shared memory segment in the buffer pointed to by <em>buf</em>. (We describe this data structure in <a href="ch48.xhtml#ch48lev1sec08">Section 48.8</a>.)</p>
<p class="term"><span class="literal">IPC_SET</span></p>
<p class="termlist">Update selected fields of the <em>shmid_ds</em> data structure associated with this shared memory segment using values in the buffer pointed to by <em>buf</em>.</p>
<h5 class="h5" id="ch48lev3sec02"><span epub:type="pagebreak" id="page_1012"/><strong>Locking and unlocking shared memory</strong></h5>
<p class="noindentab">A shared memory segment can be locked into RAM, so that it is never swapped out. This provides a performance benefit, since, once each page of the segment is memory-resident, an application is guaranteed never to be delayed by a page fault when it accesses the page. There are two <em>shmctl()</em> locking operations:</p>
<p class="bull">&#8226; The <span class="literal">SHM_LOCK</span> operation locks a shared memory segment into memory.</p>
<p class="bull">&#8226; The <span class="literal">SHM_UNLOCK</span> operation unlocks the shared memory segment, allowing it to be swapped out.</p>
<p class="noindentt">These operations are not specified by SUSv3, and they are not provided on all UNIX implementations.</p>
<p class="indent">In versions of Linux before 2.6.10, only privileged (<span class="literal">CAP_IPC_LOCK</span>) processes can lock a shared memory segment into memory. Since Linux 2.6.10, an unprivileged process can lock and unlock a shared memory segment if its effective user ID matches either the owner or the creator user ID of the segment and (in the case of <span class="literal">SHM_LOCK</span>) the process has a sufficiently high <span class="literal">RLIMIT_MEMLOCK</span> resource limit. See <a href="ch50.xhtml#ch50lev1sec02">Section 50.2</a> for details.</p>
<p class="indent">Locking a shared memory segment does not guarantee that all of the pages of the segment are memory-resident at the completion of the <em>shmctl()</em> call. Rather, nonresident pages are individually locked in only as they are faulted into memory by subsequent references by processes that have attached the shared memory segment. Once faulted in, the pages stay resident until subsequently unlocked, even if all processes detach the segment. (In other words, the <span class="literal">SHM_LOCK</span> operation sets a property of the shared memory segment, rather than a property of the calling process.)</p>
<div class="block">
<p class="noindent">By <em>faulted into memory</em>, we mean that when the process references the nonresident page, a page fault occurs. At this point, if the page is in the swap area, then it is reloaded into memory. If the page is being referenced for the first time, no corresponding page exists in the swap file. Therefore, the kernel allocates a new page of physical memory and adjusts the process&#8217;s page tables and the bookkeeping data structures for the shared memory segment.</p>
</div>
<p class="noindent">An alternative method of locking memory, with slightly different semantics, is the use of <em>mlock()</em>, which we describe in <a href="ch50.xhtml#ch50lev1sec02">Section 50.2</a>.</p>
<h3 class="h3" id="ch48lev1sec08"><strong>48.8 Shared Memory Associated Data Structure</strong></h3>
<p class="noindenta">Each shared memory segment has an associated <em>shmid_ds</em> data structure of the following form:</p>
<p class="programs">struct shmid_ds {<br/>&#160;&#160;&#160;&#160;struct ipc_perm shm_perm;&#160;&#160;&#160;/* Ownership and permissions */<br/>&#160;&#160;&#160;&#160;size_t&#160;&#160;&#160;shm_segsz;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Size of segment in bytes */<br/>&#160;&#160;&#160;&#160;time_t&#160;&#160;&#160;shm_atime;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Time of last shmat() */<br/>&#160;&#160;&#160;&#160;time_t&#160;&#160;&#160;shm_dtime;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Time of last shmdt() */<br/>&#160;&#160;&#160;&#160;time_t&#160;&#160;&#160;shm_ctime;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Time of last change */<br/>&#160;&#160;&#160;&#160;pid_t&#160;&#160;&#160;&#160;shm_cpid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* PID of creator */<br/>&#160;&#160;&#160;&#160;pid_t&#160;&#160;&#160;&#160;shm_lpid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* PID of last shmat() / shmdt() */<br/>&#160;&#160;&#160;&#160;shmatt_t shm_nattch;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of currently attached processes */<br/>};</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1013"/>SUSv3 requires all of the fields shown here. Some other UNIX implementations include additional nonstandard fields in the <em>shmid_ds</em> structure.</p>
<p class="indentb">The fields of the <em>shmid_ds</em> structure are implicitly updated by various shared memory system calls, and certain subfields of the <em>shm_perm</em> field can be explicitly updated using the <em>shmctl()</em> <span class="literal">IPC_SET</span> operation. The details are as follows:</p>
<p class="term"><em>shm_perm</em></p>
<p class="termlist">When the shared memory segment is created, the fields of this substructure are initialized as described in <a href="ch45.xhtml#ch45lev1sec03">Section 45.3</a>. The <em>uid</em>, <em>gid</em>, and (the lower 9 bits of the) <em>mode</em> subfields can be updated via <span class="literal">IPC_SET</span>. As well as the usual permission bits, the <em>shm_perm.mode</em> field holds two read-only bit-mask flags. The first of these, <span class="literal">SHM_DEST</span> (destroy), indicates whether the segment is marked for deletion (via the <em>shmctl()</em> <span class="literal">IPC_RMID</span> operation) when all processes have detached it from their address space. The other flag, <span class="literal">SHM_LOCKED</span>, indicates whether the segment is locked into physical memory (via the <em>shmctl()</em> <span class="literal">SHM_LOCK</span> operation). Neither of these flags is standardized in SUSv3, and equivalents appear on only a few other UNIX implementations, in some cases with different names.</p>
<p class="term"><em>shm_segsz</em></p>
<p class="termlist">On creation of the shared memory segment, this field is set to the requested size of the segment in bytes (i.e., to the value of the <em>size</em> argument specified in the call to <em>shmget()</em>). As noted in <a href="ch48.xhtml#ch48lev1sec02">Section 48.2</a>, shared memory is allocated in units of pages, so the actual size of the segment may be larger than this value.</p>
<p class="term"><em>shm_atime</em></p>
<p class="termlist">This field is set to 0 when the shared memory segment is created, and set to the current time whenever a process attaches the segment (<em>shmat()</em>). This field and the other timestamp fields in the <em>shmid_ds</em> structure are typed as <em>time_t</em>, and store time in seconds since the Epoch.</p>
<p class="term"><em>shm_dtime</em></p>
<p class="termlist">This field is set to 0 when the shared memory segment is created, and set to the current time whenever a process detaches the segment (<em>shmdt()</em>).</p>
<p class="term"><em>shm_ctime</em></p>
<p class="termlist">This field is set to the current time when the segment is created, and on each successful <span class="literal">IPC_SET</span> operation.</p>
<p class="term"><em>shm_cpid</em></p>
<p class="termlist">This field is set to the process ID of the process that created the segment using <em>shmget()</em>.</p>
<p class="term"><em>shm_lpid</em></p>
<p class="termlist">This field is set to 0 when the shared memory segment is created, and then set to the process ID of the calling process on each successful <em>shmat()</em> or <em>shmdt()</em>.</p>
<p class="term"><span epub:type="pagebreak" id="page_1014"/><em>shm_nattch</em></p>
<p class="termlist">This field counts the number of processes that currently have the segment attached. It is initialized to 0 when the segment is created, and then incremented by each successful <em>shmat()</em> and decremented by each successful <em>shmdt()</em>. The <em>shmatt_t</em> data type used to define this field is an unsigned integer type that SUSv3 requires to be at least the size of <em>unsigned short</em>. (On Linux, this type is defined as <em>unsigned long</em>.)</p>
<h3 class="h3" id="ch48lev1sec09"><strong>48.9 Shared Memory Limits</strong></h3>
<p class="noindentab">Most UNIX implementations impose various limits on System V shared memory. Below is a list of the Linux shared memory limits. The system call affected by the limit and the error that results if the limit is reached are noted in parentheses.</p>
<p class="term"><span class="literal">SHMMNI</span></p>
<p class="termlist">This is a system-wide limit on the number of shared memory identifiers (in other words, shared memory segments) that can be created. (<em>shmget()</em>, <span class="literal">ENOSPC</span>)</p>
<p class="term"><span class="literal">SHMMIN</span></p>
<p class="termlist">This is the minimum size (in bytes) of a shared memory segment. This limit is defined with the value 1 (this can&#8217;t be changed). However, the effective limit is the system page size. (<em>shmget()</em>, <span class="literal">EINVAL</span>)</p>
<p class="term"><span class="literal">SHMMAX</span></p>
<p class="termlist">This is the maximum size (in bytes) of a shared memory segment. The practical upper limit for <span class="literal">SHMMAX</span> depends on available RAM and swap space. (<em>shmget()</em>, <span class="literal">EINVAL</span>)</p>
<p class="term"><span class="literal">SHMALL</span></p>
<p class="termlist">This is a system-wide limit on the total number of pages of shared memory. Most other UNIX implementations don&#8217;t provide this limit. The practical upper limit for <span class="literal">SHMALL</span> depends on available RAM and swap space. (<em>shmget()</em>, <span class="literal">ENOSPC</span>)</p>
<p class="noindenttb">Some other UNIX implementations also impose the following limit (which is not implemented on Linux):</p>
<p class="term"><span class="literal">SHMSEG</span></p>
<p class="termlist">This is a per-process limit on the number of attached shared memory segments.</p>
<p class="noindentt">At system startup, the shared memory limits are set to default values. (These defaults may vary across kernel versions, and some distributors&#8217; kernels set different defaults from those provided by vanilla kernels.) On Linux, some of the limits can be viewed or changed via files in the <span class="literal">/proc</span> file system. <a href="ch48.xhtml#ch48table2">Table 48-2</a> lists the <span class="literal">/proc</span> file corresponding to each limit. As an example, here are the default limits that we see for Linux 2.6.31 on one x86-32 system:</p>
<p class="programs">$ <span class="codestrong">cd /proc/sys/kernel</span><br/>$ <span class="codestrong">cat shmmni</span><br/>4096<br/>$ <span class="codestrong">cat shmmax</span><br/>33554432<br/>$ <span class="codestrong">cat shmall</span><br/>2097152</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1015"/>The Linux-specific <em>shmctl()</em> <span class="literal">IPC_INFO</span> operation retrieves a structure of type <em>shminfo</em>, which contains the values of the various shared memory limits:</p>
<p class="programs">struct shminfo buf;<br/><br/>shmctl(0, IPC_INFO, (struct shmid_ds *) &#38;buf);</p>
<p class="noindent">A related Linux-specific operation, <span class="literal">SHM_INFO</span>, retrieves a structure of type <em>shm_info</em> that contains information about actual resources used for shared memory objects. An example of the use of <span class="literal">SHM_INFO</span> is provided in the file <span class="literal">svshm/svshm_info.c</span> in the source code distribution for this book.</p>
<p class="indent">Details about <span class="literal">IPC_INFO</span>, <span class="literal">SHM_INFO</span>, and the <em>shminfo</em> and <em>shm_info</em> structures can be found in the <em>shmctl(2)</em> manual page.</p>
<p class="tablecap"><a id="ch48table2"/><strong>Table 48-2:</strong> System V shared memory limits</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Limit</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Ceiling value (x86-32)</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Corresponding file in</strong> <span class="literal"><span class="codestrong">/proc/sys/kernel</span></span></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SHMMNI</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">32768 (IPCMNI)</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">shmmni</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SHMMAX</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Depends on available memory</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">shmmax</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">SHMALL</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">Depends on available memory</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table"><span class="literal">shmall</span></p></td>
</tr>
</tbody>
</table>
<h3 class="h3" id="ch48lev1sec10"><strong>48.10 Summary</strong></h3>
<p class="noindenta">Shared memory allows two or more processes to share the same pages of memory. No kernel intervention is required to exchange data via shared memory. Once a process has copied data into a shared memory segment, that data is immediately visible to other processes. Shared memory provides fast IPC, although this speed advantage is somewhat offset by the fact that normally we must use some type of synchronization technique, such as a System V semaphore, to synchronize access to the shared memory.</p>
<p class="indent">The recommended approach when attaching a shared memory segment is to allow the kernel to choose the address at which the segment is attached in the process&#8217;s virtual address space. This means that the segment may reside at different virtual addresses in different processes. For this reason, any references to addresses within the segment should be maintained as relative offsets, rather than as absolute pointers.</p>
<h5 class="h5" id="ch48lev3sec03"><strong>Further information</strong></h5>
<p class="noindenta">The Linux memory-management scheme and some details of the implementation of shared memory are described in [<a href="bib.xhtml#bib09">Bovet &#38; Cesati, 2005</a>].</p>
<h3 class="h3" id="ch48lev1sec11"><span epub:type="pagebreak" id="page_1016"/><strong>48.11 Exercises</strong></h3>
<p class="exer"><a id="ch48exe1"/><strong>48-1.</strong>&#160;&#160;&#160;Replace the use of binary semaphores in <a href="ch48.xhtml#ch48ex2">Listing 48-2</a> (<span class="literal">svshm_xfr_writer.c</span>) and <a href="ch48.xhtml#ch48ex3">Listing 48-3</a> (<span class="literal">svshm_xfr_reader.c</span>) with the use of event flags (<a href="ch47.xhtml#ch47exe5">Exercise 47-5</a>).</p>
<p class="exer"><a id="ch48exe2"/><strong>48-2.</strong>&#160;&#160;&#160;Explain why the program in <a href="ch48.xhtml#ch48ex3">Listing 48-3</a> incorrectly reports the number of bytes transferred if the <span class="literal">for</span> loop is modified as follows:</p>
<p class="programs1">for (xfrs = 0, bytes = 0; shmp-&gt;cnt != 0; xfrs++, bytes += shmp-&gt;cnt) {<br/>&#160;&#160;&#160;&#160;reserveSem(semid, READ_SEM);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for our turn */<br/><br/>&#160;&#160;&#160;&#160;if (write(STDOUT_FILENO, shmp-&gt;buf, shmp-&gt;cnt) != shmp-&gt;cnt)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("write");<br/><br/>&#160;&#160;&#160;&#160;releaseSem(semid, WRITE_SEM);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Give writer a turn */<br/>}</p>
<p class="exer"><a id="ch48exe3"/><strong>48-3.</strong>&#160;&#160;&#160;Try compiling the programs in <a href="ch48.xhtml#ch48ex2">Listing 48-2</a> (<span class="literal">svshm_xfr_writer.c</span>) and <a href="ch48.xhtml#ch48ex3">Listing 48-3</a> (<span class="literal">svshm_xfr_reader.c</span>) with a range of different sizes (defined by the constant <span class="literal">BUF_SIZE</span>) for the buffer used to exchange data between the two programs. Time the execution of <span class="literal">svshm_xfr_reader.c</span> for each buffer size.</p>
<p class="exer"><a id="ch48exe4"/><strong>48-4.</strong>&#160;&#160;&#160;Write a program that displays the contents of the <em>shmid_ds</em> data structure (<a href="ch48.xhtml#ch48lev1sec08">Section 48.8</a>) associated with a shared memory segment. The identifier of the segment should be specified as a command-line argument. (See the program in <a href="ch47.xhtml#ch47ex3">Listing 47-3</a>, on <a href="ch47.xhtml#page_973">page 973</a>, which performs the analogous task for System V semaphores.)</p>
<p class="exer"><a id="ch48exe5"/><strong>48-5.</strong>&#160;&#160;&#160;Write a directory service that uses a shared memory segment to publish name-value pairs. You will need to provide an API that allows callers to create a new name, modify an existing name, delete an existing name, and retrieve the value associated with a name. Use semaphores to ensure that a process performing an update to the shared memory segment has exclusive access to the segment.</p>
<p class="exer"><a id="ch48exe6"/><strong>48-6.</strong>&#160;&#160;&#160;Write a program (analogous to program in <a href="ch46.xhtml#ch46ex6">Listing 46-6</a>, on <a href="ch46.xhtml#page_953">page 953</a>) that uses the <em>shmctl()</em> <span class="literal">SHM_INFO</span> and <span class="literal">SHM_STAT</span> operations to obtain and display a list of all shared memory segments on the system.</p>
</body>
</html>
