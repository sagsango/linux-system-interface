<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch31"><span epub:type="pagebreak" id="page_655"/><strong><span class="big">31</span></strong><br/><strong>THREADS: THREAD SAFETY AND PER-THREAD STORAGE</strong></h2>
<p class="noindenta">This chapter extends the discussion of the POSIX threads API, providing a description of thread-safe functions and one-time initialization. We also discuss how to use thread-specific data or thread-local storage to make an existing function thread-safe without changing the function&#8217;s interface.</p>
<h3 class="h3" id="ch31lev1sec01"><strong>31.1 Thread Safety (and Reentrancy Revisited)</strong></h3>
<p class="noindenta">A function is said to be <em>thread-safe</em> if it can safely be invoked by multiple threads at the same time; put conversely, if a function is not thread-safe, then we can&#8217;t call it from one thread while it is being executed in another thread. For example, the following function (similar to code that we looked at in <a href="ch30.xhtml#ch30lev1sec01">Section 30.1</a>) is not thread-safe:</p>
<p class="programs">static int glob = 0;<br/><br/>static void<br/>incr(int loops)<br/>{<br/>&#160;&#160;&#160;&#160;int loc, j;<br/>&#160;&#160;&#160;&#160;for (j = 0; j &lt; loops; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;loc = glob;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;loc++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;glob = loc;<br/>&#160;&#160;&#160;&#160;}<br/>}</p>
<p class="noindent"><span epub:type="pagebreak" id="page_656"/>If multiple threads invoke this function concurrently, the final value in <em>glob</em> is unpredictable. This function illustrates the typical reason that a function is not thread-safe: it employs global or static variables that are shared by all threads.</p>
<p class="indent">There are various methods of rendering a function thread-safe. One way is to associate a mutex with the function (or perhaps with all of the functions in a library, if they all share the same global variables), lock that mutex when the function is called, and unlock it when the function returns. This approach has the virtue of simplicity. On the other hand, it means that only one thread at a time can execute the function&#8212;we say that access to the function is <em>serialized</em>. If the threads spend a significant amount of time executing this function, then this serialization results in a loss of concurrency, because the threads of a program can no longer execute in parallel.</p>
<p class="indent">A more sophisticated solution is to associate the mutex with a shared variable. We then determine which parts of the function are critical sections that access the shared variable, and acquire and release the mutex only during the execution of these critical sections. This allows multiple threads to execute the function at the same time and to operate in parallel, except when more than one thread needs to execute a critical section.</p>
<h5 class="h5" id="ch31lev3sec01"><strong>Non-thread-safe functions</strong></h5>
<p class="noindenta">To facilitate the development of threaded applications, all of the functions specified in SUSv3 are required to be implemented in a thread-safe manner, except those listed in <a href="ch31.xhtml#ch31table1">Table 31-1</a>. (Many of these functions are not discussed in this book.)</p>
<p class="indentb">In addition to the functions listed in <a href="ch31.xhtml#ch31table1">Table 31-1</a>, SUSv3 specifies the following:</p>
<p class="bull">&#8226; The <em>ctermid()</em> and <em>tmpnam()</em> functions need not be thread-safe if passed a <span class="literal">NULL</span> argument.</p>
<p class="bull">&#8226; The <em>wcrtomb()</em> and <em>wcsrtombs()</em> functions need not be thread-safe if their final argument (<em>ps</em>) is <span class="literal">NULL</span>.</p>
<p class="noindenttb">SUSv4 modifies the list of functions in <a href="ch31.xhtml#ch31table1">Table 31-1</a> as follows:</p>
<p class="bull">&#8226; The <em>ecvt()</em>, <em>fcvt()</em>, <em>gcvt()</em>, <em>gethostbyname()</em>, and <em>gethostbyaddr()</em> functions are removed, since these functions have been removed from the standard.</p>
<p class="bull">&#8226; The <em>strsignal()</em> and <em>system()</em> functions are added. The <em>system()</em> function is non-reentrant because the manipulations that it must make to signal dispositions have a process-wide effect.</p>
<p class="noindentt">The standards do not prohibit an implementation from making the functions in <a href="ch31.xhtml#ch31table1">Table 31-1</a> thread-safe. However, even if some of these functions are thread-safe on some implementations, a portable application can&#8217;t rely on this to be the case on all implementations.</p>
<p class="tablecap"><span epub:type="pagebreak" id="page_657"/><a id="ch31table1"/><strong>Table 31-1:</strong> Functions that SUSv3 does not require to be thread-safe</p>
<table class="all">
<tbody>
<tr>
<td style="vertical-align: top;" class="table_3a"><p class="table"><em>asctime()</em><br/><em>basename()</em><br/><em>catgets()</em><br/><em>crypt()</em><br/><em>ctime()</em><br/><em>dbm_clearerr()</em><br/><em>dbm_close()</em><br/><em>dbm_delete()</em><br/><em>dbm_error()</em><br/><em>dbm_fetch()</em><br/><em>dbm_firstkey()</em><br/><em>dbm_nextkey()</em><br/><em>dbm_open()</em><br/><em>dbm_store()</em><br/><em>dirname()</em><br/><em>dlerror()</em><br/><em>drand48()</em><br/><em>ecvt()</em><br/><em>encrypt()</em><br/><em>endgrent()</em><br/><em>endpwent()</em><br/><em>endutxent()</em><br/><em>fcvt()</em><br/><em>ftw()</em><br/><em>gcvt()</em><br/><em>getc_unlocked()</em><br/><em>getchar_unlocked()</em><br/><em>getdate()</em><br/><em>getenv()</em><br/><em>getgrent()</em><br/><em>getgrgid()</em><br/><em>getgrnam()</em><br/><em>gethostbyaddr()</em><br/><em>gethostbyname()</em><br/><em>gethostent()</em><br/><em>getlogin()</em><br/><em>getnetbyaddr()</em><br/><em>getnetbyname()</em><br/><em>getnetent()</em><br/><em>getopt()</em><br/><em>getprotobyname()</em><br/><em>getprotobynumber()</em><br/><em>getprotoent()</em><br/><em>getpwent()</em><br/><em>getpwnam()</em><br/><em>getpwuid()</em><br/><em>getservbyname()</em><br/><em>getservbyport()</em><br/><em>getservent()</em><br/><em>getutxent()</em><br/><em>getutxid()</em><br/><em>getutxline()</em><br/><em>gmtime()</em><br/><em>hcreate()</em><br/><em>hdestroy()</em><br/><em>hsearch()</em><br/><em>inet_ntoa()</em><br/><em>l64a()</em><br/><em>lgamma()</em><br/><em>lgammaf()</em><br/><em>lgammal()</em><br/><em>localeconv()</em><br/><em>localtime()</em><br/><em>lrand48()</em><br/><em>mrand48()</em><br/><em>nftw()</em><br/><em>nl_langinfo()</em><br/><em>ptsname()</em><br/><em>putc_unlocked()</em><br/><em>putchar_unlocked()</em><br/><em>putenv()</em><br/><em>pututxline()</em><br/><em>rand()</em><br/><em>readdir()</em><br/><em>setenv()</em><br/><em>setgrent()</em><br/><em>setkey()</em><br/><em>setpwent()</em><br/><em>setutxent()</em><br/><em>strerror()</em><br/><em>strtok()</em><br/><em>ttyname()</em><br/><em>unsetenv()</em><br/><em>wcstombs()</em><br/><em>wctomb()</em></p></td>
</tr>
</tbody>
</table>
<h5 class="h5" id="ch31lev3sec02"><strong>Reentrant and nonreentrant functions</strong></h5>
<p class="noindentab">Although the use of critical sections to implement thread safety is a significant improvement over the use of per-function mutexes, it is still somewhat inefficient because there is a cost to locking and unlocking a mutex. A <em>reentrant function</em> achieves thread safety without the use of mutexes. It does this by avoiding the use of global and static variables. Any information that must be returned to the caller, or maintained between calls to the function, is stored in buffers allocated by the caller. (We first encountered reentrancy when discussing the treatment of global variables within signal handlers in <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>.) However, not all functions can be made reentrant. The usual reasons are the following:</p>
<p class="bull">&#8226; By their nature, some functions must access global data structures. The functions in the <em>malloc</em> library provide a good example. These functions maintain a global linked list of free blocks on the heap. The functions of the <em>malloc</em> library are made thread-safe through the use of mutexes.</p>
<p class="bull">&#8226; Some functions (defined before the invention of threads) have an interface that by definition is nonreentrant, because they return pointers to storage statically allocated by the function, or they employ static storage to maintain information between successive calls to the same (or a related) function. Most of the functions in <a href="ch31.xhtml#ch31table1">Table 31-1</a> fall into this category. For example, the <em>asctime()</em> function (<a href="ch10.xhtml#ch10lev2sec03">Section 10.2.3</a>) returns a pointer to a statically allocated buffer containing a date-time string.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_658"/>For several of the functions that have nonreentrant interfaces, SUSv3 specifies reentrant equivalents with names ending with the suffix <em>_r</em>. These functions require the caller to allocate a buffer whose address is then passed to the function and used to return the result. This allows the calling thread to use a local (stack) variable for the function result buffer. For this purpose, SUSv3 specifies <em>asctime_r()</em>, <em>ctime_r()</em>, <em>getgrgid_r()</em>, <em>getgrnam_r()</em>, <em>getlogin_r()</em>, <em>getpwnam_r()</em>, <em>getpwuid_r()</em>, <em>gmtime_r()</em>, <em>localtime_r()</em>, <em>rand_r()</em>, <em>readdir_r()</em>, <em>strerror_r()</em>, <em>strtok_r()</em>, and <em>ttyname_r()</em>.</p>
<div class="block">
<p class="noindent">Some implementations also provide additional reentrant equivalents of other traditional nonreentrant functions. For example, <em>glibc</em> provides <em>crypt_r()</em>, <em>gethostbyname_r()</em>, <em>getservbyname_r()</em>, <em>getutent_r()</em>, <em>getutid_r()</em>, <em>getutline_r()</em>, and <em>ptsname_r()</em>. However, a portable application can&#8217;t rely on these functions being present on other implementations. In some cases, SUSv3 doesn&#8217;t specify these reentrant equivalents because alternatives to the traditional functions exist that are both superior and reentrant. For example, <em>getaddrinfo()</em> is the modern, reentrant alternative to <em>gethostbyname()</em> and <em>getservbyname()</em>.</p>
</div>
<h3 class="h3" id="ch31lev1sec02"><strong>31.2 One-Time Initialization</strong></h3>
<p class="noindenta">Sometimes, a threaded application needs to ensure that some initialization action occurs just once, regardless of how many threads are created. For example, a mutex may need to be initialized with special attributes using <em>pthread_mutex_init()</em>, and that initialization must occur just once. If we are creating the threads from the main program, then this is generally easy to achieve&#8212;we perform the initialization before creating any threads that depend on the initialization. However, in a library function, this is not possible, because the calling program may create the threads before the first call to the library function. Therefore, the library function needs a method of performing the initialization the first time that it is called from any thread.</p>
<p class="indent">A library function can perform one-time initialization using the <em>pthread_once()</em> function.</p>
<div class="box">
<p class="programsa">#include &lt;pthread.h&gt;<br/><br/>int <span class="codestrong">pthread_once</span>(pthread_once_t *<span class="font1">once_control</span>, void (*<span class="font1">init</span>)(void));</p>
<p class="right">Returns 0 on success, or a positive error number on error</p>
</div>
<p class="noindent">The <em>pthread_once()</em> function uses the state of the argument <em>once_control</em> to ensure that the caller-defined function pointed to by <em>init</em> is called just once, no matter how many times or from how many different threads the <em>pthread_once()</em> call is made.</p>
<p class="indent">The <em>init</em> function is called without any arguments, and thus has the following form:</p>
<p class="programs">void<br/>init(void)<br/>{<br/>&#160;&#160;&#160;&#160;/* Function body */<br/>}</p>
<p class="noindent"><span epub:type="pagebreak" id="page_659"/>The <em>once_control</em> argument is a pointer to a variable that must be statically initialized with the value <span class="literal">PTHREAD_ONCE_INIT</span>:</p>
<p class="programs">pthread_once_t once_var = PTHREAD_ONCE_INIT;</p>
<p class="noindent">The first call to <em>pthread_once()</em> that specifies a pointer to a particular <em>pthread_once_t</em> variable modifies the value of the variable pointed to by <em>once_control</em> so that subsequent calls to <em>pthread_once()</em> don&#8217;t invoke <em>init</em>.</p>
<p class="indent">One common use of <em>pthread_once()</em> is in conjunction with thread-specific data, which we describe next.</p>
<div class="block">
<p class="noindent">The main reason for the existence of <em>pthread_once()</em> is that in early versions of Pthreads, it was not possible to statically initialize a mutex. Instead, the use of <em>pthread_mutex_init()</em> was required ([<a href="bib.xhtml#bib10">Butenhof, 1996</a>]). Given the later addition of statically allocated mutexes, it is possible for a library function to perform one-time initialization using a statically allocated mutex and a static Boolean variable. Nevertheless, <em>pthread_once()</em> is retained as a convenience.</p>
</div>
<h3 class="h3" id="ch31lev1sec03"><strong>31.3 Thread-Specific Data</strong></h3>
<p class="noindenta">The most efficient way of making a function thread-safe is to make it reentrant. All new library functions should be implemented in this way. However, for an existing nonreentrant library function (one that was perhaps designed before the use of threads became common), this approach usually requires changing the function&#8217;s interface, which means modifying all of the programs that use the function.</p>
<p class="indent">Thread-specific data is a technique for making an existing function thread-safe without changing its interface. A function that uses thread-specific data may be slightly less efficient than a reentrant function, but allows us to leave the programs that call the function unchanged.</p>
<p class="indent">Thread-specific data allows a function to maintain a separate copy of a variable for each thread that calls the function, as illustrated in <a href="ch31.xhtml#ch31fig1">Figure 31-1</a>. Thread-specific data is persistent; each thread&#8217;s variable continues to exist between the thread&#8217;s invocations of the function. This allows the function to maintain per-thread information between calls to the function, and allows the function to pass distinct result buffers (if required) to each calling thread.</p>
<div class="image"><img src="../images/f31-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch31fig1"/><strong>Figure 31-1:</strong> Thread-specific data (TSD) provides per-thread storage for a function</p>
<h4 class="h4" id="ch31lev2sec01"><span epub:type="pagebreak" id="page_660"/><strong>31.3.1 Thread-Specific Data from the Library Function&#8217;s Perspective</strong></h4>
<p class="noindentab">In order to understand the use of the thread-specific data API, we need to consider things from the point of view of a library function that uses thread-specific data:</p>
<p class="bull">&#8226; The function must allocate a separate block of storage for each thread that calls the function. This block needs to be allocated once, the first time the thread calls the function.</p>
<p class="bull">&#8226; On each subsequent call from the same thread, the function needs to be able to obtain the address of the storage block that was allocated the first time this thread called the function. The function can&#8217;t maintain a pointer to the block in an automatic variable, since automatic variables disappear when the function returns; nor can it store the pointer in a static variable, since only one instance of each static variable exists in the process. The Pthreads API provides functions to handle this task.</p>
<p class="bull">&#8226; Different (i.e., independent) functions may each need thread-specific data. Each function needs a method of identifying its thread-specific data (a key), as distinct from the thread-specific data used by other functions.</p>
<p class="bull">&#8226; The function has no direct control over what happens when the thread terminates. When the thread terminates, it is probably executing code outside the function. Nevertheless, there must be some mechanism (a destructor) to ensure that the storage block allocated for this thread is automatically deallocated when the thread terminates. If this is not done, then a memory leak could occur as threads are continuously created, call the function, and then terminate.</p>
<h4 class="h4" id="ch31lev2sec02"><strong>31.3.2 Overview of the Thread-Specific Data API</strong></h4>
<p class="noindenta">The general steps that a library function performs in order to use thread-specific data are as follows:</p>
<ol>
<li class="order"><p class="orderp">The function creates a <em>key</em>, which is the means of differentiating the thread-specific data item used by this function from the thread-specific data items used by other functions. The key is created by calling the <em>pthread_key_create()</em> function. Creating a key needs to be done only once, when the first thread calls the function. For this purpose, <em>pthread_once()</em> is employed. Creating a key doesn&#8217;t allocate any blocks of thread-specific data.</p></li>
<li class="order"><p class="orderp">The call to <em>pthread_key_create()</em> serves a second purpose: it allows the caller to specify the address of the programmer-defined destructor function that is used to deallocate each of the storage blocks allocated for this key (see the next step). When a thread that has thread-specific data terminates, the Pthreads API automatically invokes the destructor, passing it a pointer to the data block for this thread.</p></li>
<li class="order"><p class="orderp">The function allocates a thread-specific data block for each thread from which it is called. This is done using <em>malloc()</em> (or a similar function). This allocation is done once for each thread, the first time the thread calls the function.</p></li>
<li class="order"><p class="orderp">In order to save a pointer to the storage allocated in the previous step, the function employs two Pthreads functions: <em>pthread_setspecific()</em> and <em>pthread_getspecific()</em>. A call to <em>pthread_setspecific()</em> is a request to the Pthreads implementation to say <span epub:type="pagebreak" id="page_661"/>&#8220;save this pointer, recording the fact that it is associated with a particular key (the one for this function) and a particular thread (the calling thread).&#8221; Calling <em>pthread_getspecific()</em> performs the complementary task, returning the pointer previously associated with a given key for the calling thread. If no pointer was previously associated with a particular key and thread, then <em>pthread_getspecific()</em> returns <span class="literal">NULL</span>. This is how a function can determine that it is being called for the first time by this thread, and thus must allocate the storage block for the thread.</p></li>
</ol>
<h4 class="h4" id="ch31lev2sec03"><strong>31.3.3 Details of the Thread-Specific Data API</strong></h4>
<p class="noindenta">In this section, we provide details of each of the functions mentioned in the previous section, and elucidate the operation of thread-specific data by describing how it is typically implemented. The next section shows how to use thread-specific data to write a thread-safe implementation of the standard C library function <em>strerror()</em>.</p>
<p class="indent">Calling <em>pthread_key_create()</em> creates a new thread-specific data key that is returned to the caller in the buffer pointed to by <em>key</em>.</p>
<div class="box">
<p class="programsa">#include &lt;pthread.h&gt;<br/><br/>int <span class="codestrong">pthread_key_create</span>(pthread_key_t *<span class="font1">key</span>, void (*<span class="font1">destructor</span>)(void *));</p>
<p class="right">Returns 0 on success, or a positive error number on error</p>
</div>
<p class="noindent">Because the returned key is used by all threads in the process, <em>key</em> should point to a global variable.</p>
<p class="indent">The <em>destructor</em> argument points to a programmer-defined function of the following form:</p>
<p class="programs">void<br/>dest(void *value)<br/>{<br/>&#160;&#160;&#160;&#160;/* Release storage pointed to by 'value' */<br/>}</p>
<p class="noindent">Upon termination of a thread that has a non-<span class="literal">NULL</span> value associated with <em>key</em>, the destructor function is automatically invoked by the Pthreads API and given that value as its argument. The passed value is normally a pointer to this thread&#8217;s thread-specific data block for this key. If a destructor is not required, then <em>destructor</em> can be specified as <span class="literal">NULL</span>.</p>
<div class="block">
<p class="noindent">If a thread has multiple thread-specific data blocks, then the order in which the destructors are called is unspecified. Destructor functions should be designed to operate independently of one another.</p>
</div>
<p class="noindentb">Looking at the implementation of thread-specific data helps us to understand how it is used. A typical implementation (NPTL is typical), involves the following arrays:</p>
<p class="bull">&#8226; a single global (i.e., process-wide) array of information about thread-specific data keys; and</p>
<p class="bull"><span epub:type="pagebreak" id="page_662"/>&#8226; a set of per-thread arrays, each containing pointers to all of the thread-specific data blocks allocated for a particular thread (i.e., this array contains the pointers stored by calls to <em>pthread_setspecific()</em>).</p>
<p class="noindentt">In this implementation, the <em>pthread_key_t</em> value returned by <em>pthread_key_create()</em> is simply an index into the global array, which we label <em>pthread_keys</em>, whose form is shown in <a href="ch31.xhtml#ch31fig2">Figure 31-2</a>. Each element of this array is a structure containing two fields. The first field indicates whether this array element is in use (i.e., has been allocated by a previous call to <em>pthread_key_create()</em>). The second field is used to store the pointer to the destructor function for the thread-specific data blocks for this key (i.e., it is a copy of the <em>destructor</em> argument to <em>pthread_key_create()</em>).</p>
<div class="image"><img src="../images/f31-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch31fig2"/><strong>Figure 31-2:</strong> Implementation of thread-specific data keys</p>
<p class="noindent">The <em>pthread_setspecific()</em> function requests the Pthreads API to save a copy of <em>value</em> in a data structure that associates it with the calling thread and with <em>key</em>, a key returned by a previous call to <em>pthread_key_create()</em>. The <em>pthread_getspecific()</em> function performs the converse operation, returning the value that was previously associated with the given <em>key</em> for this thread.</p>
<div class="box">
<p class="programsa">#include &lt;pthread.h&gt;<br/><br/>int <span class="codestrong">pthread_setspecific</span>(pthread_key_t <span class="font1">key</span>, const void *<span class="font1">value</span>);</p>
<p class="right">Returns 0 on success, or a positive error number on error</p>
<p class="programsat">void *<span class="codestrong">pthread_getspecific</span>(pthread_key_t <span class="font1">key</span>);</p>
<p class="right">Returns pointer, or <span class="literal">NULL</span> if no thread-specific data is associated with <em>key</em></p>
</div>
<p class="noindent">The <em>value</em> argument given to <em>pthread_setspecific()</em> is normally a pointer to a block of memory that has previously been allocated by the caller. This pointer will be passed as the argument for the destructor function for this <em>key</em> when the thread terminates.</p>
<div class="block">
<p class="noindent">The <em>value</em> argument doesn&#8217;t need to be a pointer to a block of memory. It could be some scalar value that can be assigned (with a cast) to <em>void *</em>. In this case, the earlier call to <em>pthread_key_create()</em> would specify <em>destructor</em> as <span class="literal">NULL</span>.</p>
</div>
<p class="noindent"><a href="ch31.xhtml#ch31fig3">Figure 31-3</a> shows a typical implementation of the data structure used to store <em>value</em>. In this diagram, we assume that <em>pthread_keys[1]</em> was allocated to a function <span epub:type="pagebreak" id="page_663"/>named <em>myfunc()</em>. For each thread, the Pthreads API maintains an array of pointers to thread-specific data blocks. The elements of each of these thread-specific arrays have a one-to-one correspondence with the elements of the global <em>pthread_keys</em> array shown in <a href="ch31.xhtml#ch31fig2">Figure 31-2</a>. The <em>pthread_setspecific()</em> function sets the element corresponding to <em>key</em> in the array for the calling thread.</p>
<div class="image"><img src="../images/f31-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch31fig3"/><strong>Figure 31-3:</strong> Data structure used to implement thread-specific data (TSD) pointers</p>
<p class="noindent">When a thread is first created, all of its thread-specific data pointers are initialized to <span class="literal">NULL</span>. This means that when our library function is called by a thread for the first time, it must begin by using <em>pthread_getspecific()</em> to check whether the thread already has an associated value for <em>key</em>. If it does not, then the function allocates a block of memory and saves a pointer to the block using <em>pthread_setspecific()</em>. We show an example of this in the thread-safe <em>strerror()</em> implementation presented in the next section.</p>
<h4 class="h4" id="ch31lev2sec04"><strong>31.3.4 Employing the Thread-Specific Data API</strong></h4>
<p class="noindenta">When we first described the standard <em>strerror()</em> function in <a href="ch03.xhtml#ch03lev1sec04">Section 3.4</a>, we noted that it may return a pointer to a statically allocated string as its function result. This means that <em>strerror()</em> may not be thread-safe. In the next few pages, we look at a non-thread-safe implementation of <em>strerror()</em>, and then show how thread-specific data can be used to make this function thread-safe.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_664"/>On many UNIX implementations, including Linux, the <em>strerror()</em> function provided by the standard C library <em>is</em> thread-safe. However, we use the example of <em>strerror()</em> anyway, because SUSv3 doesn&#8217;t require this function to be thread-safe, and its implementation provides a simple example of the use of thread-specific data.</p>
</div>
<p class="noindent"><a href="ch31.xhtml#ch31ex1">Listing 31-1</a> shows a simple non-thread-safe implementation of <em>strerror()</em>. This function makes use of a pair of global variables defined by <em>glibc</em>: <em>_sys_errlist</em> is an array of pointers to strings corresponding to the error numbers in <em>errno</em> (thus, for example, <em>_sys_errlist[EINVAL]</em> points to the string <em>Invalid argument</em>), and <em>_sys_nerr</em> specifies the number of elements in <em>_sys_errlist</em>.</p>
<p class="examplet"><a id="ch31ex1"/><strong>Listing 31-1:</strong> An implementation of <em>strerror()</em> that is not thread-safe</p>
<p class="programsli">________________________________________________________<span class="codestrong">threads/strerror.c</span><br/><br/>#define _GNU_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get '_sys_nerr' and '_sys_errlist'<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;declarations from &lt;stdio.h&gt; */<br/>#include &lt;stdio.h&gt;<br/>#include &lt;string.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get declaration of strerror() */<br/><br/>#define MAX_ERROR_LEN 256&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Maximum length of string<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;returned by strerror() */<br/><br/>static char buf[MAX_ERROR_LEN];&#160;&#160;&#160;&#160;/* Statically allocated return buffer */<br/><br/>char *<br/>strerror(int err)<br/>{<br/>&#160;&#160;&#160;&#160;if (err &lt; 0 || err &gt;= _sys_nerr || _sys_errlist[err] == NULL) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;snprintf(buf, MAX_ERROR_LEN, "Unknown error %d", err);<br/>&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;strncpy(buf, _sys_errlist[err], MAX_ERROR_LEN - 1);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;buf[MAX_ERROR_LEN - 1] = '\0';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Ensure null termination */<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;return buf;<br/>}<br/>________________________________________________________<span class="codestrong">threads/strerror.c</span></p>
<p class="noindent">We can use the program in <a href="ch31.xhtml#ch31ex2">Listing 31-2</a> to demonstrate the consequences of the fact that the <em>strerror()</em> implementation in <a href="ch31.xhtml#ch31ex1">Listing 31-1</a> is not thread-safe. This program calls <em>strerror()</em> from two different threads, but displays the returned value only after both threads have called <em>strerror()</em>. Even though each thread specifies a different value (<span class="literal">EINVAL</span> and <span class="literal">EPERM</span>) as the argument to <em>strerror()</em>, this is what we see when we compile and link this program with the version of <em>strerror()</em> shown in <a href="ch31.xhtml#ch31ex1">Listing 31-1</a>:</p>
<p class="programs">$ <span class="codestrong">./strerror_test</span><br/>Main thread has called strerror()<br/>Other thread about to call strerror()<br/>Other thread: str (0x804a7c0) = Operation not permitted<br/>Main thread:&#160;&#160;str (0x804a7c0) = Operation not permitted</p>
<p class="noindent"><span epub:type="pagebreak" id="page_665"/>Both threads displayed the <em>errno</em> string corresponding to <span class="literal">EPERM</span>, because the call to <em>strerror()</em> by the second thread (in <em>threadFunc</em>) overwrote the buffer that was written by the call to <em>strerror()</em> in the main thread. Inspection of the output shows that the local variable <em>str</em> in the two threads points to the same memory address.</p>
<p class="examplet"><a id="ch31ex2"/><strong>Listing 31-2:</strong> Calling <em>strerror()</em> from two different threads</p>
<p class="programsli">___________________________________________________ <span class="codestrong">threads/strerror_test.c</span><br/><br/>#include &lt;stdio.h&gt;<br/>#include &lt;string.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get declaration of strerror() */<br/>#include &lt;pthread.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static void *<br/>threadFunc(void *arg)<br/>{<br/>&#160;&#160;&#160;&#160;char *str;<br/><br/>&#160;&#160;&#160;&#160;printf("Other thread about to call strerror()\n");<br/>&#160;&#160;&#160;&#160;str = strerror(EPERM);<br/>&#160;&#160;&#160;&#160;printf("Other thread: str (%p) = %s\n", str, str);<br/><br/>&#160;&#160;&#160;&#160;return NULL;<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;pthread_t t;<br/>&#160;&#160;&#160;&#160;int s;<br/>&#160;&#160;&#160;&#160;char *str;<br/><br/>&#160;&#160;&#160;&#160;str = strerror(EINVAL);<br/>&#160;&#160;&#160;&#160;printf("Main thread has called strerror()\n");<br/><br/>&#160;&#160;&#160;&#160;s = pthread_create(&#38;t, NULL, threadFunc, NULL);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_create");<br/><br/>&#160;&#160;&#160;&#160;s = pthread_join(t, NULL);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_join");<br/><br/>&#160;&#160;&#160;&#160;printf("Main thread: str (%p) = %s\n", str, str);<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>___________________________________________________ <span class="codestrong">threads/strerror_test.c</span></p>
<p class="noindent"><a href="ch31.xhtml#ch31ex3">Listing 31-3</a> shows a reimplementation of <em>strerror()</em> that uses thread-specific data to ensure thread safety.</p>
<p class="indent">The first step performed by the revised <em>strerror()</em> is to call <em>pthread_once()</em> <span class="ent">&#x2463;</span> to ensure that the first invocation of this function (from any thread) calls <em>createKey()</em> <span class="ent">&#x2461;</span>. The <em>createKey()</em> function calls <em>pthread_key_create()</em> to allocate a thread-specific data <span epub:type="pagebreak" id="page_666"/>key that is stored in the global variable <em>strerrorKey</em> <span class="ent">&#x2462;</span>. The call to <em>pthread_key_create()</em> also records the address of the destructor <span class="ent">&#x2460;</span> that will be used to free the thread-specific buffers corresponding to this key.</p>
<p class="indent">The <em>strerror()</em> function then calls <em>pthread_getspecific()</em> <span class="ent">&#x2464;</span> to retrieve the address of this thread&#8217;s unique buffer corresponding to <em>strerrorKey</em>. If <em>pthread_getspecific()</em> returns <span class="literal">NULL</span>, then this thread is calling <em>strerror()</em> for the first time, and so the function allocates a new buffer using <em>malloc()</em> <span class="ent">&#x2465;</span>, and saves the address of the buffer using <em>pthread_setspecific()</em> <span class="ent">&#x2466;</span>. If the <em>pthread_getspecific()</em> call returns a non-<span class="literal">NULL</span> value, then that pointer refers to an existing buffer that was allocated when this thread previously called <em>strerror()</em>.</p>
<p class="indent">The remainder of this <em>strerror()</em> implementation is similar to the implementation that we showed earlier, with the difference that <em>buf</em> is the address of a thread-specific data buffer, rather than a static variable.</p>
<p class="examplet"><a id="ch31ex3"/><strong>Listing 31-3:</strong> A thread-safe implementation of <em>strerror()</em> using thread-specific data</p>
<p class="programsli">____________________________________________________ <span class="codestrong">threads/strerror_tsd.c</span><br/><br/>&#160;&#160;&#160;#define _GNU_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get '_sys_nerr' and '_sys_errlist'<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;declarations from &lt;stdio.h&gt; */<br/>&#160;&#160;&#160;#include &lt;stdio.h&gt;<br/>&#160;&#160;&#160;#include &lt;string.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get declaration of strerror() */<br/>&#160;&#160;&#160;#include &lt;pthread.h&gt;<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;static pthread_once_t once = PTHREAD_ONCE_INIT;<br/>&#160;&#160;&#160;static pthread_key_t strerrorKey;<br/><br/>&#160;&#160;&#160;#define MAX_ERROR_LEN 256&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Maximum length of string in per-thread<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;buffer returned by strerror() */<br/><br/>&#160;&#160;&#160;static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Free thread-specific data buffer */<br/><span class="ent">&#x2460;</span> destructor(void *buf)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;free(buf);<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* One-time key creation function */<br/><span class="ent">&#x2461;</span> createKey(void)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int s;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allocate a unique thread-specific data key and save the address<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;of the destructor for thread-specific data buffers */<br/><br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;s = pthread_key_create(&#38;strerrorKey, destructor);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_key_create");<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;char *<br/>&#160;&#160;&#160;strerror(int err)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int s;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char *buf;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Make first caller allocate key for thread-specific data */<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;s = pthread_once(&#38;once, createKey);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_once");<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;buf = pthread_getspecific(strerrorKey);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (buf == NULL) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If first call from this thread, allocate<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;buffer for thread, and save its location */<br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;buf = malloc(MAX_ERROR_LEN);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (buf == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("malloc");<br/><br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = pthread_setspecific(strerrorKey, buf);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExitEN(s, "pthread_setspecific");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (err &lt; 0 || err &gt;= _sys_nerr || _sys_errlist[err] == NULL) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;snprintf(buf, MAX_ERROR_LEN, "Unknown error %d", err);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;strncpy(buf, _sys_errlist[err], MAX_ERROR_LEN - 1);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;buf[MAX_ERROR_LEN - 1] = '\0';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Ensure null termination */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;return buf;<br/>&#160;&#160;&#160;}<br/>____________________________________________________ <span class="codestrong">threads/strerror_tsd.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_667"/>If we compile and link our test program (<a href="ch31.xhtml#ch31ex2">Listing 31-2</a>) with the new version of <em>strerror()</em> (<a href="ch31.xhtml#ch31ex3">Listing 31-3</a>) to create an executable file, <span class="literal">strerror_test_tsd</span>, then we see the following results when running the program:</p>
<p class="programs">$ <span class="codestrong">./strerror_test_tsd</span><br/>Main thread has called strerror()<br/>Other thread about to call strerror()<br/>Other thread: str (0x804b158) = Operation not permitted<br/>Main thread:&#160;&#160;str (0x804b008) = Invalid argument</p>
<p class="noindent">From this output, we see that the new version of <em>strerror()</em> is thread-safe. We also see that the address pointed to by the local variable <em>str</em> in the two threads is different.</p>
<h4 class="h4" id="ch31lev2sec05"><span epub:type="pagebreak" id="page_668"/><strong>31.3.5 Thread-Specific Data Implementation Limits</strong></h4>
<p class="noindenta">As implied by our description of how thread-specific data is typically implemented, an implementation may need to impose limits on the number of thread-specific data keys that it supports. SUSv3 requires that an implementation support at least 128 (<span class="literal">_POSIX_THREAD_KEYS_MAX</span>) keys. An application can determine how many keys an implementation actually supports either via the definition of <span class="literal">PTHREAD_KEYS_MAX</span> (defined in <span class="literal">&lt;limits.h&gt;</span>) or by calling <em>sysconf(_SC_THREAD_KEYS_MAX)</em>. Linux supports up to 1024 keys.</p>
<p class="indent">Even 128 keys should be more than sufficient for most applications. This is because each library function should employ only a small number of keys&#8212;often just one. If a function requires multiple thread-specific data values, these can usually be placed in a single structure that has just one associated thread-specific data key.</p>
<h3 class="h3" id="ch31lev1sec04"><strong>31.4 Thread-Local Storage</strong></h3>
<p class="noindenta">Like thread-specific data, thread-local storage provides persistent per-thread storage. This feature is nonstandard, but it is provided in the same or a similar form on many other UNIX implementations (e.g., Solaris and FreeBSD).</p>
<p class="indent">The main advantage of thread-local storage is that it is much simpler to use than thread-specific data. To create a thread-local variable, we simply include the <span class="literal">__thread</span> specifier in the declaration of a global or static variable:</p>
<p class="programs">static __thread char buf[MAX_ERROR_LEN];</p>
<p class="noindent">Each thread has its own copy of the variables declared with this specifier. The variables in a thread&#8217;s thread-local storage persist until the thread terminates, at which time the storage is automatically deallocated.</p>
<p class="indentb">Note the following points about the declaration and use of thread-local variables:</p>
<p class="bull">&#8226; The <span class="literal">__thread</span> keyword must immediately follow the <span class="literal">static</span> or <span class="literal">extern</span> keyword, if either of these is specified in the variable&#8217;s declaration.</p>
<p class="bull">&#8226; The declaration of a thread-local variable can include an initializer, in the same manner as a normal global or static variable declaration.</p>
<p class="bull">&#8226; The C address (<span class="literal">&#38;</span>) operator can be used to obtain the address of a thread-local variable.</p>
<p class="noindentt">Thread-local storage requires support from the kernel (provided in Linux 2.6), the Pthreads implementation (provided in NPTL), and the C compiler (provided on x86-32 with <em>gcc</em> 3.3 and later).</p>
<p class="indent"><a href="ch31.xhtml#ch31ex4">Listing 31-4</a> shows a thread-safe implementation of <em>strerror()</em> using thread-local storage. If we compile and link our test program (<a href="ch31.xhtml#ch31ex2">Listing 31-2</a>) with this version of <em>strerror()</em> to create an executable file, <span class="literal">strerror_test_tls</span>, then we see the following results when running the program:</p>
<p class="programs">$ <span class="codestrong">./strerror_test_tls</span><br/>Main thread has called strerror()<br/>Other thread about to call strerror()<br/>Other thread: str (0x40376ab0) = Operation not permitted<br/>Main thread:&#160;&#160;str (0x40175080) = Invalid argument</p>
<p class="examplet"><span epub:type="pagebreak" id="page_669"/><a id="ch31ex4"/><strong>Listing 31-4:</strong> A thread-safe implementation of <em>strerror()</em> using thread-local storage</p>
<p class="programsli">____________________________________________________ <span class="codestrong">threads/strerror_tls.c</span><br/><br/>#define _GNU_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get '_sys_nerr' and '_sys_errlist'<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;declarations from &lt;stdio.h&gt; */<br/>#include &lt;stdio.h&gt;<br/>#include &lt;string.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get declaration of strerror() */<br/>#include &lt;pthread.h&gt;<br/><br/>#define MAX_ERROR_LEN 256&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Maximum length of string in per-thread<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;buffer returned by strerror() */<br/><br/>static __thread char buf[MAX_ERROR_LEN];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Thread-local return buffer */<br/><br/>char *<br/>strerror(int err)<br/>{<br/>&#160;&#160;&#160;&#160;if (err &lt; 0 || err &gt;= _sys_nerr || _sys_errlist[err] == NULL) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;snprintf(buf, MAX_ERROR_LEN, "Unknown error %d", err);<br/>&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;strncpy(buf, _sys_errlist[err], MAX_ERROR_LEN - 1);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;buf[MAX_ERROR_LEN - 1] = '\0';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Ensure null termination */<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;return buf;<br/>}<br/>____________________________________________________ <span class="codestrong">threads/strerror_tls.c</span></p>
<h3 class="h3" id="ch31lev1sec05"><strong>31.5 Summary</strong></h3>
<p class="noindenta">A function is said to be thread-safe if it can safely be invoked from multiple threads at the same time. The usual reason a function is not thread-safe is that it makes use of global or static variables. One way to render a non-thread-safe function safe in a multithreaded application is to guard all calls to the function with a mutex lock. This approach suffers the problem that it reduces concurrency, because only one thread can be in the function at any time. An approach that allows greater concurrency is to add mutex locks around just those parts of the function that manipulate shared variables (the critical sections).</p>
<p class="indent">Mutexes can be used to render most functions thread-safe, but they carry a performance penalty because there is a cost to locking and unlocking a mutex. By avoiding the use of global and static variables, a reentrant function achieves thread-safety without the use of mutexes.</p>
<p class="indent">Most of the functions specified in SUSv3 are required to be thread-safe. SUSv3 also lists a small set of functions that are not required to be thread-safe. Typically, these are functions that employ static storage to return information to the caller or to maintain information between successive calls. By definition, such functions are not reentrant, and mutexes can&#8217;t be used to make them thread-safe. We considered two roughly equivalent coding techniques&#8212;thread-specific data and thread-local storage&#8212;that can be used to render an unsafe function thread-safe without needing <span epub:type="pagebreak" id="page_670"/>to change its interface. Both of these techniques allow a function to allocate persistent, per-thread storage.</p>
<h5 class="h5" id="ch31lev3sec03"><strong>Further information</strong></h5>
<p class="noindenta">Refer to the sources of further information listed in <a href="ch29.xhtml#ch29lev1sec10">Section 29.10</a>.</p>
<h3 class="h3" id="ch31lev1sec06"><strong>31.6 Exercises</strong></h3>
<p class="exer"><a id="ch31exe1"/><strong>31-1.</strong>&#160;&#160;&#160;Implement a function, <em>one_time_init(control, init)</em>, that performs the equivalent of <em>pthread_once()</em>. The <em>control</em> argument should be a pointer to a statically allocated structure containing a Boolean variable and a mutex. The Boolean variable indicates whether the function <em>init</em> has already been called, and the mutex controls access to that variable. To keep the implementation simple, you can ignore possibilities such as <em>init()</em> failing or being canceled when first called from a thread (i.e., it is not necessary to devise a scheme whereby, if such an event occurs, the next thread that calls <em>one_time_init()</em> reattempts the call to <em>init()</em>).</p>
<p class="exer"><a id="ch31exe2"/><strong>31-2.</strong>&#160;&#160;&#160;Use thread-specific data to write thread-safe versions of <em>dirname()</em> and <em>basename()</em> (<a href="ch18.xhtml#ch18lev1sec14">Section 18.14</a>).</p>
</body>
</html>
