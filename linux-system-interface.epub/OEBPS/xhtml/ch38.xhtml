<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch38"><span epub:type="pagebreak" id="page_783"/><strong><span class="big">38</span></strong><br/><strong>WRITING SECURE PRIVILEGED PROGRAMS</strong></h2>
<p class="noindentab">Privileged programs have access to features and resources (files, devices, and so on) that are not available to ordinary users. A program can run with privileges by two general means:</p>
<p class="bull">&#8226; The program was started under a privileged user ID. Many daemons and network servers, which are typically run as <em>root</em>, fall into this category.</p>
<p class="bull">&#8226; The program has its set-user-ID or set-group-ID permission bit set. When a set-user-ID (set-group-ID) program is execed, it changes the effective user (group) ID of the process to be the same as the owner (group) of the program file. (We first described set-user-ID and set-group-ID programs in <a href="ch09.xhtml#ch09lev1sec03">Section 9.3</a>.) In this chapter, we&#8217;ll sometimes use the term set-user-ID-<em>root</em> to distinguish a set-user-ID program that gives superuser privileges to a process from one that gives a process another effective identity.</p>
<p class="noindentt">If a privileged program contains bugs, or can be subverted by a malicious user, then the security of the system or an application can be compromised. From a security viewpoint, we should write programs so as to minimize both the chance of a compromise and the damage that can be done if a compromise does occur. These topics form the subject of this chapter, which provides a set of recommended practices for secure programming, and describes various pitfalls that should be avoided when writing privileged programs.</p>
<h3 class="h3" id="ch38lev1sec01"><span epub:type="pagebreak" id="page_784"/><strong>38.1 Is a Set-User-ID or Set-Group-ID Program Required?</strong></h3>
<p class="noindenta">One of the best pieces of advice concerning set-user-ID and set-group-ID programs is to avoid writing them whenever possible. If there is an alternative way of performing a task that doesn&#8217;t involve giving a program privilege, we should generally employ that alternative, since it eliminates the possibility of a security compromise.</p>
<p class="indent">Sometimes, we can isolate the functionality that needs privilege into a separate program that performs a single task, and exec that program in a child process as required. This technique can be especially useful for libraries. One example of such a use is provided by the <em>pt_chown</em> program described in <a href="ch64.xhtml#ch64lev2sec02">Section 64.2.2</a>.</p>
<p class="indent">Even in cases where a set-user-ID or set-group-ID is needed, it isn&#8217;t always necessary for a set-user-ID program to give a process <em>root</em> credentials. If giving a process some other credentials suffices, then this option should be preferred, since running with <em>root</em> privileges opens the gates to possible security compromises.</p>
<p class="indent">Consider a set-user-ID program that needs to allow users to update a file on which they do not have write permission. A safer way to do this is to create a dedicated group account (group ID) for this program, change the group ownership of the file to that group (and make the file writable by that group), and write a set-group-ID program that sets the process&#8217;s effective group ID to the dedicated group ID. Since the dedicated group ID is not otherwise privileged, this greatly limits the damage that can be done if the program contains bugs or can otherwise be subverted.</p>
<h3 class="h3" id="ch38lev1sec02"><strong>38.2 Operate with Least Privilege</strong></h3>
<p class="noindenta">A set-user-ID (or set-group-ID) program typically requires privileges only to perform certain operations. While the program (especially one assuming superuser privileges) is performing other work, it should disable these privileges. When privileges will never again be required, they should be dropped permanently. In other words, the program should always operate with the <em>least privilege</em> required to accomplish the tasks that it is currently performing. The saved set-user-ID facility was designed for this purpose (<a href="ch09.xhtml#ch09lev1sec04">Section 9.4</a>).</p>
<h5 class="h5" id="ch38lev3sec01"><strong>Hold privileges only while they are required</strong></h5>
<p class="noindenta">In a set-user-ID program, we can use the following sequence of <em>seteuid()</em> calls to temporarily drop and then reacquire privileges:</p>
<p class="programs">uid_t orig_euid;<br/><br/>orig_euid = geteuid();<br/>if (seteuid(getuid()) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Drop privileges */<br/>&#160;&#160;&#160;&#160;errExit("seteuid");<br/><br/>/* Do unprivileged work */<br/><br/>if (seteuid(orig_euid) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Reacquire privileges */<br/>&#160;&#160;&#160;&#160;errExit("seteuid");<br/><br/>/* Do privileged work */</p>
<p class="noindent"><span epub:type="pagebreak" id="page_785"/>The first call makes the effective user ID of the calling process the same as its real ID. The second call restores the effective user ID to the value held in the saved set-user-ID.</p>
<p class="indent">For set-group-ID programs, the saved set-group-ID saves the program&#8217;s initial effective group ID, and <em>setegid()</em> is used to drop and reacquire privilege. We describe <em>seteuid()</em>, <em>setegid()</em>, and other similar system calls mentioned in the following recommendations in <a href="ch09.xhtml#ch09">Chapter 9</a> and summarize them in <a href="ch09.xhtml#ch9table1">Table 9-1</a> (on <a href="ch09.xhtml#page_181">page 181</a>).</p>
<p class="indent">The safest practice is to drop privileges immediately on program startup, and then temporarily reacquire them as needed at later points in the program. If, at a certain point, privileges will never be required again, then the program should drop them irreversibly, by ensuring that the saved set-user-ID is also changed. This eliminates the possibility of the program being tricked into reacquiring privilege, perhaps via the stack-crashing technique described in <a href="ch38.xhtml#ch38lev1sec09">Section 38.9</a>.</p>
<h5 class="h5" id="ch38lev3sec02"><strong>Drop privileges permanently when they will never again be required</strong></h5>
<p class="noindenta">If a set-user-ID or set-group-ID program finishes all tasks that require privileges, then it should drop its privileges permanently in order to eliminate any security risk that could occur because the program is compromised by a bug or other unexpected behavior. Dropping privileges permanently is accomplished by resetting all process user (group) IDs to the same value as the real user (group) ID.</p>
<p class="indent">From a set-user-ID-<em>root</em> program whose effective user ID is currently 0, we can reset all user IDs using the following code:</p>
<p class="programs">if (setuid(getuid()) == -1)<br/>&#160;&#160;&#160;&#160;errExit("setuid");</p>
<p class="noindent">However, the above code does <em>not</em> reset the saved set-user-ID if the effective user ID of the calling process is currently nonzero: when called from a program whose effective user ID is nonzero, <em>setuid()</em> changes only the effective user ID (<a href="ch09.xhtml#ch09lev2sec01">Section 9.7.1</a>). In other words, in a set-user-ID-<em>root</em> program, the following sequence doesn&#8217;t permanently drop the user ID 0:</p>
<p class="programs">/* Initial UIDs:&#160;&#160;&#160;&#160;real=1000 effective=0 saved=0 */<br/><br/>/* 1. Usual call to temporarily drop privilege */<br/><br/>orig_euid = geteuid();<br/>if (seteuid(getuid()) == -1)<br/>&#160;&#160;&#160;&#160;errExit("seteuid");<br/><br/>/* UIDs changed to: real=1000 effective=1000 saved=0 */<br/><br/>/* 2. Looks like the right way to permanently drop privilege (WRONG!) */<br/><br/>if (setuid(getuid()) == -1)<br/>&#160;&#160;&#160;&#160;errExit("setuid");<br/><br/>/* UIDs unchanged:&#160;&#160;real=1000 effective=1000 saved=0 */</p>
<p class="noindent"><span epub:type="pagebreak" id="page_786"/>Instead, we must regain privilege prior to dropping it permanently, by inserting the following call between steps 1 and 2 above:</p>
<p class="programs">if (seteuid(orig_euid) == -1)<br/>&#160;&#160;&#160;&#160;errExit("seteuid");</p>
<p class="noindent">On the other hand, if we have a set-user-ID program owned by a user other than <em>root</em>, then, because <em>setuid()</em> is insufficient to change the saved set-user-ID, we must use either <em>setreuid()</em> or <em>setresuid()</em> to permanently drop the privileged identifier. For example, we could achieve the desired result using <em>setreuid()</em>, as follows:</p>
<p class="programs">if (setreuid(getuid(), getuid()) == -1)<br/>&#160;&#160;&#160;&#160;errExit("setreuid");</p>
<p class="noindent">This code relies on a feature of the Linux implementation of <em>setreuid()</em>: if the first (<em>ruid</em>) argument is not &#8211;1, then the saved set-user-ID is also set to the same value as the (new) effective user ID. SUSv3 doesn&#8217;t specify this feature, but many other implementations behave the same way as Linux. SUSv4 does specify this feature.</p>
<p class="indent">The <em>setregid()</em> or <em>setresgid()</em> system call must likewise be used to permanently drop a privileged group ID in a set-group-ID program, since, when the effective user ID of a program is nonzero, <em>setgid()</em> changes only the effective group ID of the calling process.</p>
<h5 class="h5" id="ch38lev3sec03"><strong>General points on changing process credentials</strong></h5>
<p class="noindentab">In the preceding pages, we described techniques for temporarily and permanently dropping privileges. We now add a few general points regarding the use of these techniques:</p>
<p class="bull">&#8226; The semantics of some of the system calls that change process credentials vary across systems. Furthermore, the semantics of some of these system calls vary depending on whether or not the caller is privileged (effective user ID of 0). For details, see <a href="ch09.xhtml#ch09">Chapter 9</a>, and especially <a href="ch09.xhtml#ch09lev2sec04">Section 9.7.4</a>. Because of these variations, [<a href="bib.xhtml#bib103">Tsafrir et al., 2008</a>] recommends that applications should use system-specific <em>nonstandard</em> system calls for changing process credentials, since, in many cases, these nonstandard system calls provide simpler and more consistent semantics than their standard counterparts. On Linux, this would translate to using <em>setresuid()</em> and <em>setresgid()</em> to change user and group credentials. Although these system calls are not present on all systems, their use is likely to be less prone to error. ([<a href="bib.xhtml#bib103">Tsafrir et al., 2008</a>] proposes a library of functions that make credential changes using what they consider to be the best interfaces available on each platform.)</p>
<p class="bull">&#8226; On Linux, even if the caller has an effective user ID of 0, system calls for changing credentials may not behave as expected if the program has explicitly manipulated its capabilities. For example, if the <span class="literal">CAP_SETUID</span> capability has been disabled, then attempts to change process user IDs will fail or, even worse, silently change only some of the requested user IDs.</p>
<p class="bull"><span epub:type="pagebreak" id="page_787"/>&#8226; Because of the possibilities listed in the two preceding points, it is highly recommended practice (see, for example, [<a href="bib.xhtml#bib103">Tsafrir et al., 2008</a>]) to not only check that a credential-changing system call has succeeded, but also to verify that the change occurred as expected. For example, if we are temporarily dropping or reacquiring a privileged user ID using <em>seteuid()</em>, then we should follow that call with a <em>geteuid()</em> call that verifies that the effective user ID is what we expect. Similarly, if we are dropping a privileged user ID permanently, then we should verify that the real user ID, effective user ID, and saved set-user-ID have all been successfully changed to the unprivileged user ID. Unfortunately, while there are standard system calls for retrieving the real and effective IDs, there are no standard system calls for retrieving the saved set IDs. Linux and a few other systems provide <em>getresuid()</em> and <em>getresgid()</em> for this purpose; on some other systems, we may need to employ techniques such as parsing information in <span class="literal">/proc</span> files.</p>
<p class="bull">&#8226; Some credential changes can be made only by processes with an effective user ID of 0. Therefore, when changing multiple IDs&#8212;supplementary group IDs, group IDs, and user IDs&#8212;we should drop the privileged effective user ID last when dropping privileged IDs. Conversely, we should raise the privileged effective user ID first when raising privileged IDs.</p>
<h3 class="h3" id="ch38lev1sec03"><strong>38.3 Be Careful When Executing a Program</strong></h3>
<p class="noindenta">Caution is required when a privileged program executes another program, either directly, via an <em>exec()</em>, or indirectly, via <em>system()</em>, <em>popen()</em>, or a similar library function.</p>
<h5 class="h5" id="ch38lev3sec04"><strong>Drop privileges permanently before execing another program</strong></h5>
<p class="noindenta">If a set-user-ID (or set-group-ID) program executes another program, then it should ensure that all process user (group) IDs are reset to the same value as the real user (group) ID, so that the new program doesn&#8217;t start with privileges and also can&#8217;t reacquire them. One way to do this is to reset all of the IDs before performing the <em>exec()</em>, using the techniques described in <a href="ch38.xhtml#ch38lev1sec02">Section 38.2</a>.</p>
<p class="indent">The same result can be achieved by preceding the <em>exec()</em> with the call <em>setuid(getuid())</em>. Even though this <em>setuid()</em> call changes only the effective user ID in a process whose effective user ID is nonzero, privileges are nevertheless dropped because (as described in <a href="ch09.xhtml#ch09lev1sec04">Section 9.4</a>) a successful <em>exec()</em> goes on to copy the effective user ID to the saved set-user-ID. (If the <em>exec()</em> fails, then the saved set-user-ID is left unchanged. This may be useful if the program then needs to perform other privileged work because the <em>exec()</em> failed.)</p>
<p class="indent">A similar approach (i.e., <em>setgid(getgid())</em>) can be used with set-group-ID programs, since a successful <em>exec()</em> also copies the effective group ID to the saved set-group-ID.</p>
<p class="indent">As an example, suppose that we have a set-user-ID program owned by user ID 200. When this program is executed by a user whose ID is 1000, the user IDs of the resulting process will be as follows:</p>
<p class="programs">real=1000 effective=200 saved=200</p>
<p class="noindent"><span epub:type="pagebreak" id="page_788"/>If this program subsequently executes the call <em>setuid(getuid())</em>, then the process user IDs are changed to the following:</p>
<p class="programs">real=1000 effective=1000 saved=200</p>
<p class="noindent">When the process executes an unprivileged program, the effective user ID of the process is copied to the saved set-user-ID, resulting in the following set of process user IDs:</p>
<p class="programs">real=1000 effective=1000 saved=1000</p>
<h5 class="h5" id="ch38lev3sec05"><strong>Avoid executing a shell (or other interpreter) with privileges</strong></h5>
<p class="noindenta">Privileged programs running under user control should never exec a shell, either directly or indirectly (via <em>system()</em>, <em>popen()</em>, <em>execlp()</em>, <em>execvp()</em>, or other similar library functions). The complexity and power of shells (and other unconstrained interpreters such as <em>awk</em>) mean that it is virtually impossible to eliminate all security loopholes, even if the execed shell doesn&#8217;t allow interactive access. The consequent risk is that the user may be able to execute arbitrary shell commands under the effective user ID of the process. If a shell must be execed, ensure that privileges are permanently dropped beforehand.</p>
<div class="block">
<p class="noindent">An example of the kind of security loophole that can occur when execing a shell is noted in the discussion of <em>system()</em> in <a href="ch27.xhtml#ch27lev1sec06">Section 27.6</a>.</p>
</div>
<p class="noindent">A few UNIX implementations honor the set-user-ID and set-group-ID permission bits when they are applied to interpreter scripts (<a href="ch27.xhtml#ch27lev1sec03">Section 27.3</a>), so that, when the script is run, the process executing the script assumes the identity of some other (privileged) user. Because of the security risks just described, Linux, like some other UNIX implementations, silently ignores the set-user-ID and set-group-ID permission bits when execing a script. Even on implementations where set-user-ID and set-group-ID scripts are permitted, their use should be avoided.</p>
<h5 class="h5" id="ch38lev3sec06"><strong>Close all unnecessary file descriptors before an <em>exec()</em></strong></h5>
<p class="noindenta">In <a href="ch27.xhtml#ch27lev1sec04">Section 27.4</a>, we noted that, by default, file descriptors remain open across an <em>exec()</em>. A privileged program may open a file that normal processes can&#8217;t access. The resulting open file descriptor represents a privileged resource. The file descriptor should be closed before an <em>exec()</em>, so that the execed program can&#8217;t access the associated file. We can do this either by explicitly closing the file descriptor or by setting its close-on-exec flag (<a href="ch27.xhtml#ch27lev1sec04">Section 27.4</a>).</p>
<h3 class="h3" id="ch38lev1sec04"><strong>38.4 Avoid Exposing Sensitive Information</strong></h3>
<p class="noindentab">When a program reads passwords or other sensitive information, it should perform whatever processing is required, and then immediately erase the information from memory. (We show an example of this in <a href="ch08.xhtml#ch08lev1sec05">Section 8.5</a>.) Leaving such information in memory is a security risk, for the following reasons:</p>
<p class="bull">&#8226; The virtual memory page containing the data may be swapped out (unless it is locked in memory using <em>mlock()</em> or similar), and could then be read from the swap area by a privileged program.</p>
<p class="bull"><span epub:type="pagebreak" id="page_789"/>&#8226; If the process receives a signal that causes it to produce a core dump file, then that file may be read to obtain the information.</p>
<p class="noindenttb">Following on from the last point, as a general principle, a secure program should prevent core dumps, so that a core dump file can&#8217;t be inspected for sensitive information. A program can ensure that a core dump file is not created by using <em>setrlimit()</em> to set the <span class="literal">RLIMIT_CORE</span> resource limit to 0 (see <a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a>).</p>
<div class="block">
<p class="noindent">By default, Linux doesn&#8217;t permit a set-user-ID program to perform a core dump in response to a signal (<a href="ch22.xhtml#ch22lev1sec01">Section 22.1</a>), even if the program has dropped all privileges. However, other UNIX implementations may not provide this security feature.</p>
</div>
<h3 class="h3" id="ch38lev1sec05"><strong>38.5 Confine the Process</strong></h3>
<p class="noindenta">In this section, we consider ways in which we can confine a program to limit the damage that is done if the program is compromised.</p>
<h5 class="h5" id="ch38lev3sec07"><strong>Consider using capabilities</strong></h5>
<p class="noindenta">The Linux capabilities scheme divides the traditional all-or-nothing UNIX privilege scheme into distinct units called <em>capabilities</em>. A process can independently enable or disable individual capabilities. By enabling just those capabilities that it requires, a program operates with less privilege than it would have if run with full <em>root</em> privileges. This reduces the potential for damage if the program is compromised.</p>
<p class="indent">Furthermore, using capabilities and the <em>securebits</em> flags, we can create a process that has a limited set of capabilities but is not owned by <em>root</em> (i.e., all of its user IDs are nonzero). Such a process can no longer use <em>exec()</em> to regain a full set of capabilities. We describe capabilities and the <em>securebits</em> flags in <a href="ch39.xhtml#ch39">Chapter 39</a>.</p>
<h5 class="h5" id="ch38lev3sec08"><strong>Consider using a <em>chroot</em> jail</strong></h5>
<p class="noindenta">A useful security technique in certain cases is to establish a <em>chroot</em> jail to limit the set of directories and files that a program may access. (Make sure to also call <em>chdir()</em> to change the process&#8217;s current working directory to a location within the jail.) Note, however, that a <em>chroot</em> jail is insufficient to confine a set-user-ID-<em>root</em> program (see <a href="ch18.xhtml#ch18lev1sec12">Section 18.12</a>).</p>
<div class="block">
<p class="noindent">An alternative to using a <em>chroot</em> jail is a <em>virtual server</em>, which is a server implemented on top of a virtual kernel. Because each virtual kernel is isolated from other virtual kernels that may be running on the same hardware, a virtual server is more secure and flexible than a <em>chroot</em> jail. (Several other modern operating systems also provide their own implementations of virtual servers.) The oldest virtualization implementation on Linux is User-Mode Linux (UML), which is a standard part of the Linux 2.6 kernel. Further information about UML can be found at <em><a href="http://user-mode-linux.sourceforge.net/">http://user-mode-linux.sourceforge.net/</a></em>. More recent virtual kernel projects include Xen (<em><a href="http://www.cl.cam.ac.uk/Research/SRG/netos/xen/">http://www.cl.cam.ac.uk/Research/SRG/netos/xen/</a></em>) and KVM (<em><a href="http://kvm.qumranet.com/">http://kvm.qumranet.com/</a></em>).</p>
</div>
<h3 class="h3" id="ch38lev1sec06"><span epub:type="pagebreak" id="page_790"/><strong>38.6 Beware of Signals and Race Conditions</strong></h3>
<p class="noindenta">A user may send arbitrary signals to a set-user-ID program that they have started. Such signals may arrive at any time and with any frequency. We need to consider the race conditions that can occur if a signal is delivered at <em>any</em> point in the execution of the program. Where appropriate, signals should be caught, blocked, or ignored to prevent possible security problems. Furthermore, the design of signal handlers should be as simple as possible, in order to reduce the risk of inadvertently creating a race condition.</p>
<p class="indent">This issue is particularly relevant with the signals that stop a process (e.g., <span class="literal">SIGTSTP</span> and <span class="literal">SIGSTOP</span>). The problematic scenario is the following:</p>
<ol>
<li class="order"><p class="orderp">A set-user-ID program determines some information about its run-time environment.</p></li>
<li class="order"><p class="orderp">The user manages to stop the process running the program and change details of the run-time environment. Such changes may include modifying the permissions on a file, changing the target of a symbolic link, or removing a file that the program depends on.</p></li>
<li class="order"><p class="orderp">The user resumes the process with a <span class="literal">SIGCONT</span> signal. At this point, the program will continue execution based on now false assumptions about its run-time environment, and these assumptions may lead to a security breach.</p></li>
</ol>
<p class="noindent">The situation described here is really just a special case of a <em>time-of-check</em>, <em>time-of-use</em> race condition. A privileged process should avoid performing operations based on previous verifications that may no longer hold (refer to the discussion of the <em>access()</em> system call in <a href="ch15.xhtml#ch15lev2sec08">Section 15.4.4</a> for a specific example). This guideline applies even when the user can&#8217;t send signals to the process. The ability to stop a process simply allows a user to widen the interval between the time of the check and the time of use.</p>
<div class="block">
<p class="noindent">Although it may be difficult on a single attempt to stop a process between the time of check and time of use, a malicious user could execute a set-user-ID program repeatedly, and use another program or a shell script to repeatedly send stop signals to the set-user-ID program and change the run-time environment. This greatly improves the chances of subverting the set-user-ID program.</p>
</div>
<h3 class="h3" id="ch38lev1sec07"><strong>38.7 Pitfalls When Performing File Operations and File I/O</strong></h3>
<p class="noindentab">If a privileged process needs to create a file, then we must take care of that file&#8217;s ownership and permissions to ensure that there is never a point, no matter how brief, when the file is vulnerable to malicious manipulation. The following guidelines apply:</p>
<p class="bull">&#8226; The process umask (<a href="ch15.xhtml#ch15lev2sec10">Section 15.4.6</a>) should be set to a value that ensures that the process never creates publicly writable files, since these could be modified by a malicious user.</p>
<p class="bull">&#8226; Since the ownership of a file is taken from the effective user ID of the creating process, judicious use of <em>seteuid()</em> or <em>setreuid()</em> to temporarily change process credentials may be required in order ensure that a newly created file doesn&#8217;t belong to the wrong user. Since the group ownership of the file <em>may</em> be taken <span epub:type="pagebreak" id="page_791"/>from process&#8217;s effective group ID (see <a href="ch15.xhtml#ch15lev2sec03">Section 15.3.1</a>), a similar statement applies with respect to set-group-ID programs, and the corresponding group ID calls can be used to avoid such problems. (To be strictly accurate, on Linux, the owner of a new file is determined by the process&#8217;s file-system user ID, which normally has the same value as the process&#8217;s effective user ID; refer to <a href="ch09.xhtml#ch09lev1sec05">Section 9.5</a>.)</p>
<p class="bull">&#8226; If a set-user-ID-<em>root</em> program must create a file that initially it must own, but which will eventually be owned by another user, the file should be created so that it is initially not writable by other users, either by using a suitable <em>mode</em> argument to <em>open()</em> or by setting the process umask before calling <em>open()</em>. Afterward, the program can change its ownership with <em>fchown()</em>, and then change its permissions, if necessary, with <em>fchmod()</em>. The key point is that a set-user-ID program should ensure that it never creates a file that is owned by the program owner and that is even momentarily writable by other users.</p>
<p class="bull">&#8226; Checks on file attributes should be performed on open file descriptors (e.g., <em>open()</em> followed by <em>fstat()</em>), rather than by checking the attributes associated with a pathname and then opening the file (e.g., <em>stat()</em> followed by <em>open()</em>). The latter method creates a time-of-use, time-of-check problem.</p>
<p class="bull">&#8226; If a program must ensure that it is the creator of a file, then the <span class="literal">O_EXCL</span> flag should be used when calling <em>open()</em>.</p>
<p class="bull">&#8226; A privileged program should avoid creating or relying on files in publicly writable directories such as <span class="literal">/tmp</span>, since this leaves the program vulnerable to malicious attempts to create unauthorized files with names expected by the privileged program. A program that absolutely must create a file in a publicly writable directory should at least ensure that the file has an unpredictable name, by using a function such as <em>mkstemp()</em> (<a href="ch05.xhtml#ch05lev1sec12">Section 5.12</a>).</p>
<h3 class="h3" id="ch38lev1sec08"><strong>38.8 Don&#8217;t Trust Inputs or the Environment</strong></h3>
<p class="noindenta">Privileged programs should avoid making assumptions about the input they are given, or the environment in which they are running.</p>
<h5 class="h5" id="ch38lev3sec09"><strong>Don&#8217;t trust the environment list</strong></h5>
<p class="noindenta">Set-user-ID and set-group-ID programs should not assume that the values of environment variables are reliable. Two variables that are particularly relevant are <span class="literal">PATH</span> and <span class="literal">IFS</span>.</p>
<p class="indent"><span class="literal">PATH</span> determines where the shell (and thus <em>system()</em> and <em>popen()</em>), as well as <em>execlp()</em> and <em>execvp()</em>, search for programs. A malicious user can set <span class="literal">PATH</span> to a value that may trick a set-user-ID program employing one of these functions into executing an arbitrary program with privilege. If these functions are to be used, <span class="literal">PATH</span> should be set to a trustworthy list of directories (but better still, absolute pathnames should be specified when execing programs). However, as already noted, it is best to drop privileges before execing a shell or employing one of the aforementioned functions.</p>
<p class="indent"><span class="literal">IFS</span> specifies the delimiting characters that the shell interprets as separating the words of a command line. This variable should be set to an empty string, which <span epub:type="pagebreak" id="page_792"/>means that only white-space characters are interpreted by the shell as word separators. Some shells always set <span class="literal">IFS</span> in this way on startup. (<a href="ch27.xhtml#ch27lev1sec06">Section 27.6</a> describes one vulnerability relating to <span class="literal">IFS</span> that appeared in older Bourne shells.)</p>
<p class="indent">In some cases, it may be safest to erase the entire environment list (<a href="ch06.xhtml#ch06lev1sec07">Section 6.7</a>), and then restore selected environment variables with known-safe values, especially when executing other programs or calling libraries that may be affected by environment variable settings.</p>
<h5 class="h5" id="ch38lev3sec10"><strong>Handle untrusted user inputs defensively</strong></h5>
<p class="noindenta">A privileged program should carefully validate all inputs from untrusted sources before taking action based on those inputs. Such validation may include verifying that numbers fall within acceptable limits, and that strings are of an acceptable length and consist of acceptable characters. Among inputs that may need to be validated in this way are those coming from user-created files, command-line arguments, interactive inputs, CGI inputs, email messages, environment variables, interprocess communication channels (FIFOs, shared memory, and so on) accessible by untrusted users, and network packets.</p>
<h5 class="h5" id="ch38lev3sec11"><strong>Avoid unreliable assumptions about the process&#8217;s run-time environment</strong></h5>
<p class="noindenta">A set-user-ID program should avoid making unreliable assumptions about its initial run-time environment. For example, standard input, output, or error may have been closed. (These descriptors might have been closed in the program that execs the set-user-ID program.) In this case, opening a file could inadvertently reuse descriptor 1 (for example), so that, while the program thinks it is writing to standard output, it is actually writing to the file it opened.</p>
<p class="indent">There are many other possibilities to consider. For example, a process may exhaust various resource limits, such as the limit on the number of processes that may be created, the CPU time resource limit, or the file size resource limit, with the result that various system calls may fail or various signals may be generated. Malicious users may attempt to deliberately engineer resource exhaustion in an attempt to subvert a program.</p>
<h3 class="h3" id="ch38lev1sec09"><strong>38.9 Beware of Buffer Overruns</strong></h3>
<p class="noindenta">Beware of buffer overruns (overflows), where an input value or copied string exceeds the allocated buffer space. Never use <em>gets()</em>, and employ functions such as <em>scanf()</em>, <em>sprintf()</em>, <em>strcpy()</em>, and <em>strcat()</em> with caution (e.g., guarding their use with <span class="literal">if</span> statements that prevent buffer overruns).</p>
<p class="indent">Buffer overruns allow techniques such as <em>stack crashing</em> (also known as <em>stack smashing</em>), whereby a malicious user employs a buffer overrun to place carefully coded bytes into a stack frame in order to force the privileged program to execute arbitrary code. (Several online sources explain the details of stack crashing; see also [<a href="bib.xhtml#bib24">Erickson, 2008</a>] and [<a href="bib.xhtml#bib03">Anley, 2007</a>].) Buffer overruns are probably the single most common source of security breaches on computer systems, as evidenced by the frequency of advisories posted by CERT (<em><a href="http://www.cert.org/">http://www.cert.org/</a></em>) and to Bugtraq (<em><a href="http://www.securityfocus.com/">http://www.securityfocus.com/</a></em>). Buffer overruns are particularly dangerous in network servers, since they leave a system open to remote attack from anywhere on a network.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_793"/>In order to make stack crashing more difficult&#8212;in particular, to make such attacks much more time-consuming when conducted remotely against network servers&#8212;from kernel 2.6.12 onward, Linux implements <em>address-space randomization</em>. This technique randomly varies the location of the stack over an 8 MB range at the top of virtual memory. In addition, the locations of memory mappings may also be randomized, if the soft <span class="literal">RLIMIT_STACK</span> limit is not infinite and the Linux-specific <span class="literal">/proc/sys/vm/legacy_va_layout</span> file contains the value 0.</p>
<p class="indent">More recent x86-32 architectures provide hardware support for marking page tables as <em>NX</em> (&#8220;no execute&#8221;). This feature is used to prevent execution of program code on the stack, thus making stack crashing more difficult.</p>
</div>
<p class="noindentb">There are safe alternatives to many of the functions mentioned above&#8212;for example, <em>snprintf()</em>, <em>strncpy()</em>, and <em>strncat()</em>&#8212;that allow the caller to specify the maximum number of characters that should be copied. These functions take the specified maximum into account in order to avoid overrunning the target buffer. In general, these alternatives are preferable, but must still be handled with care. In particular, note the following points:</p>
<p class="bull">&#8226; With most of these functions, if the specified maximum is reached, then a truncated version of the source string is placed in the target buffer. Since such a truncated string may be meaningless in terms of the semantics of the program, the caller must check if truncation occurred (e.g., using the return value from <em>snprintf()</em>), and take appropriate action if it has.</p>
<p class="bull">&#8226; Using <em>strncpy()</em> can carry a performance impact. If, in the call <em>strncpy(s1, s2, n)</em>, the string pointed to by <em>s2</em> is less than <em>n</em> bytes in length, then padding null bytes are written to <em>s1</em> to ensure that <em>n</em> bytes in total are written.</p>
<p class="bull">&#8226; If the maximum size value given to <em>strncpy()</em> is not long enough to permit the inclusion of the terminating null character, then the target string is <em>not</em> null-terminated.</p>
<div class="block">
<p class="noindent">Some UNIX implementations provide the <em>strlcpy()</em> function, which, given a length argument <em>n</em>, copies at most <em>n &#8211; 1</em> bytes to the destination buffer and always appends a null character at the end of the buffer. However, this function is not specified in SUSv3 and is not implemented in <em>glibc</em>. Furthermore, in cases where the caller is not carefully checking string lengths, this function only substitutes one problem (buffer overflows) for another (silently discarding data).</p>
</div>
<h3 class="h3" id="ch38lev1sec10"><strong>38.10 Beware of Denial-of-Service Attacks</strong></h3>
<p class="noindenta">With the increase in Internet-based services has come a corresponding increase in the opportunities for remote denial-of-service attacks. These attacks attempt to make a service unavailable to legitimate clients, either by sending the server malformed data that causes it to crash or by overloading it with bogus requests.</p>
<div class="block">
<p class="noindent">Local denial-of-service attacks are also possible. The most well-known example is when a user runs a simple fork bomb (a program that repeatedly forks, thus consuming all of the process slots on the system). However, the origin of local denial-of-service attacks is much easier to determine, and they can generally be prevented by suitable physical and password security measures.</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_794"/>Dealing with malformed requests is straightforward&#8212;a server should be programmed to rigorously check its inputs and avoid buffer overruns, as described above.</p>
<p class="indentb">Overload attacks are more difficult to deal with. Since the server can&#8217;t control the behavior of remote clients or the rate at which they submit requests, such attacks are impossible to prevent. (The server may not even be able to determine the true origin of the attack, since the source IP address of a network packet can be spoofed. Alternatively, distributed attacks may enlist unwitting intermediary hosts to direct an attack at a target system.) Nevertheless, various measures can be taken to minimize the risk and consequences of an overload attack:</p>
<p class="bull">&#8226; The server should perform load throttling, dropping requests when the load exceeds some predetermined limit. This will have the consequence of dropping legitimate requests, but prevents the server and host machine from becoming overloaded. The use of resource limits and disk quotas may also be helpful in limiting excessive loads. (Refer to <em><a href="http://sourceforge.net/projects/linuxquota/">http://sourceforge.net/projects/linuxquota/</a></em> for more information on disk quotas.)</p>
<p class="bull">&#8226; A server should employ timeouts for communication with a client, so that if the client (perhaps deliberately) doesn&#8217;t respond, the server is not tied up indefinitely waiting on the client.</p>
<p class="bull">&#8226; In the event of an overload, the server should log suitable messages so that the system administrator is notified of the problem. (However, logging should be throttled, so that logging itself does not overload the system.)</p>
<p class="bull">&#8226; The server should be programmed so that it doesn&#8217;t crash in the face of an unexpected load. For example, bounds checking should be rigorously performed to ensure that excessive requests don&#8217;t overflow a data structure.</p>
<p class="bull">&#8226; Data structures should be designed to avoid <em>algorithmic-complexity attacks</em>. For example, a binary tree may be balanced and deliver acceptable performance under typical loads. However, an attacker could construct a sequence of inputs that result in an unbalanced tree (the equivalent of a linked list in the worst case), which could cripple performance. [<a href="bib.xhtml#bib17">Crosby &#38; Wallach, 2003</a>] details the nature of such attacks and discusses data-structuring techniques that can be used to avoid them.</p>
<h3 class="h3" id="ch38lev1sec11"><strong>38.11 Check Return Statuses and Fail Safely</strong></h3>
<p class="noindenta">A privileged program should always check to see whether system calls and library functions succeed, and whether they return expected values. (This is true for all programs, of course, but is especially important for privileged programs.) Various system calls can fail, even for a program running as <em>root</em>. For example, <em>fork()</em> may fail if the system-wide limit on the number of processes is encountered, an <em>open()</em> for writing may fail on a read-only file system, or <em>chdir()</em> may fail if the target directory doesn&#8217;t exist.</p>
<p class="indent"><span epub:type="pagebreak" id="page_795"/>Even where a system call succeeds, it may be necessary to check its result. For example, where it matters, a privileged program should check that a successful <em>open()</em> has not returned one of the three standard file descriptors: 0, 1, or 2.</p>
<p class="indent">Finally, if a privileged program encounters an unexpected situation, then the appropriate behavior is usually either to terminate or, in the case of a server, to drop the client request. Attempting to fix unexpected problems typically requires making assumptions that may not be justified in all circumstances and may lead to the creation of security loopholes. In such situations, it is safer to have the program terminate, or to have the server log a message and discard the client&#8217;s request.</p>
<h3 class="h3" id="ch38lev1sec12"><strong>38.12 Summary</strong></h3>
<p class="noindenta">Privileged programs have access to system resources that are not available to ordinary users. If such programs can be subverted, then the security of the system can be compromised. In this chapter, we presented a set of guidelines for writing privileged programs. The aim of these guidelines is twofold: to minimize the chances of a privileged program being subverted, and to minimize the damage that can be done in the event that a privileged program is subverted.</p>
<h5 class="h5" id="ch38lev3sec12"><strong>Further information</strong></h5>
<p class="noindenta">[<a href="bib.xhtml#bib107">Viega &#38; McGraw, 2002</a>] covers a broad range of topics relating to the design and implementation of secure software. General information about security on UNIX systems, as well as a chapter on secure-programming techniques can be found in [<a href="bib.xhtml#bib31">Garfinkel et al., 2003</a>]. Computer security is covered at some length in [<a href="bib.xhtml#bib07">Bishop, 2005</a>], and at even greater length by the same author in [<a href="bib.xhtml#bib06">Bishop, 2003</a>]. [<a href="bib.xhtml#bib73">Peikari &#38; Chuvakin, 2004</a>] describes computer security with a focus on the various means by which system may be attacked. [<a href="bib.xhtml#bib24">Erickson, 2008</a>] and [<a href="bib.xhtml#bib03">Anley, 2007</a>] both provide a thorough discussion of various security exploits, providing enough detail for wise programmers to avoid these exploits. [<a href="bib.xhtml#bib11">Chen et al., 2002</a>] is a paper describing and analyzing the UNIX set-user-ID model. [<a href="bib.xhtml#bib103">Tsafrir et al., 2008</a>] revises and enhances the discussion of various points in [<a href="bib.xhtml#bib11">Chen et al., 2002</a>]. [<a href="bib.xhtml#bib23">Drepper, 2009</a>] provides a wealth of tips on secure and defensive programming on Linux.</p>
<p class="indentb">Several sources of information about writing secure programs are available online, including the following:</p>
<p class="bull">&#8226; Matt Bishop has written a range of security-related papers, which are available online at <em><a href="http://nob.cs.ucdavis.edu/~bishop/secprog">http://nob.cs.ucdavis.edu/~bishop/secprog</a></em>. The most interesting of these is &#8220;How to Write a Setuid Program,&#8221; (originally published in <em>;login: 12(1) Jan/Feb 1986</em>). Although somewhat dated, this paper contains a wealth of useful tips.</p>
<p class="bull">&#8226; The <em>Secure Programming for Linux and Unix HOWTO</em>, written by David Wheeler, is available at <em><a href="http://www.dwheeler.com/secure-programs/">http://www.dwheeler.com/secure-programs/</a></em>.</p>
<p class="bull">&#8226; A useful checklist for writing set-user-ID programs is available online at <em><a href="http://www.homeport.org/~adam/setuid.7.html">http://www.homeport.org/~adam/setuid.7.html</a></em>.</p>
<h3 class="h3" id="ch38lev1sec13"><span epub:type="pagebreak" id="page_796"/><strong>38.13 Exercises</strong></h3>
<p class="exer"><a id="ch38exe1"/><strong>38-1.</strong>&#160;&#160;&#160;Log in as a normal, unprivileged user, create an executable file (or copy an existing file such as <span class="literal">/bin/sleep</span>), and enable the set-user-ID permission bit on that file (<em>chmod u+s</em>). Try modifying the file (e.g., <em>cat &gt;&gt; file</em>). What happens to the file permissions as a result (<em>ls &#8211;l</em>)? Why does this happen?</p>
<p class="exer"><a id="ch38exe2"/><strong>38-2.</strong>&#160;&#160;&#160;Write a set-user-ID-<em>root</em> program similar to the <em>sudo(8)</em> program. This program should take command-line options and arguments as follows:</p>
<p class="programs1">$ <span class="codestrong">./douser [-u <span class="codeitalic">user</span> ] <span class="codeitalic">program-file arg1</span> <span class="codeitalic">arg2</span> ...</span></p>
<p class="exerp">The <em>douser</em> program executes <em>program-file</em>, with the given arguments, as though it was run by <em>user</em>. (If the <em>&#8211;u</em> option is omitted, then <em>user</em> should default to <em>root</em>.) Before executing <em>program-file</em>, <em>douser</em> should request the password for <em>user</em>, authenticate it against the standard password file (see <a href="ch08.xhtml#ch8ex2">Listing 8-2</a>, on <a href="ch08.xhtml#page_164">page 164</a>), and then set all of the process user and group IDs to the correct values for that user.</p>
</body>
</html>
