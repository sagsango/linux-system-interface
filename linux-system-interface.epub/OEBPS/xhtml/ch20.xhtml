<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch20"><span epub:type="pagebreak" id="page_387"/><strong><span class="big">20</span></strong><br/><strong>SIGNALS: FUNDAMENTAL CONCEPTS</strong></h2>
<p class="noindenta">This chapter and the next two chapters discuss signals. Although the fundamental concepts are simple, our discussion is quite lengthy, since there are many details to cover.</p>
<p class="indentb">This chapter covers the following topics:</p>
<p class="bull">&#8226; the various different signals and their purposes;</p>
<p class="bull">&#8226; the circumstances in which the kernel may generate a signal for a process, and the system calls that one process may use to send a signal to another process;</p>
<p class="bull">&#8226; how a process responds to a signal by default, and the means by which a process can change its response to a signal, in particular, through the use of a signal handler, a programmer-defined function that is automatically invoked on receipt of a signal;</p>
<p class="bull">&#8226; the use of the process signal mask to block signals, and the associated notion of pending signals; and</p>
<p class="bull">&#8226; how a process can suspend execution and wait for the delivery of a signal.</p>
<h3 class="h3" id="ch20lev1sec01"><span epub:type="pagebreak" id="page_388"/><strong>20.1 Concepts and Overview</strong></h3>
<p class="noindenta">A <em>signal</em> is a notification to a process that an event has occurred. Signals are sometimes described as <em>software interrupts</em>. Signals are analogous to hardware interrupts in that they interrupt the normal flow of execution of a program; in most cases, it is not possible to predict exactly when a signal will arrive.</p>
<p class="indentb">One process can (if it has suitable permissions) send a signal to another process. In this use, signals can be employed as a synchronization technique, or even as a primitive form of interprocess communication (IPC). It is also possible for a process to send a signal to itself. However, the usual source of many signals sent to a process is the kernel. Among the types of events that cause the kernel to generate a signal for a process are the following:</p>
<p class="bull">&#8226; A hardware exception occurred, meaning that the hardware detected a fault condition that was notified to the kernel, which in turn sent a corresponding signal to the process concerned. Examples of hardware exceptions include executing a malformed machine-language instruction, dividing by 0, or referencing a part of memory that is inaccessible.</p>
<p class="bull">&#8226; The user typed one of the terminal special characters that generate signals. These characters include the <em>interrupt</em> character (usually <em>Control-C</em>) and the <em>suspend</em> character (usually <em>Control-Z</em>).</p>
<p class="bull">&#8226; A software event occurred. For example, input became available on a file descriptor, the terminal window was resized, a timer went off, the process&#8217;s CPU time limit was exceeded, or a child of this process terminated.</p>
<p class="noindentt">Each signal is defined as a unique (small) integer, starting sequentially from 1. These integers are defined in <span class="literal">&lt;signal.h&gt;</span> with symbolic names of the form <span class="literal">SIGxxxx</span>. Since the actual numbers used for each signal vary across implementations, it is these symbolic names that are always used in programs. For example, when the user types the <em>interrupt</em> character, <span class="literal">SIGINT</span> (signal number 2) is delivered to a process.</p>
<p class="indent">Signals fall into two broad categories. The first set constitutes the <em>traditional</em> or <em>standard</em> signals, which are used by the kernel to notify processes of events. On Linux, the standard signals are numbered from 1 to 31. We describe the standard signals in this chapter. The other set of signals consists of the <em>realtime</em> signals, whose differences from standard signals are described in <a href="ch22.xhtml#ch22lev1sec08">Section 22.8</a>.</p>
<p class="indent">A signal is said to be <em>generated</em> by some event. Once generated, a signal is later <em>delivered</em> to a process, which then takes some action in response to the signal. Between the time it is generated and the time it is delivered, a signal is said to be <em>pending</em>.</p>
<p class="indent">Normally, a pending signal is delivered to a process as soon as it is next scheduled to run, or immediately if the process is already running (e.g., if the process sent a signal to itself). Sometimes, however, we need to ensure that a segment of code is not interrupted by the delivery of a signal. To do this, we can add a signal to the process&#8217;s <em>signal mask</em>&#8212;a set of signals whose delivery is currently <em>blocked</em>. If a signal is generated while it is blocked, it remains pending until it is later unblocked (removed from the signal mask). Various system calls allow a process to add and remove signals from its signal mask.</p>
<p class="indentb"><span epub:type="pagebreak" id="page_389"/>Upon delivery of a signal, a process carries out one of the following default actions, depending on the signal:</p>
<p class="bull">&#8226; The signal is <em>ignored</em>; that is, it is discarded by the kernel and has no effect on the process. (The process never even knows that it occurred.)</p>
<p class="bull">&#8226; The process is <em>terminated</em> (killed). This is sometimes referred to as <em>abnormal process termination</em>, as opposed to the normal process termination that occurs when a process terminates using <em>exit()</em>.</p>
<p class="bull">&#8226; A <em>core dump file</em> is generated, and the process is terminated. A core dump file contains an image of the virtual memory of the process, which can be loaded into a debugger in order to inspect the state of the process at the time that it terminated.</p>
<p class="bull">&#8226; The process is <em>stopped</em>&#8212;execution of the process is suspended.</p>
<p class="bull">&#8226; Execution of the process is <em>resumed</em> after previously being stopped.</p>
<p class="noindenttb">Instead of accepting the default for a particular signal, a program can change the action that occurs when the signal is delivered. This is known as setting the <em>disposition</em> of the signal. A program can set one of the following dispositions for a signal:</p>
<p class="bull">&#8226; The <em>default action</em> should occur. This is useful to undo an earlier change of the disposition of the signal to something other than its default.</p>
<p class="bull">&#8226; The signal is <em>ignored</em>. This is useful for a signal whose default action would be to terminate the process.</p>
<p class="bull">&#8226; A <em>signal handler</em> is executed.</p>
<p class="noindentt">A signal handler is a function, written by the programmer, that performs appropriate tasks in response to the delivery of a signal. For example, the shell has a handler for the <span class="literal">SIGINT</span> signal (generated by the <em>interrupt</em> character, <em>Control-C</em>) that causes it to stop what it is currently doing and return control to the main input loop, so that the user is once more presented with the shell prompt. Notifying the kernel that a handler function should be invoked is usually referred to as <em>installing</em> or <em>establishing</em> a signal handler. When a signal handler is invoked in response to the delivery of a signal, we say that the signal has been <em>handled</em> or, synonymously, <em>caught</em>.</p>
<p class="indent">Note that it isn&#8217;t possible to set the disposition of a signal to <em>terminate</em> or <em>dump core</em> (unless one of these is the default disposition of the signal). The nearest we can get to this is to install a handler for the signal that then calls either <em>exit()</em> or <em>abort()</em>. The <em>abort()</em> function (<a href="ch21.xhtml#ch21lev2sec05">Section 21.2.2</a>) generates a <span class="literal">SIGABRT</span> signal for the process, which causes it to dump core and terminate.</p>
<div class="block">
<p class="noindent">The Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/status</span> file contains various bit-mask fields that can be inspected to determine a process&#8217;s treatment of signals. The bit masks are displayed as hexadecimal numbers, with the least significant bit representing signal 1, the next bit to the left representing signal 2, and so on. These fields are <em>SigPnd</em> (per-thread pending signals), <em>ShdPnd</em> (process-wide pending signals; since Linux 2.6), <em>SigBlk</em> (blocked signals), <em>SigIgn</em> (ignored signals), and <em>SigCgt</em> (caught signals). (The difference between the <em>SigPnd</em> and <em>ShdPnd</em> fields will become clear when we describe the handling of signals in multithreaded processes in <a href="ch33.xhtml#ch33lev1sec02">Section 33.2</a>.) The same information can also be obtained using various options to the <em>ps(1)</em> command.</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_390"/>Signals appeared in very early UNIX implementations, but have gone through some significant changes since their inception. In early implementations, signals could be lost (i.e., not delivered to the target process) in certain circumstances. Furthermore, although facilities were provided to block delivery of signals while critical code was executed, in some circumstances, blocking was not reliable. These problems were remedied in 4.2BSD, which provided so-called <em>reliable signals</em>. (One further BSD innovation was the addition of extra signals to support shell job control, which we describe in <a href="ch34.xhtml#ch34lev1sec07">Section 34.7</a>.)</p>
<p class="indent">System V also added reliable semantics to signals, but employed a model incompatible with BSD. These incompatibilities were resolved only with the arrival of the POSIX.1-1990 standard, which adopted a specification for reliable signals largely based on the BSD model.</p>
<p class="indent">We consider the details of reliable and unreliable signals in <a href="ch22.xhtml#ch22lev1sec07">Section 22.7</a>, and briefly describe the older BSD and System V signal APIs in <a href="ch22.xhtml#ch22lev1sec13">Section 22.13</a>.</p>
<h3 class="h3" id="ch20lev1sec02"><strong>20.2 Signal Types and Default Actions</strong></h3>
<p class="noindentab">Earlier, we mentioned that the standard signals are numbered from 1 to 31 on Linux. However, the Linux <em>signal(7)</em> manual page lists more than 31 signal names. The excess names can be accounted for in a variety of ways. Some of the names are simply synonyms for other names, and are defined for source compatibility with other UNIX implementations. Other names are defined but unused. The following list describes the various signals:</p>
<p class="term"><span class="literal">SIGABRT</span></p>
<p class="termlist">A process is sent this signal when it calls the <em>abort()</em> function (<a href="ch21.xhtml#ch21lev2sec05">Section 21.2.2</a>). By default, this signal terminates the process with a core dump. This achieves the intended purpose of the <em>abort()</em> call: to produce a core dump for debugging.</p>
<p class="term"><span class="literal">SIGALRM</span></p>
<p class="termlist">The kernel generates this signal upon the expiration of a real-time timer set by a call to <em>alarm()</em> or <em>setitimer()</em>. A real-time timer is one that counts according to wall clock time (i.e., the human notion of elapsed time). For further details, see <a href="ch23.xhtml#ch23lev1sec01">Section 23.1</a>.</p>
<p class="term"><span class="literal">SIGBUS</span></p>
<p class="termlist">This signal (&#8220;bus error&#8221;) is generated to indicate certain kinds of memory-access errors. One such error can occur when using memory mappings created with <em>mmap()</em>, if we attempt to access an address that lies beyond the end of the underlying memory-mapped file, as described in <a href="ch49.xhtml#ch49lev2sec03">Section 49.4.3</a>.</p>
<p class="term"><span class="literal">SIGCHLD</span></p>
<p class="termlist">This signal is sent (by the kernel) to a parent process when one of its children terminates (either by calling <em>exit()</em> or as a result of being killed by a signal). It may also be sent to a process when one of its children is stopped or resumed by a signal. We consider <span class="literal">SIGCHLD</span> in detail in <a href="ch26.xhtml#ch26lev1sec03">Section 26.3</a>.</p>
<p class="term"><span epub:type="pagebreak" id="page_391"/><span class="literal">SIGCLD</span></p>
<p class="termlist">This is a synonym for <span class="literal">SIGCHLD</span>.</p>
<p class="term"><span class="literal">SIGCONT</span></p>
<p class="termlist">When sent to a stopped process, this signal causes the process to resume (i.e., to be rescheduled to run at some later time). When received by a process that is not currently stopped, this signal is ignored by default. A process may catch this signal, so that it carries out some action when it resumes. This signal is covered in more detail in <a href="ch22.xhtml#ch22lev1sec02">Sections 22.2</a> and <a href="ch34.xhtml#ch34lev1sec07">34.7</a>.</p>
<p class="term"><span class="literal">SIGEMT</span></p>
<p class="termlist">In UNIX systems generally, this signal is used to indicate an implementation-dependent hardware error. On Linux, this signal is used only in the Sun SPARC implementation. The suffix <span class="literal">EMT</span> derives from <em>emulator trap</em>, an assembler mnemonic on the Digital PDP-11.</p>
<p class="term"><span class="literal">SIGFPE</span></p>
<p class="termlist">This signal is generated for certain types of arithmetic errors, such as divide-by-zero. The suffix <span class="literal">FPE</span> is an abbreviation for <em>floating-point exception</em>, although this signal can also be generated for integer arithmetic errors. The precise details of when this signal is generated depend on the hardware architecture and the settings of CPU control registers. For example, on x86-32, integer divide-by-zero always yields a <span class="literal">SIGFPE</span>, but the handling of floating-point divide-by-zero depends on whether the <span class="literal">FE_DIVBYZERO</span> exception has been enabled. If this exception is enabled (using <em>feenableexcept()</em>), then a floating-point divide-by-zero generates <span class="literal">SIGFPE</span>; otherwise, it yields the IEEE-standard result for the operands (a floating-point representation of infinity). See the <em>fenv(3)</em> manual page and <span class="literal">&lt;fenv.h&gt;</span> for further information.</p>
<p class="term"><span class="literal">SIGHUP</span></p>
<p class="termlist">When a terminal disconnect (hangup) occurs, this signal is sent to the controlling process of the terminal. We describe the concept of a controlling process and the various circumstances in which <span class="literal">SIGHUP</span> is sent in <a href="ch34.xhtml#ch34lev1sec06">Section 34.6</a>. A second use of <span class="literal">SIGHUP</span> is with daemons (e.g., <em>init</em>, <em>httpd</em>, and <em>inetd</em>). Many daemons are designed to respond to the receipt of <span class="literal">SIGHUP</span> by reinitializing themselves and rereading their configuration files. The system administrator triggers these actions by manually sending <span class="literal">SIGHUP</span> to the daemon, either by using an explicit <em>kill</em> command or by executing a program or script that does the same.</p>
<p class="term"><span class="literal">SIGILL</span></p>
<p class="termlist">This signal is sent to a process if it tries to execute an illegal (i.e., incorrectly formed) machine-language instruction.</p>
<p class="term"><span class="literal">SIGINFO</span></p>
<p class="termlist">On Linux, this signal name is a synonym for <span class="literal">SIGPWR</span>. On BSD systems, the <span class="literal">SIGINFO</span> signal, generated by typing <em>Control-T</em>, is used to obtain status information about the foreground process group.</p>
<p class="term"><span epub:type="pagebreak" id="page_392"/><span class="literal">SIGINT</span></p>
<p class="termlist">When the user types the terminal <em>interrupt</em> character (usually <em>Control-C</em>), the terminal driver sends this signal to the foreground process group. The default action for this signal is to terminate the process.</p>
<p class="term"><span class="literal">SIGIO</span></p>
<p class="termlist">Using the <em>fcntl()</em> system call, it is possible to arrange for this signal to be generated when an I/O event (e.g., input becoming available) occurs on certain types of open file descriptors, such as those for terminals and sockets. This feature is described further in <a href="ch63.xhtml#ch63lev1sec03">Section 63.3</a>.</p>
<p class="term"><span class="literal">SIGIOT</span></p>
<p class="termlist">On Linux, this is a synonym for <span class="literal">SIGABRT</span>. On some other UNIX implementations, this signal indicates an implementation-defined hardware fault.</p>
<p class="term"><span class="literal">SIGKILL</span></p>
<p class="termlist">This is the <em>sure kill</em> signal. It can&#8217;t be blocked, ignored, or caught by a handler, and thus always terminates a process.</p>
<p class="term"><span class="literal">SIGLOST</span></p>
<p class="termlist">This signal name exists on Linux, but is unused. On some other UNIX implementations, the NFS client sends this signal to local processes holding locks if the NFS client fails to regain locks held by those processes following the recovery of a remote NFS server that crashed. (This feature is not standardized in NFS specifications.)</p>
<p class="term"><span class="literal">SIGPIPE</span></p>
<p class="termlist">This signal is generated when a process tries to write to a pipe, a FIFO, or a socket for which there is no corresponding reader process. This normally occurs because the reading process has closed its file descriptor for the IPC channel. See <a href="ch44.xhtml#ch44lev1sec02">Section 44.2</a> for further details.</p>
<p class="term"><span class="literal">SIGPOLL</span></p>
<p class="termlist">This signal, which is derived from System V, is a synonym for <span class="literal">SIGIO</span> on Linux.</p>
<p class="term"><span class="literal">SIGPROF</span></p>
<p class="termlist">The kernel generates this signal upon the expiration of a profiling timer set by a call to <em>setitimer()</em> (<a href="ch23.xhtml#ch23lev1sec01">Section 23.1</a>). A profiling timer is one that counts the CPU time used by a process. Unlike a virtual timer (see <span class="literal">SIGVTALRM</span> below), a profiling timer counts CPU time used in both user mode and kernel mode.</p>
<p class="term"><span class="literal">SIGPWR</span></p>
<p class="termlist">This is the <em>power failure</em> signal. On systems that have an uninterruptible power supply (UPS), it is possible to set up a daemon process that monitors the backup battery level in the event of a power failure. If the battery power is about to run out (after an extended power outage), then the monitoring process sends <span class="literal">SIGPWR</span> to the <em>init</em> process, which interprets this signal as a request to shut down the system in a quick and orderly fashion.</p>
<p class="term"><span epub:type="pagebreak" id="page_393"/><span class="literal">SIGQUIT</span></p>
<p class="termlist">When the user types the <em>quit</em> character (usually <em>Control-\</em>) on the keyboard, this signal is sent to the foreground process group. By default, this signal terminates a process and causes it to produce a core dump, which can then be used for debugging. Using <span class="literal">SIGQUIT</span> in this manner is useful with a program that is stuck in an infinite loop or is otherwise not responding. By typing <em>Control-\</em> and then loading the resulting core dump with the <em>gdb</em> debugger and using the <em>backtrace</em> command to obtain a stack trace, we can find out which part of the program code was executing. ([<a href="bib.xhtml#bib62">Matloff, 2008</a>] describes the use of <em>gdb</em>.)</p>
<p class="term"><span class="literal">SIGSEGV</span></p>
<p class="termlist">This very popular signal is generated when a program makes an invalid memory reference. A memory reference may be invalid because the referenced page doesn&#8217;t exist (e.g., it lies in an unmapped area somewhere between the heap and the stack), the process tried to update a location in read-only memory (e.g., the program text segment or a region of mapped memory marked read-only), or the process tried to access a part of kernel memory while running in user mode (<a href="ch02.xhtml#ch02lev1sec01">Section 2.1</a>). In C, these events often result from dereferencing a pointer containing a bad address (e.g., an uninitialized pointer) or passing an invalid argument in a function call. The name of this signal derives from the term <em>segmentation violation</em>.</p>
<p class="term"><span class="literal">SIGSTKFLT</span></p>
<p class="termlist">Documented in <em>signal(7)</em> as &#8220;stack fault on coprocessor,&#8221; this signal is defined, but is unused on Linux.</p>
<p class="term"><span class="literal">SIGSTOP</span></p>
<p class="termlist">This is the <em>sure stop</em> signal. It can&#8217;t be blocked, ignored, or caught by a handler; thus, it always stops a process.</p>
<p class="term"><span class="literal">SIGSYS</span></p>
<p class="termlist">This signal is generated if a process makes a &#8220;bad&#8221; system call. This means that the process executed an instruction that was interpreted as a system call trap, but the associated system call number was not valid (refer to <a href="ch03.xhtml#ch03lev1sec01">Section 3.1</a>).</p>
<p class="term"><span class="literal">SIGTERM</span></p>
<p class="termlist">This is the standard signal used for terminating a process and is the default signal sent by the <em>kill</em> and <em>killall</em> commands. Users sometimes explicitly send the <span class="literal">SIGKILL</span> signal to a process using <em>kill &#8211;KILL</em> or <em>kill &#8211;9</em>. However, this is generally a mistake. A well-designed application will have a handler for <span class="literal">SIGTERM</span> that causes the application to exit gracefully, cleaning up temporary files and releasing other resources beforehand. Killing a process with <span class="literal">SIGKILL</span> bypasses the <span class="literal">SIGTERM</span> handler. Thus, we should always first attempt to terminate a process using <span class="literal">SIGTERM</span>, and reserve <span class="literal">SIGKILL</span> as a last resort for killing runaway processes that don&#8217;t respond to <span class="literal">SIGTERM</span>.</p>
<p class="term"><span epub:type="pagebreak" id="page_394"/><span class="literal">SIGTRAP</span></p>
<p class="termlist">This signal is used to implement debugger breakpoints and system call tracing, as performed by <em>strace(1)</em> (<a href="app01.xhtml#app01">Appendix A</a>). See the <em>ptrace(2)</em> manual page for further information.</p>
<p class="term"><span class="literal">SIGTSTP</span></p>
<p class="termlist">This is the job-control <em>stop</em> signal, sent to stop the foreground process group when the user types the <em>suspend</em> character (usually <em>Control-Z</em>) on the keyboard. <a href="ch34.xhtml#ch34">Chapter 34</a> describes process groups (jobs) and job control in detail, as well as details of when and how a program may need to handle this signal. The name of this signal derives from &#8220;terminal stop.&#8221;</p>
<p class="term"><span class="literal">SIGTTIN</span></p>
<p class="termlist">When running under a job-control shell, the terminal driver sends this signal to a background process group when it attempts to <em>read()</em> from the terminal. This signal stops a process by default.</p>
<p class="term"><span class="literal">SIGTTOU</span></p>
<p class="termlist">This signal serves an analogous purpose to <span class="literal">SIGTTIN</span>, but for terminal output by background jobs. When running under a job-control shell, if the <span class="literal">TOSTOP</span> (<em>terminal output stop</em>) option has been enabled for the terminal (perhaps via the command <em>stty tostop</em>), the terminal driver sends <span class="literal">SIGTTOU</span> to a background process group when it attempts to <em>write()</em> to the terminal (see <a href="ch34.xhtml#ch34lev2sec03">Section 34.7.1</a>). This signal stops a process by default.</p>
<p class="term"><span class="literal">SIGUNUSED</span></p>
<p class="termlist">As the name implies, this signal is unused. On Linux 2.4 and later, this signal name is synonymous with <span class="literal">SIGSYS</span> on many architectures. In other words, this signal number is no longer unused on those architectures, although the signal name remains for backward compatibility.</p>
<p class="term"><span class="literal">SIGURG</span></p>
<p class="termlist">This signal is sent to a process to indicate the presence of <em>out-of-band</em> (also known as <em>urgent</em>) data on a socket (<a href="ch61.xhtml#ch61lev2sec08">Section 61.13.1</a>).</p>
<p class="term"><span class="literal">SIGUSR1</span></p>
<p class="termlist">This signal and <span class="literal">SIGUSR2</span> are available for programmer-defined purposes. The kernel never generates these signals for a process. Processes may use these signals to notify one another of events or to synchronize with each other. In early UNIX implementations, these were the only two signals that could be freely used in applications. (In fact, processes can send one another any signal, but this has the potential for confusion if the kernel also generates one of the signals for a process.) Modern UNIX implementations provide a large set of realtime signals that are also available for programmer-defined purposes (<a href="ch22.xhtml#ch22lev1sec08">Section 22.8</a>).</p>
<p class="term"><span epub:type="pagebreak" id="page_395"/><span class="literal">SIGUSR2</span></p>
<p class="termlist">See the description of <span class="literal">SIGUSR1</span>.</p>
<p class="term"><span class="literal">SIGVTALRM</span></p>
<p class="termlist">The kernel generates this signal upon expiration of a virtual timer set by a call to <em>setitimer()</em> (<a href="ch23.xhtml#ch23lev1sec01">Section 23.1</a>). A virtual timer is one that counts the user-mode CPU time used by a process.</p>
<p class="term"><span class="literal">SIGWINCH</span></p>
<p class="termlist">In a windowing environment, this signal is sent to the foreground process group when the terminal window size changes (as a consequence either of the user manually resizing it, or of a program resizing it via a call to <em>ioctl()</em>, as described in <a href="ch62.xhtml#ch62lev1sec09">Section 62.9</a>). By installing a handler for this signal, programs such as <em>vi</em> and <em>less</em> can know to redraw their output after a change in window size.</p>
<p class="term"><span class="literal">SIGXCPU</span></p>
<p class="termlist">This signal is sent to a process when it exceeds its CPU time resource limit (<span class="literal">RLIMIT_CPU</span>, described in <a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a>).</p>
<p class="term"><span class="literal">SIGXFSZ</span></p>
<p class="termlist">This signal is sent to a process if it attempts (using <em>write()</em> or <em>truncate()</em>) to increase the size of a file beyond the process&#8217;s file size resource limit (<span class="literal">RLIMIT_FSIZE</span>, described in <a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a>).</p>
<p class="noindenttb"><a href="ch20.xhtml#ch20table1">Table 20-1</a> summarizes a range of information about signals on Linux. Note the following points about this table:</p>
<p class="bull">&#8226; The <em>signal number</em> column shows the number assigned to this signal on various hardware architectures. Except where otherwise indicated, signals have the same number on all architectures. Architectural differences in signal numbers are indicated in parentheses, and occur on the Sun SPARC and SPARC64 (S), HP/Compaq/Digital Alpha (A), MIPS (M), and HP PA-RISC (P) architectures. In this column, <em>undef</em> indicates that a symbol is undefined on the indicated architectures.</p>
<p class="bull">&#8226; The <em>SUSv3</em> column indicates whether the signal is standardized in SUSv3.</p>
<p class="bull">&#8226; The <em>Default</em> column indicates the default action of the signal: <em>term</em> means that the signal terminates the process, <em>core</em> means that the process produces a core dump file and terminates, <em>ignore</em> means that the signal is ignored, <em>stop</em> means that the signal stops the process, and <em>cont</em> means that the signal resumes a stopped process.</p>
<div class="block1">
<p class="noindent">Certain of the signals listed previously are not shown in <a href="ch20.xhtml#ch20table1">Table 20-1</a>: <span class="literal">SIGCLD</span> (synonym for <span class="literal">SIGCHLD</span>), <span class="literal">SIGINFO</span> (unused), <span class="literal">SIGIOT</span> (synonym for <span class="literal">SIGABRT</span>), <span class="literal">SIGLOST</span> (unused), and <span class="literal">SIGUNUSED</span> (synonym for <span class="literal">SIGSYS</span> on many architectures).</p>
</div>
<p class="tablecap"><span epub:type="pagebreak" id="page_396"/><a id="ch20table1"/><strong>Table 20-1:</strong> Linux signals</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Name</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Signal number</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Description</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>SUSv3</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Default</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGABRT</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">6</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Abort process</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">core</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGALRM</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">14</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Real-time timer expired</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">term</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGBUS</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">7 (SAMP=10)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Memory access error</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">core</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGCHLD</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">17 (SA=20, MP=18)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Child terminated or stopped</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">ignore</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGCONT</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">18 (SA=19, M=25, P=26)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Continue if stopped</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">cont</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGEMT</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">undef (SAMP=7)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Hardware fault</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">term</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGFPE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">8</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Arithmetic exception</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">core</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGHUP</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">1</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Hangup</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">term</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGILL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">4</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Illegal instruction</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">core</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGINT</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">2</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Terminal interrupt</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">term</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGIO</span> / <span class="literal">SIGPOLL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">29 (SA=23, MP=22)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">I/O possible</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">term</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGKILL</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">9</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Sure kill</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">term</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGPIPE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">13</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Broken pipe</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">term</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGPROF</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">27 (M=29, P=21)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Profiling timer expired</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">term</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGPWR</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">30 (SA=29, MP=19)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Power about to fail</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">term</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGQUIT</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">3</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Terminal quit</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">core</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGSEGV</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">11</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Invalid memory reference</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">core</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGSTKFLT</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">16 (SAM=undef, P=36)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Stack fault on coprocessor</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">term</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGSTOP</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">19 (SA=17, M=23, P=24)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Sure stop</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">stop</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGSYS</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">31 (SAMP=12)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Invalid system call</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">core</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGTERM</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">15</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Terminate process</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">term</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGTRAP</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">5</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Trace/breakpoint trap</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">core</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGTSTP</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">20 (SA=18, M=24, P=25)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Terminal stop</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">stop</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGTTIN</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">21 (M=26, P=27)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Terminal read from BG</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">stop</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGTTOU</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">22 (M=27, P=28)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Terminal write from BG</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">stop</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGURG</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">23 (SA=16, M=21, P=29)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Urgent data on socket</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">ignore</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGUSR1</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">10 (SA=30, MP=16)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">User-defined signal 1</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">term</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGUSR2</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">12 (SA=31, MP=17)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">User-defined signal 2</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">term</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGVTALRM</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">26 (M=28, P=20)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Virtual timer expired</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">term</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGWINCH</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">28 (M=20, P=23)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Terminal window size change</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">ignore</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SIGXCPU</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">24 (M=30, P=33)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">CPU time limit exceeded</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">core</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">SIGXFSZ</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec">25 (M=31, P=34)</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">File size limit exceeded</p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">core</p></td>
</tr>
</tbody>
</table>
<p class="noindentb">Note the following points regarding the default behavior shown for certain signals in <a href="ch20.xhtml#ch20table1">Table 20-1</a>:</p>
<p class="bull">&#8226; On Linux 2.2, the default action for the signals <span class="literal">SIGXCPU</span>, <span class="literal">SIGXFSZ</span>, <span class="literal">SIGSYS</span>, and <span class="literal">SIGBUS</span> is to terminate the process without producing a core dump. From kernel 2.4 onward, Linux conforms to the requirements of SUSv3, with these signals causing termination with a core dump. On several other UNIX implementations, <span class="literal">SIGXCPU</span> and <span class="literal">SIGXFSZ</span> are treated in the same way as on Linux 2.2.</p>
<p class="bull">&#8226; <span class="literal">SIGPWR</span> is typically ignored by default on those other UNIX implementations where it appears.</p>
<p class="bull"><span epub:type="pagebreak" id="page_397"/>&#8226; <span class="literal">SIGIO</span> is ignored by default on several UNIX implementations (particularly BSD derivatives).</p>
<p class="bull">&#8226; Although not specified by any standards, <span class="literal">SIGEMT</span> appears on most UNIX implementations. However, this signal typically results in termination with a core dump on other implementations.</p>
<p class="bull">&#8226; In SUSv1, the default action for <span class="literal">SIGURG</span> was specified as process termination, and this is the default in some older UNIX implementations. SUSv2 adopted the current specification (ignore).</p>
<h3 class="h3" id="ch20lev1sec03"><strong>20.3 Changing Signal Dispositions: <em>signal()</em></strong></h3>
<p class="noindenta">UNIX systems provide two ways of changing the disposition of a signal: <em>signal()</em> and <em>sigaction()</em>. The <em>signal()</em> system call, which is described in this section, was the original API for setting the disposition of a signal, and it provides a simpler interface than <em>sigaction()</em>. On the other hand, <em>sigaction()</em> provides functionality that is not available with <em>signal()</em>. Furthermore, there are variations in the behavior of <em>signal()</em> across UNIX implementations (<a href="ch22.xhtml#ch22lev1sec07">Section 22.7</a>), which mean that it should never be used for establishing signal handlers in portable programs. Because of these portability issues, <em>sigaction()</em> is the (strongly) preferred API for establishing a signal handler. After we explain the use of <em>sigaction()</em> in <a href="ch20.xhtml#ch20lev1sec13">Section 20.13</a>, we&#8217;ll always employ that call when establishing signal handlers in our example programs.</p>
<div class="block">
<p class="noindent">Although documented in section 2 of the Linux manual pages, <em>signal()</em> is actually implemented in <em>glibc</em> as a library function layered on top of the <em>sigaction()</em> system call.</p>
</div>
<div class="box">
<p class="programsa">#include &lt;signal.h&gt;<br/><br/>void ( *<span class="codestrong">signal</span>(int <span class="font1">sig</span>, void (*<span class="font1">handler</span>)(int)) ) (int);</p>
<p class="right">Returns previous signal disposition on success, or <span class="literal">SIG_ERR</span> on error</p>
</div>
<p class="noindent">The function prototype for <em>signal()</em> requires some decoding. The first argument, <em>sig</em>, identifies the signal whose disposition we wish to change. The second argument, <em>handler</em>, is the address of the function that should be called when this signal is delivered. This function returns nothing (<em>void</em>) and takes one integer argument. Thus, a signal handler has the following general form:</p>
<p class="programs">void<br/>handler(int sig)<br/>{<br/>&#160;&#160;&#160;&#160;/* Code for the handler */<br/>}</p>
<p class="noindent">We describe the purpose of the <em>sig</em> argument to the handler function in <a href="ch20.xhtml#ch20lev1sec04">Section 20.4</a>.</p>
<p class="indent">The return value of <em>signal()</em> is the previous disposition of the signal. Like the <em>handler</em> argument, this is a pointer to a function returning nothing and taking one integer argument. In other words, we could write code such as the following to <span epub:type="pagebreak" id="page_398"/>temporarily establish a handler for a signal, and then reset the disposition of the signal to whatever it was previously:</p>
<p class="programs">void (*oldHandler)(int);<br/><br/>oldHandler = signal(SIGINT, newHandler);<br/>if (oldHandler == SIG_ERR)<br/>&#160;&#160;&#160;&#160;errExit("signal");<br/><br/>/* Do something else here. During this time, if SIGINT is<br/>&#160;&#160;&#160;delivered, newHandler will be used to handle the signal. */<br/><br/>if (signal(SIGINT, oldHandler) == SIG_ERR)<br/>&#160;&#160;&#160;&#160;errExit("signal");</p>
<div class="block">
<p class="noindent">It is not possible to use <em>signal()</em> to retrieve the current disposition of a signal without at the same time changing that disposition. To do that, we must use <em>sigaction()</em>.</p>
</div>
<p class="noindent">We can make the prototype for <em>signal()</em> much more comprehensible by using the following type definition for a pointer to a signal handler function:</p>
<p class="programs">typedef void (*sighandler_t)(int);</p>
<p class="noindent">This enables us to rewrite the prototype for <em>signal()</em> as follows:</p>
<p class="programs">sighandler_t signal(int sig, sighandler_t handler);</p>
<div class="block">
<p class="noindent">If the <span class="literal">_GNU_SOURCE</span> feature test macro is defined, then <em>glibc</em> exposes the nonstandard <em>sighandler_t</em> data type in the <span class="literal">&lt;signal.h&gt;</span> header file.</p>
</div>
<p class="noindentb">Instead of specifying the address of a function as the <em>handler</em> argument of <em>signal()</em>, we can specify one of the following values:</p>
<p class="term"><span class="literal">SIG_DFL</span></p>
<p class="termlist">Reset the disposition of the signal to its default (<a href="ch20.xhtml#ch20table1">Table 20-1</a>). This is useful for undoing the effect of an earlier call to <em>signal()</em> that changed the disposition for the signal.</p>
<p class="term"><span class="literal">SIG_IGN</span></p>
<p class="termlist">Ignore the signal. If the signal is generated for this process, the kernel silently discards it. The process never even knows that the signal occurred.</p>
<p class="noindentt">A successful call to <em>signal()</em> returns the previous disposition of the signal, which may be the address of a previously installed handler function, or one of the constants <span class="literal">SIG_DFL</span> or <span class="literal">SIG_IGN</span>. On error, <em>signal()</em> returns the value <span class="literal">SIG_ERR</span>.</p>
<h3 class="h3" id="ch20lev1sec04"><strong>20.4 Introduction to Signal Handlers</strong></h3>
<p class="noindenta">A <em>signal handler</em> (also called a <em>signal catcher</em>) is a function that is called when a specified signal is delivered to a process. We describe the fundamentals of signal handlers in this section, and then go into the details in <a href="ch21.xhtml#ch21">Chapter 21</a>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_399"/>Invocation of a signal handler may interrupt the main program flow at any time; the kernel calls the handler on the process&#8217;s behalf, and when the handler returns, execution of the program resumes at the point where the handler interrupted it. This sequence is illustrated in <a href="ch20.xhtml#ch20fig1">Figure 20-1</a>.</p>
<div class="image"><img src="../images/f20-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch20fig1"/><strong>Figure 20-1:</strong> Signal delivery and handler execution</p>
<p class="noindent">Although signal handlers can do virtually anything, they should, in general, be designed to be as simple as possible. We expand on this point in <a href="ch21.xhtml#ch21lev1sec01">Section 21.1</a>.</p>
<p class="examplet"><a id="ch20ex1"/><strong>Listing 20-1:</strong> Installing a handler for <span class="literal">SIGINT</span></p>
<p class="programsli">___________________________________________________________ <span class="codestrong">signals/ouch.c</span><br/><br/>#include &lt;signal.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static void<br/>sigHandler(int sig)<br/>{<br/>&#160;&#160;&#160;&#160;printf("Ouch!\n");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* UNSAFE (see <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>) */<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int j;<br/><br/>&#160;&#160;&#160;&#160;if (signal(SIGINT, sigHandler) == SIG_ERR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("signal");<br/><br/>&#160;&#160;&#160;&#160;for (j = 0; ; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%d\n", j);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep(3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Loop slowly... */<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>___________________________________________________________ <span class="codestrong">signals/ouch.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_400"/><a href="ch20.xhtml#ch20ex1">Listing 20-1</a> (on <a href="ch20.xhtml#page_399">page 399</a>) shows a simple example of a signal handler function and a main program that establishes it as the handler for the <span class="literal">SIGINT</span> signal. (The terminal driver generates this signal when we type the terminal <em>interrupt</em> character, usually <em>Control-C.)</em> The handler simply prints a message and returns.</p>
<p class="indent">The main program continuously loops. On each iteration, the program increments a counter whose value it prints, and then the program sleeps for a few seconds. (To sleep in this manner, we use the <em>sleep()</em> function, which suspends the execution of its caller for a specified number of seconds. We describe this function in <a href="ch23.xhtml#ch23lev2sec01">Section 23.4.1</a>.)</p>
<p class="indent">When we run the program in <a href="ch20.xhtml#ch20ex1">Listing 20-1</a>, we see the following:</p>
<p class="programs">$ <span class="codestrong">./ouch</span><br/>0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Main program loops, displaying successive integers</span><br/><span class="font1">Type Control-C</span><br/>Ouch!&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Signal handler is executed, and returns</span><br/>1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Control has returned to main program</span><br/>2<br/><span class="font1">Type Control-C again</span><br/>Ouch!<br/>3<br/><span class="font1">Type Control-\ (the terminal quit character)</span><br/>Quit (core dumped)</p>
<p class="noindent">When the kernel invokes a signal handler, it passes the number of the signal that caused the invocation as an integer argument to the handler. (This is the <em>sig</em> argument in the handler of <a href="ch20.xhtml#ch20ex1">Listing 20-1</a>). If a signal handler catches only one type of signal, then this argument is of little use. We can, however, establish the same handler to catch different types of signals and use this argument to determine which signal caused the handler to be invoked.</p>
<p class="indent">This is illustrated in <a href="ch20.xhtml#ch20ex2">Listing 20-2</a>, a program that establishes the same handler for <span class="literal">SIGINT</span> and <span class="literal">SIGQUIT</span>. (<span class="literal">SIGQUIT</span> is generated by the terminal driver when we type the terminal <em>quit</em> character, usually <em>Control-\</em>.) The code of the handler distinguishes the two signals by examining the <em>sig</em> argument, and takes different actions for each signal. In the <em>main()</em> function, we use <em>pause()</em> (described in <a href="ch20.xhtml#ch20lev1sec14">Section 20.14</a>) to block the process until a signal is caught.</p>
<p class="indent">The following shell session log demonstrates the use of this program:</p>
<p class="programs">$ <span class="codestrong">./intquit</span><br/><span class="font1">Type Control-C</span><br/>Caught SIGINT (1)<br/><span class="font1">Type Control-C again</span><br/>Caught SIGINT (2)<br/><span class="font1">and again</span><br/>Caught SIGINT (3)<br/><span class="font1">Type Control-\</span><br/>Caught SIGQUIT - that's all folks!</p>
<p class="noindent">In <a href="ch20.xhtml#ch20ex1">Listing 20-1</a> and <a href="ch20.xhtml#ch20ex2">Listing 20-2</a>, we use <em>printf()</em> to display the message from the signal handler. For reasons that we discuss in <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>, real-world applications should generally never call <em>stdio</em> functions from within a signal handler. However, in <span epub:type="pagebreak" id="page_401"/>various example programs, we&#8217;ll nevertheless call <em>printf()</em> from a signal handler as a simple means of seeing when the handler is called.</p>
<p class="examplet"><a id="ch20ex2"/><strong>Listing 20-2:</strong> Establishing the same handler for two different signals</p>
<p class="programsli">________________________________________________________ <span class="codestrong">signals/intquit.c</span><br/><br/>#include &lt;signal.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static void<br/>sigHandler(int sig)<br/>{<br/>&#160;&#160;&#160;&#160;static int count = 0;<br/><br/>&#160;&#160;&#160;&#160;/* UNSAFE: This handler uses non-async-signal-safe functions<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;(printf(), exit(); see <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>) */<br/><br/>&#160;&#160;&#160;&#160;if (sig == SIGINT) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Caught SIGINT (%d)\n", count);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Resume execution at point of interruption */<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;/* Must be SIGQUIT - print a message and terminate the process */<br/><br/>&#160;&#160;&#160;&#160;printf("Caught SIGQUIT - that's all folks!\n");<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;/* Establish same handler for SIGINT and SIGQUIT */<br/><br/>&#160;&#160;&#160;&#160;if (signal(SIGINT, sigHandler) == SIG_ERR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("signal");<br/>&#160;&#160;&#160;&#160;if (signal(SIGQUIT, sigHandler) == SIG_ERR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("signal");<br/><br/>&#160;&#160;&#160;&#160;for (;;)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Loop forever, waiting for signals */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pause();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Block until a signal is caught */<br/>}<br/>________________________________________________________ <span class="codestrong">signals/intquit.c</span></p>
<h3 class="h3" id="ch20lev1sec05"><strong>20.5 Sending Signals: <em>kill()</em></strong></h3>
<p class="noindenta">One process can send a signal to another process using the <em>kill()</em> system call, which is the analog of the <em>kill</em> shell command. (The term <em>kill</em> was chosen because the default action of most of the signals that were available on early UNIX implementations was to terminate the process.)</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_402"/>#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">kill</span>(pid_t <span class="font1">pid</span>, int <span class="font1">sig</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb">The <em>pid</em> argument identifies one or more processes to which the signal specified by <em>sig</em> is to be sent. Four different cases determine how <em>pid</em> is interpreted:</p>
<p class="bull">&#8226; If <em>pid</em> is greater than 0, the signal is sent to the process with the process ID specified by <em>pid</em>.</p>
<p class="bull">&#8226; If <em>pid</em> equals 0, the signal is sent to every process in the same process group as the calling process, including the calling process itself. (SUSv3 states that the signal should be sent to all processes in the same process group, excluding an &#8220;unspecified set of system processes&#8221; and adds the same qualification to each of the remaining cases.)</p>
<p class="bull">&#8226; If <em>pid</em> is less than &#8211;1, the signal is sent to all of the processes in the process group whose ID equals the absolute value of <em>pid</em>. Sending a signal to all of the processes in a process group finds particular use in shell job control (<a href="ch34.xhtml#ch34lev1sec07">Section 34.7</a>).</p>
<p class="bull">&#8226; If <em>pid</em> equals &#8211;1, the signal is sent to every process for which the calling process has permission to send a signal, except <em>init</em> (process ID 1) and the calling process. If a privileged process makes this call, then all processes on the system will be signaled, except for these last two. For obvious reasons, signals sent in this way are sometimes called <em>broadcast signals</em>. (SUSv3 doesn&#8217;t require that the calling process be excluded from receiving the signal; Linux follows the BSD semantics in this regard.)</p>
<p class="noindentt">If no process matches the specified <em>pid</em>, <em>kill()</em> fails and sets <em>errno</em> to <span class="literal">ESRCH</span> (&#8220;No such process&#8221;).</p>
<p class="indentb">A process needs appropriate permissions to be able send a signal to another process. The permission rules are as follows:</p>
<p class="bull">&#8226; A privileged (<span class="literal">CAP_KILL</span>) process may send a signal to any process.</p>
<p class="bull">&#8226; The <em>init</em> process (process ID 1), which runs with user and group of <em>root</em>, is a special case. It can be sent only signals for which it has a handler installed. This prevents the system administrator from accidentally killing <em>init</em>, which is fundamental to the operation of the system.</p>
<p class="bull">&#8226; An unprivileged process can send a signal to another process if the real or effective user ID of the sending process matches the real user ID or saved set-user-ID of the receiving process, as shown in <a href="ch20.xhtml#ch20fig2">Figure 20-2</a>. This rule allows users to send signals to set-user-ID programs that they have started, regardless of the current setting of the target process&#8217;s effective user ID. Furthermore, on Linux and other systems that provide the <em>setresuid()</em> system call, a set-user-ID program can take advantage of this rule to prevent itself being sent signals by the user that owns the executable, by using <em>setresuid()</em> to make its saved set-user-ID the same as the real user ID. (SUSv3 mandates the rules shown in <a href="ch20.xhtml#ch20fig2">Figure 20-2</a>, but Linux followed slightly different rules in kernel versions before 2.0, as described in the <em>kill(2)</em> manual page.)</p>
<p class="bull"><span epub:type="pagebreak" id="page_403"/>&#8226; The <span class="literal">SIGCONT</span> signal is treated specially. An unprivileged process may send this signal to any other process in the same session, regardless of user ID checks. This rule allows job-control shells to restart stopped jobs (process groups), even if the processes of the job have changed their user IDs (i.e., they are privileged processes that have used the system calls described in <a href="ch09.xhtml#ch09lev1sec07">Section 9.7</a> to change their credentials).</p>
<div class="image"><img src="../images/f20-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch20fig2"/><strong>Figure 20-2:</strong> Permissions required for an unprivileged process to send a signal</p>
<p class="noindent">If a process doesn&#8217;t have permissions to send a signal to the requested <em>pid</em>, then <em>kill()</em> fails, setting <em>errno</em> to <span class="literal">EPERM</span>. Where <em>pid</em> specifies a set of processes (i.e., <em>pid</em> is negative), <em>kill()</em> succeeds if at least one of them could be signaled.</p>
<p class="indent">We demonstrate the use of <em>kill()</em> in <a href="ch20.xhtml#ch20ex3">Listing 20-3</a>.</p>
<h3 class="h3" id="ch20lev1sec06"><strong>20.6 Checking for the Existence of a Process</strong></h3>
<p class="noindenta">The <em>kill()</em> system call can serve another purpose. If the <em>sig</em> argument is specified as 0 (the so-called <em>null signal</em>), then no signal is sent. Instead, <em>kill()</em> merely performs error checking to see if the process can be signaled. Read another way, this means we can use the null signal to test if a process with a specific process ID exists. If sending a null signal fails with the error <span class="literal">ESRCH</span>, then we know the process doesn&#8217;t exist. If the call fails with the error <span class="literal">EPERM</span> (meaning the process exists, but we don&#8217;t have permission to send a signal to it) or succeeds (meaning we do have permission to send a signal to the process), then we know that the process exists.</p>
<p class="indent">Verifying the existence of a particular process ID doesn&#8217;t guarantee that a particular program is still running. Because the kernel recycles process IDs as processes are born and die, the same process ID may, over time, refer to a different process. Furthermore, a particular process ID may exist, but be a zombie (i.e., a process that has died, but whose parent has not yet performed a <em>wait()</em> to obtain its termination status, as described in <a href="ch26.xhtml#ch26lev1sec02">Section 26.2</a>).</p>
<p class="indentb">Various other techniques can also be used to check whether a particular process is running, including the following:</p>
<p class="bull">&#8226; <em>The wait() system calls</em>: These calls are described in <a href="ch26.xhtml#ch26">Chapter 26</a>. They can be employed only if the monitored process is a child of the caller.</p>
<p class="bull">&#8226; <em>Semaphores and exclusive file locks</em>: If the process that is being monitored continuously holds a semaphore or a file lock, then, if we can acquire the semaphore or lock, we know the process has terminated. We describe semaphores in <a href="ch47.xhtml#ch47">Chapters 47</a> and <a href="ch53.xhtml#ch53">53</a> and file locks in <a href="ch55.xhtml#ch55">Chapter 55</a>.</p>
<p class="bull"><span epub:type="pagebreak" id="page_404"/>&#8226; <em>IPC channels such as pipes and FIFOs</em>: We set up the monitored process so that it holds a file descriptor open for writing on the channel as long as it is alive. Meanwhile, the monitoring process holds open a read descriptor for the channel, and it knows that the monitored process has terminated when the write end of the channel is closed (because it sees end-of-file). The monitoring process can determine this either by reading from its file descriptor or by monitoring the descriptor using one of the techniques described in <a href="ch63.xhtml#ch63">Chapter 63</a>.</p>
<p class="bull">&#8226; <em>The</em> <span class="literal">/proc/</span><em>PID interface</em>: For example, if a process with the process ID 12345 exists, then the directory <span class="literal">/proc/12345</span> will exist, and we can check this using a call such as <em>stat()</em>.</p>
<p class="noindentt">All of these techniques, except the last, are unaffected by recycling of process IDs.</p>
<p class="indent"><a href="ch20.xhtml#ch20ex3">Listing 20-3</a> demonstrates the use of <em>kill()</em>. This program takes two command-line arguments, a process ID and a signal number, and uses <em>kill()</em> to send the signal to the specified process. If signal 0 (the null signal) is specified, then the program reports on the existence of the target process.</p>
<h3 class="h3" id="ch20lev1sec07"><strong>20.7 Other Ways of Sending Signals: <em>raise()</em> and <em>killpg()</em></strong></h3>
<p class="noindenta">Sometimes, it is useful for a process to send a signal to itself. (We see an example of this in <a href="ch34.xhtml#ch34lev2sec05">Section 34.7.3</a>.) The <em>raise()</em> function performs this task.</p>
<div class="box">
<p class="programsa">#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">raise</span>(int <span class="font1">sig</span>);</p>
<p class="right">Returns 0 on success, or nonzero on error</p>
</div>
<p class="noindent">In a single-threaded program, a call to <em>raise()</em> is equivalent to the following call to <em>kill()</em>:</p>
<p class="programs">kill(getpid(), sig);</p>
<p class="noindent">On a system that supports threads, <em>raise(sig)</em> is implemented as:</p>
<p class="programs">pthread_kill(pthread_self(), sig)</p>
<p class="noindent">We describe the <em>pthread_kill()</em> function in <a href="ch33.xhtml#ch33lev2sec03">Section 33.2.3</a>, but for now it is sufficient to say that this implementation means that the signal will be delivered to the specific thread that called <em>raise()</em>. By contrast, the call <em>kill(getpid(), sig)</em> sends a signal to the calling <em>process</em>, and that signal may be delivered to any thread in the process.</p>
<div class="block">
<p class="noindent">The <em>raise()</em> function originates from C89. The C standards don&#8217;t cover operating system details such as process IDs, but <em>raise()</em> can be specified within the C standard because it doesn&#8217;t require reference to process IDs.</p>
</div>
<p class="noindent">When a process sends itself a signal using <em>raise()</em> (or <em>kill()</em>), the signal is delivered immediately (i.e., before <em>raise()</em> returns to the caller).</p>
<p class="indent">Note that <em>raise()</em> returns a nonzero value (not necessarily &#8211;1) on error. The only error that can occur with <em>raise()</em> is <span class="literal">EINVAL</span>, because <em>sig</em> was invalid. Therefore, where we specify one of the <span class="literal">SIGxxxx</span> constants, we don&#8217;t check the return status of this function.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_405"/><a id="ch20ex3"/><strong>Listing 20-3:</strong> Using the <em>kill()</em> system call</p>
<p class="programsli">_________________________________________________________ <span class="codestrong">signals/t_kill.c</span><br/><br/>#include &lt;signal.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int s, sig;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 3 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s pid sig-num\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;sig = getInt(argv[2], 0, "sig-num");<br/><br/>&#160;&#160;&#160;&#160;s = kill(getLong(argv[1], 0, "pid"), sig);<br/><br/>&#160;&#160;&#160;&#160;if (sig != 0) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("kill");<br/><br/>&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Null signal: process existence check */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s == 0) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Process exists and we can send it a signal\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno == EPERM)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Process exists, but we don't have "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"permission to send it a signal\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (errno == ESRCH)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Process does not exist\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("kill");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________________ <span class="codestrong">signals/t_kill.c</span></p>
<p class="noindent">The <em>killpg()</em> function sends a signal to all of the members of a process group.</p>
<div class="box">
<p class="programsa">#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">killpg</span>(pid_t <span class="font1">pgrp</span>, int <span class="font1">sig</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">A call to <em>killpg()</em> is equivalent to the following call to <em>kill()</em>:</p>
<p class="programs">kill(-pgrp, sig);</p>
<p class="noindent">If <em>pgrp</em> is specified as 0, then the signal is sent to all processes in the same process group as the caller. SUSv3 leaves this point unspecified, but most UNIX implementations interpret this case in the same way as Linux.</p>
<h3 class="h3" id="ch20lev1sec08"><span epub:type="pagebreak" id="page_406"/><strong>20.8 Displaying Signal Descriptions</strong></h3>
<p class="noindenta">Each signal has an associated printable description. These descriptions are listed in the array <em>sys_siglist</em>. For example, we can refer to <em>sys_siglist[SIGPIPE]</em> to get the description for <span class="literal">SIGPIPE</span> (broken pipe). However, rather than using the <em>sys_siglist</em> array directly, the <em>strsignal()</em> function is preferable.</p>
<div class="box">
<p class="programsa">#define _BSD_SOURCE<br/>#include &lt;signal.h&gt;<br/><br/>extern const char *const <span class="codestrong">sys_siglist</span>[];<br/><br/>#define _GNU_SOURCE<br/>#include &lt;string.h&gt;<br/><br/>char *<span class="codestrong">strsignal</span>(int <span class="font1">sig</span>);</p>
<p class="right">Returns pointer to signal description string</p>
</div>
<p class="noindent">The <em>strsignal()</em> function performs bounds checking on the <em>sig</em> argument, and then returns a pointer to a printable description of the signal, or a pointer to an error string if the signal number was invalid. (On some other UNIX implementations, <em>strsignal()</em> returns <span class="literal">NULL</span> if <em>sig</em> is invalid.)</p>
<p class="indent">Aside from bounds checking, another advantage of <em>strsignal()</em> over the direct use of <em>sys_siglist</em> is that <em>strsignal()</em> is locale-sensitive (<a href="ch10.xhtml#ch10lev1sec04">Section 10.4</a>), so that signal descriptions will be displayed in the local language.</p>
<p class="indent">An example of the use of <em>strsignal()</em> is shown in <a href="ch20.xhtml#ch20ex4">Listing 20-4</a>.</p>
<p class="indent">The <em>psignal()</em> function displays (on standard error) the string given in its argument <em>msg</em>, followed by a colon, and then the signal description corresponding to <em>sig</em>. Like <em>strsignal()</em>, <em>psignal()</em> is locale-sensitive.</p>
<div class="box">
<p class="programsa">#include &lt;signal.h&gt;<br/><br/>void <span class="codestrong">psignal</span>(int <span class="font1">sig</span>, const char *<span class="font1">msg</span>);</p>
</div>
<p class="noindent">Although <em>psignal()</em>, <em>strsignal()</em>, and <em>sys_siglist</em> are not standardized as part of SUSv3, they are nevertheless available on many UNIX implementations. (SUSv4 adds specifications for <em>psignal()</em> and <em>strsignal()</em>.)</p>
<h3 class="h3" id="ch20lev1sec09"><strong>20.9 Signal Sets</strong></h3>
<p class="noindenta">Many signal-related system calls need to be able to represent a group of different signals. For example, <em>sigaction()</em> and <em>sigprocmask()</em> allow a program to specify a group of signals that are to be blocked by a process, while <em>sigpending()</em> returns a group of signals that are currently pending for a process. (We describe these system calls shortly.)</p>
<p class="indent"><span epub:type="pagebreak" id="page_407"/>Multiple signals are represented using a data structure called a <em>signal set</em>, provided by the system data type <em>sigset_t</em>. SUSv3 specifies a range of functions for manipulating signal sets, and we now describe these functions.</p>
<div class="block">
<p class="noindent">On Linux, as on most UNIX implementations, the <em>sigset_t</em> data type is a bit mask. However, SUSv3 doesn&#8217;t require this. A signal set could conceivably be represented using some other kind of structure. SUSv3 requires only that the type of <em>sigset_t</em> be assignable. Thus, it must be implemented using either some scalar type (e.g., an integer) or a C structure (perhaps containing an array of integers).</p>
</div>
<p class="noindent">The <em>sigemptyset()</em> function initializes a signal set to contain no members. The <em>sigfillset()</em> function initializes a set to contain all signals (including all realtime signals).</p>
<div class="box">
<p class="programsa">#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">sigemptyset</span>(sigset_t *<span class="font1">set</span>);<br/>int <span class="codestrong">sigfillset</span>(sigset_t *<span class="font1">set</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">One of <em>sigemptyset()</em> or <em>sigfillset() must</em> be used to initialize a signal set. This is because C doesn&#8217;t initialize automatic variables, and the initialization of static variables to 0 can&#8217;t portably be relied upon as indicating an empty signal set, since signal sets may be implemented using structures other than bit masks. (For the same reason, it is incorrect to use <em>memset(3)</em> to zero the contents of a signal set in order to mark it as empty.)</p>
<p class="indent">After initialization, individual signals can be added to a set using <em>sigaddset()</em> and removed using <em>sigdelset()</em>.</p>
<div class="box">
<p class="programsa">#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">sigaddset</span>(const sigset_t *<span class="font1">set</span>, int <span class="font1">sig</span>);<br/>int <span class="codestrong">sigdelset</span>(const sigset_t *<span class="font1">set</span>, int <span class="font1">sig</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">For both <em>sigaddset()</em> and <em>sigdelset()</em>, the <em>sig</em> argument is a signal number.</p>
<p class="indent">The <em>sigismember()</em> function is used to test for membership of a set.</p>
<div class="box">
<p class="programsa">#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">sigismember</span>(const sigset_t *<span class="font1">set</span>, int <span class="font1">sig</span>);</p>
<p class="right">Returns 1 if <em>sig</em> is a member of <em>set</em>, 0 if it is not, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>sigismember()</em> function returns 1 (true) if <em>sig</em> is a member of <em>set</em>, 0 (false) if it is not a member, or &#8211;1 on error (e.g., <em>sig</em> is not a valid signal number).</p>
<p class="indent"><span epub:type="pagebreak" id="page_408"/>The GNU C library implements three nonstandard functions that perform tasks that are complementary to the standard signal set functions just described.</p>
<div class="box">
<p class="programsa">#define _GNU_SOURCE<br/>#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">sigandset</span>(sigset_t *<span class="font1">dest</span>, sigset_t *<span class="font1">left</span>, sigset_t *<span class="font1">right</span>);<br/>int <span class="codestrong">sigorset</span>(sigset_t *<span class="font1">dest</span>, sigset_t *<span class="font1">left</span>, sigset_t *<span class="font1">right</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
<p class="programsat">int <span class="codestrong">sigisemptyset</span>(const sigset_t *<span class="font1">set</span>);</p>
<p class="right">Returns 1 if <em>set</em> is empty, otherwise 0</p>
</div>
<p class="noindentb">These functions perform the following tasks:</p>
<p class="bull">&#8226; <em>sigandset()</em> places the intersection of the sets <em>left</em> and <em>right</em> in the set <em>dest</em>;</p>
<p class="bull">&#8226; <em>sigorset()</em> places the union of the sets <em>left</em> and <em>right</em> in the set <em>dest</em>; and</p>
<p class="bull">&#8226; <em>sigisemptyset()</em> returns true if <em>set</em> contains no signals.</p>
<h5 class="h5" id="ch20lev3sec01"><strong>Example program</strong></h5>
<p class="noindenta">Using the functions described in this section, we can write the functions shown in <a href="ch20.xhtml#ch20ex4">Listing 20-4</a>, which we employ in various later programs. The first of these, <em>printSigset()</em>, displays the signals that are members of the specified signal set. This function uses the <span class="literal">NSIG</span> constant, which is defined in <span class="literal">&lt;signal.h&gt;</span> to be one greater than the highest signal number. We use <span class="literal">NSIG</span> as the upper bound in a loop that tests all signal numbers for membership of a set.</p>
<div class="block">
<p class="noindent">Although <span class="literal">NSIG</span> is not specified in SUSv3, it is defined on most UNIX implementations. However, it may be necessary to use implementation-specific compiler options to make it visible. For example, on Linux, we must define one of the feature test macros <span class="literal">_BSD_SOURCE</span>, <span class="literal">_SVID_SOURCE</span>, or <span class="literal">_GNU_SOURCE</span>.</p>
</div>
<p class="noindent">The <em>printSigMask()</em> and <em>printPendingSigs()</em> functions employ <em>printSigset()</em> to display, respectively, the process signal mask and the set of currently pending signals. The <em>printSigMask()</em> and <em>printPendingSigs()</em> functions use the <em>sigprocmask()</em> and <em>sigpending()</em> system calls, respectively. We describe the <em>sigprocmask()</em> and <em>sigpending()</em> system calls in <a href="ch20.xhtml#ch20lev1sec10">Sections 20.10</a> and <a href="ch20.xhtml#ch20lev1sec11">20.11</a>.</p>
<p class="examplet"><a id="ch20ex4"/><strong>Listing 20-4:</strong> Functions for displaying signal sets</p>
<p class="programsli">_________________________________________________ <span class="codestrong">signals/signal_functions.c</span><br/><br/>#define _GNU_SOURCE<br/>#include &lt;string.h&gt;<br/>#include &lt;signal.h&gt;<br/>#include "signal_functions.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declares functions defined here */<br/>#include "tlpi_hdr.h"<br/><br/>/* NOTE: All of the following functions employ fprintf(), which<br/>&#160;&#160;&#160;is not async-signal-safe (see <a href="ch21.xhtml#ch21lev2sec02">Section 21.1.2</a>). As such, these<br/><span epub:type="pagebreak" id="page_409"/>&#160;&#160;&#160;functions are also not async-signal-safe (i.e., beware of<br/>&#160;&#160;&#160;indiscriminately calling them from signal handlers). */<br/><br/>void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Print list of signals within a signal set */<br/>printSigset(FILE *of, const char *prefix, const sigset_t *sigset)<br/>{<br/>&#160;&#160;&#160;&#160;int sig, cnt;<br/><br/>&#160;&#160;&#160;&#160;cnt = 0;<br/>&#160;&#160;&#160;&#160;for (sig = 1; sig &lt; NSIG; sig++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigismember(sigset, sig)) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cnt++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(of, "%s%d (%s)\n", prefix, sig, strsignal(sig));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (cnt == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(of, "%s&lt;empty signal set&gt;\n", prefix);<br/>}<br/><br/>int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Print mask of blocked signals for this process */<br/>printSigMask(FILE *of, const char *msg)<br/>{<br/>&#160;&#160;&#160;&#160;sigset_t currMask;<br/><br/>&#160;&#160;&#160;&#160;if (msg != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(of, "%s", msg);<br/><br/>&#160;&#160;&#160;&#160;if (sigprocmask(SIG_BLOCK, NULL, &#38;currMask) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/>&#160;&#160;&#160;&#160;printSigset(of, "\t\t", &#38;currMask);<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Print signals currently pending for this process */<br/>printPendingSigs(FILE *of, const char *msg)<br/>{<br/>&#160;&#160;&#160;&#160;sigset_t pendingSigs;<br/><br/>&#160;&#160;&#160;&#160;if (msg != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(of, "%s", msg);<br/><br/>&#160;&#160;&#160;&#160;if (sigpending(&#38;pendingSigs) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/>&#160;&#160;&#160;&#160;printSigset(of, "\t\t", &#38;pendingSigs);<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/>_________________________________________________ <span class="codestrong">signals/signal_functions.c</span></p>
<h3 class="h3" id="ch20lev1sec10"><span epub:type="pagebreak" id="page_410"/><strong>20.10 The Signal Mask (Blocking Signal Delivery)</strong></h3>
<p class="noindenta">For each process, the kernel maintains a <em>signal mask</em>&#8212;a set of signals whose delivery to the process is currently blocked. If a signal that is blocked is sent to a process, delivery of that signal is delayed until it is unblocked by being removed from the process signal mask. (In <a href="ch33.xhtml#ch33lev2sec01">Section 33.2.1</a>, we&#8217;ll see that the signal mask is actually a per-thread attribute, and that each thread in a multithreaded process can independently examine and modify its signal mask using the <em>pthread_sigmask()</em> function.)</p>
<p class="indentb">A signal may be added to the signal mask in the following ways:</p>
<p class="bull">&#8226; When a signal handler is invoked, the signal that caused its invocation can be automatically added to the signal mask. Whether or not this occurs depends on the flags used when the handler is established using <em>sigaction()</em>.</p>
<p class="bull">&#8226; When a signal handler is established with <em>sigaction()</em>, it is possible to specify an additional set of signals that are to be blocked when the handler is invoked.</p>
<p class="bull">&#8226; The <em>sigprocmask()</em> system call can be used at any time to explicitly add signals to, and remove signals from, the signal mask.</p>
<p class="noindentt">We delay discussion of the first two cases until we examine <em>sigaction()</em> in <a href="ch20.xhtml#ch20lev1sec13">Section 20.13</a>, and discuss <em>sigprocmask()</em> now.</p>
<div class="box">
<p class="programsa">#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">sigprocmask</span>(int <span class="font1">how</span>, const sigset_t *<span class="font1">set</span>, sigset_t *<span class="font1">oldset</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb">We can use <em>sigprocmask()</em> to change the process signal mask, to retrieve the existing mask, or both. The <em>how</em> argument determines the changes that <em>sigprocmask()</em> makes to the signal mask:</p>
<p class="term"><span class="literal">SIG_BLOCK</span></p>
<p class="termlist">The signals specified in the signal set pointed to by <em>set</em> are added to the signal mask. In other words, the signal mask is set to the union of its current value and <em>set</em>.</p>
<p class="term"><span class="literal">SIG_UNBLOCK</span></p>
<p class="termlist">The signals in the signal set pointed to by <em>set</em> are removed from the signal mask. Unblocking a signal that is not currently blocked doesn&#8217;t cause an error to be returned.</p>
<p class="term"><span class="literal">SIG_SETMASK</span></p>
<p class="termlist">The signal set pointed to by <em>set</em> is assigned to the signal mask.</p>
<p class="noindentt">In each case, if the <em>oldset</em> argument is not <span class="literal">NULL</span>, it points to a <em>sigset_t</em> buffer that is used to return the previous signal mask.</p>
<p class="indent">If we want to retrieve the signal mask without changing it, then we can specify <span class="literal">NULL</span> for the <em>set</em> argument, in which case the <em>how</em> argument is ignored.</p>
<p class="indent"><span epub:type="pagebreak" id="page_411"/>To temporarily prevent delivery of a signal, we can use the series of calls shown in <a href="ch20.xhtml#ch20ex5">Listing 20-5</a> to block the signal, and then unblock it by resetting the signal mask to its previous state.</p>
<p class="examplet"><a id="ch20ex5"/><strong>Listing 20-5:</strong> Temporarily blocking delivery of a signal</p>
<p class="programsli">______________________________________________________________________<br/><br/>&#160;&#160;&#160;&#160;sigset_t blockSet, prevMask;<br/><br/>&#160;&#160;&#160;&#160;/* Initialize a signal set to contain SIGINT */<br/><br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;blockSet);<br/>&#160;&#160;&#160;&#160;sigaddset(&#38;blockSet, SIGINT);<br/><br/>&#160;&#160;&#160;&#160;/* Block SIGINT, save previous signal mask */<br/><br/>&#160;&#160;&#160;&#160;if (sigprocmask(SIG_BLOCK, &#38;blockSet, &#38;prevMask) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask1");<br/><br/>&#160;&#160;&#160;&#160;/* ... Code that should not be interrupted by SIGINT ... */<br/><br/>&#160;&#160;&#160;&#160;/* Restore previous signal mask, unblocking SIGINT */<br/><br/>&#160;&#160;&#160;&#160;if (sigprocmask(SIG_SETMASK, &#38;prevMask, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask2");<br/>______________________________________________________________________</p>
<p class="noindent">SUSv3 specifies that if any pending signals are unblocked by a call to <em>sigprocmask()</em>, then at least one of those signals will be delivered before the call returns. In other words, if we unblock a pending signal, it is delivered to the process immediately.</p>
<p class="indent">Attempts to block <span class="literal">SIGKILL</span> and <span class="literal">SIGSTOP</span> are silently ignored. If we attempt to block these signals, <em>sigprocmask()</em> neither honors the request nor generates an error. This means that we can use the following code to block all signals except <span class="literal">SIGKILL</span> and <span class="literal">SIGSTOP</span>:</p>
<p class="programs">sigfillset(&#38;blockSet);<br/>if (sigprocmask(SIG_BLOCK, &#38;blockSet, NULL) == -1)<br/>&#160;&#160;&#160;&#160;errExit("sigprocmask");</p>
<h3 class="h3" id="ch20lev1sec11"><strong>20.11 Pending Signals</strong></h3>
<p class="noindenta">If a process receives a signal that it is currently blocking, that signal is added to the process&#8217;s set of pending signals. When (and if) the signal is later unblocked, it is then delivered to the process. To determine which signals are pending for a process, we can call <em>sigpending()</em>.</p>
<div class="box">
<p class="programsa">#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">sigpending</span>(sigset_t *<span class="font1">set</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_412"/>The <em>sigpending()</em> system call returns the set of signals that are pending for the calling process in the <em>sigset_t</em> structure pointed to by <em>set</em>. We can then examine <em>set</em> using the <em>sigismember()</em> function described in <a href="ch20.xhtml#ch20lev1sec09">Section 20.9</a>.</p>
<p class="indent">If we change the disposition of a pending signal, then, when the signal is later unblocked, it is handled according to its new disposition. Although not often used, one application of this technique is to prevent the delivery of a pending signal by setting its disposition to <span class="literal">SIG_IGN</span>, or to <span class="literal">SIG_DFL</span> if the default action for the signal is <em>ignore</em>. As a result, the signal is removed from the process&#8217;s set of pending signals and thus not delivered.</p>
<h3 class="h3" id="ch20lev1sec12"><strong>20.12 Signals Are Not Queued</strong></h3>
<p class="noindenta">The set of pending signals is only a mask; it indicates whether or not a signal has occurred, but not how many times it has occurred. In other words, if the same signal is generated multiple times while it is blocked, then it is recorded in the set of pending signals, and later delivered, just once. (One of the differences between standard and realtime signals is that realtime signals are queued, as discussed in <a href="ch22.xhtml#ch22lev1sec08">Section 22.8</a>.)</p>
<p class="indent"><a href="ch20.xhtml#ch20ex6">Listing 20-6</a> and <a href="ch20.xhtml#ch20ex7">Listing 20-7</a> show two programs that can be used to observe that signals are not queued. The program in <a href="ch20.xhtml#ch20ex6">Listing 20-6</a> takes up to four command-line arguments, as follows:</p>
<p class="programs">$ <span class="codestrong">./sig_sender <span class="codeitalic">PID num-sigs sig-num [sig-num-2]</span></span></p>
<p class="noindent">The first argument is the process ID of a process to which the program should send signals. The second argument specifies the number of signals to be sent to the target process. The third argument specifies the signal number that is to be sent to the target process. If a signal number is supplied as the fourth argument, then the program sends one instance of that signal after sending the signals specified by the previous arguments. In the example shell session below, we use this final argument to send a <span class="literal">SIGINT</span> signal to the target process; the purpose of sending this signal will become clear in a moment.</p>
<p class="examplet"><a id="ch20ex6"/><strong>Listing 20-6:</strong> Sending multiple signals</p>
<p class="programsli">______________________________________________________ <span class="codestrong">signals/sig_sender.c</span><br/><br/>#include &lt;signal.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int numSigs, sig, j;<br/>&#160;&#160;&#160;&#160;pid_t pid;<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 4 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s pid num-sigs sig-num [sig-num-2]\n", argv[0]);<br/>&#160;&#160;&#160;&#160;pid = getLong(argv[1], 0, "PID");<br/>&#160;&#160;&#160;&#160;numSigs = getInt(argv[2], GN_GT_0, "num-sigs");<br/>&#160;&#160;&#160;&#160;sig = getInt(argv[3], 0, "sig-num");<br/><br/>&#160;&#160;&#160;&#160;/* Send signals to receiver */<br/><br/>&#160;&#160;&#160;&#160;printf("%s: sending signal %d to process %ld %d times\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;argv[0], sig, (long) pid, numSigs);<br/><br/>&#160;&#160;&#160;&#160;for (j = 0; j &lt; numSigs; j++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (kill(pid, sig) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("kill");<br/><br/>&#160;&#160;&#160;&#160;/* If a fourth command-line argument was specified, send that signal */<br/><br/>&#160;&#160;&#160;&#160;if (argc &gt; 4)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (kill(pid, getInt(argv[4], 0, "sig-num-2")) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("kill");<br/><br/>&#160;&#160;&#160;&#160;printf("%s: exiting\n", argv[0]);<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>______________________________________________________ <span class="codestrong">signals/sig_sender.c</span></p>
<p class="noindentb"><span epub:type="pagebreak" id="page_413"/>The program shown in <a href="ch20.xhtml#ch20ex7">Listing 20-7</a> is designed to catch and report statistics on signals sent by the program in <a href="ch20.xhtml#ch20ex6">Listing 20-6</a>. This program performs the following steps:</p>
<p class="bull">&#8226; The program sets up a single handler to catch all signals <span class="ent">&#x2461;</span>. (It isn&#8217;t possible to catch <span class="literal">SIGKILL</span> and <span class="literal">SIGSTOP</span>, but we ignore the error that occurs when trying to establish a handler for these signals.) For most types of signals, the handler <span class="ent">&#x2460;</span> simply counts the signal using an array. If <span class="literal">SIGINT</span> is received, the handler sets a flag (<em>gotSigint</em>) that causes the program to exit its main loop (the <span class="literal">while</span> loop described below). (We explain the use of the <span class="literal">volatile</span> qualifier and the <em>sig_atomic_t</em> data type used to declare the <em>gotSigint</em> variable in <a href="ch21.xhtml#ch21lev2sec03">Section 21.1.3</a>.)</p>
<p class="bull">&#8226; If a command-line argument was supplied to the program, then the program blocks all signals for the number of seconds specified by that argument, and then, prior to unblocking the signals, displays the set of pending signals <span class="ent">&#x2462;</span>. This allows us to send signals to the process before it commences the following step.</p>
<p class="bull">&#8226; The program executes a <span class="literal">while</span> loop that consumes CPU time until <em>gotSigint</em> is set <span class="ent">&#x2463;</span>. (<a href="ch20.xhtml#ch20lev1sec14">Sections 20.14</a> and <a href="ch22.xhtml#ch22lev1sec09">22.9</a> describe the use of <em>pause()</em> and <em>sigsuspend()</em>, which are more CPU-efficient ways of waiting for the arrival of a signal.)</p>
<p class="bull">&#8226; After exiting the <span class="literal">while</span> loop, the program displays counts of all signals received <span class="ent">&#x2464;</span>.</p>
<p class="noindentt">We first use these two programs to illustrate that a blocked signal is delivered only once, no matter how many times it is generated. We do this by specifying a sleep interval for the receiver and sending all signals before the sleep interval completes.</p>
<p class="programs">$ <span class="codestrong">./sig_receiver 15 &#38;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Receiver blocks signals for 15 secs</span><br/>[1] 5368<br/>./sig_receiver: PID is 5368<br/>./sig_receiver: sleeping for 15 seconds<br/>$ <span class="codestrong">./sig_sender 5368 1000000 10 2</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Send</span> SIGUSR1 <span class="font1">signals, plus a</span> SIGINT<br/>./sig_sender: sending signal 10 to process 5368 1000000 times<br/>./sig_sender: exiting<br/>./sig_receiver: pending signals are:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2 (Interrupt)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10 (User defined signal 1)<br/>./sig_receiver: signal 10 caught 1 time<br/>[1]+&#160;&#160;Done&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;./sig_receiver 15</p>
<p class="noindent"><span epub:type="pagebreak" id="page_414"/>The command-line arguments to the sending program specified the <span class="literal">SIGUSR1</span> and <span class="literal">SIGINT</span> signals, which are signals 10 and 2, respectively, on Linux/x86.</p>
<p class="indent">From the output above, we can see that even though one million signals were sent, only one was delivered to the receiver.</p>
<p class="indent">Even if a process doesn&#8217;t block signals, it may receive fewer signals than are sent to it. This can happen if the signals are sent so fast that they arrive before the receiving process has a chance to be scheduled for execution by the kernel, with the result that the multiple signals are recorded just once in the process&#8217;s pending signal set. If we execute the program in <a href="ch20.xhtml#ch20ex7">Listing 20-7</a> with no command-line arguments (so that it doesn&#8217;t block signals and sleep), we see the following:</p>
<p class="programs">$ <span class="codestrong">./sig_receiver &#38;</span><br/>[1] 5393<br/>./sig_receiver: PID is 5393<br/>$ <span class="codestrong">./sig_sender 5393 1000000 10 2</span><br/>./sig_sender: sending signal 10 to process 5393 1000000 times<br/>./sig_sender: exiting<br/>./sig_receiver: signal 10 caught 52 times<br/>[1]+&#160;&#160;Done&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;./sig_receiver</p>
<p class="noindent">Of the million signals sent, just 52 were caught by the receiving process. (The precise number of signals caught will vary depending on the vagaries of decisions made by the kernel scheduling algorithm.) The reason for this is that each time the sending program is scheduled to run, it sends multiple signals to the receiver. However, only one of these signals is marked as pending and then delivered when the receiver has a chance to run.</p>
<p class="examplet"><a id="ch20ex7"/><strong>Listing 20-7:</strong> Catching and counting signals</p>
<p class="programsli">____________________________________________________ <span class="codestrong">signals/sig_receiver.c</span><br/><br/>&#160;&#160;&#160;#define _GNU_SOURCE<br/>&#160;&#160;&#160;#include &lt;signal.h&gt;<br/>&#160;&#160;&#160;#include "signal_functions.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declaration of printSigset() */<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;static int sigCnt[NSIG];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Counts deliveries of each signal */<br/>&#160;&#160;&#160;static volatile sig_atomic_t gotSigint = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Set nonzero if SIGINT is delivered */<br/><br/>&#160;&#160;&#160;static void<br/><span class="ent">&#x2460;</span> handler(int sig)<br/>&#160;&#160;&#160;{<br/><span epub:type="pagebreak" id="page_415"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sig == SIGINT)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;gotSigint = 1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigCnt[sig]++;<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int n, numSecs;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigset_t pendingMask, blockingMask, emptyMask;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s: PID is %ld\n", argv[0], (long) getpid());<br/><br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;for (n = 1; n &lt; NSIG; n++)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Same handler for all signals */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(void) signal(n, handler);&#160;&#160;&#160;&#160;&#160;&#160;/* Ignore errors */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If a sleep time was specified, temporarily block all signals,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep (while another process sends us signals), and then<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;display the mask of pending signals and unblock all signals */<br/><br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;if (argc &gt; 1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numSecs = getInt(argv[1], GN_GT_0, NULL);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigfillset(&#38;blockingMask);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigprocmask(SIG_SETMASK, &#38;blockingMask, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s: sleeping for %d seconds\n", argv[0], numSecs);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sleep(numSecs);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigpending(&#38;pendingMask) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigpending");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s: pending signals are: \n", argv[0]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printSigset(stdout, "\t\t", &#38;pendingMask);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;emptyMask);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Unblock all signals */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigprocmask(SIG_SETMASK, &#38;emptyMask, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;while (!gotSigint)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Loop until SIGINT caught */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;for (n = 1; n &lt; NSIG; n++)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Display number of signals received */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigCnt[n] != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s: signal %d caught %d time%s\n", argv[0], n,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigCnt[n], (sigCnt[n] == 1) ? "" : "s");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;}<br/>____________________________________________________ <span class="codestrong">signals/sig_receiver.c</span></p>
<h3 class="h3" id="ch20lev1sec13"><span epub:type="pagebreak" id="page_416"/><strong>20.13 Changing Signal Dispositions: <em>sigaction()</em></strong></h3>
<p class="noindenta">The <em>sigaction()</em> system call is an alternative to <em>signal()</em> for setting the disposition of a signal. Although <em>sigaction()</em> is somewhat more complex to use than <em>signal()</em>, in return it provides greater flexibility. In particular, <em>sigaction()</em> allows us to retrieve the disposition of a signal without changing it, and to set various attributes controlling precisely what happens when a signal handler is invoked. Additionally, as we&#8217;ll elaborate in <a href="ch22.xhtml#ch22lev1sec07">Section 22.7</a>, <em>sigaction()</em> is more portable than <em>signal()</em> when establishing a signal handler.</p>
<div class="box">
<p class="programsa">#include &lt;signal.h&gt;<br/><br/>int <span class="codestrong">sigaction</span>(int <span class="font1">sig</span>, const struct sigaction *<span class="font1">act</span>, struct sigaction *<span class="font1">oldact</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>sig</em> argument identifies the signal whose disposition we want to retrieve or change. This argument can be any signal except <span class="literal">SIGKILL</span> or <span class="literal">SIGSTOP</span>.</p>
<p class="indent">The <em>act</em> argument is a pointer to a structure specifying a new disposition for the signal. If we are interested only in finding the existing disposition of the signal, then we can specify <span class="literal">NULL</span> for this argument. The <em>oldact</em> argument is a pointer to a structure of the same type, and is used to return information about the signal&#8217;s previous disposition. If we are not interested in this information, then we can specify <span class="literal">NULL</span> for this argument. The structures pointed to by <em>act</em> and <em>oldact</em> are of the following type:</p>
<p class="programs">struct sigaction {<br/>&#160;&#160;&#160;&#160;void&#160;&#160;&#160;(*sa_handler)(int);&#160;&#160;&#160;&#160;/* Address of handler */<br/>&#160;&#160;&#160;&#160;sigset_t sa_mask;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Signals blocked during handler<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;invocation */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;&#160;sa_flags;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Flags controlling handler invocation */<br/>&#160;&#160;&#160;&#160;void&#160;&#160;&#160;(*sa_restorer)(void);&#160;&#160;/* Not for application use */<br/>};</p>
<div class="block">
<p class="noindent">The <em>sigaction</em> structure is actually somewhat more complex than shown here. We consider further details in <a href="ch21.xhtml#ch21lev1sec04">Section 21.4</a>.</p>
</div>
<p class="noindent">The <em>sa_handler</em> field corresponds to the <em>handler</em> argument given to <em>signal()</em>. It specifies the address of a signal handler, or one of the constants <span class="literal">SIG_IGN</span> or <span class="literal">SIG_DFL</span>. The <em>sa_mask</em> and <em>sa_flags</em> fields, which we discuss in a moment, are interpreted only if <em>sa_handler</em> is the address of a signal handler&#8212;that is, a value other than <span class="literal">SIG_IGN</span> or <span class="literal">SIG_DFL</span>. The remaining field, <em>sa_restorer</em>, is not intended for use in applications (and is not specified by SUSv3).</p>
<div class="block">
<p class="noindent">The <em>sa_restorer</em> field is used internally to ensure that on completion of a signal handler, a call is made to the special-purpose <em>sigreturn()</em> system call, which restores the process&#8217;s execution context so that it can continue execution at the point where it was interrupted by the signal handler. An example of this usage can be found in the <em>glibc</em> source file <span class="literal">sysdeps/unix/sysv/linux/i386/sigaction.c</span>.</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_417"/>The <em>sa_mask</em> field defines a set of signals that are to be blocked during invocation of the handler defined by <em>sa_handler</em>. When the signal handler is invoked, any signals in this set that are not currently part of the process signal mask are automatically added to the mask before the handler is called. These signals remain in the process signal mask until the signal handler returns, at which time they are automatically removed. The <em>sa_mask</em> field allows us to specify a set of signals that aren&#8217;t permitted to interrupt execution of this handler. In addition, the signal that caused the handler to be invoked is automatically added to the process signal mask. This means that a signal handler won&#8217;t recursively interrupt itself if a second instance of the same signal arrives while the handler is executing. Because blocked signals are not queued, if any of these signals are repeatedly generated during the execution of the handler, they are (later) delivered only once.</p>
<p class="indentb">The <em>sa_flags</em> field is a bit mask specifying various options controlling how the signal is handled. The following bits may be ORed (<span class="literal">|</span>) together in this field:</p>
<p class="term"><span class="literal">SA_NOCLDSTOP</span></p>
<p class="termlist">If <em>sig</em> is <span class="literal">SIGCHLD</span>, don&#8217;t generate this signal when a child process is stopped or resumed as a consequence of receiving a signal. Refer to <a href="ch26.xhtml#ch26lev2sec08">Section 26.3.2</a>.</p>
<p class="term"><span class="literal">SA_NOCLDWAIT</span></p>
<p class="termlist">(since Linux 2.6) If <em>sig</em> is <span class="literal">SIGCHLD</span>, don&#8217;t transform children into zombies when they terminate. For further details, see <a href="ch26.xhtml#ch26lev2sec09">Section 26.3.3</a>.</p>
<p class="term"><span class="literal">SA_NODEFER</span></p>
<p class="termlist">When this signal is caught, don&#8217;t automatically add it to the process signal mask while the handler is executing. The name <span class="literal">SA_NOMASK</span> is provided as a historical synonym for <span class="literal">SA_NODEFER</span>, but the latter name is preferable because it is standardized in SUSv3.</p>
<p class="term"><span class="literal">SA_ONSTACK</span></p>
<p class="termlist">Invoke the handler for this signal using an alternate stack installed by <em>sigaltstack()</em>. Refer to <a href="ch21.xhtml#ch21lev1sec03">Section 21.3</a>.</p>
<p class="term"><span class="literal">SA_RESETHAND</span></p>
<p class="termlist">When this signal is caught, reset its disposition to the default (i.e., <span class="literal">SIG_DFL</span>) before invoking the handler. (By default, a signal handler remains established until it is explicitly disestablished by a further call to <em>sigaction()</em>.) The name <span class="literal">SA_ONESHOT</span> is provided as a historical synonym for <span class="literal">SA_RESETHAND</span>, but the latter name is preferable because it is standardized in SUSv3.</p>
<p class="term"><span class="literal">SA_RESTART</span></p>
<p class="termlist">Automatically restart system calls interrupted by this signal handler. See <a href="ch21.xhtml#ch21lev1sec05">Section 21.5</a>.</p>
<p class="term"><span class="literal">SA_SIGINFO</span></p>
<p class="termlist">Invoke the signal handler with additional arguments providing further information about the signal. We describe this flag in <a href="ch21.xhtml#ch21lev1sec04">Section 21.4</a>.</p>
<p class="noindentt">All of the above options are specified in SUSv3.</p>
<p class="indent">An example of the use of <em>sigaction()</em> is shown in <a href="ch21.xhtml#ch21ex1">Listing 21-1</a>.</p>
<h3 class="h3" id="ch20lev1sec14"><span epub:type="pagebreak" id="page_418"/><strong>20.14 Waiting for a Signal: <em>pause()</em></strong></h3>
<p class="noindenta">Calling <em>pause()</em> suspends execution of the process until the call is interrupted by a signal handler (or until an unhandled signal terminates the process).</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">pause</span>(void);</p>
<p class="right">Always returns &#8211;1 with <em>errno</em> set to <span class="literal">EINTR</span></p>
</div>
<p class="noindent">When a signal is handled, <em>pause()</em> is interrupted and always returns &#8211;1 with <em>errno</em> set to <span class="literal">EINTR</span>. (We say more about the <span class="literal">EINTR</span> error in <a href="ch21.xhtml#ch21lev1sec05">Section 21.5</a>.)</p>
<p class="indent">An example of the use of <em>pause()</em> is provided in <a href="ch20.xhtml#ch20ex2">Listing 20-2</a>.</p>
<p class="indent">In <a href="ch22.xhtml#ch22lev1sec09">Sections 22.9</a>, <a href="ch22.xhtml#ch22lev1sec10">22.10</a>, and <a href="ch22.xhtml#ch22lev1sec11">22.11</a>, we look at various other ways that a program can suspend execution while waiting for a signal.</p>
<h3 class="h3" id="ch20lev1sec15"><strong>20.15 Summary</strong></h3>
<p class="noindenta">A signal is a notification that some kind of event has occurred, and may be sent to a process by the kernel, by another process, or by itself. There is a range of standard signal types, each of which has a unique number and purpose.</p>
<p class="indent">Signal delivery is typically asynchronous, meaning that the point at which the signal interrupts execution of the process is unpredictable. In some cases (e.g., hardware-generated signals), signals are delivered synchronously, meaning that delivery occurs predictably and reproducibly at a certain point in the execution of a program.</p>
<p class="indent">By default, a signal either is ignored, terminates a process (with or without a core dump), stops a running process, or restarts a stopped process. The particular default action depends on the signal type. Alternatively, a program can use <em>signal()</em> or <em>sigaction()</em> to explicitly ignore a signal or to establish a programmer-defined signal handler function that is invoked when the signal is delivered. For portability reasons, establishing a signal handler is best performed using <em>sigaction()</em>.</p>
<p class="indent">A process (with suitable permissions) can send a signal to another process using <em>kill()</em>. Sending the null signal (0) is a way of determining if a particular process ID is in use.</p>
<p class="indent">Each process has a signal mask, which is the set of signals whose delivery is currently blocked. Signals can be added to and removed from the signal mask using <em>sigprocmask()</em>.</p>
<p class="indent">If a signal is received while it is blocked, then it remains pending until it is unblocked. Standard signals can&#8217;t be queued; that is, a signal can be marked as pending (and thus later delivered) only once. A process can use the <em>sigpending()</em> system call to retrieve a signal set (a data structure used to represent multiple different signals) identifying the signals that it has pending.</p>
<p class="indent"><span epub:type="pagebreak" id="page_419"/>The <em>sigaction()</em> system call provides more control and flexibility than <em>signal()</em> when setting the disposition of a signal. First, we can specify a set of additional signals to be blocked when a handler is invoked. In addition, various flags can be used to control the actions that occur when a signal handler is invoked. For example, there are flags that select the older unreliable signal semantics (not blocking the signal causing invocation of a handler, and having the disposition of the signal reset to its default before the handler is called).</p>
<p class="indent">Using <em>pause()</em>, a process can suspend execution until a signal arrives.</p>
<h5 class="h5" id="ch20lev3sec02"><strong>Further information</strong></h5>
<p class="noindenta">[<a href="bib.xhtml#bib09">Bovet &#38; Cesati, 2005</a>] and [<a href="bib.xhtml#bib63">Maxwell, 1999</a>] provide background on the implementation of signals in Linux. [<a href="bib.xhtml#bib35">Goodheart &#38; Cox, 1994</a>] details the implementation of signals on System V Release 4. The GNU C library manual (available online at <em><a href="http://www.gnu.org/">http://www.gnu.org/</a></em>) contains an extensive description of signals.</p>
<h3 class="h3" id="ch20lev1sec16"><strong>20.16 Exercises</strong></h3>
<p class="exer"><a id="ch20exe1"/><strong>20-1.</strong>&#160;&#160;&#160;As noted in <a href="ch20.xhtml#ch20lev1sec03">Section 20.3</a>, <em>sigaction()</em> is more portable than <em>signal()</em> for establishing a signal handler. Replace the use of <em>signal()</em> by <em>sigaction()</em> in the program in <a href="ch20.xhtml#ch20ex7">Listing 20-7</a> (<span class="literal">sig_receiver.c</span>).</p>
<p class="exer"><a id="ch20exe2"/><strong>20-2.</strong>&#160;&#160;&#160;Write a program that shows that when the disposition of a pending signal is changed to be <span class="literal">SIG_IGN</span>, the program never sees (catches) the signal.</p>
<p class="exer"><a id="ch20exe3"/><strong>20-3.</strong>&#160;&#160;&#160;Write programs that verify the effect of the <span class="literal">SA_RESETHAND</span> and <span class="literal">SA_NODEFER</span> flags when establishing a signal handler with <em>sigaction()</em>.</p>
<p class="exer"><a id="ch20exe4"/><strong>20-4.</strong>&#160;&#160;&#160;Implement the <em>siginterrupt()</em> function described in <a href="ch21.xhtml#ch21lev1sec05">Section 21.5</a> using <em>sigaction()</em>.<span epub:type="pagebreak" id="page_420"/></p>
</body>
</html>
