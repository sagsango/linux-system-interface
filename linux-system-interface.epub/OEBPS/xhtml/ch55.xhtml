<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch55"><span epub:type="pagebreak" id="page_1117"/><strong><span class="big">55</span></strong><br/><strong>FILE LOCKING</strong></h2>
<p class="noindenta">Previous chapters have covered various techniques that processes can use to synchronize their actions, including signals (<a href="ch20.xhtml#ch20">Chapters 20</a> to <a href="ch22.xhtml#ch22">22</a>) and semaphores (<a href="ch47.xhtml#ch47">Chapters 47</a> and <a href="ch53.xhtml#ch53">53</a>). In this chapter, we look at further synchronization techniques designed specifically for use with files.</p>
<h3 class="h3" id="ch55lev1sec01"><strong>55.1 Overview</strong></h3>
<p class="noindenta">A frequent application requirement is to read data from a file, make some change to that data, and then write it back to the file. As long as just one process at a time ever uses a file in this way, then there are no problems. However, problems can arise if multiple processes are simultaneously updating a file. Suppose, for example, that each process performs the following steps to update a file containing a sequence number:</p>
<ol>
<li class="order"><p class="orderp">Read the sequence number from the file.</p></li>
<li class="order"><p class="orderp">Use the sequence number for some application-defined purpose.</p></li>
<li class="order"><p class="orderp">Increment the sequence number and write it back to the file.</p></li>
</ol>
<p class="noindent">The problem here is that, in the absence of any synchronization technique, two processes could perform the above steps at the same time with (for example) the consequences shown in <a href="ch55.xhtml#ch55fig1">Figure 55-1</a> (here, we assume that the initial value of the sequence number is 1000).</p>
<div class="image"><span epub:type="pagebreak" id="page_1118"/><img src="../images/f55-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch55fig1"/><strong>Figure 55-1:</strong> Two processes updating a file at the same time without synchronization</p>
<p class="noindent">The problem is clear: at the end of these steps, the file contains the value 1001, when it should contain the value 1002. (This is an example of a race condition.) To prevent such possibilities, we need some form of interprocess synchronization.</p>
<p class="indent">Although we could use (say) semaphores to perform the required synchronization, using file locks is usually preferable, because the kernel automatically associates locks with files.</p>
<div class="block">
<p class="noindent">[<a href="bib.xhtml#bib94">Stevens &#38; Rago, 2005</a>] dates the first UNIX file locking implementation to 1980, and notes that <em>fcntl()</em> locking, upon which we primarily focus in this chapter, appeared in System V Release 2 in 1984.</p>
</div>
<p class="noindentb">In this chapter, we describe two different APIs for placing file locks:</p>
<p class="bull">&#8226; <em>flock()</em>, which places locks on entire files; and</p>
<p class="bull">&#8226; <em>fcntl()</em>, which places locks on regions of a file.</p>
<p class="noindentt">The <em>flock()</em> system call originated on BSD; <em>fcntl()</em> originated on System V.</p>
<p class="indent">The general method of using <em>flock()</em> and <em>fcntl()</em> is as follows:</p>
<ol>
<li class="order"><p class="orderp">Place a lock on the file.</p></li>
<li class="order"><p class="orderp">Perform file I/O.</p></li>
<li class="order"><p class="orderp">Unlock the file so that another process can lock it.</p></li>
</ol>
<p class="noindent"><span epub:type="pagebreak" id="page_1119"/>Although file locking is normally used in conjunction with file I/O, we can also use it as a more general synchronization technique. Cooperating processes can follow a convention that locking all or part of a file indicates access by a process to some shared resource other than the file itself (e.g., a shared memory region).</p>
<h5 class="h5" id="ch55lev3sec01"><strong>Mixing locking and <em>stdio</em> functions</strong></h5>
<p class="noindentab">Because of the user-space buffering performed by the <em>stdio</em> library, we should be cautious when using <em>stdio</em> functions with the locking techniques described in this chapter. The problem is that an input buffer might be filled before a lock is placed, or an output buffer may be flushed after a lock is removed. There are a few ways to avoid these problems:</p>
<p class="bull">&#8226; Perform file I/O using <em>read()</em> and <em>write()</em> (and related system calls) instead of the <em>stdio</em> library.</p>
<p class="bull">&#8226; Flush the <em>stdio</em> stream immediately after placing a lock on the file, and flush it once more immediately before releasing the lock.</p>
<p class="bull">&#8226; Perhaps at the cost of some efficiency, disable <em>stdio</em> buffering altogether using <em>setbuf()</em> (or similar).</p>
<h5 class="h5" id="ch55lev3sec02"><strong>Advisory and mandatory locking</strong></h5>
<p class="noindenta">In the remainder of this chapter, we&#8217;ll distinguish locks as being either advisory or mandatory. By default, file locks are <em>advisory</em>. This means that a process can simply ignore a lock placed by another process. In order for an advisory locking scheme to be workable, each process accessing the file must cooperate, by placing a lock before performing file I/O. By contrast, a <em>mandatory</em> locking system forces a process performing I/O to abide by the locks held by other processes. We say more about this distinction in <a href="ch55.xhtml#ch55lev1sec04">Section 55.4</a>.</p>
<h3 class="h3" id="ch55lev1sec02"><strong>55.2 File Locking with <em>flock()</em></strong></h3>
<p class="noindenta">Although <em>fcntl()</em> provides a superset of the functionality provided by <em>flock()</em>, we nevertheless describe <em>flock()</em> because it is still used in some applications, and because it differs from <em>fcntl()</em> in some of the semantics of inheritance and release of locks.</p>
<div class="box">
<p class="programsa">#include &lt;sys/file.h&gt;<br/><br/>int <span class="codestrong">flock</span>(int <span class="font1">fd</span>, int <span class="font1">operation</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>flock()</em> system call places a single lock on an entire file. The file to be locked is specified via an open file descriptor passed in <em>fd</em>. The <em>operation</em> argument specifies one of the values <span class="literal">LOCK_SH</span>, <span class="literal">LOCK_EX</span>, or <span class="literal">LOCK_UN</span>, which are described in <a href="ch55.xhtml#ch55table1">Table 55-1</a>.</p>
<p class="indent">By default, <em>flock()</em> blocks if another process already holds an incompatible lock on a file. If we want to prevent this, we can OR (<span class="literal">|</span>) the value <span class="literal">LOCK_NB</span> into <em>operation</em>. In this case, if another process already holds an incompatible lock on the file, <em>flock()</em> doesn&#8217;t block, but instead returns &#8211;1, with <em>errno</em> set to <span class="literal">EWOULDBLOCK</span>.</p>
<p class="tablecap"><span epub:type="pagebreak" id="page_1120"/><a id="ch55table1"/><strong>Table 55-1:</strong> Values for the <em>operation</em> argument of <em>flock()</em></p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Value</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">LOCK_SH</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Place a <em>shared</em> lock on the file referred to by <em>fd</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">LOCK_EX</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Place an <em>exclusive</em> lock on the file referred to by <em>fd</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">LOCK_UN</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Unlock the file referred to by <em>fd</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">LOCK_NB</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Make a nonblocking lock request</p></td>
</tr>
</tbody>
</table>
<p class="noindent">Any number of processes may simultaneously hold a shared lock on a file. However, only one process at a time can hold an exclusive lock on a file. (In other words, exclusive locks deny both exclusive and shared locks by other processes.) <a href="ch55.xhtml#ch55table2">Table 55-2</a> summarizes the compatibility rules for <em>flock()</em> locks. Here, we assume that process A is the first to place the lock, and the table indicates whether process B can then place a lock.</p>
<p class="tablecap"><a id="ch55table2"/><strong>Table 55-2:</strong> Compatibility of <em>flock()</em> locking types</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th" rowspan="2"><p class="table"><strong>Process A</strong></p></td>
<td style="vertical-align: top;" class="table_th1" colspan="2"><p class="tablec"><strong>Process B</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><span class="literal"><span class="codestrong">LOCK_SH</span></span></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="tablec"><span class="literal"><span class="codestrong">LOCK_EX</span></span></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">LOCK_SH</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Yes</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">No</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">LOCK_EX</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">No</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">No</p></td>
</tr>
</tbody>
</table>
<p class="noindent">A process can place a shared or exclusive lock regardless of the access mode (read, write, or read-write) of the file.</p>
<p class="indent">An existing shared lock can be converted to an exclusive lock (and vice versa) by making another call to <em>flock()</em> specifying the appropriate value for <em>operation</em>. Converting a shared lock to an exclusive lock will block if another process holds a shared lock on the file, unless <span class="literal">LOCK_NB</span> was also specified.</p>
<p class="indent">A lock conversion is <em>not</em> guaranteed to be atomic. During conversion, the existing lock is first removed, and then a new lock is established. Between these two steps, another process&#8217;s pending request for an incompatible lock may be granted. If this occurs, then the conversion will block, or, if <span class="literal">LOCK_NB</span> was specified, the conversion will fail and the process will lose its original lock. (This behavior occurred in the original BSD <em>flock()</em> implementation and also occurs on many other UNIX implementations.)</p>
<div class="block">
<p class="noindent">Although it is not part of SUSv3, <em>flock()</em> appears on most UNIX implementations. Some implementations require the inclusion of either <span class="literal">&lt;fcntl.h&gt;</span> or <span class="literal">&lt;sys/fcntl.h&gt;</span> instead of <span class="literal">&lt;sys/file.h&gt;</span>. Because <em>flock()</em> originates on BSD, the locks that it places are sometimes known as <em>BSD file locks</em>.</p>
</div>
<p class="noindent"><a href="ch55.xhtml#ch55ex1">Listing 55-1</a> demonstrates the use of <em>flock()</em>. This program locks a file, sleeps for a specified number of seconds, and then unlocks the file. The program takes up to three command-line arguments. The first of these is the file to lock. The second specifies the lock type (shared or exclusive) and whether or not to include the <span class="literal">LOCK_NB</span> (nonblocking) flag. The third argument specifies the number of seconds to sleep between acquiring and releasing the lock; this argument is optional and defaults to 10 seconds.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1121"/><a id="ch55ex1"/><strong>Listing 55-1:</strong> Using <em>flock()</em></p>
<p class="programsli">_______________________________________________________ <span class="codestrong">filelock/t_flock.c</span><br/><br/>#include &lt;sys/file.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include "curr_time.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declaration of currTime() */<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int fd, lock;<br/>&#160;&#160;&#160;&#160;const char *lname;<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 3 || strcmp(argv[1], "--help") == 0 ||<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;strchr("sx", argv[2][0]) == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s file lock [sleep-time]\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"&#160;&#160;&#160;&#160;'lock' is 's' (shared) or 'x' (exclusive)\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;optionally followed by 'n' (nonblocking)\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"&#160;&#160;&#160;&#160;'sleep-time' specifies time to hold lock\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;lock = (argv[2][0] == 's') ? LOCK_SH : LOCK_EX;<br/>&#160;&#160;&#160;&#160;if (argv[2][1] == 'n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lock |= LOCK_NB;<br/><br/>&#160;&#160;&#160;&#160;fd = open(argv[1], O_RDONLY);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Open file to be locked */<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open");<br/><br/>&#160;&#160;&#160;&#160;lname = (lock &#38; LOCK_SH) ? "LOCK_SH" : "LOCK_EX";<br/><br/>&#160;&#160;&#160;&#160;printf("PID %ld: requesting %s at %s\n", (long) getpid(), lname,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;currTime("%T"));<br/><br/>&#160;&#160;&#160;&#160;if (flock(fd, lock) == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno == EWOULDBLOCK)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("PID %ld: already locked - bye!", (long) getpid());<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("flock (PID=%ld)", (long) getpid());<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;printf("PID %ld: granted&#160;&#160;&#160;&#160;%s at %s\n", (long) getpid(), lname,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;currTime("%T"));<br/><br/>&#160;&#160;&#160;&#160;sleep((argc &gt; 3) ? getInt(argv[3], GN_NONNEG, "sleep-time") : 10);<br/><br/>&#160;&#160;&#160;&#160;printf("PID %ld: releasing %s at %s\n", (long) getpid(), lname,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;currTime("%T"));<br/>&#160;&#160;&#160;&#160;if (flock(fd, LOCK_UN) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("flock");<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_______________________________________________________ <span class="codestrong">filelock/t_flock.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_1122"/>Using the program in <a href="ch55.xhtml#ch55ex1">Listing 55-1</a>, we can conduct a number of experiments to explore the behavior of <em>flock()</em>. Some examples are shown in the following shell session. We begin by creating a file, and then start an instance of our program that sits in the background and holds a shared lock for 60 seconds:</p>
<p class="programs">$ <span class="codestrong">touch tfile</span><br/>$ <span class="codestrong">./t_flock tfile s 60 &#38;</span><br/>[1] 9777<br/>PID 9777: requesting LOCK_SH at 21:19:37<br/>PID 9777: granted&#160;&#160;&#160;&#160;LOCK_SH at 21:19:37</p>
<p class="noindent">Next, we start another instance of the program that successfully requests a shared lock and then releases it:</p>
<p class="programs">$ <span class="codestrong">./t_flock tfile s 2</span><br/>PID 9778: requesting LOCK_SH at 21:19:49<br/>PID 9778: granted&#160;&#160;&#160;&#160;LOCK_SH at 21:19:49<br/>PID 9778: releasing&#160;&#160;LOCK_SH at 21:19:51</p>
<p class="noindent">However, when we start another instance of the program that makes a nonblocking requests for an exclusive lock, the request immediately fails:</p>
<p class="programs">$ <span class="codestrong">./t_flock tfile xn</span><br/>PID 9779: requesting LOCK_EX at 21:20:03<br/>PID 9779: already locked - bye!</p>
<p class="noindent">When we start another instance of the program that makes a blocking request for an exclusive lock, the program blocks. When the background process that was holding a shared lock for 60 seconds releases its lock, the blocked request is granted:</p>
<p class="programs">$ <span class="codestrong">./t_flock tfile x</span><br/>PID 9780: requesting LOCK_EX at 21:20:21<br/>PID 9777: releasing&#160;&#160;LOCK_SH at 21:20:37<br/>PID 9780: granted&#160;&#160;&#160;&#160;LOCK_EX at 21:20:37<br/>PID 9780: releasing&#160;&#160;LOCK_EX at 21:20:47</p>
<h4 class="h4" id="ch55lev2sec01"><strong>55.2.1 Semantics of Lock Inheritance and Release</strong></h4>
<p class="noindenta">As shown in <a href="ch55.xhtml#ch55table1">Table 55-1</a>, we can release a file lock via an <em>flock()</em> call that specifies <em>operation</em> as <span class="literal">LOCK_UN</span>. In addition, locks are automatically released when the corresponding file descriptor is closed. However, the story is more complicated than this. A file lock obtained via <em>flock()</em> is associated with the open file description (<a href="ch05.xhtml#ch05lev1sec04">Section 5.4</a>), rather than the file descriptor or the file (i-node) itself. This means that when a file descriptor is duplicated (via <em>dup()</em>, <em>dup2()</em>, or an <em>fcntl()</em> <span class="literal">F_DUPFD</span> operation), the new file descriptor refers to the same file lock. For example, if we have obtained a lock on the file referred to by <em>fd</em>, then the following code (which omits error checking) releases that lock:</p>
<p class="programs">flock(fd, LOCK_EX);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Gain lock via 'fd' */<br/>newfd = dup(fd);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* 'newfd' refers to same lock as 'fd' */<br/>flock(newfd, LOCK_UN);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Frees lock acquired via 'fd' */</p>
<p class="noindent">If we have acquired a lock via a particular file descriptor, and we create one or more duplicates of that descriptor, then&#8212;if we don&#8217;t explicitly perform an unlock operation&#8212;the lock is released only when all of the duplicate descriptors have been closed.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1123"/>However, if we use <em>open()</em> to obtain a second file descriptor (and associated open file description) referring to the same file, this second descriptor is treated independently by <em>flock()</em>. For example, a process executing the following code will block on the second <em>flock()</em> call:</p>
<p class="programs">fd1 = open("a.txt", O_RDWR);<br/>fd2 = open("a.txt", O_RDWR);<br/>flock(fd1, LOCK_EX);<br/>flock(fd2, LOCK_EX);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Locked out by lock on 'fd1' */</p>
<p class="noindent">Thus, a process can lock itself out of a file using <em>flock()</em>. As we&#8217;ll see later, this can&#8217;t happen with record locks obtained by <em>fcntl()</em>.</p>
<p class="indent">When we create a child process using <em>fork()</em>, that child obtains duplicates of its parent&#8217;s file descriptors, and, as with descriptors duplicated via <em>dup()</em> and so on, these descriptors refer to the same open file descriptions and thus to the same locks. For example, the following code causes a child to remove a parent&#8217;s lock:</p>
<p class="programs">flock(fd, LOCK_EX);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent obtains lock */<br/>if (fork() == 0)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If child... */<br/>&#160;&#160;&#160;&#160;flock(fd, LOCK_UN);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Release lock shared with parent */</p>
<p class="noindent">These semantics can sometimes be usefully exploited to (atomically) transfer a file lock from a parent process to a child process: after the <em>fork()</em>, the parent closes its file descriptor, and the lock is under sole control of the child process. As we&#8217;ll see later, this isn&#8217;t possible using record locks obtained by <em>fcntl()</em>.</p>
<p class="indent">Locks created by <em>flock()</em> are preserved across an <em>exec()</em> (unless the close-on-exec flag was set for the file descriptor and that file descriptor was the last one referencing the underlying open file description).</p>
<p class="indent">The Linux semantics described above conform to the classical BSD implementation of <em>flock()</em>. On some UNIX implementations, <em>flock()</em> is implemented using <em>fcntl()</em>, and we&#8217;ll see later that the inheritance and release semantics of <em>fcntl()</em> locks differ from those of <em>flock()</em> locks. Because the interactions between locks created by <em>flock()</em> and <em>fcntl()</em> are undefined, an application should use only one of these locking methods on a file.</p>
<h4 class="h4" id="ch55lev2sec02"><strong>55.2.2 Limitations of <em>flock()</em></strong></h4>
<p class="noindentab">Placing locks with <em>flock()</em> suffers from a number of limitations:</p>
<p class="bull">&#8226; Only whole files can be locked. Such coarse locking limits the potential for concurrency among cooperating processes. If, for example, we have multiple processes, each of which would like to simultaneously access different parts of the same file, then locking via <em>flock()</em> would needlessly prevent these processes from operating concurrently.</p>
<p class="bull">&#8226; We can place only advisory locks with <em>flock()</em>.</p>
<p class="bull">&#8226; Many NFS implementations don&#8217;t recognize locks granted by <em>flock()</em>.</p>
<p class="noindentt">All of these limitations are addressed by the locking scheme implemented by <em>fcntl()</em>, which we describe in the next section.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_1124"/>Historically, the Linux NFS server did not support <em>flock()</em> locks. Since kernel 2.6.12, the Linux NFS server supports <em>flock()</em> locks by implementing them as an <em>fcntl()</em> lock on the entire file. This can cause some strange effects when mixing BSD locks on the server and BSD locks on the client: the clients usually won&#8217;t see the server&#8217;s locks, and vice versa.</p>
</div>
<h3 class="h3" id="ch55lev1sec03"><strong>55.3 Record Locking with <em>fcntl()</em></strong></h3>
<p class="noindenta">Using <em>fcntl()</em> (<a href="ch05.xhtml#ch05lev1sec02">Section 5.2</a>), we can place a lock on any part of a file, ranging from a single byte to the entire file. This form of file locking is usually called <em>record locking</em>. However, this term is a misnomer, because files on the UNIX system are byte sequences, with no concept of record boundaries. Any notion of records within a file is defined purely within an application.</p>
<p class="indent">Typically, <em>fcntl()</em> is used to lock byte ranges corresponding to the application-defined record boundaries within the file; hence the origin of the term <em>record locking</em>. The terms <em>byte range</em>, <em>file region</em>, and <em>file segment</em> are less commonly used, but more accurate, descriptions of this type of lock. (Because this is the only kind of locking specified in the original POSIX.1 standard and in SUSv3, it is sometimes also called POSIX file locking.)</p>
<div class="block">
<p class="noindent">SUSv3 requires record locking to be supported for regular files, and permits it to be supported for other file types. Although it generally makes sense to apply record locks only to regular files (since, for most other file types, it isn&#8217;t meaningful to talk about byte ranges for the data contained in the file), on Linux, it is possible to apply a record lock to any type of file descriptor.</p>
</div>
<p class="noindent"><a href="ch55.xhtml#ch55fig2">Figure 55-2</a> shows how record locking might be used to synchronize access by two processes to the same region of a file. (In this diagram, we assume that all lock requests are blocking, so that they will wait if a lock is held by another process.)</p>
<p class="indent">The general form of the <em>fcntl()</em> call used to create or remove a file lock is as follows:</p>
<p class="programs">struct flock flockstr;<br/><br/>/* Set fields of 'flockstr' to describe lock to be placed or removed */<br/><br/>fcntl(fd, cmd, &#38;flockstr);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Place lock defined by 'flockstr' */</p>
<p class="noindent">The <em>fd</em> argument is an open file descriptor referring to the file on which we wish to place a lock.</p>
<p class="indent">Before discussing the <em>cmd</em> argument, we first describe the <em>flock</em> structure.</p>
<h5 class="h5" id="ch55lev3sec03"><strong>The <em>flock</em> structure</strong></h5>
<p class="noindenta">The <em>flock</em> structure defines the lock that we wish to acquire or remove. It is defined as follows:</p>
<p class="programs">struct flock {<br/>&#160;&#160;&#160;&#160;short l_type;&#160;&#160;&#160;&#160;&#160;&#160;/* Lock type: F_RDLCK, F_WRLCK, F_UNLCK */<br/>&#160;&#160;&#160;&#160;short l_whence;&#160;&#160;&#160;&#160;/* How to interpret 'l_start': SEEK_SET,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SEEK_CUR, SEEK_END */<br/>&#160;&#160;&#160;&#160;off_t l_start;&#160;&#160;&#160;&#160;&#160;/* Offset where the lock begins */<br/>&#160;&#160;&#160;&#160;off_t l_len;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of bytes to lock; 0 means "until EOF" */<br/>&#160;&#160;&#160;&#160;pid_t l_pid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Process preventing our lock (F_GETLK only) */<br/>};</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1125"/>The <em>l_type</em> field indicates the type of lock we want to place. It is specified as one of the values in <a href="ch55.xhtml#ch55table3">Table 55-3</a>.</p>
<p class="indent">Semantically, read (<span class="literal">F_RDLCK</span>) and write (<span class="literal">F_WRLCK</span>) locks correspond to the shared and exclusive locks applied by <em>flock()</em>, and they follow the same compatibility rules (<a href="ch55.xhtml#ch55table2">Table 55-2</a>): any number of processes can hold read locks on a file region, but only one process can hold a write lock, and that lock excludes read and write locks by other processes. Specifying <em>l_type</em> as <span class="literal">F_UNLCK</span> is analogous to the <em>flock()</em> <span class="literal">LOCK_UN</span> operation.</p>
<p class="tablecap"><a id="ch55table3"/><strong>Table 55-3:</strong> Lock types for <em>fcntl()</em> locking</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Lock type</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">F_RDLCK</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Place a read lock</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">F_WRLCK</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Place a write lock</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">F_UNLCK</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Remove an existing lock</p></td>
</tr>
</tbody>
</table>
<div class="image"><img src="../images/f55-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch55fig2"/><strong>Figure 55-2:</strong> Using record locks to synchronize access to the same region of a file</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1126"/>In order to place a read lock on a file, the file must be open for reading. Similarly, to place a write lock, the file must be open for writing. To place both types of locks, we open the file read-write (<span class="literal">O_RDWR</span>). Attempting to place a lock that is incompatible with the file access mode results in the error <span class="literal">EBADF</span>.</p>
<p class="indentb">The <em>l_whence</em>, <em>l_start</em>, and <em>l_len</em> fields together specify the range of bytes to be locked. The first two of these fields are analogous to the <em>whence</em> and <em>offset</em> arguments to <em>lseek()</em> (<a href="ch04.xhtml#ch04lev1sec07">Section 4.7</a>). The <em>l_start</em> field specifies an offset within the file that is interpreted with respect to one of the following:</p>
<p class="bull">&#8226; the start of the file, if <em>l_whence</em> is <span class="literal">SEEK_SET</span>;</p>
<p class="bull">&#8226; the current file offset, if <em>l_whence</em> is <span class="literal">SEEK_CUR</span>; or</p>
<p class="bull">&#8226; the end of the file, if <em>l_whence</em> is <span class="literal">SEEK_END</span>.</p>
<p class="noindentt">In the last two cases, <em>l_start</em> can be a negative number, as long as the resulting file position doesn&#8217;t lie before the start of the file (byte 0).</p>
<p class="indent">The <em>l_len</em> field contains an integer specifying the number of bytes to lock, starting from the position defined by <em>l_whence</em> and <em>l_start</em>. It is possible to lock nonexistent bytes past the end of the file, but it is not possible to lock bytes before the start of the file.</p>
<p class="indent">Since kernel 2.4.21, Linux allows a negative value to be supplied in <em>l_len</em>. This is a request to lock the <em>l_len</em> bytes preceding the position specified by <em>l_whence</em> and <em>l_start</em> (i.e., bytes in the range <em>(l_start &#8211; abs(l_len))</em> through to <em>(l_start &#8211; 1)</em>). SUSv3 permits, but doesn&#8217;t require, this feature. Several other UNIX implementations also provide it.</p>
<p class="indent">In general, applications should lock the minimum range of bytes necessary. This allows greater concurrency for other processes simultaneously trying to lock different regions of the same file.</p>
<div class="block">
<p class="noindent">The term <em>minimum range</em> needs qualification in some circumstances. Mixing record locks and calls to <em>mmap()</em> can have unpleasant consequences on network file systems such as NFS and CIFS. The problem occurs because <em>mmap()</em> maps files in units of the system page size. If a file lock is page-aligned, then all is well, since the lock will cover the entire region corresponding to a dirty page. However, if the lock is not page-aligned, then there is a race condition&#8212;the kernel may write into the area that is not covered by the lock if any part of the mapped page has been modified.</p>
</div>
<p class="noindent">Specifying 0 in <em>l_len</em> has the special meaning &#8220;lock all bytes from the point specified by <em>l_start</em> and <em>l_whence</em> through to the end of the file, no matter how large the file grows.&#8221; This is convenient if we don&#8217;t know in advance how many bytes we are going to add to a file. To lock the entire file, we can specify <em>l_whence</em> as <span class="literal">SEEK_SET</span> and both <em>l_start</em> and <em>l_len</em> as 0.</p>
<h5 class="h5" id="ch55lev3sec04"><strong>The <em>cmd</em> argument</strong></h5>
<p class="noindentab">When working with file locks, three possible values may be specified for the <em>cmd</em> argument of <em>fcntl()</em>. The first two are used for acquiring and releasing locks:</p>
<p class="term"><span class="literal">F_SETLK</span></p>
<p class="termlist">Acquire (<em>l_type</em> is <span class="literal">F_RDLCK</span> or <span class="literal">F_WRLCK</span>) or release (<em>l_type</em> is <span class="literal">F_UNLCK</span>) a lock on the bytes specified by <em>flockstr</em>. If an incompatible lock is held by another <span epub:type="pagebreak" id="page_1127"/>process on any part of the region to be locked, <em>fcntl()</em> fails with the error <span class="literal">EAGAIN</span>. On some UNIX implementations, <em>fcntl()</em> fails with the error <span class="literal">EACCES</span> in this case. SUSv3 permits either possibility, and a portable application should test for both values.</p>
<p class="term"><span class="literal">F_SETLKW</span></p>
<p class="termlist">This is the same as <span class="literal">F_SETLK</span>, except that if another process holds an incompatible lock on any part of the region to be locked, then the call blocks until the lock can be granted. If we are handling signals and have not specified <span class="literal">SA_RESTART</span> (<a href="ch21.xhtml#ch21lev1sec05">Section 21.5</a>), then an <span class="literal">F_SETLKW</span> operation may be interrupted (i.e., fail with the error <span class="literal">EINTR</span>). We can take advantage of this behavior to use <em>alarm()</em> or <em>setitimer()</em> to set a timeout on the lock request.</p>
<p class="noindentt">Note that <em>fcntl()</em> locks either the entire region specified or nothing at all. There is no notion of locking just those bytes of the requested region that are currently unlocked.</p>
<p class="indentb">The remaining <em>fcntl()</em> operation is used to determine whether we can place a lock on a given region:</p>
<p class="term"><span class="literal">F_GETLK</span></p>
<p class="termlist">Check if it would be possible to acquire the lock specified in <em>flockstr</em>, but don&#8217;t actually acquire it. The <em>l_type</em> field must be <span class="literal">F_RDLCK</span> or <span class="literal">F_WRLCK</span>. The <em>flockstr</em> structure is treated as a value-result argument; on return, it contains information informing us whether or not the specified lock could be placed. If the lock would be permitted (i.e., no incompatible locks exist on the specified file region), then <span class="literal">F_UNLCK</span> is returned in the <em>l_type</em> field, and the remaining fields are left unchanged. If one or more incompatible locks exist on the region, then <em>flockstr</em> returns information about <em>one</em> of those locks (it is indeterminate which), including its type (<em>l_type</em>), range of bytes (<em>l_start</em> and <em>l_len</em>; <em>l_whence</em> is always returned as <span class="literal">SEEK_SET</span>), and the process ID of the process holding the lock (<em>l_pid</em>).</p>
<p class="noindentt">Note that there are potential race conditions when combining the use of <span class="literal">F_GETLK</span> with a subsequent <span class="literal">F_SETLK</span> or <span class="literal">F_SETLKW</span>. By the time we perform the latter operation, the information returned by <span class="literal">F_GETLK</span> may already be out of date. Thus, <span class="literal">F_GETLK</span> is less useful than it first appears. Even if <span class="literal">F_GETLK</span> says that it is possible to place a lock, we must still be prepared for an error return from <span class="literal">F_SETLK</span> or for <span class="literal">F_SETLKW</span> to block.</p>
<div class="block">
<p class="noindent">The GNU C library also implements the function <em>lockf()</em>, which is just a simplified interface layered on top of <em>fcntl()</em>. (SUSv3 specifies <em>lockf()</em>, but doesn&#8217;t specify the relationship between <em>lockf()</em> and <em>fcntl()</em>. However, most UNIX systems implement <em>lockf()</em> on top of <em>fcntl()</em>.) A call of the form <em>lockf(fd, operation, size)</em> is equivalent to a call to <em>fcntl()</em> with <em>l_whence</em> set to <span class="literal">SEEK_CUR</span>, <em>l_start</em> set to 0, and <em>l_len</em> set to <em>size</em>; that is, <em>lockf()</em> locks a sequence of bytes starting at the current file offset. The <em>operation</em> argument to <em>lockf()</em> is analogous to the <em>cmd</em> argument to <em>fcntl()</em>, but different constants are used for acquiring, releasing, and testing for the presence of locks. The <em>lockf()</em> function places only exclusive (i.e., write) locks. See the <em>lockf(3)</em> manual page for further details.</p>
</div>
<h5 class="h5" id="ch55lev3sec05"><span epub:type="pagebreak" id="page_1128"/><strong>Details of lock acquisition and release</strong></h5>
<p class="noindentab">Note the following points regarding the acquisition and release of locks created with <em>fcntl()</em>:</p>
<p class="bull">&#8226; Unlocking a file region always immediately succeeds. It is not an error to unlock a region on which we don&#8217;t currently hold a lock.</p>
<p class="bull">&#8226; At any time, a process can hold just one type of lock on a particular region of a file. Placing a new lock on a region we have already locked either results in no change (if the lock type is the same as the existing lock) or atomically converts the existing lock to the new mode. In the latter case, when converting a read lock to a write lock, we need to be prepared for the possibility that the call will yield an error (<span class="literal">F_SETLK</span>) or block (<span class="literal">F_SETLKW</span>). (This differs from <em>flock()</em>, whose lock conversions are not atomic.)</p>
<p class="bull">&#8226; A process can never lock itself out of a file region, even when placing locks via multiple file descriptors referring to the same file. (This contrasts with <em>flock()</em>, and we say more on this point in <a href="ch55.xhtml#ch55lev2sec07">Section 55.3.5</a>.)</p>
<p class="bull">&#8226; Placing a lock of a different mode in the middle of a lock we already hold results in three locks: two smaller locks in the previous mode are created on either side of the new lock (see <a href="ch55.xhtml#ch55fig3">Figure 55-3</a>). Conversely, acquiring a second lock adjacent to or overlapping an existing lock in the same mode results in a single coalesced lock covering the combined area of the two locks. Other permutations are possible. For example, unlocking a region in the middle of a larger existing lock leaves two smaller locked regions on either side of the unlocked region. If a new lock overlaps an existing lock with a different mode, then the existing lock is shrunk, because the overlapping bytes are incorporated into the new lock.</p>
<p class="bull">&#8226; Closing a file descriptor has some unusual semantics with respect to file region locks. We describe these semantics in <a href="ch55.xhtml#ch55lev2sec07">Section 55.3.5</a>.</p>
<div class="image"><img src="../images/f55-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch55fig3"/><strong>Figure 55-3:</strong> Splitting of an existing read lock by a write lock by the same process</p>
<h4 class="h4" id="ch55lev2sec03"><strong>55.3.1 Deadlock</strong></h4>
<p class="noindenta">When using <span class="literal">F_SETLKW</span>, we need to be aware of the type of scenario illustrated in <a href="ch55.xhtml#ch55fig4">Figure 55-4</a>. In this scenario, each process&#8217;s second lock request is blocked by a lock held by the other process. Such a scenario is referred to as a <em>deadlock</em>. If unchecked by the kernel, this would leave both processes blocked forever. To prevent this possibility, the kernel checks each new lock request made via <span class="literal">F_SETLKW</span> to see if it would result in a deadlock situation. If it would, then the kernel selects one <span epub:type="pagebreak" id="page_1129"/>of the blocked processes and causes its <em>fcntl()</em> call to unblock and fail with the error <span class="literal">EDEADLK</span>. (On Linux, the process making the most recent <em>fcntl()</em> call is selected, but this is not required by SUSv3, and may not hold true on future versions of Linux or on other UNIX implementations. Any process using <span class="literal">F_SETLKW</span> must be prepared to handle an <span class="literal">EDEADLK</span> error.)</p>
<div class="image"><img src="../images/f55-04.jpg" alt="image"/></div>
<p class="figcap"><a id="ch55fig4"/><strong>Figure 55-4:</strong> Deadlock when two processes deny each other&#8217;s lock requests</p>
<p class="noindent">Deadlock situations are detected even when placing locks on multiple different files, as are circular deadlocks involving multiple processes. (By <em>circular deadlock</em>, we mean, for example, process A waiting to acquire a lock on a region locked by process B, process B waiting on a lock held by process C, and process C waiting on a lock held by process A.)</p>
<h4 class="h4" id="ch55lev2sec04"><strong>55.3.2 Example: An Interactive Locking Program</strong></h4>
<p class="noindenta">The program shown in <a href="ch55.xhtml#ch55ex2">Listing 55-2</a> allows us to interactively experiment with record locking. This program takes a single command-line argument: the name of a file on which we wish to place locks. Using this program, we can verify many of our previous statements regarding the operation of record locking. The program is designed to be used interactively and accepts commands of this form:</p>
<div class="box2">
<p class="noindenta"><em>cmd lock start length</em> <span class="literal">[</span> <em>whence</em> <span class="literal">]</span></p>
</div>
<p class="noindent">For <em>cmd</em>, we can specify <em>g</em> to perform an <span class="literal">F_GETLK</span>, <em>s</em> to perform an <span class="literal">F_SETLK</span>, or <em>w</em> to perform an <span class="literal">F_SETLKW</span>. The remaining arguments are used to initialize the <em>flock</em> structure passed to <em>fcntl()</em>. The <em>lock</em> argument specifies the value for the <em>l_type</em> field and is <em>r</em> for <span class="literal">F_RDLCK</span>, <em>w</em> for <span class="literal">F_WRLCK</span>, or <em>u</em> for <span class="literal">F_UNLCK</span>. The <em>start</em> and <em>length</em> arguments are integers specifying the values for the <em>l_start</em> and <em>l_len</em> fields. Finally, the optional <em>whence</em> argument specifies the value for the <em>l_whence</em> field, and may be <em>s</em> for <span class="literal">SEEK_SET</span> (the default), <em>c</em> for <span class="literal">SEEK_CUR</span>, or <em>e</em> for <span class="literal">SEEK_END</span>. (For an explanation of why we cast the <em>l_start</em> and <em>l_len</em> fields to <em>long long</em> in the <em>printf()</em> call in <a href="ch55.xhtml#ch55ex2">Listing 55-2</a>, see <a href="ch05.xhtml#ch05lev1sec10">Section 5.10</a>.)</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1130"/><a id="ch55ex2"/><strong>Listing 55-2:</strong> Experimenting with record locking</p>
<p class="programsli">____________________________________________ <span class="codestrong">filelock/i_fcntl_locking.c</span><br/><br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>#define MAX_LINE 100<br/><br/>static void<br/>displayCmdFmt(void)<br/>{<br/>&#160;&#160;&#160;&#160;printf("\n&#160;&#160;&#160;&#160;Format: cmd lock start length [whence]\n\n");<br/>&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;'cmd' is 'g' (GETLK), 's' (SETLK), or 'w' (SETLKW)\n");<br/>&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;'lock' is 'r' (READ), 'w' (WRITE), or 'u' (UNLOCK)\n");<br/>&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;'start' and 'length' specify byte range to lock\n");<br/>&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;'whence' is 's' (SEEK_SET, default), 'c' (SEEK_CUR), "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"or 'e' (SEEK_END)\n\n");<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int fd, numRead, cmd, status;<br/>&#160;&#160;&#160;&#160;char lock, cmdCh, whence, line[MAX_LINE];<br/>&#160;&#160;&#160;&#160;struct flock fl;<br/>&#160;&#160;&#160;&#160;long long len, st;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s file\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;fd = open(argv[1], O_RDWR);<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open (%s)", argv[1]);<br/><br/>&#160;&#160;&#160;&#160;printf("Enter ? for help\n");<br/><br/>&#160;&#160;&#160;&#160;for (;;) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Prompt for locking command and carry it out */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("PID=%ld&gt; ", (long) getpid());<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fflush(stdout);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (fgets(line, MAX_LINE, stdin) == NULL)&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* EOF */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;line[strlen(line) - 1] = '\0';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Remove trailing '\n' */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (*line == '\0')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Skip blank lines */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (line[0] == '?') {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;displayCmdFmt();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;whence = 's';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* In case not otherwise filled in */<br/><span epub:type="pagebreak" id="page_1131"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numRead = sscanf(line, "%c %c %lld %lld %c", &#38;cmdCh, &#38;lock,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#38;st, &#38;len, &#38;whence);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fl.l_start = st;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fl.l_len = len;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead &lt; 4 || strchr("gsw", cmdCh) == NULL ||<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;strchr("rwu", lock) == NULL || strchr("sce", whence) == NULL) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Invalid command!\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cmd = (cmdCh == 'g') ? F_GETLK : (cmdCh == 's') ? F_SETLK : F_SETLKW;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fl.l_type = (lock == 'r') ? F_RDLCK : (lock == 'w') ? F_WRLCK : F_UNLCK;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fl.l_whence = (whence == 'c') ? SEEK_CUR :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(whence == 'e') ? SEEK_END : SEEK_SET;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;status = fcntl(fd, cmd, &#38;fl);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Perform request... */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (cmd == F_GETLK) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* ... and see what happened */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (status == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("fcntl - F_GETLK");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (fl.l_type == F_UNLCK)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("[PID=%ld] Lock can be placed\n", (long) getpid());<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Locked out by someone else */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("[PID=%ld] Denied by %s lock on %lld:%lld "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"(held by PID %ld)\n", (long) getpid(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(fl.l_type == F_RDLCK) ? "READ" : "WRITE",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long long) fl.l_start,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long long) fl.l_len, (long) fl.l_pid);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* F_SETLK, F_SETLKW */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (status == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("[PID=%ld] %s\n", (long) getpid(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(lock == 'u') ? "unlocked" : "got lock");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (errno == EAGAIN || errno == EACCES)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* F_SETLK */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("[PID=%ld] failed (incompatible lock)\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) getpid());<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (errno == EDEADLK)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* F_SETLKW */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("[PID=%ld] failed (deadlock)\n", (long) getpid());<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("fcntl - F_SETLK(W)");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>____________________________________________ <span class="codestrong">filelock/i_fcntl_locking.c</span></p>
<p class="noindent">In the following shell session logs, we demonstrate the use of the program in <a href="ch55.xhtml#ch55ex2">Listing 55-2</a> by running two instances to place locks on the same 100-byte file (<span class="literal">tfile</span>). <a href="ch55.xhtml#ch55fig5">Figure 55-5</a> shows the state of granted and queued lock requests at various points during this shell session log, as noted in the commentary below.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1132"/>We start a first instance (process A) of the program in <a href="ch55.xhtml#ch55ex2">Listing 55-2</a>, placing a read lock on bytes 0 to 39 of the file:</p>
<p class="programs"><span class="codestrong">Terminal window 1</span><br/>$ <span class="codestrong">ls -l tfile</span><br/>-rw-r--r--&#160;&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;100 Apr 18 12:19 tfile<br/>$ <span class="codestrong">./i_fcntl_locking tfile</span><br/>Enter ? for help<br/>PID=790&gt; <span class="codestrong">s r 0 40</span><br/>[PID=790] got lock</p>
<p class="noindent">Then we start a second instance of the program (process B), placing a read lock on a bytes 70 through to the end of the file:</p>
<p class="programs3"><span class="codestrong">Terminal window 2</span><br/>$ <span class="codestrong">./i_fcntl_locking tfile</span><br/>Enter ? for help<br/>PID=800&gt; <span class="codestrong">s r -30 0 e</span><br/>[PID=800] got lock</p>
<p class="noindent">At this point, things appear as shown in part <em>a</em> of <a href="ch55.xhtml#ch55fig5">Figure 55-5</a>, where process A (process ID 790) and process B (process ID 800) hold locks on different parts of the file.</p>
<p class="indent">Now we return to process A, where we try to place a write lock on the entire file. We first employ <span class="literal">F_GETLK</span> to test whether the lock can be placed and are informed that there is a conflicting lock. Then we try placing the lock with <span class="literal">F_SETLK</span>, which also fails. Finally, we try placing the lock with <span class="literal">F_SETLKW</span>, which blocks.</p>
<p class="programs">PID=790&gt; <span class="codestrong">g w 0 0</span><br/>[PID=790] Denied by READ lock on 70:0 (held by PID 800)<br/>PID=790&gt; <span class="codestrong">s w 0 0</span><br/>[PID=790] failed (incompatible lock)<br/>PID=790&gt; <span class="codestrong">w w 0 0</span></p>
<p class="noindent">At this point, things appear as shown in part <em>b</em> of <a href="ch55.xhtml#ch55fig5">Figure 55-5</a>, where process A and process B each hold a lock on different parts of the file, and process A has a queued lock request on the whole file.</p>
<p class="indent">We continue in process B, by trying to place a write lock on the entire file. We first test whether the lock can be placed using <span class="literal">F_GETLK</span>, which informs us that there is a conflicting lock. We then try placing the lock using <span class="literal">F_SETLKW</span>.</p>
<p class="programs3">PID=800&gt; <span class="codestrong">g w 0 0</span><br/>[PID=800] Denied by READ lock on 0:40<br/>(held by PID 790)<br/>PID=800&gt; <span class="codestrong">w w 0 0</span><br/>[PID=800] failed (deadlock)</p>
<p class="noindent">Part <em>c</em> of <a href="ch55.xhtml#ch55fig5">Figure 55-5</a> shows what happened when process B made a blocking request to place a write lock on the entire file: a deadlock. At this point, the kernel selected one of the lock requests to fail&#8212;in this case, the request by process B, which then receives the <span class="literal">EDEADLK</span> error from its <em>fcntl()</em> call.</p>
<p class="indent">We continue in process B, by removing all of its locks on the file:</p>
<p class="programs">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PID=800&gt; <span class="codestrong">s u 0 0</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[PID=800] unlocked<br/>[PID=790] got lock</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1133"/>As we see from the last line of output, this allowed process A&#8217;s blocked lock request to be granted.</p>
<p class="indent">It is important to realize that even though process B&#8217;s deadlocked request was canceled, it still held its other lock, and so process A&#8217;s queued lock request remained blocked. Process A&#8217;s lock request is granted only when process B removes its other lock, bringing about the situation shown in part <em>d</em> of <a href="ch55.xhtml#ch55fig5">Figure 55-5</a>.</p>
<div class="image"><img src="../images/f55-05.jpg" alt="image"/></div>
<p class="figcap"><a id="ch55fig5"/><strong>Figure 55-5:</strong> State of granted and queued lock requests while running <span class="literal">i_fcntl_locking.c</span></p>
<h4 class="h4" id="ch55lev2sec05"><strong>55.3.3 Example: A Library of Locking Functions</strong></h4>
<p class="noindentab"><a href="ch55.xhtml#ch55ex3">Listing 55-3</a> provides a set of locking functions that we can use in other programs. These functions are as follows:</p>
<p class="bull">&#8226; The <em>lockRegion()</em> function uses <span class="literal">F_SETLK</span> to place a lock on the open file referred to by the file descriptor <em>fd</em>. The <em>type</em> argument specifies the lock type (<span class="literal">F_RDLCK</span> or <span class="literal">F_WRLCK</span>). The <em>whence</em>, <em>start</em>, and <em>len</em> arguments specify the range of bytes to lock. These arguments provide the values for the similarly named fields of the <em>flock</em> structure that is used to place the lock.</p>
<p class="bull">&#8226; The <em>lockRegionWait()</em> function is like <em>lockRegion()</em>, but makes a blocking lock request; that is, it uses <span class="literal">F_SETLKW</span>, rather than <span class="literal">F_SETLK</span>.</p>
<p class="bull"><span epub:type="pagebreak" id="page_1134"/>&#8226; The <em>regionIsLocked()</em> function tests whether a lock can be placed on a file. The arguments of this function are as for <em>lockRegion()</em>. This function returns 0 (false) if no process holds a lock that conflicts with the lock specified in the call. If one or more processes hold conflicting locks, then this function returns a nonzero value (i.e., true)&#8212;the process ID of one of the processes holding a conflicting lock.</p>
<p class="examplet"><a id="ch55ex3"/><strong>Listing 55-3:</strong> File region locking functions</p>
<p class="programsli">_____________________________________________ <span class="codestrong">filelock/region_locking.c</span><br/><br/>#include &lt;fcntl.h&gt;<br/>#include "region_locking.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declares functions defined here */<br/><br/>/* Lock a file region (private; public interfaces below) */<br/><br/>static int<br/>lockReg(int fd, int cmd, int type, int whence, int start, off_t len)<br/>{<br/>&#160;&#160;&#160;&#160;struct flock fl;<br/><br/>&#160;&#160;&#160;&#160;fl.l_type = type;<br/>&#160;&#160;&#160;&#160;fl.l_whence = whence;<br/>&#160;&#160;&#160;&#160;fl.l_start = start;<br/>&#160;&#160;&#160;&#160;fl.l_len = len;<br/><br/>&#160;&#160;&#160;&#160;return fcntl(fd, cmd, &#38;fl);<br/>}<br/><br/>int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Lock a file region using nonblocking F_SETLK */<br/>lockRegion(int fd, int type, int whence, int start, int len)<br/>{<br/>&#160;&#160;&#160;&#160;return lockReg(fd, F_SETLK, type, whence, start, len);<br/>}<br/><br/>int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Lock a file region using blocking F_SETLKW */<br/>lockRegionWait(int fd, int type, int whence, int start, int len)<br/>{<br/>&#160;&#160;&#160;&#160;return lockReg(fd, F_SETLKW, type, whence, start, len);<br/>}<br/><br/>/* Test if a file region is lockable. Return 0 if lockable, or<br/>&#160;&#160;&#160;PID of process holding incompatible lock, or -1 on error. */<br/><br/>pid_t<br/>regionIsLocked(int fd, int type, int whence, int start, int len)<br/>{<br/>&#160;&#160;&#160;&#160;struct flock fl;<br/><br/>&#160;&#160;&#160;&#160;fl.l_type = type;<br/>&#160;&#160;&#160;&#160;fl.l_whence = whence;<br/>&#160;&#160;&#160;&#160;fl.l_start = start;<br/>&#160;&#160;&#160;&#160;fl.l_len = len;<br/>&#160;&#160;&#160;&#160;if (fcntl(fd, F_GETLK, &#38;fl) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/>&#160;&#160;&#160;&#160;return (fl.l_type == F_UNLCK) ? 0 : fl.l_pid;<br/>}<br/>_____________________________________________ <span class="codestrong">filelock/region_locking.c</span></p>
<h4 class="h4" id="ch55lev2sec06"><span epub:type="pagebreak" id="page_1135"/><strong>55.3.4 Lock Limits and Performance</strong></h4>
<p class="noindenta">SUSv3 allows an implementation to place fixed, system-wide upper limits on the number of record locks that can be acquired. When this limit is reached, <em>fcntl()</em> fails with the error <span class="literal">ENOLCK</span>. Linux doesn&#8217;t set a fixed upper limit on the number of record locks that may be acquired; we are merely limited by availability of memory. (Many other UNIX implementations are similar.)</p>
<p class="indentb">How quickly can record locks be acquired and released? There is no fixed answer to this question, since the speed of these operations is a function of the kernel data structure used to maintain record locks and the location of a particular lock within that data structure. We look at this structure in a moment, but first we consider some requirements that influence its design:</p>
<p class="bull">&#8226; The kernel needs to be able to merge a new lock with any existing locks (held by the same process) of the same mode that may lie on either side of the new lock.</p>
<p class="bull">&#8226; A new lock may completely replace one or more existing locks held by the calling process. The kernel needs to be able to easily locate all of these locks.</p>
<p class="bull">&#8226; When creating a new lock with a different mode in the middle of an existing lock, the job of splitting the existing lock (<a href="ch55.xhtml#ch55fig3">Figure 55-3</a>) should be simple.</p>
<p class="noindentt">The kernel data structure used to maintain information about locks is designed to satisfy these requirements. Each open file has an associated linked list of locks held against that file. Locks within the list are ordered, first by process ID, and then by starting offset. An example of such a list is shown in <a href="ch55.xhtml#ch55fig6">Figure 55-6</a>.</p>
<div class="block">
<p class="noindent">The kernel also maintains <em>flock()</em> locks and file leases in the linked list of locks associated with an open file. (We briefly describe file leases when discussing the <span class="literal">/proc/locks</span> file in <a href="ch55.xhtml#ch55lev1sec05">Section 55.5</a>.) However, these types of locks are typically far fewer in number and therefore less likely to impact performance, so we ignore them in our discussion.</p>
</div>
<div class="image"><img src="../images/f55-06.jpg" alt="image"/></div>
<p class="figcap"><a id="ch55fig6"/><strong>Figure 55-6:</strong> Example of a record lock list for a single file</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1136"/>Whenever a new lock is added to this data structure, the kernel must check for conflicts with any existing lock on the file. This search is carried out sequentially, starting at the head of the list.</p>
<p class="indent">Assuming a large number of locks distributed randomly among many processes, we can say that the time required to add or remove a lock increases roughly linearly with the number of locks already held on the file.</p>
<h4 class="h4" id="ch55lev2sec07"><strong>55.3.5 Semantics of Lock Inheritance and Release</strong></h4>
<p class="noindentab">The semantics of <em>fcntl()</em> record lock inheritance and release differ substantially from those for locks created using <em>flock()</em>. Note the following points:</p>
<p class="bull">&#8226; Record locks are not inherited across a <em>fork()</em> by a child process. This contrasts with <em>flock()</em>, where the child inherits a reference to the <em>same</em> lock and can release this lock, with the consequence that the parent also loses the lock.</p>
<p class="bull">&#8226; Record locks are preserved across an <em>exec()</em>. (However, note the effect of the close-on-exec flag, described below.)</p>
<p class="bull">&#8226; All of the threads in a process share the same set of record locks.</p>
<p class="bull">&#8226; Record locks are associated with both a process and an i-node (refer to <a href="ch05.xhtml#ch05lev1sec04">Section 5.4</a>). An unsurprising consequence of this association is that when a process terminates, all of its record locks are released. Less expected is that whenever a process closes a file descriptor, <em>all</em> locks held by the process on the corresponding file are released, regardless of the file descriptor(s) through which the locks were obtained. For example, in the following code, the <em>close(fd2)</em> call releases the lock held by the calling process on <span class="literal">testfile</span>, even though the lock was obtained via the file descriptor <em>fd1</em>:</p>
<p class="programsbl">struct flock fl;<br/><br/>fl.l_type = F_WRLCK;<br/>fl.l_whence = SEEK_SET;<br/>fl.l_start = 0;<br/>fl.l_len = 0;<br/><br/>fd1 = open("testfile", O_RDWR);<br/>fd2 = open("testfile", O_RDWR);<br/><br/>if (fcntl(fd1, cmd, &#38;fl) == -1)<br/>&#160;&#160;&#160;&#160;errExit("fcntl");<br/><br/>close(fd2);</p>
<p class="noindent">The semantics described in the last point apply no matter how the various descriptors referring to the same file were obtained and no matter how the descriptor is closed. For example, <em>dup()</em>, <em>dup2()</em>, and <em>fcntl()</em> can all be used to obtain duplicates of an open file descriptor. And, as well as performing an explicit <em>close()</em>, a descriptor can be closed by an <em>exec()</em> call if the close-on-exec flag was set, or via a <em>dup2()</em> call, which closes its second file descriptor argument if that descriptor is already open.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1137"/>The semantics of <em>fcntl()</em> lock inheritance and release are an architectural blemish. For example, they make the use of record locks from library packages problematic, since a library function can&#8217;t prevent the possibility that its caller will close a file descriptor referring to a locked file and thus remove a lock obtained by the library code. An alternative implementation scheme would have been to associate a lock with a file descriptor rather than with an i-node. However, the current semantics are the historical and now standardized behavior of record locks. Unfortunately, these semantics greatly limit the utility of <em>fcntl()</em> locking.</p>
<div class="block">
<p class="noindent">With <em>flock()</em>, a lock is associated only with an open file description, and remains in effect until either any process holding a reference to the lock explicitly releases the lock or all file descriptors referring to the open file description are closed.</p>
</div>
<h4 class="h4" id="ch55lev2sec08"><strong>55.3.6 Lock Starvation and Priority of Queued Lock Requests</strong></h4>
<p class="noindenta">When multiple processes must wait in order to place a lock on a currently locked region, a couple of questions arise.</p>
<p class="indent">Can a process waiting to place a write lock be starved by a series of processes placing read locks on the same region? On Linux (as on many other UNIX implementations), a series of read locks can indeed starve a blocked write lock, possibly indefinitely.</p>
<p class="indentb">When two or more processes are waiting to place a lock, are there any rules that determine which process obtains the lock when it becomes available? For example, are lock requests satisfied in FIFO order? And do the rules depend on the types of locks being requested by each process (i.e., does a process requesting a read lock have priority over one requesting a write lock or vice versa, or neither)? On Linux, the rules are as follows:</p>
<p class="bull">&#8226; The order in which queued lock requests are granted is indeterminate. If multiple processes are waiting to place locks, then the order in which they are satisfied depends on how the processes are scheduled.</p>
<p class="bull">&#8226; Writers don&#8217;t have priority over readers, and vice versa.</p>
<p class="noindentt">Such statements don&#8217;t necessarily hold true on other systems. On some UNIX implementations, lock requests are served in FIFO order, and readers have priority over writers.</p>
<h3 class="h3" id="ch55lev1sec04"><strong>55.4 Mandatory Locking</strong></h3>
<p class="noindentab">The kinds of locks we have described so far are <em>advisory</em>. This means that a process is free to ignore the use of <em>fcntl()</em> (or <em>flock()</em>) and simply perform I/O on the file. The kernel doesn&#8217;t prevent this. When using advisory locking, it is up to the application designer to:</p>
<p class="bull">&#8226; set appropriate ownership (or group ownership) and permissions for the file, so as to prevent noncooperating process from performing file I/O; and</p>
<p class="bull">&#8226; ensure that the processes composing the application cooperate by obtaining the appropriate lock on the file before performing I/O.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_1138"/>Linux, like many other UNIX implementations, also allows <em>fcntl()</em> record locks to be <em>mandatory</em>. This means that every file I/O operation is checked to see whether it is compatible with any locks held by other processes on the region of the file on which I/O is being performed.</p>
<div class="block">
<p class="noindent">Advisory mode locking is sometimes referred to as <em>discretionary locking</em>, while mandatory locking is sometimes referred to as <em>enforcement-mode locking</em>. SUSv3 doesn&#8217;t specify mandatory locking, but it is available (with some variation in the details) on most modern UNIX implementations.</p>
</div>
<p class="noindent">In order to use mandatory locking on Linux, we must enable it on the file system containing the files we wish to lock and on each file to be locked. We enable mandatory locking on a file system by mounting it with the (Linux-specific) <em>&#8211;o mand</em> option:</p>
<p class="programs"># <span class="codestrong">mount -o mand /dev/sda10 /testfs</span></p>
<p class="noindent">From a program, we can achieve the same result by specifying the <span class="literal">MS_MANDLOCK</span> flag when calling <em>mount(2)</em> (<a href="ch14.xhtml#ch14lev2sec01">Section 14.8.1</a>).</p>
<p class="indent">We can check whether a mounted file system has mandatory locking enabled by looking at the output of the <em>mount(8)</em> command with no options:</p>
<p class="programs"># <span class="codestrong">mount | grep sda10</span><br/>/dev/sda10 on /testfs type ext3 (rw,mand)</p>
<p class="noindent">Mandatory locking is enabled on a file by the combination of having the set-group-ID permission bit turned on and the group-execute permission turned off. This combination of permission bits was otherwise meaningless and unused in earlier UNIX implementations. In this way, later UNIX systems added mandatory locking without needing to change existing programs or add new system calls. From the shell, we can enable mandatory locking on a file as follows:</p>
<p class="programs">$ <span class="codestrong">chmod g+s,g-x /testfs/file</span></p>
<p class="noindent">From a program, we can enable mandatory locking for a file by setting permissions appropriately using <em>chmod()</em> or <em>fchmod()</em> (<a href="ch15.xhtml#ch15lev2sec11">Section 15.4.7</a>).</p>
<p class="indent">When displaying permissions for a file whose permission bits are set for mandatory locking, <em>ls(1)</em> displays an <em>S</em> in the group-execute permission column:</p>
<p class="programs">$ <span class="codestrong">ls -l /testfs/file</span><br/>-rw-r-Sr--&#160;&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;&#160;&#160;0 Apr 22 14:11 /testfs/file</p>
<p class="noindent">Mandatory locking is supported for all native Linux and UNIX file systems, but may not be supported on some network file systems or on non-UNIX file systems. For example, Microsoft&#8217;s VFAT file system has no set-group-ID permission bit, so mandatory locking can&#8217;t be used on VFAT file systems.</p>
<h5 class="h5" id="ch55lev3sec06"><strong>Effect of mandatory locking on file I/O operations</strong></h5>
<p class="noindenta">If mandatory locking is enabled for a file, what happens when a system call that performs data transfer (e.g., <em>read()</em> or <em>write()</em>) encounters a lock conflict (i.e., an attempt is made to write to a region that is currently read or write locked, or to read from a region that is currently write locked)? The answer depends on whether the file has been opened in blocking or nonblocking mode. If the file was opened <span epub:type="pagebreak" id="page_1139"/>in blocking mode, the system call blocks. If the file was opened with the <span class="literal">O_NONBLOCK</span> flag, the system call immediately fails with the error <span class="literal">EAGAIN</span>. Similar rules apply for <em>truncate()</em> and <em>ftruncate()</em>, if the bytes they are attempting to add or remove from the file overlap a region currently locked (for reading or writing) by another process.</p>
<p class="indent">If we have opened a file in blocking mode (i.e., <span class="literal">O_NONBLOCK</span> is not specified in the <em>open()</em> call), then I/O system calls can be involved in deadlock situations. Consider the example shown in <a href="ch55.xhtml#ch55fig7">Figure 55-7</a>, involving two processes that open the same file for blocking I/O, obtain write locks on different parts of the file, and then each attempt to write to the region locked by the other process. The kernel resolves this situation in the same way that deadlock between two <em>fcntl()</em> calls is resolved (<a href="ch55.xhtml#ch55lev2sec03">Section 55.3.1</a>): it selects one of the processes involved in the deadlock and causes its <em>write()</em> system call to fail with the error <span class="literal">EDEADLK</span>.</p>
<div class="image"><img src="../images/f55-07.jpg" alt="image"/></div>
<p class="figcap"><a id="ch55fig7"/><strong>Figure 55-7:</strong> Deadlock when mandatory locking is in force</p>
<p class="noindent">Attempts to <em>open()</em> a file with the <span class="literal">O_TRUNC</span> flag always fail immediately (with the error <span class="literal">EAGAIN</span>) if any other process holds a read or write lock on any part of the file.</p>
<p class="indent">It is not possible to create a shared memory mapping (i.e., <em>mmap()</em> with the <span class="literal">MAP_SHARED</span> flag) on a file if any other process holds a mandatory read or write lock on <em>any</em> part of the file. Conversely, it is not possible to place a mandatory lock on <em>any</em> part of a file that is currently involved in a shared memory mapping. In both cases, the relevant system call fails immediately with the error <span class="literal">EAGAIN</span>. The reason for these restrictions becomes clear when we consider the implementation of memory mappings. In <a href="ch49.xhtml#ch49lev2sec02">Section 49.4.2</a>, we saw that a shared file mapping both reads from and writes to a file (and the latter operation, in particular, conflicts with any type of lock on the file). Furthermore, this file I/O is performed by the memory-management subsystem, which has no knowledge of the location of any file locks in the system. Thus, to prevent a mapping from updating a file on which a mandatory lock is held, the kernel performs a simple check&#8212;testing at the time of the <em>mmap()</em> call whether there are locks anywhere in the file to be mapped (and vice versa for <em>fcntl()</em>).</p>
<h5 class="h5" id="ch55lev3sec07"><span epub:type="pagebreak" id="page_1140"/><strong>Mandatory locking caveats</strong></h5>
<p class="noindentab">Mandatory locks do less for us than we might at first expect, and have some potential shortcomings and problems:</p>
<p class="bull">&#8226; Holding a mandatory lock on a file doesn&#8217;t prevent another process from deleting it, since all that is required to unlink a file is suitable permissions on the parent directory.</p>
<p class="bull">&#8226; Careful consideration should be applied before enabling mandatory locks on a publicly accessible file, since not even privileged processes can override a mandatory lock. A malicious user could continuously hold a lock on the file in order to create a denial-of-service attack. (While in most cases, we could make the file accessible once more by turning off the set-group-ID bit, this may not be possible if, for example, the mandatory file lock is causing the system to hang.)</p>
<p class="bull">&#8226; There is a performance cost associated with the use of mandatory locking. For each I/O system call made on a file with mandatory locking enabled, the kernel must check for lock conflicts on the file. If the file has a large number of locks, this check can slow I/O system calls significantly.</p>
<p class="bull">&#8226; Mandatory locking also incurs a cost in application design. We need to handle the possibility that each I/O system call can return <span class="literal">EAGAIN</span> (for nonblocking I/O) or <span class="literal">EDEADLK</span> (for blocking I/O).</p>
<p class="bull">&#8226; As a consequence of some kernel race conditions in the current Linux implementation, there are circumstances in which system calls that perform I/O operations can succeed despite the presence of mandatory locks that should deny those operations.</p>
<p class="noindentt">In summary, the use of mandatory locks is best avoided.</p>
<h3 class="h3" id="ch55lev1sec05"><strong>55.5 The</strong> <span class="literal"><span class="codestrong">/proc/locks</span></span> <strong>File</strong></h3>
<p class="noindenta">We can view the set of locks currently held in the system by examining the contents of the Linux-specific <span class="literal">/proc/locks</span> file. Here is an example of the information we can see in this file (in this case, for four locks):</p>
<p class="programs">$ <span class="codestrong">cat /proc/locks</span><br/>1: POSIX&#160;&#160;ADVISORY&#160;&#160;WRITE 458 03:07:133880 0 EOF<br/>2: FLOCK&#160;&#160;ADVISORY&#160;&#160;WRITE 404 03:07:133875 0 EOF<br/>3: POSIX&#160;&#160;ADVISORY&#160;&#160;WRITE 312 03:07:133853 0 EOF<br/>4: FLOCK&#160;&#160;ADVISORY&#160;&#160;WRITE 274 03:07:81908 0 EOF</p>
<p class="noindent">The <span class="literal">/proc/locks</span> file displays information about locks created by both <em>flock()</em> and <em>fcntl()</em>. The eight fields shown for each lock are as follows (from left to right):</p>
<ol>
<li class="order"><p class="orderp">The ordinal number of the lock within the set of all locks shown in this file. (Refer to <a href="ch55.xhtml#ch55lev2sec06">Section 55.3.4</a>.)</p></li>
<li class="order"><p class="orderp">The type of lock. Here, <span class="literal">FLOCK</span> indicates a lock created by <em>flock()</em>, and <span class="literal">POSIX</span> indicates a lock created by <em>fcntl()</em>.</p></li>
<li class="order"><p class="orderp">The mode of the lock, either <span class="literal">ADVISORY</span> or <span class="literal">MANDATORY</span>.</p></li>
<li class="order"><p class="orderp"><span epub:type="pagebreak" id="page_1141"/>The type of lock, either <span class="literal">READ</span> or <span class="literal">WRITE</span> (corresponding to shared and exclusive locks for <em>flock()</em>).</p></li>
<li class="order"><p class="orderp">The process ID of the process holding the lock.</p></li>
<li class="order"><p class="orderp">Three colon-separated numbers that identify the file on which the lock is held. These numbers are the major and minor device numbers of the file system on which the file resides, followed by the i-node number of the file.</p></li>
<li class="order"><p class="orderp">The starting byte of the lock. This is always 0 for <em>flock()</em> locks.</p></li>
<li class="order"><p class="orderp">The ending byte of the lock. Here, <span class="literal">EOF</span> indicates that the lock runs to the end of the file (i.e., <em>l_len</em> was specified as 0 for a lock created by <em>fcntl()</em>). For <em>flock()</em> locks, this column is always <span class="literal">EOF</span>.</p></li>
</ol>
<div class="block2">
<p class="noindent">In Linux 2.4 and earlier, each line of <span class="literal">/proc/locks</span> includes five additional hexadecimal values. These are pointer addresses used by the kernel to record locks in various lists. These values are not useful in application programs.</p>
</div>
<p class="noindent">Using the information in <span class="literal">/proc/locks</span>, we can find out which process is holding a lock, and on what file. The following shell session shows how to do this for lock number 3 in the list above. This lock is held by process ID 312, on the i-node 133853 on the device with major ID 3 and minor ID 7. We begin by using <em>ps(1)</em> to list information about the process with process ID 312:</p>
<p class="programs">$ <span class="codestrong">ps -p 312</span><br/>&#160;&#160;PID TTY&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;TIME CMD<br/>&#160;&#160;312 ?&#160;&#160;&#160;&#160;&#160;&#160;&#160;00:00:00 atd</p>
<p class="noindent">The above output shows that the program holding the lock is <em>atd</em>, the daemon that executes scheduled batch jobs.</p>
<p class="indent">In order to find the locked file, we first search the files in the <span class="literal">/dev</span> directory, and thus determine that the device with ID 3:7 is <span class="literal">/dev/sda7</span>:</p>
<p class="programs">$ <span class="codestrong">ls -li /dev | awk '$6 == "3," &#38;&#38; $7 == 7'</span><br/>&#160;&#160;1311 brw-rw----&#160;&#160;&#160;&#160;1 root&#160;&#160;&#160;disk&#160;&#160;&#160;&#160;3,&#160;&#160;7 May 12&#160;&#160;2006 /dev/<span class="codestrong">sda</span>7</p>
<p class="noindent">We then determine the mount point for the device <span class="literal">/dev/sda7</span> and search that part of the file system for the file whose i-node number is 133853:</p>
<p class="programs">$ <span class="codestrong">mount | grep sda7</span><br/>/dev/sda7 on / type reiserfs (rw)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Device is mounted on</span> /<br/>$ <span class="codestrong">su</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">So we can search all directories</span><br/>Password:<br/># <span class="codestrong">find / -mount -inum 133853</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Search for i-node 133853</span><br/>/var/run/atd.pid</p>
<p class="noindent">The <em>find &#8211;mount</em> option prevents <em>find</em> from descending into subdirectories under <span class="literal">/</span> that are mount points for other file systems.</p>
<p class="indent">Finally, we display the contents of the locked file:</p>
<p class="programs"># <span class="codestrong">cat /var/run/atd.pid</span><br/>312</p>
<p class="noindent">Thus, we see that the <em>atd</em> daemon is holding a lock on the file <span class="literal">/var/run/atd.pid</span>, and that the content of this file is the process ID of the process running <em>atd</em>. This daemon <span epub:type="pagebreak" id="page_1142"/>is employing a technique to ensure that only one instance of the daemon is running at a time. We describe this technique in <a href="ch55.xhtml#ch55lev1sec06">Section 55.6</a>.</p>
<p class="indent">We can also use <span class="literal">/proc/locks</span> to obtain information about blocked lock requests, as demonstrated in the following output:</p>
<p class="programs">$ <span class="codestrong">cat /proc/locks</span><br/>1: POSIX&#160;&#160;ADVISORY&#160;&#160;WRITE 11073 03:07:436283 100 109<br/>1: -&gt; POSIX&#160;&#160;ADVISORY&#160;&#160;WRITE 11152 03:07:436283 100 109<br/>2: POSIX&#160;&#160;MANDATORY WRITE 11014 03:07:436283 0 9<br/>2: -&gt; POSIX&#160;&#160;MANDATORY WRITE 11024 03:07:436283 0 9<br/>2: -&gt; POSIX&#160;&#160;MANDATORY READ&#160;&#160;11122 03:07:436283 0 19<br/>3: FLOCK&#160;&#160;ADVISORY&#160;&#160;WRITE 10802 03:07:134447 0 EOF<br/>3: -&gt; FLOCK&#160;&#160;ADVISORY&#160;&#160;WRITE 10840 03:07:134447 0 EOF</p>
<p class="noindent">Lines shown with the characters <span class="literal">-&gt;</span> immediately after a lock number represent lock requests blocked by the corresponding lock number. Thus, we see one request blocked on lock 1 (an advisory lock created with <em>fcntl()</em>), two requests blocked on lock 2 (a mandatory lock created with <em>fcntl()</em>), and one request blocked on lock 3 (a lock created with <em>flock()</em>).</p>
<div class="block">
<p class="noindent">The <span class="literal">/proc/locks</span> file also displays information about any file leases that are held by processes on the system. File leases are a Linux-specific mechanism available in Linux 2.4 and later. If a process takes out a lease on a file, then it is notified (by delivery of a signal) if another process tries to <em>open()</em> or <em>truncate()</em> that file. (The inclusion of <em>truncate()</em> is necessary because it is the only system call that can be used to change the contents of a file without first opening it.) File leases are provided in order to allow Samba to support the <em>opportunistic locks</em> (<em>oplocks</em>) functionality of the Microsoft SMB protocol and to allow NFS version 4 to support <em>delegations</em> (which are similar to SMB oplocks). Further details about file leases can be found under the description of the <span class="literal">F_SETLEASE</span> operation in the <em>fcntl(2)</em> manual page.</p>
</div>
<h3 class="h3" id="ch55lev1sec06"><strong>55.6 Running Just One Instance of a Program</strong></h3>
<p class="noindenta">Some programs&#8212;in particular, many daemons&#8212;need to ensure that only one instance of the program is running on the system at a time. A common method of doing this is to have the daemon create a file in a standard directory and place a write lock on it. The daemon holds the file lock for the duration of its execution and deletes the file just before terminating. If another instance of the daemon is started, it will fail to obtain a write lock on the file. Consequently, it will realize that another instance of the daemon must already be running, and terminate.</p>
<div class="block">
<p class="noindent">Many network servers use an alternative convention of assuming that a server instance is already running if the well-known socket port to which the server binds is already in use (<a href="ch61.xhtml#ch61lev1sec10">Section 61.10</a>).</p>
</div>
<p class="noindent">The <span class="literal">/var/run</span> directory is the usual location for such lock files. Alternatively, the location of the file may be specified by a line in the daemon&#8217;s configuration file.</p>
<p class="indent">Conventionally, a daemon writes its own process ID into the lock file, and hence the file is often named with an extension <span class="literal">.pid</span> (for example, <em>syslogd</em> creates the file <span class="literal">/var/run/syslogd.pid</span>). This is useful if some application needs to find the <span epub:type="pagebreak" id="page_1143"/>process ID of the daemon. It also allows an extra sanity check&#8212;we can verify whether that process ID exists using <em>kill(pid, 0)</em>, as described in <a href="ch20.xhtml#ch20lev1sec06">Section 20.6</a>. (In older UNIX implementations that did not provide file locking, this was used as an imperfect, but usually practicable, way of assessing whether an instance of the daemon really was still running, or whether an earlier instance had simply failed to delete the file before terminating.)</p>
<p class="indent">There are many minor variations in the code used to create and lock a process ID lock file. <a href="ch55.xhtml#ch55ex4">Listing 55-4</a> is based on ideas presented in [<a href="bib.xhtml#bib90">Stevens, 1999</a>] and provides a function, <em>createPidFile()</em>, that encapsulates the steps described above. We would typically call this function with a line such as the following:</p>
<p class="programs">if (createPidFile("mydaemon", "/var/run/mydaemon.pid", 0) == -1)<br/>&#160;&#160;&#160;&#160;errExit("createPidFile");</p>
<p class="noindent">One subtlety in the <em>createPidFile()</em> function is the use of <em>ftruncate()</em> to erase any previous string in the lock file. This is done because the last instance of the daemon may have failed to delete the file, perhaps because of a system crash. In this case, if the process ID of the new daemon instance is small, we might otherwise not completely overwrite the previous contents of the file. For example, if our process ID is 789, then we would write just <span class="literal">789\n</span> to the file, but a previous daemon instance might have written <span class="literal">12345\n</span>. If we did not truncate the file, then the resulting content would be <span class="literal">789\n5\n</span>. Erasing any existing string may not be strictly necessary, but it is tidier and removes any potential for confusion.</p>
<p class="indent">The <em>flags</em> argument can specify the constant <span class="literal">CPF_CLOEXEC</span>, which causes <em>createPidFile()</em> to set the close-on-exec flag (<a href="ch27.xhtml#ch27lev1sec04">Section 27.4</a>) for the file descriptor. This is useful for servers that restart themselves by calling <em>exec()</em>. If the file descriptor was not closed during the <em>exec()</em>, then the restarted server would think that a duplicate instance of the server is already running.</p>
<p class="examplet"><a id="ch55ex4"/><strong>Listing 55-4:</strong> Creating a PID lock file to ensure just one instance of a program is started</p>
<p class="programsli">____________________________________________ <span class="codestrong">filelock/create_pid_file.c</span><br/><br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include "region_locking.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* For lockRegion() */<br/>#include "create_pid_file.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declares createPidFile() and<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;defines CPF_CLOEXEC */<br/>#include "tlpi_hdr.h"<br/><br/>#define BUF_SIZE 100&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Large enough to hold maximum PID as string */<br/><br/>/* Open/create the file named in 'pidFile', lock it, optionally set the<br/>&#160;&#160;&#160;close-on-exec flag for the file descriptor, write our PID into the file,<br/>&#160;&#160;&#160;and (in case the caller is interested) return the file descriptor<br/>&#160;&#160;&#160;referring to the locked file. The caller is responsible for deleting<br/>&#160;&#160;&#160;'pidFile' file (just) before process termination. 'progName' should be the<br/>&#160;&#160;&#160;name of the calling program (i.e., argv[0] or similar), and is used only for<br/>&#160;&#160;&#160;diagnostic messages. If we can't open 'pidFile', or we encounter some other<br/>&#160;&#160;&#160;error, then we print an appropriate diagnostic and terminate. */<br/><br/>int<br/>createPidFile(const char *progName, const char *pidFile, int flags)<br/>{<br/>&#160;&#160;&#160;&#160;int fd;<br/>&#160;&#160;&#160;&#160;char buf[BUF_SIZE];<br/><br/>&#160;&#160;&#160;&#160;fd = open(pidFile, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("Could not open PID file %s", pidFile);<br/><br/>&#160;&#160;&#160;&#160;if (flags &#38; CPF_CLOEXEC) {<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Set the close-on-exec file descriptor flag */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flags = fcntl(fd, F_GETFD);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Fetch flags */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (flags == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("Could not get flags for PID file %s", pidFile);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flags |= FD_CLOEXEC;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Turn on FD_CLOEXEC */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (fcntl(fd, F_SETFD, flags) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Update flags */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("Could not set flags for PID file %s", pidFile);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (lockRegion(fd, F_WRLCK, SEEK_SET, 0, 0) == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno == EAGAIN || errno == EACCES)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("PID file '%s' is locked; probably "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"'%s' is already running", pidFile, progName);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("Unable to lock PID file '%s'", pidFile);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (ftruncate(fd, 0) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("Could not truncate PID file '%s'", pidFile);<br/><br/>&#160;&#160;&#160;&#160;snprintf(buf, BUF_SIZE, "%ld\n", (long) getpid());<br/>&#160;&#160;&#160;&#160;if (write(fd, buf, strlen(buf)) != strlen(buf))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("Writing to PID file '%s'", pidFile);<br/><br/>&#160;&#160;&#160;&#160;return fd;<br/>}<br/>____________________________________________ <span class="codestrong">filelock/create_pid_file.c</span></p>
<h3 class="h3" id="ch55lev1sec07"><span epub:type="pagebreak" id="page_1144"/><strong>55.7 Older Locking Techniques</strong></h3>
<p class="noindenta">In older UNIX implementations that lacked file locking, a number of <em>ad hoc</em> locking techniques were employed. Although all of these have been superseded by <em>fcntl()</em> record locking, we describe them here since they still appear in some older programs. All of these techniques are advisory in nature.</p>
<h5 class="h5" id="ch55lev3sec08"><span epub:type="pagebreak" id="page_1145"/><span class="literal"><span class="codestrong">open(file, O_CREAT | O_EXCL,...)</span></span> <strong>plus</strong> <span class="literal"><span class="codestrong">unlink(file)</span></span></h5>
<p class="noindentab">SUSv3 requires that an <em>open()</em> call with the flags <span class="literal">O_CREAT</span> and <span class="literal">O_EXCL</span> perform the steps of checking for the existence of a file and creating it atomically (<a href="ch05.xhtml#ch05lev1sec01">Section 5.1</a>). This means that if two processes attempt to create a file specifying these flags, it is guaranteed that only one of them will succeed. (The other process will receive the error <span class="literal">EEXIST</span> from <em>open()</em>.) Used in conjunction with the <em>unlink()</em> system call, this provides the basis for a locking mechanism. Acquiring the lock is performed by successfully opening the file with the <span class="literal">O_CREAT</span> and <span class="literal">O_EXCL</span> flags, followed by an immediate <em>close()</em>. Releasing the lock is performed using <em>unlink()</em>. Although workable, this technique has several limitations:</p>
<p class="bull">&#8226; If the <em>open()</em> fails, indicating that some other process has the lock, then we must retry the <em>open()</em> in some kind of loop, either polling continuously (which wastes CPU time) or with a delay between each attempt (which means that there may be some delay between the time the lock becomes available and when we actually acquire it). With <em>fcntl()</em>, we can use <span class="literal">F_SETLKW</span> to block until the lock becomes free.</p>
<p class="bull">&#8226; Acquiring and releasing locks using <em>open()</em> and <em>unlink()</em> involves file-system operations that are rather slower than the use of record locks. (On one of the author&#8217;s x86-32 systems running Linux 2.6.31, acquiring and releasing 1 million locks on an <em>ext3</em> file using the technique described here required 44 seconds. Acquiring and releasing 1 million record locks on the same byte of a file required 2.5 seconds.)</p>
<p class="bull">&#8226; If a process accidentally exits without deleting the lock file, the lock is not released. There are <em>ad hoc</em> techniques for handling this problem, including checking the last modification time of the file and having the lock holder write its process ID to the file so that we can check if the process still exists, but none of these techniques is foolproof. By comparison, record locks are released automatically when a process terminates.</p>
<p class="bull">&#8226; If we are placing multiple locks (i.e., using multiple lock files), deadlocks are not detected. If a deadlock arises, the processes involved in the deadlock will remain blocked indefinitely. (Each process will be spinning, checking to see if it can obtain the lock it requires.) By contrast, the kernel provides deadlock detection for <em>fcntl()</em> record locks.</p>
<p class="bull">&#8226; NFS version 2 doesn&#8217;t support <span class="literal">O_EXCL</span> semantics. Linux 2.4 NFS clients also fail to implement <span class="literal">O_EXCL</span> correctly, even for NFS version 3 and later.</p>
<h5 class="h5" id="ch55lev3sec09"><span class="literal"><span class="codestrong">link(file, lockfile)</span></span> <strong>plus</strong> <span class="literal"><span class="codestrong">unlink(lockfile)</span></span></h5>
<p class="noindenta">The fact that the <em>link()</em> system call fails if the new link already exists has also been used as a locking mechanism, again employing <em>unlink()</em> to perform the unlock function. The usual approach is to have each process that needs to acquire the lock create a unique temporary filename, typically one including the process ID (and possibly the hostname, if the lock file is created on a network file system). To acquire the lock, this temporary file is linked to some agreed-upon standard pathname. (The semantics of hard links require that the two pathnames reside in the same file system.) <span epub:type="pagebreak" id="page_1146"/>If the <em>link()</em> call succeeds, we have obtained the lock. If it fails (<span class="literal">EEXIST</span>), then another process has the lock and we must try again later. This technique suffers the same limitations as the <em>open(file, O_CREAT | O_EXCL,...)</em> technique described above.</p>
<h5 class="h5" id="ch55lev3sec10"><span class="literal"><span class="codestrong">open(file, O_CREAT | O_TRUNC | O_WRONLY, 0)</span></span> <strong>plus</strong> <span class="literal"><span class="codestrong">unlink(file)</span></span></h5>
<p class="noindenta">The fact that calling <em>open()</em> on an existing file fails if <span class="literal">O_TRUNC</span> is specified and write permission is denied on the file can be used as the basis of a locking technique. To obtain a lock, we use the following code (which omits error checking) to create a new file:</p>
<p class="programs">fd = open(file, O_CREAT | O_TRUNC | O_WRONLY, (mode_t) 0);<br/>close(fd);</p>
<div class="block">
<p class="noindent">For an explanation of why we use the <em>(mode_t)</em> cast in the <em>open()</em> call above, see <a href="app03.xhtml#app03">Appendix C</a>.</p>
</div>
<p class="noindent">If the <em>open()</em> call succeeds (i.e., the file didn&#8217;t previously exist), we have the lock. If it fails with <span class="literal">EACCES</span> (i.e., the file exists and has no permissions for anyone), then another process has the lock, and we must try again later. This technique suffers the same limitations as the previous techniques, with the added caveat that we can&#8217;t employ it in a program with superuser privileges, since the <em>open()</em> call will always succeed, regardless of the permissions that are set on the file.</p>
<h3 class="h3" id="ch55lev1sec08"><strong>55.8 Summary</strong></h3>
<p class="noindenta">File locks allow processes to synchronize access to a file. Linux provides two file locking system calls: the BSD-derived <em>flock()</em> and the System V&#8211;derived <em>fcntl()</em>. Although both system calls are available on most UNIX implementations, only <em>fcntl()</em> locking is standardized in SUSv3.</p>
<p class="indent">The <em>flock()</em> system call locks an entire file. Two types of locks may be placed: shared locks, which are compatible with shared locks held by other processes, and exclusive locks, which prevent other processes from placing any type of lock.</p>
<p class="indent">The <em>fcntl()</em> system call places locks (&#8220;record locks&#8221;) on any region of a file, ranging from a single byte to the entire file. Two types of locks may be placed: read locks and write locks, which have similar compatibility semantics to the shared and exclusive locks placed via <em>flock()</em>. If a blocking (<span class="literal">F_SETLKW</span>) lock request would bring about a deadlock situation, then the kernel causes <em>fcntl()</em> to fail (with the error <span class="literal">EDEADLK</span>) in one of the affected processes.</p>
<p class="indent">Locks placed using <em>flock()</em> and <em>fcntl()</em> are invisible to one another (except on systems that implement <em>flock()</em> using <em>fcntl()</em>). The locks placed via <em>flock()</em> and <em>fcntl()</em> have different semantics with respect to inheritance across <em>fork()</em> and release when file descriptors are closed.</p>
<p class="indent">The Linux-specific <span class="literal">/proc/locks</span> file displays the file locks currently held by all processes on the system.</p>
<h5 class="h5" id="ch55lev3sec11"><strong>Further information</strong></h5>
<p class="noindenta">An extensive discussion of <em>fcntl()</em> record locking can be found in [<a href="bib.xhtml#bib94">Stevens &#38; Rago, 2005</a>] and [<a href="bib.xhtml#bib90">Stevens, 1999</a>]. Some details of the implementation of <em>flock()</em> and <em>fcntl()</em> <span epub:type="pagebreak" id="page_1147"/>locking on Linux are provided in [<a href="bib.xhtml#bib09">Bovet &#38; Cesati, 2005</a>]. [<a href="bib.xhtml#bib99">Tanenbaum, 2007</a>] and [<a href="bib.xhtml#bib18">Deitel et al., 2004</a>] describe deadlocking concepts in general, including coverage of deadlock detection, avoidance, and prevention.</p>
<h3 class="h3" id="ch55lev1sec09"><strong>55.9 Exercises</strong></h3>
<p class="exer"><a id="ch55exe1"/><strong>55-1.</strong>&#160;&#160;&#160;Experiment by running multiple instances of the program in <a href="ch55.xhtml#ch55ex1">Listing 55-1</a> (<span class="literal">t_flock.c</span>) to determine the following points about the operation of <em>flock()</em>:</p>
<p class="olista1">a) Can a series of processes acquiring shared locks on a file starve a process attempting to place an exclusive lock on the file?</p>
<p class="olista1">b) Suppose that a file is locked exclusively, and other processes are waiting to place both shared and exclusive locks on the file. When the first lock is released, are there any rules determining which process is next granted a lock? For example, do shared locks have priority over exclusive locks or vice versa? Are locks granted in FIFO order?</p>
<p class="olista1">c) If you have access to some other UNIX implementation that provides <em>flock()</em>, try to determine the rules on that implementation.</p>
<p class="exer"><a id="ch55exe2"/><strong>55-2.</strong>&#160;&#160;&#160;Write a program to determine whether <em>flock()</em> detects deadlock situations when being used to lock two different files in two processes.</p>
<p class="exer"><a id="ch55exe3"/><strong>55-3.</strong>&#160;&#160;&#160;Write a program to verify the statements made in <a href="ch55.xhtml#ch55lev2sec01">Section 55.2.1</a> regarding the semantics of inheritance and release of <em>flock()</em> locks.</p>
<p class="exer"><a id="ch55exe4"/><strong>55-4.</strong>&#160;&#160;&#160;Experiment by running the programs in <a href="ch55.xhtml#ch55ex1">Listing 55-1</a> (<span class="literal">t_flock.c</span>) and <a href="ch55.xhtml#ch55ex2">Listing 55-2</a> (<span class="literal">i_fcntl_locking.c</span>) to see whether locks granted by <em>flock()</em> and <em>fcntl()</em> have any effect on one another. If you have access to other UNIX implementations, try the same experiment on those implementations.</p>
<p class="exer"><a id="ch55exe5"/><strong>55-5.</strong>&#160;&#160;&#160;In <a href="ch55.xhtml#ch55lev2sec06">Section 55.3.4</a>, we noted that, on Linux, the time required to add or check for the existence of a lock is a function of the position of the lock in the list of all locks on the file. Write two programs to verify this:</p>
<p class="olista1">a) The first program should acquire (say) 40,001 write locks on a file. These locks are placed on alternating bytes of the file; that is, locks are placed on bytes 0, 2, 4, 6, and so on through to (say) byte 80,000. Having acquired these locks, the process then goes to sleep.</p>
<p class="olista1">b) While the first program is sleeping, the second program loops (say) 10,000 times, using <span class="literal">F_SETLK</span> to try to lock one of the bytes locked by the previous program (these lock attempts always fail). In any particular execution, the program always tries to lock byte <em>N * 2</em> of the file.</p>
<p class="exerp">Using the shell built-in <em>time</em> command, measure the time required by the second program for <em>N</em> equals 0, 10,000, 20,000, 30,000, and 40,000. Do the results match the expected linear behavior?</p>
<p class="exer"><a id="ch55exe6"/><strong>55-6.</strong>&#160;&#160;&#160;Experiment with the program in <a href="ch55.xhtml#ch55ex2">Listing 55-2</a> (<span class="literal">i_fcntl_locking.c</span>) to verify the statements made in <a href="ch55.xhtml#ch55lev2sec08">Section 55.3.6</a> regarding lock starvation and priority for <em>fcntl()</em> record locks.</p>
<p class="exer"><span epub:type="pagebreak" id="page_1148"/><a id="ch55exe7"/><strong>55-7.</strong>&#160;&#160;&#160;If you have access to other UNIX implementations, use the program in <a href="ch55.xhtml#ch55ex2">Listing 55-2</a> (<span class="literal">i_fcntl_locking.c</span>) to see if you can establish any rules for <em>fcntl()</em> record locking regarding starvation of writers and regarding the order in which multiple queued lock requests are granted.</p>
<p class="exer"><a id="ch55exe8"/><strong>55-8.</strong>&#160;&#160;&#160;Use the program in <a href="ch55.xhtml#ch55ex2">Listing 55-2</a> (<span class="literal">i_fcntl_locking.c</span>) to demonstrate that the kernel detects circular deadlocks involving three (or more) processes locking the same file.</p>
<p class="exer"><a id="ch55exe9"/><strong>55-9.</strong>&#160;&#160;&#160;Write a pair of programs (or a single program that uses a child process) to bring about the deadlock situation with mandatory locks described in <a href="ch55.xhtml#ch55lev1sec04">Section 55.4</a>.</p>
<p class="exer"><strong>55-10.</strong> Read the manual page of the <em>lockfile(1)</em> utility that is supplied with <em>procmail</em>. Write a simple version of this program.</p>
</body>
</html>
