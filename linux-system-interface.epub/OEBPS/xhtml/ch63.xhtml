<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch63"><span epub:type="pagebreak" id="page_1325"/><strong><span class="big">63</span></strong><br/><strong>ALTERNATIVE I/O MODELS</strong></h2>
<p class="noindentab">This chapter discusses three alternatives to the conventional file I/O model that we have employed in most programs shown in this book:</p>
<p class="bull">&#8226; I/O multiplexing (the <em>select()</em> and <em>poll()</em> system calls);</p>
<p class="bull">&#8226; signal-driven I/O; and</p>
<p class="bull">&#8226; the Linux-specific <em>epoll</em> API.</p>
<h3 class="h3" id="ch63lev1sec01"><strong>63.1 Overview</strong></h3>
<p class="noindenta">Most of the programs that we have presented so far in this book employ an I/O model under which a process performs I/O on just one file descriptor at a time, and each I/O system call blocks until the data is transferred. For example, when reading from a pipe, a <em>read()</em> call normally blocks if no data is currently present in the pipe, and a <em>write()</em> call blocks if there is insufficient space in the pipe to hold the data to be written. Similar behavior occurs when performing I/O on various other types of files, including FIFOs and sockets.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_1326"/>Disk files are a special case. As described in <a href="ch13.xhtml#ch13">Chapter 13</a>, the kernel employs the buffer cache to speed disk I/O requests. Thus, a <em>write()</em> to a disk returns as soon as the requested data has been transferred to the kernel buffer cache, rather than waiting until the data is written to disk (unless the <span class="literal">O_SYNC</span> flag was specified when opening the file). Correspondingly, a <em>read()</em> transfers data from the buffer cache to a user buffer, and if the required data is not in the buffer cache, then the kernel puts the process to sleep while a disk read is performed.</p>
</div>
<p class="noindentb">The traditional blocking I/O model is sufficient for many applications, but not all. In particular, some applications need to be able to do one or both of the following:</p>
<p class="bull">&#8226; Check whether I/O is possible on a file descriptor without blocking if it is not possible.</p>
<p class="bull">&#8226; Monitor multiple file descriptors to see if I/O is possible on any of them.</p>
<p class="noindentt">We have already encountered two techniques that can be used to partially address these needs: nonblocking I/O and the use of multiple processes or threads.</p>
<p class="indent">We described nonblocking I/O in some detail in <a href="ch05.xhtml#ch05lev1sec09">Sections 5.9</a> and <a href="ch44.xhtml#ch44lev1sec09">44.9</a>. If we place a file descriptor in nonblocking mode by enabling the <span class="literal">O_NONBLOCK</span> open file status flag, then an I/O system call that can&#8217;t be immediately completed returns an error instead of blocking. Nonblocking I/O can be employed with pipes, FIFOs, sockets, terminals, pseudoterminals, and some other types of devices.</p>
<p class="indent">Nonblocking I/O allows us to periodically check (&#8220;poll&#8221;) whether I/O is possible on a file descriptor. For example, we can make an input file descriptor nonblocking, and then periodically perform nonblocking reads. If we need to monitor multiple file descriptors, then we mark them all nonblocking, and poll each of them in turn. However, polling in this manner is usually undesirable. If polling is done only infrequently, then the latency before an application responds to an I/O event may be unacceptably long; on the other hand, polling in a tight loop wastes CPU time.</p>
<div class="block">
<p class="noindent">In this chapter, we use the word <em>poll</em> in two distinct ways. One of these is as the name of the I/O multiplexing system call, <em>poll()</em>. In the other use, we mean &#8220;performing a nonblocking check on the status of a file descriptor.&#8221;</p>
</div>
<p class="noindent">If we don&#8217;t want a process to block when performing I/O on a file descriptor, we can instead create a new process to perform the I/O. The parent process can then carry on to perform other tasks, while the child process blocks until the I/O is complete. If we need to handle I/O on multiple file descriptors, we can create one child for each descriptor. The problems with this approach are expense and complexity. Creating and maintaining processes places a load on the system, and, typically, the child processes will need to use some form of IPC to inform the parent about the status of I/O operations.</p>
<p class="indent">Using multiple threads instead of processes is less demanding of resources, but the threads will probably still need to communicate information to one another about the status of I/O operations, and the programming can be complex, especially if we are using thread pools to minimize the number of threads used to handle large numbers of simultaneous clients. (One place where threads can be particularly useful is if the application needs to call a third-party library that performs blocking I/O. An application can avoid blocking in this case by making the library call in a separate thread.)</p>
<p class="indentb"><span epub:type="pagebreak" id="page_1327"/>Because of the limitations of both nonblocking I/O and the use of multiple threads or processes, one of the following alternatives is often preferable:</p>
<p class="bull">&#8226; <em>I/O multiplexing</em> allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them. The <em>select()</em> and <em>poll()</em> system calls perform I/O multiplexing.</p>
<p class="bull">&#8226; <em>Signal-driven I/O</em> is a technique whereby a process requests that the kernel send it a signal when input is available or data can be written on a specified file descriptor. The process can then carry on performing other activities, and is notified when I/O becomes possible via receipt of the signal. When monitoring large numbers of file descriptors, signal-driven I/O provides significantly better performance than <em>select()</em> and <em>poll()</em>.</p>
<p class="bull">&#8226; The <em>epoll</em> API is a Linux-specific feature that first appeared in Linux 2.6. Like the I/O multiplexing APIs, the <em>epoll</em> API allows a process to monitor multiple file descriptors to see if I/O is possible on any of them. Like signal-driven I/O, the <em>epoll</em> API provides much better performance when monitoring large numbers of file descriptors.</p>
<div class="block1">
<p class="noindent">In the remainder of this chapter, we&#8217;ll generally frame the discussion of the above techniques in terms of processes. However, these techniques can also be employed in multithreaded applications.</p>
</div>
<p class="noindent">In effect, I/O multiplexing, signal-driven I/O, and <em>epoll</em> are all methods of achieving the same result&#8212;monitoring one or, commonly, several file descriptors simultaneously to see if they are <em>ready</em> to perform I/O (to be precise, to see whether an I/O system call could be performed without blocking). The transition of a file descriptor into a ready state is triggered by some type of I/O <em>event</em>, such as the arrival of input, the completion of a socket connection, or the availability of space in a previously full socket send buffer after TCP transmits queued data to the socket peer. Monitoring multiple file descriptors is useful in applications such as network servers that must simultaneously monitor multiple client sockets, or applications that must simultaneously monitor input from a terminal and a pipe or socket.</p>
<p class="indent">Note that none of these techniques performs I/O. They merely tell us that a file descriptor is ready. Some other system call must then be used to actually perform the I/O.</p>
<div class="block">
<p class="noindent">One I/O model that we don&#8217;t describe in this chapter is POSIX asynchronous I/O (AIO). POSIX AIO allows a process to queue an I/O operation to a file and then later be notified when the operation is complete. The advantage of POSIX AIO is that the initial I/O call returns immediately, so that the process is not tied up waiting for data to be transferred to the kernel or for the operation to complete. This allows the process to perform other tasks in parallel with the I/O (which may include queuing further I/O requests). For certain types of applications, POSIX AIO can provide useful performance benefits. Currently, Linux provides a threads-based implementation of POSIX AIO within <em>glibc</em>. At the time of writing, work is ongoing toward providing an in-kernel implementation of POSIX AIO, which should provide better scaling performance. POSIX AIO is described in [<a href="bib.xhtml#bib28">Gallmeister, 1995</a>], [<a href="bib.xhtml#bib78">Robbins &#38; Robbins, 2003</a>], and the <em>aio(7)</em> manual page.</p>
</div>
<h5 class="h5" id="ch63lev3sec01"><span epub:type="pagebreak" id="page_1328"/><strong>Which technique?</strong></h5>
<p class="noindentab">During the course of this chapter, we&#8217;ll consider the reasons we may choose one of these techniques rather than another. In the meantime, we summarize a few points:</p>
<p class="bull">&#8226; The <em>select()</em> and <em>poll()</em> system calls are long-standing interfaces that have been present on UNIX systems for many years. Compared to the other techniques, their primary advantage is portability. Their main disadvantage is that they don&#8217;t scale well when monitoring large numbers (hundreds or thousands) of file descriptors.</p>
<p class="bull">&#8226; The key advantage of the <em>epoll</em> API is that it allows an application to efficiently monitor large numbers of file descriptors. Its primary disadvantage is that it is a Linux-specific API.</p>
<div class="block1">
<p class="noindent">Some other UNIX implementations provide (nonstandard) mechanisms similar to <em>epoll</em>. For example, Solaris provides the special <span class="literal">/dev/poll</span> file (described in the Solaris <em>poll(7d)</em> manual page), and some of the BSDs provide the <em>kqueue</em> API (which provides a more general-purpose monitoring facility than <em>epoll</em>). [<a href="bib.xhtml#bib93">Stevens et al., 2004</a>] briefly describes these two mechanisms; a longer discussion of <em>kqueue</em> can be found in [<a href="bib.xhtml#bib52">Lemon, 2001</a>].</p>
</div>
<p class="bull">&#8226; Like <em>epoll</em>, signal-driven I/O allows an application to efficiently monitor large numbers of file descriptors. However, <em>epoll</em> provides a number of advantages over signal-driven I/O:</p>
<p class="dash1">&#8211; We avoid the complexities of dealing with signals.</p>
<p class="dash1">&#8211; We can specify the kind of monitoring that we want to perform (e.g., ready for reading or ready for writing).</p>
<p class="dash1">&#8211; We can select either level-triggered or edge-triggered notification (described in <a href="ch63.xhtml#ch63lev2sec01">Section 63.1.1</a>).</p>
<p class="bullp">Furthermore, taking full advantage of signal-driven I/O requires the use of nonportable, Linux-specific features, and if we do this, signal-driven I/O is no more portable than <em>epoll</em>.</p>
<p class="noindentt">Because, on the one hand, <em>select()</em> and <em>poll()</em> are more portable, while signal-driven I/O and <em>epoll</em> deliver better performance, for some applications, it can be worthwhile writing an abstract software layer for monitoring file descriptor events. With such a layer, portable programs can employ <em>epoll</em> (or a similar API) on systems that provide it, and fall back to the use of <em>select()</em> or <em>poll()</em> on other systems.</p>
<div class="block">
<p class="noindent">The <em>libevent</em> library is a software layer that provides an abstraction for monitoring file descriptor events. It has been ported to a number of UNIX systems. As its underlying mechanism, <em>libevent</em> can (transparently) employ any of the techniques described in this chapter: <em>select()</em>, <em>poll()</em>, signal-driven I/O, or <em>epoll</em>, as well as the Solaris specific <span class="literal">/dev/poll</span> interface or the BSD <em>kqueue</em> interface. (Thus, <em>libevent</em> also serves as an example of how to use each of these techniques.) Written by Niels Provos, <em>libevent</em> is available at <em><a href="http://monkey.org/~provos/libevent/">http://monkey.org/~provos/libevent/</a></em>.</p>
</div>
<h4 class="h4" id="ch63lev2sec01"><span epub:type="pagebreak" id="page_1329"/><strong>63.1.1 Level-Triggered and Edge-Triggered Notification</strong></h4>
<p class="noindentab">Before discussing the various alternative I/O mechanisms in detail, we need to distinguish two models of readiness notification for a file descriptor:</p>
<p class="bull">&#8226; <em>Level-triggered notification</em>: A file descriptor is considered to be ready if it is possible to perform an I/O system call without blocking.</p>
<p class="bull">&#8226; <em>Edge-triggered notification</em>: Notification is provided if there is I/O activity (e.g., new input) on a file descriptor since it was last monitored.</p>
<p class="noindent"><a href="ch63.xhtml#ch63table1">Table 63-1</a> summarizes the notification models employed by I/O multiplexing, signal-driven I/O, and <em>epoll</em>. The <em>epoll</em> API differs from the other two I/O models in that it can employ both level-triggered notification (the default) and edge-triggered notification.</p>
<p class="tablecap"><a id="ch63table1"/><strong>Table 63-1:</strong> Use of level-triggered and edge-triggered notification models</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>I/O model</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong>Level-triggered?</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="tablec"><strong>Edge-triggered?</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>select()</em>, <em>poll()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Signal-driven I/O</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><em>epoll</em></p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="tablec">&#8226;</p></td>
</tr>
</tbody>
</table>
<p class="noindent">Details of the differences between these two notification models will become clearer during the course of the chapter. For now, we describe how the choice of notification model affects the way we design a program.</p>
<p class="indent">When we employ level-triggered notification, we can check the readiness of a file descriptor at any time. This means that when we determine that a file descriptor is ready (e.g., it has input available), we can perform some I/O on the descriptor, and then repeat the monitoring operation to check if the descriptor is still ready (e.g., it still has more input available), in which case we can perform more I/O, and so on. In other words, because the level-triggered model allows us to repeat the I/O monitoring operation at any time, it is not necessary to perform as much I/O as possible (e.g., read as many bytes as possible) on the file descriptor (or even perform any I/O at all) each time we are notified that a file descriptor is ready.</p>
<p class="indentb">By contrast, when we employ edge-triggered notification, we receive notification only when an I/O event occurs. We don&#8217;t receive any further notification until another I/O event occurs. Furthermore, when an I/O event is notified for a file descriptor, we usually don&#8217;t know how much I/O is possible (e.g., how many bytes are available for reading). Therefore, programs that employ edge-triggered notification are usually designed according to the following rules:</p>
<p class="bull">&#8226; After notification of an I/O event, the program should&#8212;at some point&#8212;perform as much I/O as possible (e.g., read as many bytes as possible) on the corresponding file descriptor. If the program fails to do this, then it might miss the opportunity to perform some I/O, because it would not be aware of the need to operate on the file descriptor until another I/O event occurred. This could lead to spurious data loss or blockages in a program. We said &#8220;at some point,&#8221; because sometimes it may not be desirable to perform all of the I/O immediately after we determine that the file descriptor is ready. The problem is that we may <span epub:type="pagebreak" id="page_1330"/>starve other file descriptors of attention if we perform a large amount of I/O on one file descriptor. We consider this point in more detail when we describe the edge-triggered notification model for <em>epoll</em> in <a href="ch63.xhtml#ch63lev2sec15">Section 63.4.6</a>.</p>
<p class="bull">&#8226; If the program employs a loop to perform as much I/O as possible on the file descriptor, and the descriptor is marked as blocking, then eventually an I/O system call will block when no more I/O is possible. For this reason, each monitored file descriptor is normally placed in nonblocking mode, and after notification of an I/O event, I/O operations are performed repeatedly until the relevant system call (e.g., <em>read()</em> or <em>write()</em>) fails with the error <span class="literal">EAGAIN</span> or <span class="literal">EWOULDBLOCK</span>.</p>
<h4 class="h4" id="ch63lev2sec02"><strong>63.1.2 Employing Nonblocking I/O with Alternative I/O Models</strong></h4>
<p class="noindentab">Nonblocking I/O (the <span class="literal">O_NONBLOCK</span> flag) is often used in conjunction with the I/O models described in this chapter. Some examples of why this can be useful are the following:</p>
<p class="bull">&#8226; As explained in the previous section, nonblocking I/O is usually employed in conjunction with I/O models that provide edge-triggered notification of I/O events.</p>
<p class="bull">&#8226; If multiple processes (or threads) are performing I/O on the same open file descriptions, then, from a particular process&#8217;s point of view, a descriptor&#8217;s readiness may change between the time the descriptor was notified as being ready and the time of the subsequent I/O call. Consequently, a blocking I/O call could block, thus preventing the process from monitoring other file descriptors. (This can occur for all of the I/O models that we describe in this chapter, regardless of whether they employ level-triggered or edge-triggered notification.)</p>
<p class="bull">&#8226; Even after a level-triggered API such as <em>select()</em> or <em>poll()</em> informs us that a file descriptor for a stream socket is ready for writing, if we write a large enough block of data in a single <em>write()</em> or <em>send()</em>, then the call will nevertheless block.</p>
<p class="bull">&#8226; In rare cases, level-triggered APIs such as <em>select()</em> and <em>poll()</em> can return spurious readiness notifications&#8212;they can falsely inform us that a file descriptor is ready. This could be caused by a kernel bug or be expected behavior in an uncommon scenario.</p>
<div class="block1">
<p class="noindent">Section 16.6 of [<a href="bib.xhtml#bib93">Stevens et al., 2004</a>] describes one example of spurious readiness notifications on BSD systems for a listening socket. If a client connects to a server&#8217;s listening socket and then resets the connection, a <em>select()</em> performed by the server between these two events will indicate the listening socket as being readable, but a subsequent <em>accept()</em> that is performed after the client&#8217;s reset will block.</p>
</div>
<h3 class="h3" id="ch63lev1sec02"><strong>63.2 I/O Multiplexing</strong></h3>
<p class="noindenta">I/O multiplexing allows us to simultaneously monitor multiple file descriptors to see if I/O is possible on any of them. We can perform I/O multiplexing using either of two system calls with essentially the same functionality. The first of these, <em>select()</em>, appeared along with the sockets API in BSD. This was historically the more widespread of the two system calls. The other system call, <em>poll()</em>, appeared in System V. Both <em>select()</em> and <em>poll()</em> are nowadays required by SUSv3.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1331"/>We can use <em>select()</em> and <em>poll()</em> to monitor file descriptors for regular files, terminals, pseudoterminals, pipes, FIFOs, sockets, and some types of character devices. Both system calls allow a process either to block indefinitely waiting for file descriptors to become ready or to specify a timeout on the call.</p>
<h4 class="h4" id="ch63lev2sec03"><strong>63.2.1 The <em>select()</em> System Call</strong></h4>
<p class="noindenta">The <em>select()</em> system call blocks until one or more of a set of file descriptors becomes ready.</p>
<div class="box">
<p class="programsa">#include &lt;sys/time.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* For portability */<br/>#include &lt;sys/select.h&gt;<br/><br/>int <span class="codestrong">select</span>(int <span class="font1">nfds</span>, fd_set *<span class="font1">readfds</span>, fd_set *<span class="font1">writefds</span>, fd_set *<span class="font1">exceptfds</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct timeval *<span class="font1">timeout</span>);</p>
<p class="right">Returns number of ready file descriptors, 0 on timeout, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>nfds</em>, <em>readfds</em>, <em>writefds</em>, and <em>exceptfds</em> arguments specify the file descriptors that <em>select()</em> is to monitor. The <em>timeout</em> argument can be used to set an upper limit on the time for which <em>select()</em> will block. We describe each of these arguments in detail below.</p>
<div class="block">
<p class="noindent">In the prototype for <em>select()</em> shown above, we include <span class="literal">&lt;sys/time.h&gt;</span> because that was the header specified in SUSv2, and some UNIX implementations require this header. (The <span class="literal">&lt;sys/time.h&gt;</span> header is present on Linux, and including it does no harm.)</p>
</div>
<h5 class="h5" id="ch63lev3sec02"><strong>File descriptor sets</strong></h5>
<p class="noindentab">The <em>readfds</em>, <em>writefds</em>, and <em>exceptfds</em> arguments are pointers to <em>file descriptor sets</em>, represented using the data type <em>fd_set</em>. These arguments are used as follows:</p>
<p class="bull">&#8226; <em>readfds</em> is the set of file descriptors to be tested to see if input is possible;</p>
<p class="bull">&#8226; <em>writefds</em> is the set of file descriptors to be tested to see if output is possible; and</p>
<p class="bull">&#8226; <em>exceptfds</em> is the set of file descriptors to be tested to see if an exceptional condition has occurred.</p>
<p class="noindenttb">The term <em>exceptional condition</em> is often misunderstood to mean that some sort of error condition has arisen on the file descriptor. This is not the case. An exceptional condition occurs in just two circumstances on Linux (other UNIX implementations are similar):</p>
<p class="bull">&#8226; A state change occurs on a pseudoterminal slave connected to a master that is in packet mode (<a href="ch64.xhtml#ch64lev1sec05">Section 64.5</a>).</p>
<p class="bull">&#8226; Out-of-band data is received on a stream socket (<a href="ch61.xhtml#ch61lev2sec08">Section 61.13.1</a>).</p>
<p class="noindentt">Typically, the <em>fd_set</em> data type is implemented as a bit mask. However, we don&#8217;t need to know the details, since all manipulation of file descriptor sets is done via four macros: <span class="literal">FD_ZERO()</span>, <span class="literal">FD_SET()</span>, <span class="literal">FD_CLR()</span>, and <span class="literal">FD_ISSET()</span>.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_1332"/>#include &lt;sys/select.h&gt;<br/><br/>void <span class="codestrong">FD_ZERO</span>(fd_set *<span class="font1">fdset</span>);<br/>void <span class="codestrong">FD_SET</span>(int <span class="font1">fd</span>, fd_set *<span class="font1">fdset</span>);<br/>void <span class="codestrong">FD_CLR</span>(int <span class="font1">fd</span>, fd_set *<span class="font1">fdset</span>);<br/><br/>int <span class="codestrong">FD_ISSET</span>(int <span class="font1">fd</span>, fd_set *<span class="font1">fdset</span>);</p>
<p class="right">Returns true (1) if <em>fd</em> is in <em>fdset</em>, or false (0) otherwise</p>
</div>
<p class="noindentb">These macros operate as follows:</p>
<p class="bull">&#8226; <span class="literal">FD_ZERO()</span> initializes the set pointed to by <em>fdset</em> to be empty.</p>
<p class="bull">&#8226; <span class="literal">FD_SET()</span> adds the file descriptor <em>fd</em> to the set pointed to by <em>fdset</em>.</p>
<p class="bull">&#8226; <span class="literal">FD_CLR()</span> removes the file descriptor <em>fd</em> from the set pointed to by <em>fdset</em>.</p>
<p class="bull">&#8226; <span class="literal">FD_ISSET()</span> returns true if the file descriptor <em>fd</em> is a member of the set pointed to by <em>fdset</em>.</p>
<p class="noindentt">A file descriptor set has a maximum size, defined by the constant <span class="literal">FD_SETSIZE</span>. On Linux, this constant has the value 1024. (Other UNIX implementations have similar values for this limit.)</p>
<div class="block">
<p class="noindent">Even though the <span class="literal">FD_*</span> macros are operating on user-space data structures, and the kernel implementation of <em>select()</em> can handle descriptor sets with larger sizes, <em>glibc</em> provides no simple way of modifying the definition of <span class="literal">FD_SETSIZE</span>. If we want to change this limit, we must modify the definition in the <em>glibc</em> header files. However, for reasons that we describe later in this chapter, if we need to monitor large numbers of descriptors, then using <em>epoll</em> is probably preferable to the use of <em>select()</em>.</p>
</div>
<p class="noindent">The <em>readfds</em>, <em>writefds</em>, and <em>exceptfds</em> arguments are all value-result. Before the call to <em>select()</em>, the <em>fd_set</em> structures pointed to by these arguments must be initialized (using <span class="literal">FD_ZERO()</span> and <span class="literal">FD_SET()</span>) to contain the set of file descriptors of interest. The <em>select()</em> call modifies each of these structures so that, on return, they contain the set of file descriptors that are ready. (Since these structures are modified by the call, we must ensure that we reinitialize them if we are repeatedly calling <em>select()</em> from within a loop.) The structures can then be examined using <span class="literal">FD_ISSET()</span>.</p>
<p class="indent">If we are not interested in a particular class of events, then the corresponding <em>fd_set</em> argument can be specified as <span class="literal">NULL</span>. We say more about the precise meaning of each of the three event types in <a href="ch63.xhtml#ch63lev2sec05">Section 63.2.3</a>.</p>
<p class="indent">The <em>nfds</em> argument must be set one greater than the highest file descriptor number included in any of the three file descriptor sets. This argument allows <em>select()</em> to be more efficient, since the kernel then knows not to check whether file descriptor numbers higher than this value are part of each file descriptor set.</p>
<h5 class="h5" id="ch63lev3sec03"><span epub:type="pagebreak" id="page_1333"/><strong>The <em>timeout</em> argument</strong></h5>
<p class="noindenta">The <em>timeout</em> argument controls the blocking behavior of <em>select()</em>. It can be specified either as <span class="literal">NULL</span>, in which case <em>select()</em> blocks indefinitely, or as a pointer to a <em>timeval</em> structure:</p>
<p class="programs">struct timeval {<br/>&#160;&#160;&#160;&#160;time_t&#160;&#160;&#160;&#160;&#160;&#160;tv_sec;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Seconds */<br/>&#160;&#160;&#160;&#160;suseconds_t tv_usec;&#160;&#160;&#160;&#160;&#160;&#160;/* Microseconds (long int) */<br/>};</p>
<p class="noindent">If both fields of <em>timeout</em> are 0, then <em>select()</em> doesn&#8217;t block; it simply polls the specified file descriptors to see which ones are ready and returns immediately. Otherwise, <em>timeout</em> specifies an upper limit on the time for which <em>select()</em> is to wait.</p>
<p class="indent">Although the <em>timeval</em> structure affords microsecond precision, the accuracy of the call is limited by the granularity of the software clock (<a href="ch10.xhtml#ch10lev1sec06">Section 10.6</a>). SUSv3 specifies that the timeout is rounded upward if it is not an exact multiple of this granularity.</p>
<div class="block">
<p class="noindent">SUSv3 requires that the maximum permissible timeout interval be at least 31 days. Most UNIX implementations allow a considerably higher limit. Since Linux/x86-32 uses a 32-bit integer for the <em>time_t</em> type, the upper limit is many years.</p>
</div>
<p class="noindentb">When <em>timeout</em> is <span class="literal">NULL</span>, or points to a structure containing nonzero fields, <em>select()</em> blocks until one of the following occurs:</p>
<p class="bull">&#8226; at least one of the file descriptors specified in <em>readfds</em>, <em>writefds</em>, or <em>exceptfds</em> becomes ready;</p>
<p class="bull">&#8226; the call is interrupted by a signal handler; or</p>
<p class="bull">&#8226; the amount of time specified by <em>timeout</em> has passed.</p>
<div class="block1">
<p class="noindent">In older UNIX implementations that lacked a sleep call with subsecond precision (e.g., <em>nanosleep()</em>), <em>select()</em> was used to emulate this functionality by specifying <em>nfds</em> as 0; <em>readfds</em>, <em>writefds</em>, and <em>exceptfds</em> as <span class="literal">NULL</span>; and the desired sleep interval in <em>timeout</em>.</p>
</div>
<p class="noindent">On Linux, if <em>select()</em> returns because one or more file descriptors became ready, and if <em>timeout</em> was non-<span class="literal">NULL</span>, then <em>select()</em> updates the structure to which <em>timeout</em> points to indicate how much time remained until the call would have timed out. However, this behavior is implementation-specific. SUSv3 also allows the possibility that an implementation leaves the structure pointed to by <em>timeout</em> unchanged, and most other UNIX implementations <em>don&#8217;t</em> modify this structure. Portable applications that employ <em>select()</em> within a loop should always ensure that the structure pointed to by <em>timeout</em> is initialized before each <em>select()</em> call, and should ignore the information returned in the structure after the call.</p>
<p class="indent">SUSv3 states that the structure pointed to by <em>timeout</em> may be modified only on a successful return from <em>select()</em>. However, on Linux, if <em>select()</em> is interrupted by a signal handler (so that it fails with the error <span class="literal">EINTR</span>), then the structure is modified to indicate the time remaining until a timeout would have occurred (i.e., like a successful return).</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_1334"/>If we use the Linux-specific <em>personality()</em> system call to set a personality that includes the <span class="literal">STICKY_TIMEOUTS</span> personality bit, then <em>select()</em> doesn&#8217;t modify the structure pointed to by <em>timeout</em>.</p>
</div>
<h5 class="h5" id="ch63lev3sec04"><strong>Return value from <em>select()</em></strong></h5>
<p class="noindentab">As its function result, <em>select()</em> returns one of the following:</p>
<p class="bull">&#8226; A return value of &#8211;1 indicates that an error occurred. Possible errors include <span class="literal">EBADF</span> and <span class="literal">EINTR</span>. <span class="literal">EBADF</span> indicates that one of the file descriptors in <em>readfds</em>, <em>writefds</em>, or <em>exceptfds</em> is invalid (e.g., not currently open). <span class="literal">EINTR</span>, indicates that the call was interrupted by a signal handler. (As noted in <a href="ch21.xhtml#ch21lev1sec05">Section 21.5</a>, <em>select()</em> is never automatically restarted if interrupted by a signal handler.)</p>
<p class="bull">&#8226; A return value of 0 means that the call timed out before any file descriptor became ready. In this case, each of the returned file descriptor sets will be empty.</p>
<p class="bull">&#8226; A positive return value indicates that one or more file descriptors is ready. The return value is the number of ready descriptors. In this case, each of the returned file descriptor sets must be examined (using <span class="literal">FD_ISSET()</span>) in order to find out which I/O events occurred. If the same file descriptor is specified in more than one of <em>readfds</em>, <em>writefds</em>, and <em>exceptfds</em>, it is counted multiple times if it is ready for more than one event. In other words, <em>select()</em> returns the total number of file descriptors marked as ready in all three returned sets.</p>
<h5 class="h5" id="ch63lev3sec05"><strong>Example program</strong></h5>
<p class="noindenta">The program in <a href="ch63.xhtml#ch63ex1">Listing 63-1</a> demonstrates the use of <em>select()</em>. Using command-line arguments, we can specify the <em>timeout</em> and the file descriptors that we wish to monitor. The first command-line argument specifies the <em>timeout</em> for <em>select()</em>, in seconds. If a hyphen (<span class="literal">-</span>) is specified here, then <em>select()</em> is called with a timeout of <span class="literal">NULL</span>, meaning block indefinitely. Each of the remaining command-line arguments specifies the number of a file descriptor to be monitored, followed by letters indicating the operations for which the descriptor is to be checked. The letters we can specify here are <em>r</em> (ready for read) and <em>w</em> (ready for write).</p>
<p class="examplet"><a id="ch63ex1"/><strong>Listing 63-1:</strong> Using <em>select()</em> to monitor multiple file descriptors</p>
<p class="programsli">_________________________________________________________ <span class="codestrong">altio/t_select.c</span><br/><br/>#include &lt;sys/time.h&gt;<br/>#include &lt;sys/select.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static void<br/>usageError(const char *progName)<br/>{<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "Usage: %s {timeout|-} fd-num[rw]...\n", progName);<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;- means infinite timeout; \n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;r = monitor for read\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;w = monitor for write\n\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;e.g.: %s - 0rw 1w\n", progName);<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}<br/><br/><span epub:type="pagebreak" id="page_1335"/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;fd_set readfds, writefds;<br/>&#160;&#160;&#160;&#160;int ready, nfds, fd, numRead, j;<br/>&#160;&#160;&#160;&#160;struct timeval timeout;<br/>&#160;&#160;&#160;&#160;struct timeval *pto;<br/>&#160;&#160;&#160;&#160;char buf[10];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Large enough to hold "rw\0" */<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0]);<br/><br/>&#160;&#160;&#160;&#160;/* Timeout for select() is specified in argv[1] */<br/><br/>&#160;&#160;&#160;&#160;if (strcmp(argv[1], "-") == 0) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pto = NULL;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Infinite timeout */<br/>&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pto = &#38;timeout;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;timeout.tv_sec = getLong(argv[1], 0, "timeout");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;timeout.tv_usec = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* No microseconds */<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;/* Process remaining arguments to build file descriptor sets */<br/><br/>&#160;&#160;&#160;&#160;nfds = 0;<br/>&#160;&#160;&#160;&#160;FD_ZERO(&#38;readfds);<br/>&#160;&#160;&#160;&#160;FD_ZERO(&#38;writefds);<br/><br/>&#160;&#160;&#160;&#160;for (j = 2; j &lt; argc; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numRead = sscanf(argv[j], "%d%2[rw]", &#38;fd, buf);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead != 2)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (fd &gt;= FD_SETSIZE)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cmdLineErr("file descriptor exceeds limit (%d)\n", FD_SETSIZE);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (fd &gt;= nfds)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nfds = fd + 1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Record maximum fd + 1 */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (strchr(buf, 'r') != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;FD_SET(fd, &#38;readfds);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (strchr(buf, 'w') != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;FD_SET(fd, &#38;writefds);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;/* We've built all of the arguments; now call select() */<br/><br/>&#160;&#160;&#160;&#160;ready = select(nfds, &#38;readfds, &#38;writefds, NULL, pto);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Ignore exceptional events */<br/>&#160;&#160;&#160;&#160;if (ready == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("select");<br/><br/>&#160;&#160;&#160;&#160;/* Display results of select() */<br/><br/>&#160;&#160;&#160;&#160;printf("ready = %d\n", ready);<br/><br/><span epub:type="pagebreak" id="page_1336"/>&#160;&#160;&#160;&#160;for (fd = 0; fd &lt; nfds; fd++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%d: %s%s\n", fd, FD_ISSET(fd, &#38;readfds) ? "r" : "",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;FD_ISSET(fd, &#38;writefds) ? "w" : "");<br/><br/>&#160;&#160;&#160;&#160;if (pto != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("timeout after select(): %ld.%03ld\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) timeout.tv_sec, (long) timeout.tv_usec / 1000);<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________________ <span class="codestrong">altio/t_select.c</span></p>
<p class="noindent">In the following shell session log, we demonstrate the use of the program in <a href="ch63.xhtml#ch63ex1">Listing 63-1</a>. In the first example, we make a request to monitor file descriptor 0 for input with a 10-second <em>timeout</em>:</p>
<p class="programs">$ <span class="codestrong">./t_select 10 0r</span><br/><span class="font1">Press Enter, so that a line of input is available on file descriptor 0</span><br/>ready = 1<br/>0: r<br/>timeout after select(): 8.003<br/>$&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Next shell prompt is displayed</span></p>
<p class="noindent">The above output shows us that <em>select()</em> determined that one file descriptor was ready. This was file descriptor 0, which was ready for reading. We can also see that the <em>timeout</em> was modified. The final line of output, consisting of just the shell <span class="literal">$</span> prompt, appeared because the <em>t_select</em> program didn&#8217;t read the newline character that made file descriptor 0 ready, and so that character was read by the shell, which responded by printing another prompt.</p>
<p class="indent">In the next example, we again monitor file descriptor 0 for input, but this time with a <em>timeout</em> of 0 seconds:</p>
<p class="programs">$ <span class="codestrong">./t_select 0 0r</span><br/>ready = 0<br/>timeout after select(): 0.000</p>
<p class="noindent">The <em>select()</em> call returned immediately, and found no file descriptor was ready.</p>
<p class="indent">In the next example, we monitor two file descriptors: descriptor 0, to see if input is available, and descriptor 1, to see if output is possible. In this case, we specify the <em>timeout</em> as <span class="literal">NULL</span> (the first command-line argument is a hyphen), meaning infinity:</p>
<p class="programs">$ <span class="codestrong">./t_select - 0r 1w</span><br/>ready = 1<br/>0:<br/>1: w</p>
<p class="noindent">The <em>select()</em> call returned immediately, informing us that output was possible on file descriptor 1.</p>
<h4 class="h4" id="ch63lev2sec04"><span epub:type="pagebreak" id="page_1337"/><strong>63.2.2 The <em>poll()</em> System Call</strong></h4>
<p class="noindenta">The <em>poll()</em> system call performs a similar task to <em>select()</em>. The major difference between the two system calls lies in how we specify the file descriptors to be monitored. With <em>select()</em>, we provide three sets, each marked to indicate the file descriptors of interest. With <em>poll()</em>, we provide a list of file descriptors, each marked with the set of events of interest.</p>
<div class="box">
<p class="programsa">#include &lt;poll.h&gt;<br/><br/>int <span class="codestrong">poll</span>(struct pollfd <span class="font1">fds</span>[], nfds_t <span class="font1">nfds</span>, int <span class="font1">timeout</span>);</p>
<p class="right">Returns number of ready file descriptors, 0 on timeout, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>pollfd</em> array (<em>fds</em>) and the <em>nfds</em> argument specify the file descriptors that <em>poll()</em> is to monitor. The <em>timeout</em> argument can be used to set an upper limit on the time for which <em>poll()</em> will block. We describe each of these arguments in detail below.</p>
<h5 class="h5" id="ch63lev3sec06"><strong>The <em>pollfd</em> array</strong></h5>
<p class="noindenta">The <em>fds</em> argument lists the file descriptors to be monitored by <em>poll()</em>. This argument is an array of <em>pollfd</em> structures, defined as follows:</p>
<p class="programs">struct pollfd {<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;fd;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* File descriptor */<br/>&#160;&#160;&#160;&#160;short events;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Requested events bit mask */<br/>&#160;&#160;&#160;&#160;short revents;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Returned events bit mask */<br/>};</p>
<p class="noindent">The <em>nfds</em> arguments specifies the number of items in the <em>fds</em> array. The <em>nfds_t</em> data type used to type the <em>nfds</em> argument is an unsigned integer type.</p>
<p class="indent">The <em>events</em> and <em>revents</em> fields of the <em>pollfd</em> structure are bit masks. The caller initializes <em>events</em> to specify the events to be monitored for the file descriptor <em>fd</em>. Upon return from <em>poll()</em>, <em>revents</em> is set to indicate which of those events actually occurred for this file descriptor.</p>
<p class="indent"><a href="ch63.xhtml#ch63table2">Table 63-2</a> lists the bits that may appear in the <em>events</em> and <em>revents</em> fields. The first group of bits in this table (<span class="literal">POLLIN</span>, <span class="literal">POLLRDNORM</span>, <span class="literal">POLLRDBAND</span>, <span class="literal">POLLPRI</span>, and <span class="literal">POLLRDHUP</span>) are concerned with input events. The next group of bits (<span class="literal">POLLOUT</span>, <span class="literal">POLLWRNORM</span>, and <span class="literal">POLLWRBAND</span>) are concerned with output events. The third group of bits (<span class="literal">POLLERR</span>, <span class="literal">POLLHUP</span>, and <span class="literal">POLLNVAL</span>) are set in the <em>revents</em> field to return additional information about the file descriptor. If specified in the <em>events</em> field, these three bits are ignored. The final bit (<span class="literal">POLLMSG</span>) is unused by <em>poll()</em> on Linux.</p>
<div class="block">
<p class="noindent">On UNIX implementations providing STREAMS devices, <span class="literal">POLLMSG</span> indicates that a message containing a <span class="literal">SIGPOLL</span> signal has reached the head of the stream. <span class="literal">POLLMSG</span> is unused on Linux, because Linux doesn&#8217;t implement STREAMS.</p>
</div>
<p class="tablecap"><span epub:type="pagebreak" id="page_1338"/><a id="ch63table2"/><strong>Table 63-2:</strong> Bit-mask values for <em>events</em> and <em>revents</em> fields of the <em>pollfd</em> structure</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Bit</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong>Input in <em>events</em>?</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong>Returned in <em>revents</em>?</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLLIN</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Data other than high-priority data can be read</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLLRDNORM</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Equivalent to <span class="literal">POLLIN</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLLRDBAND</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Priority data can be read (unused on Linux)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLLPRI</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">High-priority data can be read</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">POLLRDHUP</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Shutdown on peer socket</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLLOUT</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Normal data can be written</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLLWRNORM</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Equivalent to <span class="literal">POLLOUT</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">POLLWRBAND</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Priority data can be written</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLLERR</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">An error has occurred</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLLHUP</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">A hangup has occurred</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">POLLNVAL</span></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">File descriptor is not open</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">POLLMSG</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Unused on Linux (and unspecified in SUSv3)</p></td>
</tr>
</tbody>
</table>
<p class="noindent">If <em>events</em> is specified as 0, the only bits that can be returned in <em>revents</em> are <span class="literal">POLLERR</span>, <span class="literal">POLLHUP</span>, and <span class="literal">POLLNVAL</span>.</p>
<p class="indent">Specifying a negative value for the <em>fd</em> field (e.g., negating its value if nonzero) causes the corresponding <em>events</em> field to be ignored and the <em>revents</em> field always to be returned as 0. This technique can be used to (perhaps temporarily) disable monitoring of a single file descriptor, without needing to rebuild the entire <em>fds</em> list.</p>
<p class="indentb">Note the following further points regarding the Linux implementation of <em>poll()</em>:</p>
<p class="bull">&#8226; Although defined as separate bits, <span class="literal">POLLIN</span> and <span class="literal">POLLRDNORM</span> are synonymous.</p>
<p class="bull">&#8226; Although defined as separate bits, <span class="literal">POLLOUT</span> and <span class="literal">POLLWRNORM</span> are synonymous.</p>
<p class="bull">&#8226; <span class="literal">POLLRDBAND</span> is generally unused; that is, it is ignored in the <em>events</em> field and not set in <em>revents</em>.</p>
<div class="block1">
<p class="noindent">The only place where <span class="literal">POLLRDBAND</span> is set is in code implementing the (obsolete) DECnet networking protocol.</p>
</div>
<p class="bull">&#8226; Although set for sockets in certain circumstances, <span class="literal">POLLWRBAND</span> conveys no useful information. (There are no circumstances in which <span class="literal">POLLWRBAND</span> is set when <span class="literal">POLLOUT</span> and <span class="literal">POLLWRNORM</span> are not also set.)</p>
<div class="block1">
<p class="noindent"><span class="literal">POLLRDBAND</span> and <span class="literal">POLLWRBAND</span> are meaningful on implementations that provide System V STREAMS (which Linux does not). Under STREAMS, a message can be assigned a nonzero priority, and such messages are queued to the receiver in decreasing order of priority, in a band ahead of normal (priority 0) messages.</p>
</div>
<p class="bull">&#8226; The <span class="literal">_XOPEN_SOURCE</span> feature test macro must be defined in order to obtain the definitions of the constants <span class="literal">POLLRDNORM</span>, <span class="literal">POLLRDBAND</span>, <span class="literal">POLLWRNORM</span>, and <span class="literal">POLLWRBAND</span> from <span class="literal">&lt;poll.h&gt;</span>.</p>
<p class="bull"><span epub:type="pagebreak" id="page_1339"/>&#8226; <span class="literal">POLLRDHUP</span> is a Linux-specific flag available since kernel 2.6.17. In order to obtain this definition from <span class="literal">&lt;poll.h&gt;</span>, the <span class="literal">_GNU_SOURCE</span> feature test macro must be defined.</p>
<p class="bull">&#8226; <span class="literal">POLLNVAL</span> is returned if the specified file descriptor was closed at the time of the <em>poll()</em> call.</p>
<p class="noindentt">Summarizing the above points, the <em>poll()</em> flags of real interest are <span class="literal">POLLIN</span>, <span class="literal">POLLOUT</span>, <span class="literal">POLLPRI</span>, <span class="literal">POLLRDHUP</span>, <span class="literal">POLLHUP</span>, and <span class="literal">POLLERR</span>. We consider the meanings of these flags in greater detail in <a href="ch63.xhtml#ch63lev2sec05">Section 63.2.3</a>.</p>
<h5 class="h5" id="ch63lev3sec07"><strong>The <em>timeout</em> argument</strong></h5>
<p class="noindentab">The <em>timeout</em> argument determines the blocking behavior of <em>poll()</em> as follows:</p>
<p class="bull">&#8226; If <em>timeout</em> equals &#8211;1, block until one of the file descriptors listed in the <em>fds</em> array is ready (as defined by the corresponding <em>events</em> field) or a signal is caught.</p>
<p class="bull">&#8226; If <em>timeout</em> equals 0, do not block&#8212;just perform a check to see which file descriptors are ready.</p>
<p class="bull">&#8226; If <em>timeout</em> is greater than 0, block for up to <em>timeout</em> milliseconds, until one of the file descriptors in <em>fds</em> is ready, or until a signal is caught.</p>
<p class="noindentt">As with <em>select()</em>, the accuracy of <em>timeout</em> is limited by the granularity of the software clock (<a href="ch10.xhtml#ch10lev1sec06">Section 10.6</a>), and SUSv3 specifies that <em>timeout</em> is always rounded upward if it is not an exact multiple of the clock granularity.</p>
<h5 class="h5" id="ch63lev3sec08"><strong>Return value from <em>poll()</em></strong></h5>
<p class="noindentab">As its function result, <em>poll()</em> returns one of the following:</p>
<p class="bull">&#8226; A return value of &#8211;1 indicates that an error occurred. One possible error is <span class="literal">EINTR</span>, indicating that the call was interrupted by a signal handler. (As noted in <a href="ch21.xhtml#ch21lev1sec05">Section 21.5</a>, <em>poll()</em> is never automatically restarted if interrupted by a signal handler.)</p>
<p class="bull">&#8226; A return of 0 means that the call timed out before any file descriptor became ready.</p>
<p class="bull">&#8226; A positive return value indicates that one or more file descriptors are ready. The returned value is the number of <em>pollfd</em> structures in the <em>fds</em> array that have a nonzero <em>revents</em> field.</p>
<div class="block1">
<p class="noindent">Note the slightly different meaning of a positive return value from <em>select()</em> and <em>poll()</em>. The <em>select()</em> system call counts a file descriptor multiple times if it occurs in more than one returned file descriptor set. The <em>poll()</em> system call returns a count of ready file descriptors, and a file descriptor is counted only once, even if multiple bits are set in the corresponding <em>revents</em> field.</p>
</div>
<h5 class="h5" id="ch63lev3sec09"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch63.xhtml#ch63ex2">Listing 63-2</a> provides a simple demonstration of the use of <em>poll()</em>. This program creates a number of pipes (each pipe uses a consecutive pair of file descriptors), writes bytes to the write ends of randomly selected pipes, and then performs a <em>poll()</em> to see which pipes have data available for reading.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1340"/>The following shell session shows an example of what we see when running this program. The command-line arguments to the program specify that ten pipes should be created, and writes should be made to three randomly selected pipes.</p>
<p class="programs">$ <span class="codestrong">./poll_pipes 10 3</span><br/>Writing to fd:&#160;&#160;&#160;4 (read fd:&#160;&#160;&#160;3)<br/>Writing to fd:&#160;&#160;14 (read fd:&#160;&#160;13)<br/>Writing to fd:&#160;&#160;14 (read fd:&#160;&#160;13)<br/>poll() returned: 2<br/>Readable:&#160;&#160;&#160;3<br/>Readable:&#160;&#160;13</p>
<p class="noindent">From the above output, we can see that <em>poll()</em> found two pipes had data available for reading.</p>
<p class="examplet"><a id="ch63ex2"/><strong>Listing 63-2:</strong> Using <em>poll()</em> to monitor multiple file descriptors</p>
<p class="programsli">_______________________________________________________ <span class="codestrong">altio/poll_pipes.c</span><br/><br/>#include &lt;time.h&gt;<br/>#include &lt;poll.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int numPipes, j, ready, randPipe, numWrites;<br/>&#160;&#160;&#160;&#160;int (*pfds)[2];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* File descriptors for all pipes */<br/>&#160;&#160;&#160;&#160;struct pollfd *pollFd;<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s num-pipes [num-writes]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;/* Allocate the arrays that we use. The arrays are sized according<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;to the number of pipes specified on command line */<br/><br/>&#160;&#160;&#160;&#160;numPipes = getInt(argv[1], GN_GT_0, "num-pipes");<br/><br/>&#160;&#160;&#160;&#160;pfds = calloc(numPipes, sizeof(int [2]));<br/>&#160;&#160;&#160;&#160;if (pfds == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("calloc");<br/>&#160;&#160;&#160;&#160;pollFd = calloc(numPipes, sizeof(struct pollfd));<br/>&#160;&#160;&#160;&#160;if (pollFd == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("calloc");<br/><br/>&#160;&#160;&#160;&#160;/* Create the number of pipes specified on command line */<br/><br/>&#160;&#160;&#160;&#160;for (j = 0; j &lt; numPipes; j++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (pipe(pfds[j]) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("pipe %d", j);<br/><br/>&#160;&#160;&#160;&#160;/* Perform specified number of writes to random pipes */<br/><br/>&#160;&#160;&#160;&#160;numWrites = (argc &gt; 2) ? getInt(argv[2], GN_GT_0, "num-writes") : 1;<br/><br/>&#160;&#160;&#160;&#160;srandom((int) time(NULL));<br/>&#160;&#160;&#160;&#160;for (j = 0; j &lt; numWrites; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;randPipe = random() % numPipes;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Writing to fd: %3d (read fd: %3d)\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pfds[randPipe][1], pfds[randPipe][0]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (write(pfds[randPipe][1], "a", 1) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("write %d", pfds[randPipe][1]);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;/* Build the file descriptor list to be supplied to poll(). This list<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;is set to contain the file descriptors for the read ends of all of<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;the pipes. */<br/><br/>&#160;&#160;&#160;&#160;for (j = 0; j &lt; numPipes; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pollFd[j].fd = pfds[j][0];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pollFd[j].events = POLLIN;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;ready = poll(pollFd, numPipes, 0);<br/>&#160;&#160;&#160;&#160;if (ready == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("poll");<br/><br/>&#160;&#160;&#160;&#160;printf("poll() returned: %d\n", ready);<br/><br/>&#160;&#160;&#160;&#160;/* Check which pipes have data available for reading */<br/><br/>&#160;&#160;&#160;&#160;for (j = 0; j &lt; numPipes; j++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (pollFd[j].revents &#38; POLLIN)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Readable: %3d\n", pollFd[j].fd);<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_______________________________________________________ <span class="codestrong">altio/poll_pipes.c</span></p>
<h4 class="h4" id="ch63lev2sec05"><span epub:type="pagebreak" id="page_1341"/><strong>63.2.3 When Is a File Descriptor Ready?</strong></h4>
<p class="noindentab">Correctly using <em>select()</em> and <em>poll()</em> requires an understanding of the conditions under which a file descriptor indicates as being ready. SUSv3 says that a file descriptor (with <span class="literal">O_NONBLOCK</span> clear) is considered to be ready if a call to an I/O function would not block, <em>regardless of whether the function would actually transfer data</em>. The key point is italicized: <em>select()</em> and <em>poll()</em> tell us whether an I/O operation would not block, rather than whether it would successfully transfer data. In this light, let us consider how these system calls operate for different types of file descriptors. We show this information in tables containing two columns:</p>
<p class="bull">&#8226; The <em>select()</em> column indicates whether a file descriptor is marked as readable (<span class="literal">r</span>), writable (<span class="literal">w</span>), or having an exceptional condition (<span class="literal">x</span>).</p>
<p class="bull">&#8226; The <em>poll()</em> column indicates the bit(s) returned in the <em>revents</em> field. In these tables, we omit mention of <span class="literal">POLLRDNORM</span>, <span class="literal">POLLWRNORM</span>, <span class="literal">POLLRDBAND</span>, and <span class="literal">POLLWRBAND</span>. Although some of these flags may be returned in <em>revents</em> in various circumstances (if they are specified in <em>events</em>), they convey no useful information beyond that provided by <span class="literal">POLLIN</span>, <span class="literal">POLLOUT</span>, <span class="literal">POLLHUP</span>, and <span class="literal">POLLERR</span>.</p>
<h5 class="h5" id="ch63lev3sec10"><span epub:type="pagebreak" id="page_1342"/><strong>Regular files</strong></h5>
<p class="noindentab">File descriptors that refer to regular files are always marked as readable and writable by <em>select()</em>, and returned with <span class="literal">POLLIN</span> and <span class="literal">POLLOUT</span> set in <em>revents</em> for <em>poll()</em>, for the following reasons:</p>
<p class="bull">&#8226; A <em>read()</em> will always immediately return data, end-of-file, or an error (e.g., the file was not opened for reading).</p>
<p class="bull">&#8226; A <em>write()</em> will always immediately transfer data or fail with some error.</p>
<div class="block1">
<p class="noindent">SUSv3 says that <em>select()</em> should also mark a descriptor for a regular file as having an exceptional condition (though this has no obvious meaning for regular files). Only some implementations do this; Linux is one of those that do not.</p>
</div>
<h5 class="h5" id="ch63lev3sec11"><strong>Terminals and pseudoterminals</strong></h5>
<p class="noindenta"><a href="ch63.xhtml#ch63table3">Table 63-3</a> summarizes the behavior of <em>select()</em> and <em>poll()</em> for terminals and pseudoterminals (<a href="ch64.xhtml#ch64">Chapter 64</a>).</p>
<p class="indent">When one half of a pseudoterminal pair is closed, the <em>revents</em> setting returned by <em>poll()</em> for the other half of the pair depends on the implementation. On Linux, at least the <span class="literal">POLLHUP</span> flag is set. However, other implementations return various flags to indicate this event&#8212;for example, <span class="literal">POLLHUP</span>, <span class="literal">POLLERR</span>, or <span class="literal">POLLIN</span>. Furthermore, on some implementations, the flags that are set depend on whether it is the master or the slave device that is being monitored.</p>
<p class="tablecap"><a id="ch63table3"/><strong>Table 63-3:</strong> <em>select()</em> and <em>poll()</em> indications for terminals and pseudoterminals</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Condition or event</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><em>select()</em></strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong><em>poll()</em></strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Input available</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">r</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">POLLIN</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Output possible</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">w</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">POLLOUT</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">After <em>close()</em> by pseudoterminal peer</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">rw</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">See text</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table">Pseudoterminal master in packet mode detects slave state change</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">x</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table"><span class="literal">POLLPRI</span></p></td>
</tr>
</tbody>
</table>
<h5 class="h5" id="ch63lev3sec12"><strong>Pipes and FIFOs</strong></h5>
<p class="noindenta"><a href="ch63.xhtml#ch63table4">Table 63-4</a> summarizes the details for the read end of a pipe or FIFO. The <em>Data in pipe?</em> column indicates whether the pipe has at least 1 byte of data available for reading. In this table, we assume that <span class="literal">POLLIN</span> was specified in the <em>events</em> field for <em>poll()</em>.</p>
<p class="indent">On some other UNIX implementations, if the write end of a pipe is closed, then, instead of returning with <span class="literal">POLLHUP</span> set, <em>poll()</em> returns with the <span class="literal">POLLIN</span> bit set (since a <em>read()</em> will return immediately with end-of-file). Portable applications should check to see if either bit is set in order to know if a <em>read()</em> will block.</p>
<p class="indent"><a href="ch63.xhtml#ch63table5">Table 63-5</a> summarizes the details for the write end of a pipe or FIFO. In this table, we assume that <span class="literal">POLLOUT</span> was specified in the <em>events</em> field for <em>poll()</em>. The <em>Space for PIPE_BUF bytes?</em> column indicates whether the pipe has room to atomically write <span class="literal">PIPE_BUF</span> bytes without blocking. This is the criterion on which Linux considers a pipe ready for writing. Some other UNIX implementations use the same criterion; others consider a pipe writable if even a single byte can be written. (In Linux 2.6.10 and earlier, the capacity of a pipe is the same as <span class="literal">PIPE_BUF</span>. This means that a pipe is considered unwritable if it contains even a single byte of data.)</p>
<p class="indent"><span epub:type="pagebreak" id="page_1343"/>On some other UNIX implementations, if the read end of a pipe is closed, then, instead of returning with <span class="literal">POLLERR</span> set, <em>poll()</em> returns with either the <span class="literal">POLLOUT</span> bit or the <span class="literal">POLLHUP</span> bit set. Portable applications need to check to see if any of these bits is set to determine if a <em>write()</em> will block.</p>
<p class="tablecap"><a id="ch63table4"/><strong>Table 63-4:</strong> <em>select()</em> and <em>poll()</em> indications for the read end of a pipe or FIFO</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th" colspan="2"><p class="tablec"><strong>Condition or event</strong></p></td>
<td style="vertical-align: middle;" class="table_th" rowspan="2"><p class="table"><strong><em>select()</em></strong></p></td>
<td style="vertical-align: middle;" class="table_th1" rowspan="2"><p class="table"><strong><em>poll()</em></strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Data in pipe?</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Write end open?</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">no</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">no</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">r</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">POLLHUP</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">r</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">POLLIN</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table">yes</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">no</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">r</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table"><span class="literal">POLLIN | POLLHUP</span></p></td>
</tr>
</tbody>
</table>
<p class="tablecap"><a id="ch63table5"/><strong>Table 63-5:</strong> <em>select()</em> and <em>poll()</em> indications for the write end of a pipe or FIFO</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th" colspan="2"><p class="tablec"><strong>Condition or event</strong></p></td>
<td style="vertical-align: middle;" class="table_th" rowspan="2"><p class="table"><strong><em>select()</em></strong></p></td>
<td style="vertical-align: middle;" class="table_th1" rowspan="2"><p class="table"><strong><em>poll()</em></strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Space for</strong> <span class="literal"><span class="codestrong">PIPE_BUF</span></span> <strong>bytes?</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Read end open?</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">no</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">no</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">w</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">POLLERR</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">yes</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">w</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">POLLOUT</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table">yes</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">no</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">w</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table"><span class="literal">POLLOUT | POLLERR</span></p></td>
</tr>
</tbody>
</table>
<h5 class="h5" id="ch63lev3sec13"><strong>Sockets</strong></h5>
<p class="noindenta"><a href="ch63.xhtml#ch63table6">Table 63-6</a> summarizes the behavior of <em>select()</em> and <em>poll()</em> for sockets. For the <em>poll()</em> column, we assume that <em>events</em> was specified as <span class="literal">(POLLIN | POLLOUT | POLLPRI)</span>. For the <em>select()</em> column, we assume that the file descriptor is being tested to see if input is possible, output is possible, or an exceptional condition occurred (i.e., the file descriptor is specified in all three sets passed to <em>select()</em>). This table covers just the common cases, not all possible scenarios.</p>
<div class="block">
<p class="noindent">The Linux <em>poll()</em> behavior for UNIX domain sockets after a peer <em>close()</em> differs from that shown in <a href="ch63.xhtml#ch63table6">Table 63-6</a>. As well as the other flags, <em>poll()</em> additionally returns <span class="literal">POLLHUP</span> in <em>revents</em>.</p>
</div>
<p class="tablecap"><a id="ch63table6"/><strong>Table 63-6:</strong> <em>select()</em> and <em>poll()</em> indications for sockets</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Condition or event</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><em>select()</em></strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong><em>poll()</em></strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Input available</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">r</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">POLLIN</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Output possible</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">w</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">POLLOUT</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Incoming connection established on listening socket</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">r</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">POLLIN</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Out-of-band data received (TCP only)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">x</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">POLLPRI</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table">Stream socket peer closed connection</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">rw</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table"><span class="literal">POLLIN | POLLOUT | POLLRDHUP</span></p></td>
</tr>
</tbody>
</table>
<p class="noindent">The Linux-specific <span class="literal">POLLRDHUP</span> flag (available since Linux 2.6.17) needs a little further explanation. This flag&#8212;actually in the form of <span class="literal">EPOLLRDHUP</span>&#8212;is designed primarily for use with the edge-triggered mode of the <em>epoll</em> API (<a href="ch63.xhtml#ch63lev1sec04">Section 63.4</a>). It is returned when the remote end of a stream socket connection has shut down the writing half <span epub:type="pagebreak" id="page_1344"/>of the connection. The use of this flag allows an application that uses the <em>epoll</em> edge-triggered interface to employ simpler code to recognize a remote shutdown. (The alternative is for the application to note that the <span class="literal">POLLIN</span> flag is set and then perform a <em>read()</em>, which indicates the remote shutdown with a return of 0.)</p>
<h4 class="h4" id="ch63lev2sec06"><strong>63.2.4 Comparison of <em>select()</em> and <em>poll()</em></strong></h4>
<p class="noindenta">In this section, we consider some similarities and differences between <em>select()</em> and <em>poll()</em>.</p>
<h5 class="h5" id="ch63lev3sec14"><strong>Implementation details</strong></h5>
<p class="noindenta">Within the Linux kernel, <em>select()</em> and <em>poll()</em> both employ the same set of kernel-internal <em>poll</em> routines. These <em>poll</em> routines are distinct from the <em>poll()</em> system call itself. Each routine returns information about the readiness of a single file descriptor. This readiness information takes the form of a bit mask whose values correspond to the bits returned in the <em>revents</em> field by the <em>poll()</em> system call (<a href="ch63.xhtml#ch63table2">Table 63-2</a>). The implementation of the <em>poll()</em> system call involves calling the kernel <em>poll</em> routine for each file descriptor and placing the resulting information in the corresponding <em>revents</em> field.</p>
<p class="indent">To implement <em>select()</em>, a set of macros is used to convert the information returned by the kernel <em>poll</em> routines into the corresponding event types returned by <em>select()</em>:</p>
<p class="programs">#define POLLIN_SET&#160;&#160;(POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Ready for reading */<br/>#define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Ready for writing */<br/>#define POLLEX_SET&#160;&#160;(POLLPRI)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Exceptional condition */</p>
<p class="noindent">These macro definitions reveal the semantic correspondence between the information returned by <em>select()</em> and <em>poll()</em>. (If we look at the <em>select()</em> and <em>poll()</em> columns in the tables in <a href="ch63.xhtml#ch63lev2sec05">Section 63.2.3</a>, we see that the indications provided by each system call are consistent with the above macros.) The only additional information we need to complete the picture is that <em>poll()</em> returns <span class="literal">POLLNVAL</span> in the <em>revents</em> field if one of the monitored file descriptors was closed at the time of the call, while <em>select()</em> returns &#8211;1 with <em>errno</em> set to <span class="literal">EBADF</span>.</p>
<h5 class="h5" id="ch63lev3sec15"><strong>API differences</strong></h5>
<p class="noindentab">The following are some differences between the <em>select()</em> and <em>poll()</em> APIs:</p>
<p class="bull">&#8226; The use of the <em>fd_set</em> data type places an upper limit (<span class="literal">FD_SETSIZE</span>) on the range of file descriptors that can be monitored by <em>select()</em>. By default, this limit is 1024 on Linux, and changing it requires recompiling the application. By contrast, <em>poll()</em> places no intrinsic limit on the range of file descriptors that can be monitored.</p>
<p class="bull">&#8226; Because the <em>fd_set</em> arguments of <em>select()</em> are value-result, we must reinitialize them if making repeated <em>select()</em> calls from within a loop. By using separate <em>events</em> (input) and <em>revents</em> (output) fields, <em>poll()</em> avoids this requirement.</p>
<p class="bull"><span epub:type="pagebreak" id="page_1345"/>&#8226; The <em>timeout</em> precision afforded by <em>select()</em> (microseconds) is greater than that afforded by <em>poll()</em> (milliseconds). (The accuracy of the timeouts of both of these system calls is nevertheless limited by the software clock granularity.)</p>
<p class="bull">&#8226; If one of the file descriptors being monitored was closed, then <em>poll()</em> informs us exactly which one, via the <span class="literal">POLLNVAL</span> bit in the corresponding <em>revents</em> field. By contrast, <em>select()</em> merely returns &#8211;1 with <em>errno</em> set to <span class="literal">EBADF</span>, leaving us to determine which file descriptor is closed by checking for an error when performing an I/O system call on the descriptor. However, this is typically not an important difference, since an application can usually keep track of which file descriptors it has closed.</p>
<h5 class="h5" id="ch63lev3sec16"><strong>Portability</strong></h5>
<p class="noindenta">Historically, <em>select()</em> was more widely available than <em>poll()</em>. Nowadays, both interfaces are standardized by SUSv3 and widely available on contemporary implementations. However, there is some variation in the behavior of <em>poll()</em> across implementations, as noted in <a href="ch63.xhtml#ch63lev2sec05">Section 63.2.3</a>.</p>
<h5 class="h5" id="ch63lev3sec17"><strong>Performance</strong></h5>
<p class="noindentab">The performance of <em>poll()</em> and <em>select()</em> is similar if either of the following is true:</p>
<p class="bull">&#8226; The range of file descriptors to be monitored is small (i.e., the maximum file descriptor number is low).</p>
<p class="bull">&#8226; A large number of file descriptors are being monitored, but they are densely packed (i.e., most or all of the file descriptors from 0 up to some limit are being monitored).</p>
<p class="noindentt">However, the performance of <em>select()</em> and <em>poll()</em> can differ noticeably if the set of file descriptors to be monitored is sparse; that is, the maximum file descriptor number, <em>N</em>, is large, but only one or a few descriptors in the range 0 to <em>N</em> are being monitored. In this case, <em>poll()</em> can perform better than <em>select()</em>. We can understand the reasons for this by considering the arguments passed to the two system calls. With <em>select()</em>, we pass one or more file descriptor sets and an integer, <em>nfds</em>, which is one greater than the maximum file descriptor to be examined in each set. The <em>nfds</em> argument has the same value, regardless of whether we are monitoring all file descriptors in the range 0 to <em>(nfds &#8211; 1)</em> or only the descriptor <em>(nfds &#8211; 1)</em>. In both cases, the kernel must examine <em>nfds</em> elements in each set in order to check exactly which file descriptors are to be monitored. By contrast, when using <em>poll()</em>, we specify only the file descriptors of interest to us, and the kernel checks only those descriptors.</p>
<div class="block">
<p class="noindent">The difference in performance for <em>poll()</em> and <em>select()</em> with sparse descriptor sets was quite significant in Linux 2.4. Some optimizations in Linux 2.6 have narrowed the performance gap considerably.</p>
</div>
<p class="noindent">We consider the performance of <em>select()</em> and <em>poll()</em> further in <a href="ch63.xhtml#ch63lev2sec14">Section 63.4.5</a>, where we compare the performance of these system calls against <em>epoll</em>.</p>
<h4 class="h4" id="ch63lev2sec07"><span epub:type="pagebreak" id="page_1346"/><strong>63.2.5 Problems with <em>select()</em> and <em>poll()</em></strong></h4>
<p class="noindentab">The <em>select()</em> and <em>poll()</em> system calls are the portable, long-standing, and widely used methods of monitoring multiple file descriptors for readiness. However, these APIs suffer some problems when monitoring a large number of file descriptors:</p>
<p class="bull">&#8226; On each call to <em>select()</em> or <em>poll()</em>, the kernel must check all of the specified file descriptors to see if they are ready. When monitoring a large number of file descriptors that are in a densely packed range, the time required for this operation greatly outweighs the time required for the next two operations.</p>
<p class="bull">&#8226; In each call to <em>select()</em> or <em>poll()</em>, the program must pass a data structure to the kernel describing all of the file descriptors to be monitored, and, after checking the descriptors, the kernel returns a modified version of this data structure to the program. (Furthermore, for <em>select()</em>, we must initialize the data structure before each call.) For <em>poll()</em>, the size of the data structure increases with the number of file descriptors being monitored, and the task of copying it from user to kernel space and back again consumes a noticeable amount of CPU time when monitoring many file descriptors. For <em>select()</em>, the size of the data structure is fixed by <span class="literal">FD_SETSIZE</span>, regardless of the number of file descriptors being monitored.</p>
<p class="bull">&#8226; After the call to <em>select()</em> or <em>poll()</em>, the program must inspect every element of the returned data structure to see which file descriptors are ready.</p>
<p class="noindentt">The consequence of the above points is that the CPU time required by <em>select()</em> and <em>poll()</em> increases with the number of file descriptors being monitored (see <a href="ch63.xhtml#ch63lev2sec14">Section 63.4.5</a> for more details). This creates problems for programs that monitor large numbers of file descriptors.</p>
<p class="indent">The poor scaling performance of <em>select()</em> and <em>poll()</em> stems from a simple limitation of these APIs: typically, a program makes repeated calls to monitor the same set of file descriptors; however, the kernel doesn&#8217;t remember the list of file descriptors to be monitored between successive calls.</p>
<p class="indent">Signal-driven I/O and <em>epoll</em>, which we examine in the following sections, are both mechanisms that allow the kernel to record a persistent list of file descriptors in which a process is interested. Doing this eliminates the performance scaling problems of <em>select()</em> and <em>poll()</em>, yielding solutions that scale according to the number of I/O events that occur, rather than according to the number of file descriptors being monitored. Consequently, signal-driven I/O and <em>epoll</em> provide superior performance when monitoring large numbers of file descriptors.</p>
<h3 class="h3" id="ch63lev1sec03"><strong>63.3 Signal-Driven I/O</strong></h3>
<p class="noindenta">With I/O multiplexing, a process makes a system call (<em>select()</em> or <em>poll()</em>) in order to check whether I/O is possible on a file descriptor. With signal-driven I/O, a process requests that the kernel send it a signal when I/O is possible on a file descriptor. The process can then perform any other activity until I/O is possible, at which time <span epub:type="pagebreak" id="page_1347"/>the signal is delivered to the process. To use signal-driven I/O, a program performs the following steps:</p>
<ol>
<li class="order"><p class="orderp">Establish a handler for the signal delivered by the signal-driven I/O mechanism. By default, this notification signal is <span class="literal">SIGIO</span>.</p></li>
<li class="order"><p class="orderp">Set the <em>owner</em> of the file descriptor&#8212;that is, the process or process group that is to receive signals when I/O is possible on the file descriptor. Typically, we make the calling process the owner. The owner is set using an <em>fcntl()</em> <span class="literal">F_SETOWN</span> operation of the following form:</p>
<p class="programs">fcntl(fd, F_SETOWN, pid);</p></li>
<li class="order"><p class="orderp">Enable nonblocking I/O by setting the <span class="literal">O_NONBLOCK</span> open file status flag.</p></li>
<li class="order"><p class="orderp">Enable signal-driven I/O by turning on the <span class="literal">O_ASYNC</span> open file status flag. This can be combined with the previous step, since they both require the use of the <em>fcntl()</em> <span class="literal">F_SETFL</span> operation (<a href="ch05.xhtml#ch05lev1sec03">Section 5.3</a>), as in the following example:</p>
<p class="programs">flags = fcntl(fd, F_GETFL);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get current flags */<br/>fcntl(fd, F_SETFL, flags | O_ASYNC | O_NONBLOCK);</p></li>
<li class="order"><p class="orderp">The calling process can now perform other tasks. When I/O becomes possible, the kernel generates a signal for the process and invokes the signal handler established in step 1.</p></li>
<li class="order"><p class="orderp">Signal-driven I/O provides edge-triggered notification (<a href="ch63.xhtml#ch63lev2sec01">Section 63.1.1</a>). This means that once the process has been notified that I/O is possible, it should perform as much I/O (e.g., read as many bytes) as possible. Assuming a nonblocking file descriptor, this means executing a loop that performs I/O system calls until a call fails with the error <span class="literal">EAGAIN</span> or <span class="literal">EWOULDBLOCK</span>.</p></li>
</ol>
<p class="noindent">On Linux 2.4 and earlier, signal-driven I/O can be employed with file descriptors for sockets, terminals, pseudoterminals, and certain other types of devices. Linux 2.6 additionally allows signal-driven I/O to be employed with pipes and FIFOs. Since Linux 2.6.25, signal-driven I/O can also be used with <em>inotify</em> file descriptors.</p>
<p class="indent">In the following pages, we first present an example of the use of signal-driven I/O, and then explain some of the above steps in greater detail.</p>
<div class="block">
<p class="noindent">Historically, signal-driven I/O was sometimes referred to as <em>asynchronous I/O</em>, and this is reflected in the name (<span class="literal">O_ASYNC</span>) of the associated open file status flag. However, nowadays, the term <em>asynchronous I/O</em> is used to refer to the type of functionality provided by the POSIX AIO specification. Using POSIX AIO, a process requests the kernel to perform an I/O operation, and the kernel <em>initiates</em> the operation, but immediately passes control back to the calling process; the process is then later notified when the I/O operation completes or an error occurs.</p>
<p class="indent"><span class="literal">O_ASYNC</span> was specified in POSIX.1g, but was not included in SUSv3 because the specification of the required behavior for this flag was deemed insufficient.</p>
<p class="indent">Several UNIX implementations, especially older ones, don&#8217;t define the <span class="literal">O_ASYNC</span> constant for use with <em>fcntl()</em>. Instead, the constant is named <span class="literal">FASYNC</span>, and <em>glibc</em> defines this latter name as a synonym for <span class="literal">O_ASYNC</span>.</p>
</div>
<h5 class="h5" id="ch63lev3sec18"><span epub:type="pagebreak" id="page_1348"/><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch63.xhtml#ch63ex3">Listing 63-3</a> provides a simple example of the use of signal-driven I/O. This program performs the steps described above for enabling signal-driven I/O on standard input, and then places the terminal in cbreak mode (<a href="ch62.xhtml#ch62lev2sec03">Section 62.6.3</a>), so that input is available a character at a time. The program then enters an infinite loop, performing the &#8220;work&#8221; of incrementing a variable, <em>cnt</em>, while waiting for input to become available. Whenever input becomes available, the <span class="literal">SIGIO</span> handler sets a flag, <em>gotSigio</em>, that is monitored by the main program. When the main program sees that this flag is set, it reads all available input characters and prints them along with the current value of <em>cnt</em>. If a hash character (<span class="literal">#</span>) is read in the input, the program terminates.</p>
<p class="indent">Here is an example of what we see when we run this program and type the <em>x</em> character a number of times, followed by a hash (<span class="literal">#</span>) character:</p>
<p class="programs">$ <span class="codestrong">./demo_sigio</span><br/>cnt=37; read x<br/>cnt=100; read x<br/>cnt=159; read x<br/>cnt=223; read x<br/>cnt=288; read x<br/>cnt=333; read #</p>
<p class="examplet"><a id="ch63ex3"/><strong>Listing 63-3:</strong> Using signal-driven I/O on a terminal</p>
<p class="programsli">_______________________________________________________ <span class="codestrong">altio/demo_sigio.c</span><br/><br/>#include &lt;signal.h&gt;<br/>#include &lt;ctype.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include &lt;termios.h&gt;<br/>#include "tty_functions.h"&#160;&#160;&#160;&#160;&#160;&#160;/* Declaration of ttySetCbreak() */<br/>#include "tlpi_hdr.h"<br/><br/>static volatile sig_atomic_t gotSigio = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Set nonzero on receipt of SIGIO */<br/><br/>static void<br/>sigioHandler(int sig)<br/>{<br/>&#160;&#160;&#160;&#160;gotSigio = 1;<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int flags, j, cnt;<br/>&#160;&#160;&#160;&#160;struct termios origTermios;<br/>&#160;&#160;&#160;&#160;char ch;<br/>&#160;&#160;&#160;&#160;struct sigaction sa;<br/>&#160;&#160;&#160;&#160;Boolean done;<br/><br/><span epub:type="pagebreak" id="page_1349"/>&#160;&#160;&#160;&#160;/* Establish handler for "I/O possible" signal */<br/><br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;sa.sa_flags = SA_RESTART;<br/>&#160;&#160;&#160;&#160;sa.sa_handler = sigioHandler;<br/>&#160;&#160;&#160;&#160;if (sigaction(SIGIO, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;/* Set owner process that is to receive "I/O possible" signal */<br/><br/>&#160;&#160;&#160;&#160;if (fcntl(STDIN_FILENO, F_SETOWN, getpid()) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fcntl(F_SETOWN)");<br/><br/>&#160;&#160;&#160;&#160;/* Enable "I/O possible" signaling and make I/O nonblocking<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;for file descriptor */<br/><br/>&#160;&#160;&#160;&#160;flags = fcntl(STDIN_FILENO, F_GETFL);<br/>&#160;&#160;&#160;&#160;if (fcntl(STDIN_FILENO, F_SETFL, flags | O_ASYNC | O_NONBLOCK) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fcntl(F_SETFL)");<br/><br/>&#160;&#160;&#160;&#160;/* Place terminal in cbreak mode */<br/><br/>&#160;&#160;&#160;&#160;if (ttySetCbreak(STDIN_FILENO, &#38;origTermios) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("ttySetCbreak");<br/><br/>&#160;&#160;&#160;&#160;for (done = FALSE, cnt = 0; !done ; cnt++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (j = 0; j &lt; 100000000; j++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Slow main loop down a little */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (gotSigio) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Is input available? */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;gotSigio = 0;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Read all available input until error (probably EAGAIN)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;or EOF (not actually possible in cbreak mode) or a<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hash (#) character is read */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (read(STDIN_FILENO, &#38;ch, 1) &gt; 0 &#38;&#38; !done) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("cnt=%d; read %c\n", cnt, ch);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;done = ch == '#';<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;/* Restore original terminal settings */<br/><br/>&#160;&#160;&#160;&#160;if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &#38;origTermios) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("tcsetattr");<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_______________________________________________________ <span class="codestrong">altio/demo_sigio.c</span></p>
<h5 class="h5" id="ch63lev3sec19"><span epub:type="pagebreak" id="page_1350"/><strong>Establish the signal handler before enabling signal-driven I/O</strong></h5>
<p class="noindenta">Because the default action of <span class="literal">SIGIO</span> is to terminate the process, we should enable the handler for <span class="literal">SIGIO</span> before enabling signal-driven I/O on a file descriptor. If we enable signal-driven I/O before establishing the <span class="literal">SIGIO</span> handler, then there is a time window during which, if I/O becomes possible, delivery of <span class="literal">SIGIO</span> will terminate the process.</p>
<div class="block">
<p class="noindent">On some UNIX implementations, <span class="literal">SIGIO</span> is ignored by default.</p>
</div>
<h5 class="h5" id="ch63lev3sec20"><strong>Setting the file descriptor owner</strong></h5>
<p class="noindenta">We set the file descriptor owner using an <em>fcntl()</em> operation of the following form:</p>
<p class="programs">fcntl(fd, F_SETOWN, pid);</p>
<p class="noindent">We may specify that either a single process or all of the processes in a process group are to be signaled when I/O is possible on the file descriptor. If <em>pid</em> is positive, it is interpreted as a process ID. If <em>pid</em> is negative, its absolute value specifies a process group ID.</p>
<div class="block">
<p class="noindent">On older UNIX implementations, an <em>ioctl()</em> operation&#8212;either <span class="literal">FIOSETOWN</span> or <span class="literal">SIOCSPGRP</span>&#8212;was used to achieve the same effect as <span class="literal">F_SETOWN</span>. For compatibility, these <em>ioctl()</em> operations are also provided on Linux.</p>
</div>
<p class="noindent">Typically, <em>pid</em> is specified as the process ID of the calling process (so that the signal is sent to the process that has the file descriptor open). However, it is possible to specify another process or a process group (e.g., the caller&#8217;s process group), and signals will be sent to that target, subject to the permission checks described in <a href="ch20.xhtml#ch20lev1sec05">Section 20.5</a>, where the sending process is considered to be the process that does the <span class="literal">F_SETOWN</span>.</p>
<p class="indent">The <em>fcntl()</em> <span class="literal">F_GETOWN</span> operation returns the ID of the process or process group that is to receive signals when I/O is possible on a specified file descriptor:</p>
<p class="programs">id = fcntl(fd, F_GETOWN);<br/>if (id == -1)<br/>&#160;&#160;&#160;&#160;errExit("fcntl");</p>
<p class="noindent">A process group ID is returned as a negative number by this call.</p>
<div class="block">
<p class="noindent">The <em>ioctl()</em> operation that corresponds to <span class="literal">F_GETOWN</span> on older UNIX implementations was <span class="literal">FIOGETOWN</span> or <span class="literal">SIOCGPGRP</span>. Both of these <em>ioctl()</em> operations are also provided on Linux.</p>
</div>
<p class="noindent">A limitation in the system call convention employed on some Linux architectures (notably, x86) means that if a file descriptor is owned by a process group ID less than 4096, then, instead of returning that ID as a negative function result from the <em>fcntl()</em> <span class="literal">F_GETOWN</span> operation, <em>glibc</em> misinterprets it as a system call error. Consequently, the <em>fcntl()</em> wrapper function returns &#8211;1, and <em>errno</em> contains the (positive) process group ID. This is a consequence of the fact that the kernel system call interface indicates errors by returning a negative <em>errno</em> value as a function result, and there are a few cases where it is necessary to distinguish such results from a successful call that returns a valid negative value. To make this distinction, <em>glibc</em> interprets negative <span epub:type="pagebreak" id="page_1351"/>system call returns in the range &#8211;1 to &#8211;4095 as indicating an error, copies this (absolute) value into <em>errno</em>, and returns &#8211;1 as the function result for the application program. This technique is generally sufficient for dealing with the few system call service routines that can return a valid negative result; the <em>fcntl()</em> <span class="literal">F_GETOWN</span> operation is the only practical case where it fails. This limitation means that an application that uses process groups to receive &#8220;I/O possible&#8221; signals (which is unusual) can&#8217;t reliably use <span class="literal">F_GETOWN</span> to discover which process group owns a file descriptor.</p>
<div class="block">
<p class="noindent">Since <em>glibc</em> version 2.11, the <em>fcntl()</em> wrapper function fixes the problem of <span class="literal">F_GETOWN</span> with process group IDs less than 4096. It does this by implementing <span class="literal">F_GETOWN</span> in user space using the <span class="literal">F_GETOWN_EX</span> operation (<a href="ch63.xhtml#ch63lev2sec09">Section 63.3.2</a>), which is provided by Linux 2.6.32 and later.</p>
</div>
<h4 class="h4" id="ch63lev2sec08"><strong>63.3.1 When Is &#8220;I/O Possible&#8221; Signaled?</strong></h4>
<p class="noindenta">We now consider the details of when &#8220;I/O possible&#8221; is signaled for various file types.</p>
<h5 class="h5" id="ch63lev3sec21"><strong>Terminals and pseudoterminals</strong></h5>
<p class="noindenta">For terminals and pseudoterminals, a signal is generated whenever new input becomes available, even if previous input has not yet been read. &#8220;Input possible&#8221; is also signaled if an end-of-file condition occurs on a terminal (but not on a pseudoterminal).</p>
<p class="indent">There is no &#8220;output possible&#8221; signaling for terminals. A terminal disconnect is also not signaled.</p>
<p class="indent">Starting with kernel 2.4.19, Linux provides &#8220;output possible&#8221; signaling for the slave side of a pseudoterminal. This signal is generated whenever input is consumed on the master side of the pseudoterminal.</p>
<h5 class="h5" id="ch63lev3sec22"><strong>Pipes and FIFOs</strong></h5>
<p class="noindentab">For the read end of a pipe or FIFO, a signal is generated in these circumstances:</p>
<p class="bull">&#8226; Data is written to the pipe (even if there was already unread input available).</p>
<p class="bull">&#8226; The write end of the pipe is closed.</p>
<p class="noindenttb">For the write end of a pipe or FIFO, a signal is generated in these circumstances:</p>
<p class="bull">&#8226; A read from the pipe increases the amount of free space in the pipe so that it is now possible to write <span class="literal">PIPE_BUF</span> bytes without blocking.</p>
<p class="bull">&#8226; The read end of the pipe is closed.</p>
<h5 class="h5" id="ch63lev3sec23"><strong>Sockets</strong></h5>
<p class="noindentab">Signal-driven I/O works for datagram sockets in both the UNIX and the Internet domains. A signal is generated in the following circumstances:</p>
<p class="bull">&#8226; An input datagram arrives on the socket (even if there were already unread datagrams waiting to be read).</p>
<p class="bull">&#8226; An asynchronous error occurs on the socket.</p>
<p class="noindenttb"><span epub:type="pagebreak" id="page_1352"/>Signal-driven I/O works for stream sockets in both the UNIX and the Internet domains. A signal is generated in the following circumstances:</p>
<p class="bull">&#8226; A new connection is received on a listening socket.</p>
<p class="bull">&#8226; A TCP <em>connect()</em> request completes; that is, the active end of a TCP connection entered the ESTABLISHED state, as shown in <a href="ch61.xhtml#ch61fig5">Figure 61-5</a> (<a href="ch61.xhtml#page_1272">page 1272</a>). The analogous condition is not signaled for UNIX domain sockets.</p>
<p class="bull">&#8226; New input is received on the socket (even if there was already unread input available).</p>
<p class="bull">&#8226; The peer closes its writing half of the connection using <em>shutdown()</em>, or closes its socket altogether using <em>close()</em>.</p>
<p class="bull">&#8226; Output is possible on the socket (e.g., space has become available in the socket send buffer).</p>
<p class="bull">&#8226; An asynchronous error occurs on the socket.</p>
<h5 class="h5" id="ch63lev3sec24"><strong><em>inotify</em> file descriptors</strong></h5>
<p class="noindenta">A signal is generated when the <em>inotify</em> file descriptor becomes readable&#8212;that is, when an event occurs for one of the files monitored by the <em>inotify</em> file descriptor.</p>
<h4 class="h4" id="ch63lev2sec09"><strong>63.3.2 Refining the Use of Signal-Driven I/O</strong></h4>
<p class="noindenta">In applications that need to simultaneously monitor very large numbers (i.e., thousands) of file descriptors&#8212;for example, certain types of network servers&#8212;signal-driven I/O can provide significant performance advantages by comparison with <em>select()</em> and <em>poll()</em>. Signal-driven I/O offers superior performance because the kernel &#8220;remembers&#8221; the list of file descriptors to be monitored, and signals the program only when I/O events actually occur on those descriptors. As a result, the performance of a program employing signal-driven I/O scales according to the number of I/O events that occur, rather than the number of file descriptors being monitored.</p>
<p class="indentb">To take full advantage of signal-driven I/O, we must perform two steps:</p>
<p class="bull">&#8226; Employ a Linux-specific <em>fcntl()</em> operation, <span class="literal">F_SETSIG</span>, to specify a realtime signal that should be delivered instead of <span class="literal">SIGIO</span> when I/O is possible on a file descriptor.</p>
<p class="bull">&#8226; Specify the <span class="literal">SA_SIGINFO</span> flag when using <em>sigaction()</em> to establish the handler for the realtime signal employed in the previous step (see <a href="ch21.xhtml#ch21lev1sec04">Section 21.4</a>).</p>
<p class="noindentt">The <em>fcntl()</em> <span class="literal">F_SETSIG</span> operation specifies an alternative signal that should be delivered instead of <span class="literal">SIGIO</span> when I/O is possible on a file descriptor:</p>
<p class="programs">if (fcntl(fd, F_SETSIG, sig) == -1)<br/>&#160;&#160;&#160;&#160;errExit("fcntl");</p>
<p class="noindent">The <span class="literal">F_GETSIG</span> operation performs the converse of <span class="literal">F_SETSIG</span>, retrieving the signal currently set for a file descriptor:</p>
<p class="programs">sig = fcntl(fd, F_GETSIG);<br/>if (sig == -1)<br/>&#160;&#160;&#160;&#160;errExit("fcntl");</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1353"/>(In order to obtain the definitions of the <span class="literal">F_SETSIG</span> and <span class="literal">F_GETSIG</span> constants from <span class="literal">&lt;fcntl.h&gt;</span>, we must define the <span class="literal">_GNU_SOURCE</span> feature test macro.)</p>
<p class="indentb">Using <span class="literal">F_SETSIG</span> to change the signal used for &#8220;I/O possible&#8221; notification serves two purposes, both of which are needed if we are monitoring large numbers of I/O events on multiple file descriptors:</p>
<p class="bull">&#8226; The default &#8220;I/O possible&#8221; signal, <span class="literal">SIGIO</span>, is one of the standard, nonqueuing signals. If multiple I/O events are signaled while <span class="literal">SIGIO</span> is blocked&#8212;perhaps because the <span class="literal">SIGIO</span> handler is already invoked&#8212;all notifications except the first will be lost. If we use <span class="literal">F_SETSIG</span> to specify a realtime signal as the &#8220;I/O possible&#8221; signal, multiple notifications can be queued.</p>
<p class="bull">&#8226; If the handler for the signal is established using a <em>sigaction()</em> call in which the <span class="literal">SA_SIGINFO</span> flag is specified in the <em>sa.sa_flags</em> field, then a <em>siginfo_t</em> structure is passed as the second argument to the signal handler (<a href="ch21.xhtml#ch21lev1sec04">Section 21.4</a>). This structure contains fields identifying the file descriptor on which the event occurred, as well as the type of event.</p>
<p class="noindentt">Note that the use of <em>both</em> <span class="literal">F_SETSIG</span> and <span class="literal">SA_SIGINFO</span> is required in order for a valid <em>siginfo_t</em> structure to be passed to the signal handler.</p>
<p class="indent">If we perform an <span class="literal">F_SETSIG</span> operation specifying <em>sig</em> as 0, then we return to the default behavior: <span class="literal">SIGIO</span> is delivered, and a <em>siginfo_t</em> argument is not supplied to the handler.</p>
<p class="indentb">For an &#8220;I/O possible&#8221; event, the fields of interest in the <em>siginfo_t</em> structure passed to the signal handler are as follows:</p>
<p class="bull">&#8226; <em>si_signo</em>: the number of the signal that caused the invocation of the handler. This value is the same as the first argument to the signal handler.</p>
<p class="bull">&#8226; <em>si_fd</em>: the file descriptor for which the I/O event occurred.</p>
<p class="bull">&#8226; <em>si_code</em>: a code indicating the type of event that occurred. The values that can appear in this field, along with their general descriptions, are shown in <a href="ch63.xhtml#ch63table7">Table 63-7</a>.</p>
<p class="bull">&#8226; <em>si_band</em>: a bit mask containing the same bits as are returned in the <em>revents</em> field by the <em>poll()</em> system call. The value set in <em>si_code</em> has a one-to-one correspondence with the bit-mask setting in <em>si_band</em>, as shown in <a href="ch63.xhtml#ch63table7">Table 63-7</a>.</p>
<p class="tablecap"><a id="ch63table7"/><strong>Table 63-7:</strong> <em>si_code</em> and <em>si_band</em> values in the <em>siginfo_t</em> structure for &#8220;I/O possible&#8221; events</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><em>si_code</em></strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><em>si_band</em> mask value</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLL_IN</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLLIN | POLLRDNORM</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Input available; end-of-file condition</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLL_OUT</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLLOUT | POLLWRNORM | POLLWRBAND</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Output possible</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLL_MSG</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLLIN | POLLRDNORM | POLLMSG</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Input message available (unused)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLL_ERR</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLLERR</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">I/O error</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLL_PRI</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">POLLPRI | POLLRDNORM</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">High-priority input available</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">POLL_HUP</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">POLLHUP | POLLERR</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Hangup occurred</p></td>
</tr>
</tbody>
</table>
<p class="noindent">In an application that is purely input-driven, we can further refine the use of <span class="literal">F_SETSIG</span>. Instead of monitoring I/O events via a signal handler, we can block the nominated &#8220;I/O possible&#8221; signal, and then accept the queued signals via calls to <em>sigwaitinfo()</em> or <span epub:type="pagebreak" id="page_1354"/><em>sigtimedwait()</em> (<a href="ch22.xhtml#ch22lev1sec10">Section 22.10</a>). These system calls return a <em>siginfo_t</em> structure that contains the same information as is passed to a signal handler established with <span class="literal">SA_SIGINFO</span>. Accepting signals in this manner returns us to a synchronous model of event processing, but with the advantage that we are much more efficiently notified about the file descriptors on which I/O events have occurred than if we use <em>select()</em> or <em>poll()</em>.</p>
<h5 class="h5" id="ch63lev3sec25"><strong>Handling signal-queue overflow</strong></h5>
<p class="noindenta">We saw in <a href="ch22.xhtml#ch22lev1sec08">Section 22.8</a> that there is a limit on the number of realtime signals that may be queued. If this limit is reached, the kernel reverts to delivering the default <span class="literal">SIGIO</span> signal for &#8220;I/O possible&#8221; notifications. This informs the process that a signal-queue overflow occurred. When this happens, we lose information about which file descriptors have I/O events, because <span class="literal">SIGIO</span> is not queued. (Furthermore, the <span class="literal">SIGIO</span> handler doesn&#8217;t receive a <em>siginfo_t</em> argument, which means that the signal handler can&#8217;t determine the file descriptor that generated the signal.)</p>
<p class="indent">We can reduce the likelihood of signal-queue overflows by increasing the limit on the number of realtime signals that can be queued, as described in <a href="ch22.xhtml#ch22lev1sec08">Section 22.8</a>. However, this doesn&#8217;t eliminate the need to handle the possibility of an overflow. A properly designed application using <span class="literal">F_SETSIG</span> to establish a realtime signal as the &#8220;I/O possible&#8221; notification mechanism must also establish a handler for <span class="literal">SIGIO</span>. If <span class="literal">SIGIO</span> is delivered, then the application can drain the queue of realtime signals using <em>sigwaitinfo()</em> and temporarily revert to the use of <em>select()</em> or <em>poll()</em> to obtain a complete list of file descriptors with outstanding I/O events.</p>
<h5 class="h5" id="ch63lev3sec26"><strong>Using signal-driven I/O with multithreaded applications</strong></h5>
<p class="noindenta">Starting with kernel 2.6.32, Linux provides two new, nonstandard <em>fcntl()</em> operations that can be used to set the target for &#8220;I/O possible&#8221; signals: <span class="literal">F_SETOWN_EX</span> and <span class="literal">F_GETOWN_EX</span>.</p>
<p class="indent">The <span class="literal">F_SETOWN_EX</span> operation is like <span class="literal">F_SETOWN</span>, but as well as allowing the target to be specified as a process or process group, it also permits a thread to be specified as the target for &#8220;I/O possible&#8221; signals. For this operation, the third argument of <em>fcntl()</em> is a pointer to a structure of the following form:</p>
<p class="programs">struct f_owner_ex {<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;type;<br/>&#160;&#160;&#160;&#160;pid_t pid;<br/>};</p>
<p class="noindentb">The <em>type</em> field defines the meaning of the <em>pid</em> field, and has one of the following values:</p>
<p class="term"><span class="literal">F_OWNER_PGRP</span></p>
<p class="termlist">The <em>pid</em> field specifies the ID of a process group that is to be the target of &#8220;I/O possible&#8221; signals. Unlike with <span class="literal">F_SETOWN</span>, a process group ID is specified as a positive value.</p>
<p class="term"><span class="literal">F_OWNER_PID</span></p>
<p class="termlist">The <em>pid</em> field specifies the ID of a process that is to be the target of &#8220;I/O possible&#8221; signals.</p>
<p class="term"><span epub:type="pagebreak" id="page_1355"/><span class="literal">F_OWNER_TID</span></p>
<p class="termlist">The <em>pid</em> field specifies the ID of a thread that is to be the target of &#8220;I/O possible&#8221; signals. The ID specified in <em>pid</em> is a value returned by <em>clone()</em> or <em>gettid()</em>.</p>
<p class="noindentt">The <span class="literal">F_GETOWN_EX</span> operation is the converse of the <span class="literal">F_SETOWN_EX</span> operation. It uses the <em>f_owner_ex</em> structure pointed to by the third argument of <em>fcntl()</em> to return the settings defined by a previous <span class="literal">F_SETOWN_EX</span> operation.</p>
<div class="block">
<p class="noindent">Because the <span class="literal">F_SETOWN_EX</span> and <span class="literal">F_GETOWN_EX</span> operations represent process group IDs as positive values, <span class="literal">F_GETOWN_EX</span> doesn&#8217;t suffer the problem described earlier for <span class="literal">F_GETOWN</span> when using process group IDs less than 4096.</p>
</div>
<h3 class="h3" id="ch63lev1sec04"><strong>63.4 The <em>epoll</em> API</strong></h3>
<p class="noindentab">Like the I/O multiplexing system calls and signal-driven I/O, the Linux <em>epoll</em> (event poll) API is used to monitor multiple file descriptors to see if they are ready for I/O. The primary advantages of the <em>epoll</em> API are the following:</p>
<p class="bull">&#8226; The performance of <em>epoll</em> scales much better than <em>select()</em> and <em>poll()</em> when monitoring large numbers of file descriptors.</p>
<p class="bull">&#8226; The <em>epoll</em> API permits either level-triggered or edge-triggered notification. By contrast, <em>select()</em> and <em>poll()</em> provide only level-triggered notification, and signal-driven I/O provides only edge-triggered notification.</p>
<p class="noindenttb">The performance of <em>epoll</em> and signal-driven I/O is similar. However, <em>epoll</em> has some advantages over signal-driven I/O:</p>
<p class="bull">&#8226; We avoid the complexities of signal handling (e.g., signal-queue overflow).</p>
<p class="bull">&#8226; We have greater flexibility in specifying what kind of monitoring we want to perform (e.g., checking to see if a file descriptor for a socket is ready for reading, writing, or both).</p>
<p class="noindentt">The <em>epoll</em> API is Linux-specific, and is new in Linux 2.6.</p>
<p class="indentb">The central data structure of the <em>epoll</em> API is an <em>epoll instance</em>, which is referred to via an open file descriptor. This file descriptor is not used for I/O. Instead, it is a handle for kernel data structures that serve two purposes:</p>
<p class="bull">&#8226; recording a list of file descriptors that this process has declared an interest in monitoring&#8212;the <em>interest list</em>; and</p>
<p class="bull">&#8226; maintaining a list of file descriptors that are ready for I/O&#8212;the <em>ready list</em>.</p>
<p class="noindentt">The membership of the ready list is a subset of the interest list.</p>
<p class="indent">For each file descriptor monitored by <em>epoll</em>, we can specify a bit mask indicating events that we are interested in knowing about. These bit masks correspond closely to the bit masks used with <em>poll()</em>.</p>
<p class="indentb">The <em>epoll</em> API consists of three system calls:</p>
<p class="bull">&#8226; The <em>epoll_create()</em> system call creates an <em>epoll</em> instance and returns a file descriptor referring to the instance.</p>
<p class="bull"><span epub:type="pagebreak" id="page_1356"/>&#8226; The <em>epoll_ctl()</em> system call manipulates the interest list associated with an <em>epoll</em> instance. Using <em>epoll_ctl()</em>, we can add a new file descriptor to the list, remove an existing descriptor from the list, and modify the mask that determines which events are to be monitored for a descriptor.</p>
<p class="bull">&#8226; The <em>epoll_wait()</em> system call returns items from the ready list associated with an <em>epoll</em> instance.</p>
<h4 class="h4" id="ch63lev2sec10"><strong>63.4.1 Creating an <em>epoll</em> Instance: <em>epoll_create()</em></strong></h4>
<p class="noindenta">The <em>epoll_create()</em> system call creates a new <em>epoll</em> instance whose interest list is initially empty.</p>
<div class="box">
<p class="programsa">#include &lt;sys/epoll.h&gt;<br/><br/>int <span class="codestrong">epoll_create</span>(int <span class="font1">size</span>);</p>
<p class="right">Returns file descriptor on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>size</em> argument specifies the number of file descriptors that we expect to monitor via the <em>epoll</em> instance. This argument is not an upper limit, but rather a hint to the kernel about how to initially dimension internal data structures. (Since Linux 2.6.8, the <em>size</em> argument must be greater than zero but is otherwise ignored, because changes in the implementation meant that the information it provided is no longer required.)</p>
<p class="indent">As its function result, <em>epoll_create()</em> returns a file descriptor referring to the new <em>epoll</em> instance. This file descriptor is used to refer to the <em>epoll</em> instance in other <em>epoll</em> system calls. When the file descriptor is no longer required, it should be closed in the usual way, using <em>close()</em>. When all file descriptors referring to an <em>epoll</em> instance are closed, the instance is destroyed and its associated resources are released back to the system. (Multiple file descriptors may refer to the same <em>epoll</em> instance as a consequence of calls to <em>fork()</em> or descriptor duplication using <em>dup()</em> or similar.)</p>
<div class="block">
<p class="noindent">Starting with kernel 2.6.27, Linux supports a new system call, <em>epoll_create1()</em>. This system call performs the same task as <em>epoll_create()</em>, but drops the obsolete <em>size</em> argument and adds a <em>flags</em> argument that can be used to modify the behavior of the system call. One flag is currently supported: <span class="literal">EPOLL_CLOEXEC</span>, which causes the kernel to enable the close-on-exec flag (<span class="literal">FD_CLOEXEC</span>) for the new file descriptor. This flag is useful for the same reasons as the <em>open()</em> <span class="literal">O_CLOEXEC</span> flag described in <a href="ch04.xhtml#ch04lev2sec01">Section 4.3.1</a>.</p>
</div>
<h4 class="h4" id="ch63lev2sec11"><strong>63.4.2 Modifying the <em>epoll</em> Interest List: <em>epoll_ctl()</em></strong></h4>
<p class="noindenta">The <em>epoll_ctl()</em> system call modifies the interest list of the <em>epoll</em> instance referred to by the file descriptor <em>epfd</em>.</p>
<div class="box">
<p class="programsa">#include &lt;sys/epoll.h&gt;<br/><br/>int <span class="codestrong">epoll_ctl</span>(int <span class="font1">epfd</span>, int <span class="font1">op</span>, int <span class="font1">fd</span>, struct epoll_event *<span class="font1">ev</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_1357"/>The <em>fd</em> argument identifies which of the file descriptors in the interest list is to have its settings modified. This argument can be a file descriptor for a pipe, FIFO, socket, POSIX message queue, <em>inotify</em> instance, terminal, device, or even another <em>epoll</em> descriptor (i.e., we can build a kind of hierarchy of monitored descriptors). However, <em>fd</em> can&#8217;t be a file descriptor for a regular file or a directory (the error <span class="literal">EPERM</span> results).</p>
<p class="indentb">The <em>op</em> argument specifies the operation to be performed, and has one of the following values:</p>
<p class="term"><span class="literal">EPOLL_CTL_ADD</span></p>
<p class="termlist">Add the file descriptor <em>fd</em> to the interest list for <em>epfd</em>. The set of events that we are interested in monitoring for <em>fd</em> is specified in the buffer pointed to by <em>ev</em>, as described below. If we attempt to add a file descriptor that is already in the interest list, <em>epoll_ctl()</em> fails with the error <span class="literal">EEXIST</span>.</p>
<p class="term"><span class="literal">EPOLL_CTL_MOD</span></p>
<p class="termlist">Modify the events setting for the file descriptor <em>fd</em>, using the information specified in the buffer pointed to by <em>ev</em>. If we attempt to modify the settings of a file descriptor that is not in the interest list for <em>epfd</em>, <em>epoll_ctl()</em> fails with the error <span class="literal">ENOENT</span>.</p>
<p class="term"><span class="literal">EPOLL_CTL_DEL</span></p>
<p class="termlist">Remove the file descriptor <em>fd</em> from the interest list for <em>epfd</em>. The <em>ev</em> argument is ignored for this operation. If we attempt to remove a file descriptor that is not in the interest list for <em>epfd</em>, <em>epoll_ctl()</em> fails with the error <span class="literal">ENOENT</span>. Closing a file descriptor automatically removes it from all of the <em>epoll</em> interest lists of which it is a member.</p>
<p class="noindentt">The <em>ev</em> argument is a pointer to a structure of type <em>epoll_event</em>, defined as follows:</p>
<p class="programs">struct epoll_event {<br/>&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;&#160;&#160;events;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* epoll events (bit mask) */<br/>&#160;&#160;&#160;&#160;epoll_data_t data;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* User data */<br/>};</p>
<p class="noindent">The <em>data</em> field of the <em>epoll_event</em> structure is typed as follows:</p>
<p class="programs">typedef union epoll_data {<br/>&#160;&#160;&#160;&#160;void&#160;&#160;&#160;&#160;&#160;&#160;&#160;*ptr;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Pointer to user-defined data */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fd;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* File descriptor */<br/>&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;&#160;u32;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* 32-bit integer */<br/>&#160;&#160;&#160;&#160;uint64_t&#160;&#160;&#160;&#160;u64;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* 64-bit integer */<br/>} epoll_data_t;</p>
<p class="noindentb">The <em>ev</em> argument specifies settings for the file descriptor <em>fd</em>, as follows:</p>
<p class="bull">&#8226; The <em>events</em> subfield is a bit mask specifying the set of events that we are interested in monitoring for <em>fd</em>. We say more about the bit values that can be used in this field in the next section.</p>
<p class="bull">&#8226; The <em>data</em> subfield is a union, one of whose members can be used to specify information that is passed back to the calling process (via <em>epoll_wait()</em>) if <em>fd</em> later becomes ready.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_1358"/><a href="ch63.xhtml#ch63ex4">Listing 63-4</a> shows an example of the use of <em>epoll_create()</em> and <em>epoll_ctl()</em>.</p>
<p class="examplet"><a id="ch63ex4"/><strong>Listing 63-4:</strong> Using <em>epoll_create()</em> and <em>epoll_ctl()</em></p>
<p class="programsli">______________________________________________________________________<br/><br/>&#160;&#160;&#160;&#160;int epfd;<br/>&#160;&#160;&#160;&#160;struct epoll_event ev;<br/><br/>&#160;&#160;&#160;&#160;epfd = epoll_create(5);<br/>&#160;&#160;&#160;&#160;if (epfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("epoll_create");<br/><br/>&#160;&#160;&#160;&#160;ev.data.fd = fd;<br/>&#160;&#160;&#160;&#160;ev.events = EPOLLIN;<br/>&#160;&#160;&#160;&#160;if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &#38;ev) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("epoll_ctl");<br/>______________________________________________________________________</p>
<h5 class="h5" id="ch63lev3sec27"><strong>The</strong> <span class="literal"><span class="codestrong">max_user_watches</span></span> <strong>limit</strong></h5>
<p class="noindenta">Because each file descriptor registered in an <em>epoll</em> interest list requires a small amount of nonswappable kernel memory, the kernel provides an interface that defines a limit on the total number of file descriptors that each user can register in all <em>epoll</em> interest lists. The value of this limit can be viewed and modified via <span class="literal">max_user_watches</span>, a Linux-specific file in the <span class="literal">/proc/sys/fs/epoll</span> directory. The default value of this limit is calculated based on available system memory (see the <em>epoll(7)</em> manual page).</p>
<h4 class="h4" id="ch63lev2sec12"><strong>63.4.3 Waiting for Events: <em>epoll_wait()</em></strong></h4>
<p class="noindenta">The <em>epoll_wait()</em> system call returns information about ready file descriptors from the <em>epoll</em> instance referred to by the file descriptor <em>epfd</em>. A single <em>epoll_wait()</em> call can return information about multiple ready file descriptors.</p>
<div class="box">
<p class="programsa">#include &lt;sys/epoll.h&gt;<br/><br/>int <span class="codestrong">epoll_wait</span>(int <span class="font1">epfd</span>, struct epoll_event *<span class="font1">evlist</span>, int <span class="font1">maxevents</span>, int <span class="font1">timeout</span>);</p>
<p class="right">Returns number of ready file descriptors, 0 on timeout, or &#8211;1 on error</p>
</div>
<p class="noindent">The information about ready file descriptors is returned in the array of <em>epoll_event</em> structures pointed to by <em>evlist</em>. (The <em>epoll_event</em> structure was described in the previous section.) The <em>evlist</em> array is allocated by the caller, and the number of elements it contains is specified in <em>maxevents</em>.</p>
<p class="indent">Each item in the array <em>evlist</em> returns information about a single ready file descriptor. The <em>events</em> subfield returns a mask of the events that have occurred on this descriptor. The <em>data</em> subfield returns whatever value was specified in <em>ev.data</em> when we registered interest in this file descriptor using <em>epoll_ctl()</em>. Note that the <em>data</em> field provides the only mechanism for finding out the number of the file <span epub:type="pagebreak" id="page_1359"/>descriptor associated with this event. Thus, when we make the <em>epoll_ctl()</em> call that places a file descriptor in the interest list, we should either set <em>ev.data.fd</em> to the file descriptor number (as shown in <a href="ch63.xhtml#ch63ex4">Listing 63-4</a>) or set <em>ev.data.ptr</em> to point to a structure that contains the file descriptor number.</p>
<p class="indentb">The <em>timeout</em> argument determines the blocking behavior of <em>epoll_wait()</em>, as follows:</p>
<p class="bull">&#8226; If <em>timeout</em> equals &#8211;1, block until an event occurs for one of the file descriptors in the interest list for <em>epfd</em> or until a signal is caught.</p>
<p class="bull">&#8226; If <em>timeout</em> equals 0, perform a nonblocking check to see which events are currently available on the file descriptors in the interest list for <em>epfd</em>.</p>
<p class="bull">&#8226; If <em>timeout</em> is greater than 0, block for up to <em>timeout</em> milliseconds, until an event occurs on one of the file descriptors in the interest list for <em>epfd</em>, or until a signal is caught.</p>
<p class="noindentt">On success, <em>epoll_wait()</em> returns the number of items that have been placed in the array <em>evlist</em>, or 0 if no file descriptors were ready within the interval specified by <em>timeout</em>. On error, <em>epoll_wait()</em> returns &#8211;1, with <em>errno</em> set to indicate the error.</p>
<p class="indent">In a multithreaded program, it is possible for one thread to use <em>epoll_ctl()</em> to add file descriptors to the interest list of an <em>epoll</em> instance that is already being monitored by <em>epoll_wait()</em> in another thread. These changes to the interest list will be taken into account immediately, and the <em>epoll_wait()</em> call will return readiness information about the newly added file descriptors.</p>
<h5 class="h5" id="ch63lev3sec28"><strong><em>epoll</em> events</strong></h5>
<p class="noindenta">The bit values that can be specified in <em>ev.events</em> when we call <em>epoll_ctl()</em> and that are placed in the <em>evlist[].events</em> fields returned by <em>epoll_wait()</em> are shown in <a href="ch63.xhtml#ch63table8">Table 63-8</a>. With the addition of an <span class="literal">E</span> prefix, most of these bits have names that are the same as the corresponding event bits used with <em>poll()</em>. (The exceptions are <span class="literal">EPOLLET</span> and <span class="literal">EPOLLONESHOT</span>, which we describe in more detail below.) The reason for this correspondence is that, when specified as input to <em>epoll_ctl()</em> or returned as output via <em>epoll_wait()</em>, these bits convey exactly the same meaning as the corresponding <em>poll()</em> event bits.</p>
<p class="tablecap"><a id="ch63table8"/><strong>Table 63-8:</strong> Bit-mask values for the <em>epoll events</em> field</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Bit</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong>Input to <em>epoll_ctl()</em>?</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong>Returned by <em>epoll_wait()</em>?</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">EPOLLIN</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Data other than high-priority data can be read</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">EPOLLPRI</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">High-priority data can be read</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">EPOLLRDHUP</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Shutdown on peer socket (since Linux 2.6.17)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">EPOLLOUT</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Normal data can be written</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">EPOLLET</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Employ edge-triggered event notification</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">EPOLLONESHOT</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Disable monitoring after event notification</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">EPOLLERR</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">An error has occurred</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">EPOLLHUP</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">&#160;</p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec">&#8226;</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">A hangup has occurred</p></td>
</tr>
</tbody>
</table>
<h5 class="h5" id="ch63lev3sec29"><span epub:type="pagebreak" id="page_1360"/><strong>The</strong> <span class="literal"><span class="codestrong">EPOLLONESHOT</span></span> <strong>flag</strong></h5>
<p class="noindenta">By default, once a file descriptor is added to an <em>epoll</em> interest list using the <em>epoll_ctl()</em> <span class="literal">EPOLL_CTL_ADD</span> operation, it remains active (i.e., subsequent calls to <em>epoll_wait()</em> will inform us whenever the file descriptor is ready) until we explicitly remove it from the list using the <em>epoll_ctl()</em> <span class="literal">EPOLL_CTL_DEL</span> operation. If we want to be notified only once about a particular file descriptor, then we can specify the <span class="literal">EPOLLONESHOT</span> flag (available since Linux 2.6.2) in the <em>ev.events</em> value passed in <em>epoll_ctl()</em>. If this flag is specified, then, after the next <em>epoll_wait()</em> call that informs us that the corresponding file descriptor is ready, the file descriptor is marked inactive in the interest list, and we won&#8217;t be informed about its state by future <em>epoll_wait()</em> calls. If desired, we can subsequently reenable monitoring of this file descriptor using the <em>epoll_ctl()</em> <span class="literal">EPOLL_CTL_MOD</span> operation. (We can&#8217;t use the <span class="literal">EPOLL_CTL_ADD</span> operation for this purpose, because the inactive file descriptor is still part of the <em>epoll</em> interest list.)</p>
<h5 class="h5" id="ch63lev3sec30"><strong>Example program</strong></h5>
<p class="noindentab"><a href="ch63.xhtml#ch63ex5">Listing 63-5</a> demonstrates the use of the <em>epoll</em> API. As command-line arguments, this program expects the pathnames of one or more terminals or FIFOs. The program performs the following steps:</p>
<p class="bull">&#8226; Create an <em>epoll</em> instance <span class="ent">&#x2460;</span>.</p>
<p class="bull">&#8226; Open each of the files named on the command line for input <span class="ent">&#x2461;</span> and add the resulting file descriptor to the interest list of the <em>epoll</em> instance <span class="ent">&#x2462;</span>, specifying the set of events to be monitored as <span class="literal">EPOLLIN</span>.</p>
<p class="bull">&#8226; Execute a loop <span class="ent">&#x2463;</span> that calls <em>epoll_wait()</em> <span class="ent">&#x2464;</span> to monitor the interest list of the <em>epoll</em> instance and handles the returned events from each call. Note the following points about this loop:</p>
<p class="dash1">&#8211; After the <em>epoll_wait()</em> call, the program checks for an <span class="literal">EINTR</span> return <span class="ent">&#x2465;</span>, which may occur if the program was stopped by a signal in the middle of the <em>epoll_wait()</em> call and then resumed by <span class="literal">SIGCONT</span>. (Refer to <a href="ch21.xhtml#ch21lev1sec05">Section 21.5</a>.) If this occurs, the program restarts the <em>epoll_wait()</em> call.</p>
<p class="dash1">&#8211; If the <em>epoll_wait()</em> call was successful, the program uses a further loop to check each of the ready items in <em>evlist</em> <span class="ent">&#x2466;</span>. For each item in <em>evlist</em>, the program checks the <em>events</em> field for the presence of not just <span class="literal">EPOLLIN</span> <span class="ent">&#x2467;</span>, but also <span class="literal">EPOLLHUP</span> and <span class="literal">EPOLLERR</span> <span class="ent">&#x2468;</span>. These latter events can occur if the other end of a FIFO was closed or a terminal hangup occurred. If <span class="literal">EPOLLIN</span> was returned, then the program reads some input from the corresponding file descriptor and displays it on standard output. Otherwise, if either <span class="literal">EPOLLHUP</span> or <span class="literal">EPOLLERR</span> occurred, the program closes the corresponding file descriptor <span class="ent">&#x2469;</span> and decrements the counter of open files (<em>numOpenFds</em>).</p>
<p class="dash1">&#8211; The loop terminates when all open file descriptors have been closed (i.e., when <em>numOpenFds</em> equals 0).</p>
<p class="noindentt">The following shell session logs demonstrate the use of the program in <a href="ch63.xhtml#ch63ex5">Listing 63-5</a>. We use two terminal windows. In one window, we use the program in <a href="ch63.xhtml#ch63ex5">Listing 63-5</a> to monitor two FIFOs for input. (Each open of a FIFO for reading by this program will complete only after another process has opened the FIFO for writing, as <span epub:type="pagebreak" id="page_1361"/>described in <a href="ch44.xhtml#ch44lev1sec07">Section 44.7</a>.) In the other window, we run instances of <em>cat(1)</em> that write data to these FIFOs.</p>
<p class="programs"><span class="codestrong">Terminal window 1</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="codestrong">Terminal window 2</span><br/>$ <span class="codestrong">mkfifo p q</span><br/>$ <span class="codestrong">./epoll_input p q</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$ <span class="codestrong">cat &gt; p</span><br/>Opened "p" on fd 4<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Type Control-Z to suspend cat</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[1]+&#160;&#160;Stopped&#160;&#160;&#160;&#160;&#160;cat &gt;p<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$ <span class="codestrong">cat &gt; q</span><br/>Opened "q" on fd 5<br/>About to epoll_wait()<br/><span class="font1">Type Control-Z to suspend the epoll_input program</span><br/>[1]+&#160;&#160;Stopped&#160;&#160;&#160;&#160;&#160;./epoll_input p q</p>
<p class="noindent">Above, we suspended our monitoring program so that we can now generate input on both FIFOs, and close the write end of one of them:</p>
<p class="programs3"><span class="codestrong">qqq</span><br/><span class="font1">Type Control-D to terminate "cat &gt; q"</span><br/>$ <span class="codestrong">fg %1</span><br/>cat &gt;p<br/><span class="codestrong">ppp</span></p>
<p class="noindent">Now we resume our monitoring program by bringing it into the foreground, at which point <em>epoll_wait()</em> returns two events:</p>
<p class="programs">$ <span class="codestrong">fg</span><br/>./epoll_input p q<br/>About to epoll_wait()<br/>Ready: 2<br/>&#160;&#160;fd=4; events: EPOLLIN<br/>&#160;&#160;&#160;&#160;read 4 bytes: ppp<br/><br/>&#160;&#160;fd=5; events: EPOLLIN EPOLLHUP<br/>&#160;&#160;&#160;&#160;read 4 bytes: qqq<br/><br/>About to epoll_wait()<br/>Ready: 1<br/>&#160;&#160;fd=5; events: EPOLLHUP<br/>&#160;&#160;&#160;&#160;closing fd 5<br/>About to epoll_wait()</p>
<p class="noindent">The two blank lines in the above output are the newlines that were read by the instances of <em>cat</em>, written to the FIFOs, and then read and echoed by our program.</p>
<p class="indent">Now we type <em>Control-D</em> in the second terminal window in order to terminate the remaining instance of <em>cat</em>, which causes <em>epoll_wait()</em> to once more return, this time with a single event:</p>
<p class="programs">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Type Control-D to terminate "cat &gt;p"</span><br/>Ready: 1<br/>&#160;&#160;fd=4; events: EPOLLHUP<br/>&#160;&#160;&#160;&#160;closing fd 4<br/>All file descriptors closed; bye</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1362"/><a id="ch63ex5"/><strong>Listing 63-5:</strong> Using the <em>epoll</em> API</p>
<p class="programsli">_______________________________________________________ <span class="codestrong">altio/epoll_input.c</span><br/><br/>&#160;&#160;&#160;#include &lt;sys/epoll.h&gt;<br/>&#160;&#160;&#160;#include &lt;fcntl.h&gt;<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;#define MAX_BUF&#160;&#160;&#160;&#160;&#160;1000&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Maximum bytes fetched by a single read() */<br/>&#160;&#160;&#160;#define MAX_EVENTS&#160;&#160;&#160;&#160;&#160;5&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Maximum number of events to be returned from<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;a single epoll_wait() call */<br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int epfd, ready, fd, s, j, num0penFds;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct epoll_event ev;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct epoll_event evlist[MAX_EVENTS];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char buf[MAX_BUF];<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s file...\n", argv[0]);<br/><br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;epfd = epoll_create(argc - 1);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (epfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("epoll_create");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Open each file on command line, and add it to the "interest<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;list" for the epoll instance */<br/><br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;for (j = 1; j &lt; argc; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fd = open(argv[j], O_RDONLY);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Opened \"%s\" on fd %d\n", argv[j], fd);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ev.events = EPOLLIN;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Only interested in input events */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ev.data.fd = fd;<br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &#38;ev) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("epoll_ctl");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;numOpenFds = argc - 1;<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;while (numOpenFds &gt; 0) {<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Fetch up to MAX_EVENTS items from the ready list */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("About to epoll_wait()\n");<br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ready = epoll_wait(epfd, evlist, MAX_EVENTS, -1);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (ready == -1) {<br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno == EINTR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Restart if interrupted by signal */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("epoll_wait");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Ready: %d\n", ready);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Deal with returned list of events */<br/><br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (j = 0; j &lt; ready; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;fd=%d; events: %s%s%s\n", evlist[j].data.fd,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(evlist[j].events &#38; EPOLLIN)&#160;&#160;? "EPOLLIN "&#160;&#160;: "",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(evlist[j].events &#38; EPOLLHUP) ? "EPOLLHUP " : "",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(evlist[j].events &#38; EPOLLERR) ? "EPOLLERR " : "");<br/><br/><span class="ent">&#x2467;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (evlist[j].events &#38; EPOLLIN) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s = read(evlist[j].data.fd, buf, MAX_BUF);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("read");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;read %d bytes: %.*s\n", s, s, buf);<br/><br/><span class="ent">&#x2468;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else if (evlist[j].events &#38; (EPOLLHUP | EPOLLERR)) {<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* After the epoll_wait(), EPOLLIN and EPOLLHUP may both have<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;been set. But we'll only get here, and thus close the file<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;descriptor, if EPOLLIN was not set. This ensures that all<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;outstanding input (possibly more than MAX_BUF bytes) is<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;consumed (by further loop iterations) before the file<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;descriptor is closed. */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;closing fd %d\n", evlist[j].data.fd);<br/><span class="ent">&#x2469;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (close(evlist[j].data.fd) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numOpenFds--;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("All file descriptors closed; bye\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;}<br/>_______________________________________________________ <span class="codestrong">altio/epoll_input.c</span></p>
<h4 class="h4" id="ch63lev2sec13"><span epub:type="pagebreak" id="page_1363"/><strong>63.4.4 A Closer Look at <em>epoll</em> Semantics</strong></h4>
<p class="noindenta">We now look at some subtleties of the interaction of open files, file descriptors, and <em>epoll</em>. For the purposes of this discussion, it is worth reviewing <a href="ch05.xhtml#ch5fig2">Figure 5-2</a> (<a href="ch05.xhtml#page_95">page 95</a>), which shows the relationship between file descriptors, open file descriptions, and the system-wide file i-node table.</p>
<p class="indentb">When we create an <em>epoll</em> instance using <em>epoll_create()</em>, the kernel creates a new in-memory i-node and open file description, and allocates a new file descriptor in the calling process that refers to the open file description. The interest list for an <em>epoll</em> instance is associated with the open file description, not with the <em>epoll</em> file descriptor. This has the following consequences:</p>
<p class="bull">&#8226; If we duplicate an <em>epoll</em> file descriptor using <em>dup()</em> (or similar), then the duplicated descriptor refers to the same <em>epoll</em> interest and ready lists as the original descriptor. We may modify the interest list by specifying either file descriptor <span epub:type="pagebreak" id="page_1364"/>as the <em>epfd</em> argument in a call to <em>epoll_ctl()</em>. Similarly, we can retrieve items from the ready list by specifying either file descriptor as the <em>epfd</em> argument in a call to <em>epoll_wait()</em>.</p>
<p class="bull">&#8226; The preceding point also applies after a call to <em>fork()</em>. The child inherits a duplicate of the parent&#8217;s <em>epoll</em> file descriptor, and this duplicate descriptor refers to the same <em>epoll</em> data structures.</p>
<p class="noindentt">When we perform an <em>epoll_ctl()</em> <span class="literal">EPOLL_CTL_ADD</span> operation, the kernel adds an item to the <em>epoll</em> interest list that records both the number of the monitored file descriptor and a reference to the corresponding open file description. For the purpose of <em>epoll_wait()</em> calls, the kernel monitors the open file description. This means that we must refine our earlier statement that when a file descriptor is closed, it is automatically removed from any <em>epoll</em> interest lists of which it is a member. The refinement is this: an open file description is removed from the <em>epoll</em> interest list once all file descriptors that refer to it have been closed. This means that if we create duplicate descriptors referring to an open file&#8212;using <em>dup()</em> (or similar) or <em>fork()</em>&#8212;then the open file will be removed only after the original descriptor and all of the duplicates have been closed.</p>
<p class="indent">These semantics can lead to some behavior that at first appears surprising. Suppose that we execute the code shown in <a href="ch63.xhtml#ch63ex6">Listing 63-6</a>. The <em>epoll_wait()</em> call in this code will tell us that the file descriptor <em>fd1</em> is ready (in other words, <em>evlist[0].data.fd</em> will be equal to <em>fd1</em>), even though <em>fd1</em> has been closed. This is because there is still one open file descriptor, <em>fd2</em>, referring to the open file description contained in the <em>epoll</em> interest list. A similar scenario occurs when two processes hold duplicate descriptors for the same open file description (typically, as a result of a <em>fork()</em>), and the process performing the <em>epoll_wait()</em> has closed its file descriptor, but the other process still holds the duplicate descriptor open.</p>
<p class="examplet"><a id="ch63ex6"/><strong>Listing 63-6:</strong> Semantics of <em>epoll</em> with duplicate file descriptors</p>
<p class="programsli">______________________________________________________________________<br/><br/>&#160;&#160;&#160;&#160;int epfd, fd1, fd2;<br/>&#160;&#160;&#160;&#160;struct epoll_event ev;<br/>&#160;&#160;&#160;&#160;struct epoll_event evlist[MAX_EVENTS];<br/><br/>&#160;&#160;&#160;&#160;/* Omitted: code to open 'fd1' and create epoll file descriptor 'epfd' ... */<br/><br/>&#160;&#160;&#160;&#160;ev.data.fd = fd1<br/>&#160;&#160;&#160;&#160;ev.events = EPOLLIN;<br/>&#160;&#160;&#160;&#160;if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd1, ev) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("epoll_ctl");<br/><br/>&#160;&#160;&#160;&#160;/* Suppose that 'fd1' now happens to become ready for input */<br/><br/>&#160;&#160;&#160;&#160;fd2 = dup(fd1);<br/>&#160;&#160;&#160;&#160;close(fd1);<br/>&#160;&#160;&#160;&#160;ready = epoll_wait(epfd, evlist, MAX_EVENTS, -1);<br/>&#160;&#160;&#160;&#160;if (ready == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("epoll_wait");<br/>______________________________________________________________________</p>
<h4 class="h4" id="ch63lev2sec14"><span epub:type="pagebreak" id="page_1365"/><strong>63.4.5 Performance of <em>epoll</em> Versus I/O Multiplexing</strong></h4>
<p class="noindenta"><a href="ch63.xhtml#ch63table9">Table 63-9</a> shows the results (on Linux 2.6.25) when we monitor <em>N</em> contiguous file descriptors in the range <em>0</em> to <em>N &#8211; 1</em> using <em>poll()</em>, <em>select()</em>, and <em>epoll</em>. (The test was arranged such that during each monitoring operation, exactly one randomly selected file descriptor is ready.) From this table, we see that as the number of file descriptors to be monitored grows large, <em>poll()</em> and <em>select()</em> perform poorly. By contrast, the performance of <em>epoll</em> hardly declines as <em>N</em> grows large. (The small decline in performance as <em>N</em> increases is possibly a result of reaching CPU caching limits on the test system.)</p>
<div class="block">
<p class="noindent">For the purposes of this test, <span class="literal">FD_SETSIZE</span> was changed to 16,384 in the <em>glibc</em> header files to allow the test program to monitor large numbers of file descriptors using <em>select()</em>.</p>
</div>
<p class="tablecap"><a id="ch63table9"/><strong>Table 63-9:</strong> Times taken by <em>poll()</em>, <em>select()</em>, and <em>epoll</em> for 100,000 monitoring operations</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Number of descriptors monitored (<em>N</em>)</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><em>poll()</em> CPU time (seconds)</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><em>select()</em> CPU time (seconds)</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong><em>epoll</em> CPU time (seconds)</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">10</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">0.61</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">0.73</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec"><span class="literal">0.41</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">100</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">2.9</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">3.0</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec"><span class="literal">0.42</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">1000</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">35</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="tablec"><span class="literal">35</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec"><span class="literal">0.53</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="tablec"><span class="literal">10000</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec"><span class="literal">990</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="tablec"><span class="literal">930</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="tablec"><span class="literal">0.66</span></p></td>
</tr>
</tbody>
</table>
<p class="noindentb">In <a href="ch63.xhtml#ch63lev2sec07">Section 63.2.5</a>, we saw why <em>select()</em> and <em>poll()</em> perform poorly when monitoring large numbers of file descriptors. We now look at the reasons why <em>epoll</em> performs better:</p>
<p class="bull">&#8226; On each call to <em>select()</em> or <em>poll()</em>, the kernel must check all of the file descriptors specified in the call. By contrast, when we mark a descriptor to be monitored with <em>epoll_ctl()</em>, the kernel records this fact in a list associated with the underlying open file description, and whenever an I/O operation that makes the file descriptor ready is performed, the kernel adds an item to the ready list for the <em>epoll</em> descriptor. (An I/O event on a single open file description may cause multiple file descriptors associated with that description to become ready.) Subsequent <em>epoll_wait()</em> calls simply fetch items from the ready list.</p>
<p class="bull">&#8226; Each time we call <em>select()</em> or <em>poll()</em>, we pass a data structure to the kernel that identifies all of the file descriptors that are to be monitored, and, on return, the kernel passes back a data structure describing the readiness of all of these descriptors. By contrast, with <em>epoll</em>, we use <em>epoll_ctl()</em> to build up a data structure <em>in kernel space</em> that lists the set of file descriptors to be monitored. Once this data structure has been built, each later call to <em>epoll_wait()</em> doesn&#8217;t need to pass any information about file descriptors to the kernel, and the call returns information about only those descriptors that are ready.</p>
<div class="block">
<p class="noindent">In addition to the above points, for <em>select()</em>, we must initialize the input data structure prior to each call, and for both <em>select()</em> and <em>poll()</em>, we must inspect the returned data structure to find out which of the <em>N</em> file descriptors are ready. However, some testing showed that the time required for these other steps was <span epub:type="pagebreak" id="page_1366"/>insignificant compared to the time required for the system call to monitor <em>N</em> descriptors. <a href="ch63.xhtml#ch63table9">Table 63-9</a> doesn&#8217;t include the times for the inspection step.</p>
</div>
<p class="noindent">Very roughly, we can say that for large values of <em>N</em> (the number of file descriptors being monitored), the performance of <em>select()</em> and <em>poll()</em> scales linearly with <em>N</em>. We start to see this behavior for the <em>N = 100</em> and <em>N = 1000</em> cases in <a href="ch63.xhtml#ch63table9">Table 63-9</a>. By the time we reach <em>N = 10000</em>, the scaling has actually become worse than linear.</p>
<p class="indent">By contrast, <em>epoll</em> scales (linearly) according to the number of I/O events that occur. The <em>epoll</em> API is thus particularly efficient in a scenario that is common in servers that handle many simultaneous clients: of the many file descriptors being monitored, most are idle; only a few descriptors are ready.</p>
<h4 class="h4" id="ch63lev2sec15"><strong>63.4.6 Edge-Triggered Notification</strong></h4>
<p class="noindenta">By default, the <em>epoll</em> mechanism provides <em>level-triggered</em> notification. By this, we mean that <em>epoll</em> tells us whether an I/O operation can be performed on a file descriptor without blocking. This is the same type of notification as is provided by <em>poll()</em> and <em>select()</em>.</p>
<p class="indent">The <em>epoll</em> API also allows for <em>edge-triggered</em> notification&#8212;that is, a call to <em>epoll_wait()</em> tells us if there has been I/O activity on a file descriptor since the previous call to <em>epoll_wait()</em> (or since the descriptor was opened, if there was no previous call). Using <em>epoll</em> with edge-triggered notification is semantically similar to signal-driven I/O, except that if multiple I/O events occur, <em>epoll</em> coalesces them into a single notification returned via <em>epoll_wait()</em>; with signal-driven I/O, multiple signals may be generated.</p>
<p class="indent">To employ edge-triggered notification, we specify the <span class="literal">EPOLLET</span> flag in <em>ev.events</em> when calling <em>epoll_ctl()</em>:</p>
<p class="programs">struct epoll_event ev;<br/><br/>ev.data.fd = fd<br/>ev.events = EPOLLIN | EPOLLET;<br/>if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &#38;ev) == -1)<br/>&#160;&#160;&#160;&#160;errExit("epoll_ctl");</p>
<p class="noindent">We illustrate the difference between level-triggered and edge-triggered <em>epoll</em> notification using an example. Suppose that we are using <em>epoll</em> to monitor a socket for input (<span class="literal">EPOLLIN</span>), and the following steps occur:</p>
<ol>
<li class="order"><p class="orderp">Input arrives on the socket.</p></li>
<li class="order"><p class="orderp">We perform an <em>epoll_wait()</em>. This call will tell us that the socket is ready, regardless of whether we are employing level-triggered or edge-triggered notification.</p></li>
<li class="order"><p class="orderp">We perform a second call to <em>epoll_wait()</em>.</p></li>
</ol>
<p class="noindent">If we are employing level-triggered notification, then the second <em>epoll_wait()</em> call will inform us that the socket is ready. If we are employing edge-triggered notification, then the second call to <em>epoll_wait()</em> will block, because no new input has arrived since the previous call to <em>epoll_wait()</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1367"/>As we noted in <a href="ch63.xhtml#ch63lev2sec01">Section 63.1.1</a>, edge-triggered notification is usually employed in conjunction with nonblocking file descriptors. Thus, the general framework for using edge-triggered <em>epoll</em> notification is as follows:</p>
<ol>
<li class="order"><p class="orderp">Make all file descriptors that are to be monitored nonblocking.</p></li>
<li class="order"><p class="orderp">Build the <em>epoll</em> interest list using <em>epoll_ctl()</em>.</p></li>
<li class="order"><p class="orderp">Handle I/O events using the following loop:</p>
<p class="olista">a) Retrieve a list of ready descriptors using <em>epoll_wait()</em>.</p>
<p class="olista">b) For each file descriptor that is ready, process I/O until the relevant system call (e.g., <em>read()</em>, <em>write()</em>, <em>recv()</em>, <em>send()</em>, or <em>accept()</em>) returns with the error <span class="literal">EAGAIN</span> or <span class="literal">EWOULDBLOCK</span>.</p></li>
</ol>
<h5 class="h5" id="ch63lev3sec31"><strong>Preventing file-descriptor starvation when using edge-triggered notification</strong></h5>
<p class="noindenta">Suppose that we are monitoring multiple file descriptors using edge-triggered notification, and that a ready file descriptor has a large amount (perhaps an endless stream) of input available. If, after detecting that this file descriptor is ready, we attempt to consume all of the input using nonblocking reads, then we risk starving the other file descriptors of attention (i.e., it may be a long time before we again check them for readiness and perform I/O on them). One solution to this problem is for the application to maintain a list of file descriptors that have been notified as being ready, and execute a loop that continuously performs the following actions:</p>
<ol>
<li class="order"><p class="orderp">Monitor the file descriptors using <em>epoll_wait()</em> and add ready descriptors to the application list. If any file descriptors are already registered as being ready in the application list, then the timeout for this monitoring step should be small or 0, so that if no new file descriptors are ready, the application can quickly proceed to the next step and service any file descriptors that are already known to be ready.</p></li>
<li class="order"><p class="orderp">Perform a limited amount of I/O on those file descriptors registered as being ready in the application list (perhaps cycling through them in round-robin fashion, rather than always starting from the beginning of the list after each call to <em>epoll_wait()</em>). A file descriptor can be removed from the application list when the relevant nonblocking I/O system call fails with the <span class="literal">EAGAIN</span> or <span class="literal">EWOULDBLOCK</span> error.</p></li>
</ol>
<p class="noindent">Although it requires extra programming work, this approach offers other benefits in addition to preventing file-descriptor starvation. For example, we can include other steps in the above loop, such as handling timers and accepting signals with <em>sigwaitinfo()</em> (or similar).</p>
<p class="indent">Starvation considerations can also apply when using signal-driven I/O, since it also presents an edge-triggered notification mechanism. By contrast, starvation considerations don&#8217;t necessarily apply in applications employing a level-triggered notification mechanism. This is because we can employ blocking file descriptors with level-triggered notification and use a loop that continuously checks descriptors for readiness, and then performs <em>some</em> I/O on the ready descriptors before once more checking for ready file descriptors.</p>
<h3 class="h3" id="ch63lev1sec05"><span epub:type="pagebreak" id="page_1368"/><strong>63.5 Waiting on Signals and File Descriptors</strong></h3>
<p class="noindenta">Sometimes, a process needs to simultaneously wait for I/O to become possible on one of a set of file descriptors or for the delivery of a signal. We might attempt to perform such an operation using <em>select()</em>, as shown in <a href="ch63.xhtml#ch63ex7">Listing 63-7</a>.</p>
<p class="examplet"><a id="ch63ex7"/><strong>Listing 63-7:</strong> Incorrect method of unblocking signals and calling <em>select()</em></p>
<p class="programsli">______________________________________________________________________<br/><br/>sig_atomic_t gotSig = 0;<br/><br/>void<br/>handler(int sig)<br/>{<br/>&#160;&#160;&#160;&#160;gotSig = 1;<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct sigaction sa;<br/>&#160;&#160;&#160;&#160;...<br/><br/>&#160;&#160;&#160;&#160;sa.sa_handler = handler;<br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;sa.sa_flags = 0;<br/>&#160;&#160;&#160;&#160;if (sigaction(SIGUSR1, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;/* What if the signal is delivered now? */<br/><br/>&#160;&#160;&#160;&#160;ready = select(nfds, &#38;readfds, NULL, NULL, NULL);<br/>&#160;&#160;&#160;&#160;if (ready &gt; 0) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%d file descriptors ready\n", ready);<br/>&#160;&#160;&#160;&#160;} else if (ready == -1 &#38;&#38; errno == EINTR) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (gotSig)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Got signal\n");<br/>&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Some other error */<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;...<br/>}<br/>______________________________________________________________________</p>
<p class="noindent">The problem with this code is that if the signal (<span class="literal">SIGUSR1</span> in this example) arrives after establishing the handler but before <em>select()</em> is called, then the <em>select()</em> call will nevertheless block. (This is a form of race condition.) We now look at some solutions to this problem.</p>
<div class="block">
<p class="noindent">Since version 2.6.27, Linux provides a further technique that can be used to simultaneously wait on signals and file descriptors: the <em>signalfd</em> mechanism described in <a href="ch22.xhtml#ch22lev1sec11">Section 22.11</a>. Using this mechanism, we can receive signals via a <span epub:type="pagebreak" id="page_1369"/>file descriptor that is monitored (along with other file descriptors) using <em>select()</em>, <em>poll()</em>, or <em>epoll_wait()</em>.</p>
</div>
<h4 class="h4" id="ch63lev2sec16"><strong>63.5.1 The <em>pselect()</em> System Call</strong></h4>
<p class="noindenta">The <em>pselect()</em> system call performs a similar task to <em>select()</em>. The main semantic difference is an additional argument, <em>sigmask</em>, that specifies a set of signals to be unmasked while the call is blocked.</p>
<div class="box">
<p class="programsa">#include &lt;sys/select.h&gt;<br/><br/>int <span class="codestrong">pselect</span>(int <span class="font1">nfds</span>, fd_set *<span class="font1">readfds</span>, fd_set *<span class="font1">writefds</span>, fd_set *<span class="font1">exceptfds</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct timespec *<span class="font1">timeout</span>, const sigset_t *<span class="font1">sigmask</span>);</p>
<p class="right">Returns number of ready file descriptors, 0 on timeout, or &#8211;1 on error</p>
</div>
<p class="noindent">More precisely, suppose we have the following <em>pselect()</em> call:</p>
<p class="programs">ready = pselect(nfds, &#38;readfds, &#38;writefds, &#38;exceptfds, timeout, &#38;sigmask);</p>
<p class="noindent">This call is equivalent to <em>atomically</em> performing the following steps:</p>
<p class="programs">sigset_t origmask;<br/><br/>pthread_sigmask(SIG_SETMASK, &#38;sigmask, &#38;origmask);<br/>ready = select(nfds, &#38;readfds, &#38;writefds, &#38;exceptfds, timeout);<br/>pthread_sigmask(SIG_SETMASK, &#38;origmask, NULL); /* Restore signal mask */</p>
<p class="noindent">Using <em>pselect()</em>, we can recode the first part of the body of our main program in <a href="ch63.xhtml#ch63ex7">Listing 63-7</a> as shown in <a href="ch63.xhtml#ch63ex8">Listing 63-8</a>.</p>
<p class="indentb">Aside from the <em>sigmask</em> argument, <em>select()</em> and <em>pselect()</em> differ in the following ways:</p>
<p class="bull">&#8226; The <em>timeout</em> argument to <em>pselect()</em> is a <em>timespec</em> structure (<a href="ch23.xhtml#ch23lev2sec02">Section 23.4.2</a>), which allows the timeout to be specified with nanosecond (instead of microsecond) precision.</p>
<p class="bull">&#8226; SUSv3 explicitly states that <em>pselect()</em> doesn&#8217;t modify the <em>timeout</em> argument on return.</p>
<p class="noindentt">If we specify the <em>sigmask</em> argument of <em>pselect()</em> as <span class="literal">NULL</span>, then <em>pselect()</em> is equivalent to <em>select()</em> (i.e., it performs no manipulation of the process signal mask), except for the differences just noted.</p>
<p class="indent">The <em>pselect()</em> interface is an invention of POSIX.1g, and is nowadays incorporated in SUSv3. It is not available on all UNIX implementations, and was added to Linux only in kernel 2.6.16.</p>
<div class="block">
<p class="noindent">Previously, a <em>pselect()</em> library function was provided by <em>glibc</em>, but this implementation didn&#8217;t provide the atomicity guarantees that are required for the correct operation of the call. Such guarantees can be provided only by a kernel implementation of <em>pselect()</em>.</p>
</div>
<p class="examplet"><span epub:type="pagebreak" id="page_1370"/><a id="ch63ex8"/><strong>Listing 63-8:</strong> Using <em>pselect()</em></p>
<p class="programsli">______________________________________________________________________<br/><br/>&#160;&#160;&#160;sigset_t emptyset, blockset;<br/>&#160;&#160;&#160;struct sigaction sa;<br/><br/>&#160;&#160;&#160;sigemptyset(&#38;blockset);<br/>&#160;&#160;&#160;sigaddset(&#38;blockset, SIGUSR1);<br/><br/>&#160;&#160;&#160;if (sigprocmask(SIG_BLOCK, &#38;blockset, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask");<br/><br/>&#160;&#160;&#160;sa.sa_handler = handler;<br/>&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;sa.sa_flags = SA_RESTART;<br/>&#160;&#160;&#160;if (sigaction(SIGUSR1, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;sigemptyset(&#38;emptyset);<br/>&#160;&#160;&#160;ready = pselect(nfds, &#38;readfds, NULL, NULL, NULL, &#38;emptyset);<br/>&#160;&#160;&#160;if (ready == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("pselect");<br/>______________________________________________________________________</p>
<h5 class="h5" id="ch63lev3sec32"><strong>The <em>ppoll()</em> and <em>epoll_pwait()</em> system calls</strong></h5>
<p class="noindenta">Linux 2.6.16 also added a new, nonstandard system call, <em>ppoll()</em>, whose relationship to <em>poll()</em> is analogous to the relationship of <em>pselect()</em> to <em>select()</em>. Similarly, starting with kernel 2.6.19, Linux also includes <em>epoll_pwait()</em>, providing an analogous extension to <em>epoll_wait()</em>. See the <em>ppoll(2)</em> and <em>epoll_pwait(2)</em> manual pages for details.</p>
<h4 class="h4" id="ch63lev2sec17"><strong>63.5.2 The Self-Pipe Trick</strong></h4>
<p class="noindenta">Since <em>pselect()</em> is not widely implemented, portable applications must employ other strategies to avoid race conditions when simultaneously waiting for signals and calling <em>select()</em> on a set of file descriptors. One common solution is the following:</p>
<ol>
<li class="order"><p class="orderp">Create a pipe, and mark its read and write ends as nonblocking.</p></li>
<li class="order"><p class="orderp">As well as monitoring all of the other file descriptors that are of interest, include the read end of the pipe in the <em>readfds</em> set given to <em>select()</em>.</p></li>
<li class="order"><p class="orderp">Install a handler for the signal that is of interest. When this signal handler is called, it writes a byte of data to the pipe. Note the following points about the signal handler:</p>
<p class="dash1">&#8211; The write end of the pipe was marked as nonblocking in the first step to prevent the possibility that signals arrive so rapidly that repeated invocations of the signal handler fill the pipe, with the result that the signal handler&#8217;s <em>write()</em> (and thus the process itself) is blocked. (It doesn&#8217;t matter if a write to a full pipe fails, since the previous writes will already have indicated the delivery of the signal.)</p>
<p class="dash1"><span epub:type="pagebreak" id="page_1371"/>&#8211; The signal handler is installed after creating the pipe, in order to prevent the race condition that would occur if a signal was delivered before the pipe was created.</p>
<p class="dash1">&#8211; It is safe to use <em>write()</em> inside the signal handler, because it is one of the async-signal-safe functions listed in <a href="ch21.xhtml#ch21table1">Table 21-1</a>, on <a href="ch21.xhtml#page_426">page 426</a>.</p></li>
<li class="order"><p class="orderp">Place the <em>select()</em> call in a loop, so that it is restarted if interrupted by a signal handler. (Restarting in this fashion is not strictly necessary; it merely means that we can check for the arrival of a signal by inspecting <em>readfds</em>, rather than checking for an <span class="literal">EINTR</span> error return.)</p></li>
<li class="order"><p class="orderp">On successful completion of the <em>select()</em> call, we can determine whether a signal arrived by checking if the file descriptor for the read end of the pipe is set in <em>readfds</em>.</p></li>
<li class="order"><p class="orderp">Whenever a signal has arrived, read all bytes that are in the pipe. Since multiple signals may arrive, employ a loop that reads bytes until the (nonblocking) <em>read()</em> fails with the error <span class="literal">EAGAIN</span>. After draining the pipe, perform whatever actions must be taken in response to delivery of the signal.</p></li>
</ol>
<p class="noindent">This technique is commonly known as the <em>self-pipe trick</em>, and code demonstrating this technique is shown in <a href="ch63.xhtml#ch63ex9">Listing 63-9</a>.</p>
<p class="indent">Variations on this technique can equally be employed with <em>poll()</em> and <em>epoll_wait()</em>.</p>
<p class="examplet"><a id="ch63ex9"/><strong>Listing 63-9:</strong> Using the self-pipe trick</p>
<p class="programsli">____________________________________________________ <span class="font1">from</span> <span class="codestrong">altio/self_pipe.c</span><br/><br/>static int pfd[2];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* File descriptors for pipe */<br/><br/>static void<br/>handler(int sig)<br/>{<br/>&#160;&#160;&#160;&#160;int savedErrno;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* In case we change 'errno' */<br/><br/>&#160;&#160;&#160;&#160;savedErrno = errno;<br/>&#160;&#160;&#160;&#160;if (write(pfd[1], "x", 1) == -1 &#38;&#38; errno != EAGAIN)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("write");<br/>&#160;&#160;&#160;&#160;errno = savedErrno;<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;fd_set readfds;<br/>&#160;&#160;&#160;&#160;int ready, nfds, flags;<br/>&#160;&#160;&#160;&#160;struct timeval timeout;<br/>&#160;&#160;&#160;&#160;struct timeval *pto;<br/>&#160;&#160;&#160;&#160;struct sigaction sa;<br/>&#160;&#160;&#160;&#160;char ch;<br/><br/><span epub:type="pagebreak" id="page_1372"/>&#160;&#160;&#160;&#160;/* ... Initialize 'timeout', 'readfds', and 'nfds' for select() */<br/><br/>&#160;&#160;&#160;&#160;if (pipe(pfd) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("pipe");<br/><br/>&#160;&#160;&#160;&#160;FD_SET(pfd[0], &#38;readfds);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Add read end of pipe to 'readfds' */<br/>&#160;&#160;&#160;&#160;nfds = max(nfds, pfd[0] + 1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* And adjust 'nfds' if required */<br/><br/>&#160;&#160;&#160;&#160;flags = fcntl(pfd[0], F_GETFL);<br/>&#160;&#160;&#160;&#160;if (flags == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fcntl-F_GETFL");<br/>&#160;&#160;&#160;&#160;flags |= O_NONBLOCK;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Make read end nonblocking */<br/>&#160;&#160;&#160;&#160;if (fcntl(pfd[0], F_SETFL, flags) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fcntl-F_SETFL");<br/><br/>&#160;&#160;&#160;&#160;flags = fcntl(pfd[1], F_GETFL);<br/>&#160;&#160;&#160;&#160;if (flags == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fcntl-F_GETFL");<br/>&#160;&#160;&#160;&#160;flags |= O_NONBLOCK;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Make write end nonblocking */<br/>&#160;&#160;&#160;&#160;if (fcntl(pfd[1], F_SETFL, flags) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fcntl-F_SETFL");<br/><br/>&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;sa.sa_flags = SA_RESTART;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Restart interrupted read()s */<br/>&#160;&#160;&#160;&#160;sa.sa_handler = handler;<br/>&#160;&#160;&#160;&#160;if (sigaction(SIGINT, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/>&#160;&#160;&#160;&#160;while ((ready = select(nfds, &#38;readfds, NULL, NULL, pto)) == -1 &#38;&#38;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errno == EINTR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Restart if interrupted by signal */<br/>&#160;&#160;&#160;&#160;if (ready == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Unexpected error */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("select");<br/><br/>&#160;&#160;&#160;&#160;if (FD_ISSET(pfd[0], &#38;readfds)) {&#160;&#160;&#160;/* Handler was called */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("A signal was caught\n");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (;;) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Consume bytes from pipe */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (read(pfd[0], &#38;ch, 1) == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno == EAGAIN)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* No more bytes */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("read");&#160;&#160;&#160;&#160;/* Some other error */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Perform any actions that should be taken in response to signal */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;/* Examine file descriptor sets returned by select() to see<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;which other file descriptors are ready */<br/>}<br/>____________________________________________________ <span class="font1">from</span> <span class="codestrong">altio/self_pipe.c</span></p>
<h3 class="h3" id="ch63lev1sec06"><span epub:type="pagebreak" id="page_1373"/><strong>63.6 Summary</strong></h3>
<p class="noindenta">In this chapter, we explored various alternatives to the standard model for performing I/O: I/O multiplexing (<em>select()</em> and <em>poll()</em>), signal-driven I/O, and the Linux-specific <em>epoll</em> API. All of these mechanisms allow us to monitor multiple file descriptors to see if I/O is possible on any of them. None of these mechanisms actually performs I/O. Instead, once we have determined that a file descriptor is ready, we use the traditional I/O system calls to perform the I/O.</p>
<p class="indent">The <em>select()</em> and <em>poll()</em> I/O multiplexing calls simultaneously monitor multiple file descriptors to see if I/O is possible on any of the descriptors. With both system calls, we pass a complete list of to-be-checked file descriptors to the kernel on each system call, and the kernel returns a modified list indicating which descriptors are ready. The fact that complete file descriptor lists are passed and checked on each call means that <em>select()</em> and <em>poll()</em> perform poorly when monitoring large numbers of file descriptors.</p>
<p class="indent">Signal-driven I/O allows a process to receive a signal when I/O is possible on a file descriptor. To enable signal-driven I/O, we must establish a handler for the <span class="literal">SIGIO</span> signal, set the owner process that is to receive the signal, and enable signal generation by setting the <span class="literal">O_ASYNC</span> open file status flag. This mechanism offers significant performance benefits over I/O multiplexing when monitoring large numbers of file descriptors. Linux allows us to change the signal used for notification, and if we instead employ a realtime signal, then multiple notifications can be queued, and the signal handler can use its <em>siginfo_t</em> argument to determine the file descriptor and event type that generated the signal.</p>
<p class="indent">Like signal-driven I/O, <em>epoll</em> offers superior performance when monitoring large numbers of file descriptors. The performance advantage of <em>epoll</em> (and signal-driven I/O) derives from the fact that the kernel &#8220;remembers&#8221; the list of file descriptors that a process is monitoring (by contrast with <em>select()</em> and <em>poll()</em>, where each system call must again tell the kernel which file descriptors to check). The <em>epoll</em> API has some notable advantages over the use of signal-driven I/O: we avoid the complexities of dealing with signals and can specify which types of I/O events (e.g., input or output) are to be monitored.</p>
<p class="indent">In the course of this chapter, we drew a distinction between level-triggered and edge-triggered readiness notification. With a level-triggered notification model, we are informed whether I/O is currently possible on a file descriptor. By contrast, edge-triggered notification informs us whether I/O activity has occurred on a file descriptor since it was last monitored. The I/O multiplexing system calls offer a level-triggered notification model; signal-driven I/O approximates to an edge-triggered model; and <em>epoll</em> is capable of operating under either model (level-triggered is the default). Edge-triggered notification is usually employed in conjunction with nonblocking I/O.</p>
<p class="indent">We concluded the chapter by looking at a problem that sometimes faces programs that monitor multiple file descriptors: how to simultaneously also wait for the delivery of a signal. The usual solution to this problem is the so-called self-pipe trick, whereby a handler for the signal writes a byte to a pipe whose read end is included among the set of monitored file descriptors. SUSv3 specifies <em>pselect()</em>, a variation of <em>select()</em> that provides another solution to this problem. However, <em>pselect()</em> is not available on all UNIX implementations. Linux also provides the analogous (but nonstandard) <em>ppoll()</em> and <em>epoll_pwait()</em>.</p>
<h5 class="h5" id="ch63lev3sec33"><span epub:type="pagebreak" id="page_1374"/><strong>Further information</strong></h5>
<p class="noindenta">[<a href="bib.xhtml#bib93">Stevens et al., 2004</a>] describes I/O multiplexing and signal-driven I/O, with particular emphasis on the use of these mechanisms with sockets. [<a href="bib.xhtml#bib29">Gammo et al, 2004</a>] is a paper comparing the performance of <em>select()</em>, <em>poll()</em>, and <em>epoll</em>.</p>
<p class="indent">A particularly interesting online resource is at <em><a href="http://www.kegel.com/c10k.html">http://www.kegel.com/c10k.html</a></em>. Written by Dan Kegel, and entitled &#8220;The C10K problem,&#8221; this web page explores the issues facing developers of web servers designed to simultaneously serve tens of thousands of clients. The web page includes a host of links to related information.</p>
<h3 class="h3" id="ch63lev1sec07"><strong>63.7 Exercises</strong></h3>
<p class="exer"><a id="ch63exe1"/><strong>63-1.</strong>&#160;&#160;&#160;Modify the program in <a href="ch63.xhtml#ch63ex2">Listing 63-2</a> (<span class="literal">poll_pipes.c</span>) to use <em>select()</em> instead of <em>poll()</em>.</p>
<p class="exer"><a id="ch63exe2"/><strong>63-2.</strong>&#160;&#160;&#160;Write an <em>echo</em> server (see <a href="ch60.xhtml#ch60lev1sec02">Sections 60.2</a> and <a href="ch60.xhtml#ch60lev1sec03">60.3</a>) that handles both TCP and UDP clients. To do this, the server must create both a listening TCP socket and a UDP socket, and then monitor both sockets using one of the techniques described in this chapter.</p>
<p class="exer"><a id="ch63exe3"/><strong>63-3.</strong>&#160;&#160;&#160;<a href="ch63.xhtml#ch63lev1sec05">Section 63.5</a> noted that <em>select()</em> can&#8217;t be used to wait on both signals and file descriptors, and described a solution using a signal handler and a pipe. A related problem exists when a program needs to wait for input on both a file descriptor and a System V message queue (since System V message queues don&#8217;t use file descriptors). One solution is to fork a separate child process that copies each message from the queue to a pipe included among the file descriptors monitored by the parent. Write a program that uses this scheme with <em>select()</em> to monitor input from both the terminal and a message queue.</p>
<p class="exer"><a id="ch63exe4"/><strong>63-4.</strong>&#160;&#160;&#160;The last step of the description of the self-pipe technique in <a href="ch63.xhtml#ch63lev2sec17">Section 63.5.2</a> stated that the program should first drain the pipe, and then perform any actions that should be taken in response to the signal. What might happen if these substeps were reversed?</p>
<p class="exer"><a id="ch63exe5"/><strong>63-5.</strong>&#160;&#160;&#160;Modify the program in <a href="ch63.xhtml#ch63ex9">Listing 63-9</a> (<span class="literal">self_pipe.c</span>) to use <em>poll()</em> instead of <em>select()</em>.</p>
<p class="exer"><a id="ch63exe6"/><strong>63-6.</strong>&#160;&#160;&#160;Write a program that uses <em>epoll_create()</em> to create an <em>epoll</em> instance and then immediately waits on the returned file descriptor using <em>epoll_wait()</em>. When, as in this case, <em>epoll_wait()</em> is given an <em>epoll</em> file descriptor with an empty interest list, what happens? Why might this be useful?</p>
<p class="exer"><a id="ch63exe7"/><strong>63-7.</strong>&#160;&#160;&#160;Suppose we have an <em>epoll</em> file descriptor that is monitoring multiple file descriptors, all of which are always ready. If we perform a series of <em>epoll_wait()</em> calls in which <em>maxevents</em> is much smaller than the number of ready file descriptors (e.g., <em>maxevents</em> is 1), without performing all possible I/O on the ready descriptors between calls, what descriptor(s) does <em>epoll_wait()</em> return in each call? Write a program to determine the answer. (For the purposes of this experiment, it suffices to perform no I/O between the <em>epoll_wait()</em> system calls.) Why might this behavior be useful?</p>
<p class="exer"><a id="ch63exe8"/><strong>63-8.</strong>&#160;&#160;&#160;Modify the program in <a href="ch63.xhtml#ch63ex3">Listing 63-3</a> (<span class="literal">demo_sigio.c</span>) to use a realtime signal instead of <span class="literal">SIGIO</span>. Modify the signal handler to accept a <em>siginfo_t</em> argument and display the values of the <em>si_fd</em> and <em>si_code</em> fields of this structure.</p>
</body>
</html>
