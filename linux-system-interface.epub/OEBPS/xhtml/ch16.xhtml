<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch16"><span epub:type="pagebreak" id="page_311"/><strong><span class="big">16</span></strong><br/><strong>EXTENDED ATTRIBUTES</strong></h2>
<p class="noindenta">This chapter describes extended attributes (EAs), which allow arbitrary metadata, in the form of name-value pairs, to be associated with file i-nodes. EAs were added to Linux in version 2.6.</p>
<h3 class="h3" id="ch16lev1sec01"><strong>16.1 Overview</strong></h3>
<p class="noindenta">EAs are used to implement access control lists (<a href="ch17.xhtml#ch17">Chapter 17</a>) and file capabilities (<a href="ch39.xhtml#ch39">Chapter 39</a>). However, the design of EAs is general enough to allow them to be used for other purposes as well. For example, EAs could be used to record a file version number, information about the MIME type or character set for the file, or (a pointer to) a graphical icon.</p>
<p class="indent">EAs are not specified in SUSv3. However, a similar feature is provided on a few other UNIX implementations, notably the modern BSDs (see <em>extattr(2)</em>) and Solaris 9 and later (see <em>fsattr(5)</em>).</p>
<p class="indent">EAs require support from the underlying file system. This support is provided in <em>Btrfs</em>, <em>ext2</em>, <em>ext3</em>, <em>ext4</em>, <em>JFS</em>, <em>Reiserfs</em>, and <em>XFS</em>.</p>
<div class="block">
<p class="noindent">Support for EAs is optional for each file system, and is controlled by kernel configuration options under the <em>File systems</em> menu. EAs are supported on <em>Reiserfs</em> since Linux 2.6.7.</p>
</div>
<h5 class="h5" id="ch16lev3sec01"><span epub:type="pagebreak" id="page_312"/><strong>EA namespaces</strong></h5>
<p class="noindenta">EAs have names of the form <em>namespace.name</em>. The <em>namespace</em> component serves to separate EAs into functionally distinct classes. The <em>name</em> component uniquely identifies an EA within the given <em>namespace</em>.</p>
<p class="indentb">Four values are supported for <em>namespace</em>: <em>user</em>, <em>trusted</em>, <em>system</em>, and <em>security</em>. These four types of EAs are used as follows:</p>
<p class="bull">&#8226; <em>User</em> EAs may be manipulated by unprivileged processes, subject to file permission checks: to retrieve the value of a <em>user</em> EA requires read permission on the file; to change the value of a <em>user</em> EA requires write permission. (Lack of the required permission results in an <span class="literal">EACCES</span> error.) In order to associate <em>user</em> EAs with a file on <em>ext2</em>, <em>ext3</em>, <em>ext4</em>, or <em>Reiserfs</em> file systems, the underlying file system must be mounted with the <em>user_xattr</em> option:</p>
<p class="programsbl">$ <span class="codestrong">mount -o user_xattr <span class="codeitalic">device directory</span></span></p>
<p class="bull">&#8226; <em>Trusted</em> EAs are like <em>user</em> EAs in that they can be manipulated by user processes. The difference is that a process must be privileged (<span class="literal">CAP_SYS_ADMIN</span>) in order to manipulate <em>trusted</em> EAs.</p>
<p class="bull">&#8226; <em>System</em> EAs are used by the kernel to associate system objects with a file. Currently, the only supported object type is an access control list (<a href="ch17.xhtml#ch17">Chapter 17</a>).</p>
<p class="bull">&#8226; <em>Security</em> EAs are used to store file security labels for operating system security modules, and to associate capabilities with executable files (<a href="ch39.xhtml#ch39lev2sec02">Section 39.3.2</a>). <em>Security</em> EAs were initially devised to support Security-Enhanced Linux (SELinux, <em><a href="http://www.nsa.gov/research/selinux/">http://www.nsa.gov/research/selinux/</a></em>).</p>
<p class="noindentt">An i-node may have multiple associated EAs, in the same namespace or in different namespaces. The EA names within each namespace are distinct sets. In the <em>user</em> and <em>trusted</em> namespaces, EA names can be arbitrary strings. In the <em>system</em> namespace, only names explicitly permitted by the kernel (e.g., those used for access control lists) are allowed.</p>
<div class="block">
<p class="noindent"><em>JFS</em> supports another namespace, <em>os2</em>, that is not implemented in other file systems. The <em>os2</em> namespace is provided to support legacy OS/2 file-system EAs. A process doesn&#8217;t need to be privileged in order to create <em>os2</em> EAs.</p>
</div>
<h5 class="h5" id="ch16lev3sec02"><strong>Creating and viewing EAs from the shell</strong></h5>
<p class="noindenta">From the shell, we can use the <em>setfattr(1)</em> and <em>getfattr(1)</em> commands to set and view the EAs on a file:</p>
<p class="programs">$ <span class="codestrong">touch tfile</span><br/>$ <span class="codestrong">setfattr -n user.x -v "The past is not dead." tfile</span><br/>$ <span class="codestrong">setfattr -n user.y -v "In fact, it's not even past." tfile</span><br/>$ <span class="codestrong">getfattr -n user.x tfile</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Retrieve value of a single EA</span><br/># file: tfile&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Informational message from getfattr</span><br/>user.x="The past is not dead."&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">The getfattr command prints a blank</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">line after each file's attributes</span><br/>$ <span class="codestrong">getfattr -d tfile</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Dump values of all user EAs</span><br/># file: tfile<br/>user.x="The past is not dead."<br/>user.y="In fact, it's not even past."<br/><br/>$ <span class="codestrong">setfattr -n user.x tfile</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Change value of EA to be an empty string</span><br/>$ <span class="codestrong">getfattr -d tfile</span><br/># file: tfile<br/>user.x<br/>user.y="In fact, it's not even past."<br/><br/>$ <span class="codestrong">setfattr -x user.y tfile</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Remove an EA</span><br/>$ <span class="codestrong">getfattr -d tfile</span><br/># file: tfile<br/>user.x</p>
<p class="noindent"><span epub:type="pagebreak" id="page_313"/>One of the points that the preceding shell session demonstrates is that the value of an EA may be an empty string, which is not the same as an EA that is undefined. (At the end of the shell session, the value of <em>user.x</em> is an empty string and <em>user.y</em> is undefined.)</p>
<p class="indent">By default, <em>getfattr</em> lists only the values of <em>user</em> EAs. The <em>&#8211;m</em> option can be used to specify a regular expression pattern that selects the EA names that are to be displayed:</p>
<p class="programs">$ <span class="codestrong">getfattr -m '<span class="codeitalic">pattern</span>' <span class="codeitalic">file</span></span></p>
<p class="noindent">The default value for <em>pattern</em> is <span class="literal">^user\.</span>. We can list all EAs on a file using the following command:</p>
<p class="programs">$ <span class="codestrong">getfattr -m - <span class="codeitalic">file</span></span></p>
<h3 class="h3" id="ch16lev1sec02"><strong>16.2 Extended Attribute Implementation Details</strong></h3>
<p class="noindenta">In this section, we extend the overview of the preceding section to fill in a few details of the implementation of EAs.</p>
<h5 class="h5" id="ch16lev3sec03"><strong>Restrictions on <em>user</em> extended attributes</strong></h5>
<p class="noindentab">It is only possible to place <em>user</em> EAs on regular files and directories. Other file types are excluded for the following reasons:</p>
<p class="bull">&#8226; For a symbolic link, all permissions are enabled for all users, and these permissions can&#8217;t be changed. (Symbolic link permissions have no meaning on Linux, as detailed in <a href="ch18.xhtml#ch18lev1sec02">Section 18.2</a>.) This means that permissions can&#8217;t be used to prevent arbitrary users from placing <em>user</em> EAs on a symbolic link. The resolution of this problem is to prevent all users from creating <em>user</em> EAs on the symbolic link.</p>
<p class="bull">&#8226; For device files, sockets, and FIFOs, the permissions control the access that users are granted for the purpose of performing I/O on the underlying object. Manipulating these permissions to control the creation of <em>user</em> EAs would conflict with this purpose.</p>
<p class="noindentt">Furthermore, it is not possible for an unprivileged process to place a <em>user</em> EA on a directory owned by another user if the sticky bit (<a href="ch15.xhtml#ch15lev2sec09">Section 15.4.5</a>) is set on the directory. <span epub:type="pagebreak" id="page_314"/>This prevents arbitrary users from attaching EAs to directories such as <span class="literal">/tmp</span>, which are publicly writable (and so would allow arbitrary users to manipulate EAs on the directory), but which have the sticky bit set to prevent users from deleting files owned by other users in the directory.</p>
<h5 class="h5" id="ch16lev3sec04"><strong>Implementation limits</strong></h5>
<p class="noindentab">The Linux VFS imposes the following limits on EAs on all file systems:</p>
<p class="bull">&#8226; The length of an EA name is limited to 255 characters.</p>
<p class="bull">&#8226; An EA value is limited to 64 kB.</p>
<p class="noindenttb">In addition, some file systems impose more restrictive limits on the size and number of EAs that can be associated with a file:</p>
<p class="bull">&#8226; On <em>ext2, ext3</em>, and <em>ext4</em>, the total bytes used by the names and values of all EAs on a file is limited to the size of a single logical disk block (<a href="ch14.xhtml#ch14lev1sec03">Section 14.3</a>): 1024, 2048, or 4096 bytes.</p>
<p class="bull">&#8226; On <em>JFS</em>, there is an upper limit of 128 kB on the total bytes used by the names and values of all EAs on a file.</p>
<h3 class="h3" id="ch16lev1sec03"><strong>16.3 System Calls for Manipulating Extended Attributes</strong></h3>
<p class="noindenta">In this section, we look at the system calls used to update, retrieve, and remove EAs.</p>
<h5 class="h5" id="ch16lev3sec05"><strong>Creating and modifying EAs</strong></h5>
<p class="noindenta">The <em>setxattr()</em>, <em>lsetxattr()</em>, and <em>fsetxattr()</em> system calls set the value of one of a file&#8217;s EAs.</p>
<div class="box">
<p class="programsa">#include &lt;sys/xattr.h&gt;<br/><br/>int <span class="codestrong">setxattr</span>(const char *<span class="font1">pathname</span>, const char *<span class="font1">name</span>, const void *<span class="font1">value</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_t <span class="font1">size</span>, int <span class="font1">flags</span>);<br/>int <span class="codestrong">lsetxattr</span>(const char *<span class="font1">pathname</span>, const char *<span class="font1">name</span>, const void *<span class="font1">value</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_t <span class="font1">size</span>, int <span class="font1">flags</span>);<br/>int <span class="codestrong">fsetxattr</span>(int <span class="font1">fd</span>, const char *<span class="font1">name</span>, const void *<span class="font1">value</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_t <span class="font1">size</span>, int <span class="font1">flags</span>);</p>
<p class="right">All return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb">The differences between these three calls are analogous to those between <em>stat()</em>, <em>lstat()</em>, and <em>fstat()</em> (<a href="ch15.xhtml#ch15lev1sec01">Section 15.1</a>):</p>
<p class="bull">&#8226; <em>setxattr()</em> identifies a file by <em>pathname</em>, and dereferences the filename if it is a symbolic link;</p>
<p class="bull">&#8226; <em>lsetxattr()</em> identifies a file by <em>pathname</em>, but doesn&#8217;t dereference symbolic links; and</p>
<p class="bull">&#8226; <em>fsetxattr()</em> identifies a file by the open file descriptor <em>fd</em>.</p>
<p class="noindentt">The same distinction applies to the other groups of system calls described in the remainder of this section.</p>
<p class="indent"><span epub:type="pagebreak" id="page_315"/>The <em>name</em> argument is a null-terminated string that defines the name of the EA. The <em>value</em> argument is a pointer to a buffer that defines the new value for the EA. The <em>size</em> argument specifies the length of this buffer.</p>
<p class="indentb">By default, these system calls create a new EA if one with the given <em>name</em> doesn&#8217;t already exist, or replace the value of an EA if it does already exist. The <em>flags</em> argument provides finer control over this behavior. It may be specified as 0 to obtain the default behavior, or as one of the following constants:</p>
<p class="term"><span class="literal">XATTR_CREATE</span></p>
<p class="termlist">Fail (<span class="literal">EEXIST</span>) if an EA with the given <em>name</em> already exists.</p>
<p class="term"><span class="literal">XATTR_REPLACE</span></p>
<p class="termlist">Fail (<span class="literal">ENODATA</span>) if an EA with the given <em>name</em> doesn&#8217;t already exist.</p>
<p class="noindentt">Here is an example of the use of <em>setxattr()</em> to create a <em>user</em> EA:</p>
<p class="programs">char *value;<br/><br/>value = "The past is not dead.";<br/><br/>if (setxattr(pathname, "user.x", value, strlen(value), 0) == -1)<br/>&#160;&#160;&#160;&#160;errExit("setxattr");</p>
<h5 class="h5" id="ch16lev3sec06"><strong>Retrieving the value of an EA</strong></h5>
<p class="noindenta">The <em>getxattr()</em>, <em>lgetxattr()</em>, and <em>fgetxattr()</em> system calls retrieve the value of an EA.</p>
<div class="box">
<p class="programsa">#include &lt;sys/xattr.h&gt;<br/><br/>ssize_t <span class="codestrong">getxattr</span>(const char *<span class="font1">pathname</span>, const char *<span class="font1">name</span>, void *<span class="font1">value</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_t <span class="font1">size</span>);<br/>ssize_t <span class="codestrong">lgetxattr</span>(const char *<span class="font1">pathname</span>, const char *<span class="font1">name</span>, void *<span class="font1">value</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_t <span class="font1">size</span>);<br/>ssize_t <span class="codestrong">fgetxattr</span>(int <span class="font1">fd</span>, const char *<span class="font1">name</span>, void *<span class="font1">value</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_t <span class="font1">size</span>);</p>
<p class="right">All return (nonnegative) size of EA value on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>name</em> argument is a null-terminated string that identifies the EA whose value we want to retrieve. The EA value is returned in the buffer pointed to by <em>value</em>. This buffer must be allocated by the caller, and its length must be specified in <em>size</em>. On success, these system calls return the number of bytes copied into <em>value</em>.</p>
<p class="indent">If the file doesn&#8217;t have an attribute with the given <em>name</em>, these system calls fail with the error <span class="literal">ENODATA</span>. If <em>size</em> is too small, these system calls fail with the error <span class="literal">ERANGE</span>.</p>
<p class="indent">It is possible to specify <em>size</em> as 0, in which case <em>value</em> is ignored but the system call still returns the size of the EA value. This provides a mechanism to determine the size of the <em>value</em> buffer required for a subsequent call to actually retrieve the EA value. Note, however, that we still have no guarantee that the returned size will be big enough when subsequently trying to retrieve the value. Another process may have assigned a bigger value to the attribute in the meantime, or removed the attribute altogether.</p>
<h5 class="h5" id="ch16lev3sec07"><span epub:type="pagebreak" id="page_316"/><strong>Removing an EA</strong></h5>
<p class="noindenta">The <em>removexattr()</em>, <em>lremovexattr()</em>, and <em>fremovexattr()</em> system calls remove an EA from a file.</p>
<div class="box">
<p class="programsa">#include &lt;sys/xattr.h&gt;<br/><br/>int <span class="codestrong">removexattr</span>(const char *<span class="font1">pathname</span>, const char *<span class="font1">name</span>);<br/>int <span class="codestrong">lremovexattr</span>(const char *<span class="font1">pathname</span>, const char *<span class="font1">name</span>);<br/>int <span class="codestrong">fremovexattr</span>(int <span class="font1">fd</span>, const char *<span class="font1">name</span>);</p>
<p class="right">All return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The null-terminated string given in <em>name</em> identifies the EA that is to be removed. An attempt to remove an EA that doesn&#8217;t exist fails with the error <span class="literal">ENODATA</span>.</p>
<h5 class="h5" id="ch16lev3sec08"><strong>Retrieving the names of all EAs associated with a file</strong></h5>
<p class="noindenta">The <em>listxattr()</em>, <em>llistxattr()</em>, and <em>flistxattr()</em> system calls return a list containing the names of all of the EAs associated with a file.</p>
<div class="box">
<p class="programsa">#include &lt;sys/xattr.h&gt;<br/><br/>ssize_t <span class="codestrong">listxattr</span>(const char *<span class="font1">pathname</span>, char *<span class="font1">list</span>, size_t <span class="font1">size</span>);<br/>ssize_t <span class="codestrong">llistxattr</span>(const char *<span class="font1">pathname</span>, char *<span class="font1">list</span>, size_t <span class="font1">size</span>);<br/>ssize_t <span class="codestrong">flistxattr</span>(int <span class="font1">fd</span>, char *<span class="font1">list</span>, size_t <span class="font1">size</span>);</p>
<p class="right">All return number of bytes copied into <em>list</em> on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The list of EA names is returned as a series of null-terminated strings in the buffer pointed to by <em>list</em>. The size of this buffer must be specified in <em>size</em>. On success, these system calls return the number of bytes copied into <em>list</em>.</p>
<p class="indent">As with <em>getxattr()</em>, it is possible to specify <em>size</em> as 0, in which case <em>list</em> is ignored, but the system call returns the size of the buffer that would be required for a subsequent call to actually retrieve the EA name list (assuming it remains unchanged).</p>
<p class="indent">To retrieve a list of the EA names associated with a file requires only that the file be accessible (i.e., that we have execute access to all of the directories included in <em>pathname</em>). No permissions are required on the file itself.</p>
<p class="indent">For security reasons, the EA names returned in <em>list</em> may exclude attributes to which the calling process doesn&#8217;t have access. For example, most file systems omit <em>trusted</em> attributes from the list returned by a call to <em>listxattr()</em> in an unprivileged process. But note the &#8220;may&#8221; in the earlier sentence, indicating that a file-system implementation is not obliged to do this. Therefore, we need to allow for the possibility that a subsequent call to <em>getxattr()</em> using an EA name returned in <em>list</em> may fail because the process doesn&#8217;t have the privilege required to obtain the value of that EA. (A similar failure could also happen if another process deleted an attribute between the calls to <em>listxattr()</em> and <em>getxattr()</em>.)</p>
<h5 class="h5" id="ch16lev3sec09"><span epub:type="pagebreak" id="page_317"/><strong>Example program</strong></h5>
<p class="noindenta">The program in <a href="ch16.xhtml#ch16ex1">Listing 16-1</a> retrieves and displays the names and values of all EAs of the files listed on its command line. For each file, the program uses <em>listxattr()</em> to retrieve the names of all EAs associated with the file, and then executes a loop calling <em>getxattr()</em> once for each name, to retrieve the corresponding value. By default, attribute values are displayed as plain text. If the <em>&#8211;x</em> option is supplied, then the attribute values are displayed as hexadecimal strings. The following shell session log demonstrates the use of this program:</p>
<p class="programs">$ <span class="codestrong">setfattr -n user.x -v "The past is not dead." tfile</span><br/>$ <span class="codestrong">setfattr -n user.y -v "In fact, it's not even past." tfile</span><br/>$ <span class="codestrong">./xattr_view tfile</span><br/>tfile:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;name=user.x; value=The past is not dead.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;name=user.y; value=In fact, it's not even past.</p>
<p class="examplet"><a id="ch16ex1"/><strong>Listing 16-1:</strong> Display file extended attributes</p>
<p class="programsli">________________________________________________________<span class="codestrong">xattr/xattr_view.c</span><br/><br/>#include &lt;sys/xattr.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>#define XATTR_SIZE 10000<br/><br/>static void<br/>usageError(char *progName)<br/>{<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "Usage: %s [-x] file...\n", progName);<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;char list[XATTR_SIZE], value[XATTR_SIZE];<br/>&#160;&#160;&#160;&#160;ssize_t listLen, valueLen;<br/>&#160;&#160;&#160;&#160;int ns, j, k, opt;<br/>&#160;&#160;&#160;&#160;Boolean hexDisplay;<br/><br/>&#160;&#160;&#160;&#160;hexDisplay = 0;<br/>&#160;&#160;&#160;&#160;while ((opt = getopt(argc, argv, "x")) != -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (opt) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'x': hexDisplay = 1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case '?': usageError(argv[0]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (optind &gt;= argc)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0]);<br/>&#160;&#160;&#160;&#160;for (j = optind; j &lt; argc; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;listLen = listxattr(argv[j], list, XATTR_SIZE);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (listLen == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("listxattr");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s:\n", argv[j]);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Loop through all EA names, displaying name + value */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (ns = 0; ns &lt; listLen; ns += strlen(&#38;list[ns]) + 1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;name=%s; ", &#38;list[ns]);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;valueLen = getxattr(argv[j], &#38;list[ns], value, XATTR_SIZE);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (valueLen == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("couldn't get value");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else if (!hexDisplay) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("value=%.*s", (int) valueLen, value);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("value=");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (k = 0; k &lt; valueLen; k++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%02x ", (unsigned int) value[k]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("\n");<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>________________________________________________________<span class="codestrong">xattr/xattr_view.c</span></p>
<h3 class="h3" id="ch16lev1sec04"><span epub:type="pagebreak" id="page_318"/><strong>16.4 Summary</strong></h3>
<p class="noindenta">From version 2.6 onward, Linux supports extended attributes, which allow arbitrary metadata to be associated with a file, in the form of name-value pairs.</p>
<h3 class="h3" id="ch16lev1sec05"><strong>16.5 Exercise</strong></h3>
<p class="exer"><a id="ch16exe1"/><strong>16-1.</strong>&#160;&#160;&#160;Write a program that can be used to create or modify a <em>user</em> EA for a file (i.e., a simple version of <em>setfattr(1)</em>). The filename and the EA name and value should be supplied as command-line arguments to the program.</p>
</body>
</html>
