<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch52"><span epub:type="pagebreak" id="page_1063"/><strong><span class="big">52</span></strong><br/><strong>POSIX MESSAGE QUEUES</strong></h2>
<p class="noindentab">This chapter describes POSIX message queues, which allow processes to exchange data in the form of messages. POSIX message queues are similar to their System V counterparts, in that data is exchanged in units of whole messages. However, there are also some notable differences:</p>
<p class="bull">&#8226; POSIX message queues are reference counted. A queue that is marked for deletion is removed only after it is closed by all processes that are currently using it.</p>
<p class="bull">&#8226; Each System V message has an integer type, and messages can be selected in a variety of ways using <em>msgrcv()</em>. By contrast, POSIX messages have an associated priority, and messages are always strictly queued (and thus received) in priority order.</p>
<p class="bull">&#8226; POSIX message queues provide a feature that allows a process to be asynchronously notified when a message is available on a queue.</p>
<p class="noindentt">POSIX message queues are a relatively recent addition to Linux. The required implementation support was added in kernel 2.6.6 (in addition, <em>glibc</em> 2.3.4 or later is required).</p>
<div class="block">
<p class="noindent">POSIX message queue support is an optional kernel component that is configured via the <span class="literal">CONFIG_POSIX_MQUEUE</span> option.</p>
</div>
<h3 class="h3" id="ch52lev1sec01"><span epub:type="pagebreak" id="page_1064"/><strong>52.1 Overview</strong></h3>
<p class="noindentab">The main functions in the POSIX message queue API are the following:</p>
<p class="bull">&#8226; The <em>mq_open()</em> function creates a new message queue or opens an existing queue, returning a message queue descriptor for use in later calls.</p>
<p class="bull">&#8226; The <em>mq_send()</em> function writes a message to a queue.</p>
<p class="bull">&#8226; The <em>mq_receive()</em> function reads a message from a queue.</p>
<p class="bull">&#8226; The <em>mq_close()</em> function closes a message queue that the process previously opened.</p>
<p class="bull">&#8226; The <em>mq_unlink()</em> function removes a message queue name and marks the queue for deletion when all processes have closed it.</p>
<p class="noindenttb">The above functions all serve fairly obvious purposes. In addition, a couple of features are peculiar to the POSIX message queue API:</p>
<p class="bull">&#8226; Each message queue has an associated set of attributes. Some of these attributes can be set when the queue is created or opened using <em>mq_open()</em>. Two functions are provided to retrieve and change queue attributes: <em>mq_getattr()</em> and <em>mq_setattr()</em>.</p>
<p class="bull">&#8226; The <em>mq_notify()</em> function allows a process to register for message notification from a queue. After registering, the process is notified of the availability of a message by delivery of a signal or by the invocation of a function in a separate thread.</p>
<h3 class="h3" id="ch52lev1sec02"><strong>52.2 Opening, Closing, and Unlinking a Message Queue</strong></h3>
<p class="noindenta">In this section, we look at the functions used to open, close, and remove message queues.</p>
<h5 class="h5" id="ch52lev3sec01"><strong>Opening a message queue</strong></h5>
<p class="noindenta">The <em>mq_open()</em> function creates a new message queue or opens an existing queue.</p>
<div class="box">
<p class="programsa">#include &lt;fcntl.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Defines O_* constants */<br/>#include &lt;sys/stat.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Defines mode constants */<br/>#include &lt;mqueue.h&gt;<br/><br/>mqd_t <span class="codestrong">mq_open</span>(const char *<span class="font1">name</span>, int <span class="font1">oflag</span>, ...<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* mode_t <span class="font1">mode</span>, struct mq_attr *<span class="font1">attr</span> */);</p>
<p class="right">Returns a message queue descriptor on success, or <em>(mqd_t)</em> &#8211;1 on error</p>
</div>
<p class="noindent">The <em>name</em> argument identifies the message queue, and is specified according to the rules given in <a href="ch51.xhtml#ch51lev1sec01">Section 51.1</a>.</p>
<p class="indent">The <em>oflag</em> argument is a bit mask that controls various aspects of the operation of <em>mq_open()</em>. The values that can be included in this mask are summarized in <a href="ch52.xhtml#ch52table1">Table 52-1</a>.</p>
<p class="tablecap"><span epub:type="pagebreak" id="page_1065"/><a id="ch52table1"/><strong>Table 52-1:</strong> Bit values for the <em>mq_open() oflag</em> argument</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Flag</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_CREAT</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Create queue if it doesn&#8217;t already exist</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">O_EXCL</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">With <span class="literal">O_CREAT</span>, create queue exclusively</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_RDONLY</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Open for reading only</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">O_WRONLY</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Open for writing only</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">O_RDWR</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Open for reading and writing</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">O_NONBLOCK</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Open in nonblocking mode</p></td>
</tr>
</tbody>
</table>
<p class="noindent">One of the purposes of the <em>oflag</em> argument is to determine whether we are opening an existing queue or creating and opening a new queue. If <em>oflag</em> doesn&#8217;t include <span class="literal">O_CREAT</span>, we are opening an existing queue. If <em>oflag</em> includes <span class="literal">O_CREAT</span>, a new, empty queue is created if one with the given <em>name</em> doesn&#8217;t already exist. If <em>oflag</em> specifies both <span class="literal">O_CREAT</span> and <span class="literal">O_EXCL</span>, and a queue with the given <em>name</em> already exists, then <em>mq_open()</em> fails.</p>
<p class="indent">The <em>oflag</em> argument also indicates the kind of access that the calling process will make to the message queue, by specifying exactly one of the values <span class="literal">O_RDONLY</span>, <span class="literal">O_WRONLY</span>, or <span class="literal">O_RDWR</span>.</p>
<p class="indent">The remaining flag value, <span class="literal">O_NONBLOCK</span>, causes the queue to be opened in nonblocking mode. If a subsequent call to <em>mq_receive()</em> or <em>mq_send()</em> can&#8217;t be performed without blocking, the call will fail immediately with the error <span class="literal">EAGAIN</span>.</p>
<p class="indentb">If <em>mq_open()</em> is being used to open an existing message queue, the call requires only two arguments. However, if <span class="literal">O_CREAT</span> is specified in <em>flags</em>, two further arguments are required: <em>mode</em> and <em>attr</em>. (If the queue specified by <em>name</em> already exists, these two arguments are ignored.) These arguments are used as follows:</p>
<p class="bull">&#8226; The <em>mode</em> argument is a bit mask that specifies the permissions to be placed on the new message queue. The bit values that may be specified are the same as for files (<a href="ch15.xhtml#ch15table4">Table 15-4</a>, on <a href="ch15.xhtml#page_295">page 295</a>), and, as with <em>open()</em>, the value in <em>mode</em> is masked against the process umask (<a href="ch15.xhtml#ch15lev2sec10">Section 15.4.6</a>). To read from a queue (<em>mq_receive()</em>), read permission must be granted to the corresponding class of user; to write to a queue (<em>mq_send()</em>), write permission is required.</p>
<p class="bull">&#8226; The <em>attr</em> argument is an <em>mq_attr</em> structure that specifies attributes for the new message queue. If <em>attr</em> is <span class="literal">NULL</span>, the queue is created with implementation-defined default attributes. We describe the <em>mq_attr</em> structure in <a href="ch52.xhtml#ch52lev1sec04">Section 52.4</a>.</p>
<p class="noindentt">Upon successful completion, <em>mq_open()</em> returns a <em>message queue descriptor</em>, a value of type <em>mqd_t</em>, which is used in subsequent calls to refer to this open message queue. The only stipulation that SUSv3 makes about this data type is that it may not be an array; that is, it is guaranteed to be a type that can be used in an assignment statement or passed by value as a function argument. (On Linux, <em>mqd_t</em> is an <em>int</em>, but, for example, on Solaris it is defined as <em>void *</em>.)</p>
<p class="indent">An example of the use of <em>mq_open()</em> is provided in <a href="ch52.xhtml#ch52ex2">Listing 52-2</a>.</p>
<h5 class="h5" id="ch52lev3sec02"><strong>Effect of <em>fork()</em>, <em>exec()</em>, and process termination on message queue descriptors</strong></h5>
<p class="noindenta">During a <em>fork()</em>, the child process receives copies of its parent&#8217;s message queue descriptors, and these descriptors refer to the same open message queue descriptions. <span epub:type="pagebreak" id="page_1066"/>(We explain message queue descriptions in <a href="ch52.xhtml#ch52lev1sec03">Section 52.3</a>.) The child doesn&#8217;t inherit any of its parent&#8217;s message notification registrations.</p>
<p class="indent">When a process performs an <em>exec()</em> or terminates, all of its open message queue descriptors are closed. As a consequence of closing its message queue descriptors, all of the process&#8217;s message notification registrations on the corresponding queues are deregistered.</p>
<h5 class="h5" id="ch52lev3sec03"><strong>Closing a message queue</strong></h5>
<p class="noindenta">The <em>mq_close()</em> function closes the message queue descriptor <em>mqdes</em>.</p>
<div class="box">
<p class="programsa">#include &lt;mqueue.h&gt;<br/><br/>int <span class="codestrong">mq_close</span>(mqd_t <span class="font1">mqdes</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">If the calling process has registered via <em>mqdes</em> for message notification from the queue (<a href="ch52.xhtml#ch52lev1sec06">Section 52.6</a>), then the notification registration is automatically removed, and another process can subsequently register for message notification from the queue.</p>
<p class="indent">A message queue descriptor is automatically closed when a process terminates or calls <em>exec()</em>. As with file descriptors, we should explicitly close message queue descriptors that are no longer required, in order to prevent the process from running out of message queue descriptors.</p>
<p class="indent">As with <em>close()</em> for files, closing a message queue doesn&#8217;t delete it. For that purpose, we need <em>mq_unlink()</em>, which is the message queue analog of <em>unlink()</em>.</p>
<h5 class="h5" id="ch52lev3sec04"><strong>Removing a message queue</strong></h5>
<p class="noindenta">The <em>mq_unlink()</em> function removes the message queue identified by <em>name</em>, and marks the queue to be destroyed once all processes cease using it (this may mean immediately, if all processes that had the queue open have already closed it).</p>
<div class="box">
<p class="programsa">#include &lt;mqueue.h&gt;<br/><br/>int <span class="codestrong">mq_unlink</span>(const char *<span class="font1">name</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent"><a href="ch52.xhtml#ch52ex1">Listing 52-1</a> demonstrates the use of <em>mq_unlink()</em>.</p>
<p class="examplet"><a id="ch52ex1"/><strong>Listing 52-1:</strong> Using <em>mq_unlink()</em> to unlink a POSIX message queue</p>
<p class="programsli">_______________________________________________________ <span class="codestrong">pmsg/pmsg_unlink.c</span><br/><br/>#include &lt;mqueue.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s mq-name\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;if (mq_unlink(argv[1]) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mq_unlink");<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_______________________________________________________ <span class="codestrong">pmsg/pmsg_unlink.c</span></p>
<h3 class="h3" id="ch52lev1sec03"><span epub:type="pagebreak" id="page_1067"/><strong>52.3 Relationship Between Descriptors and Message Queues</strong></h3>
<p class="noindenta">The relationship between a message queue descriptor and an open message queue is analogous to the relationship between a file descriptor and an open file (<a href="ch05.xhtml#ch5fig2">Figure 5-2</a>, on <a href="ch05.xhtml#page_95">page 95</a>). A message queue descriptor is a per-process handle that refers to an entry in the system-wide table of open message queue descriptions, and this entry in turn refers to a message queue object. This relationship is illustrated in <a href="ch52.xhtml#ch52fig1">Figure 52-1</a>.</p>
<div class="block">
<p class="noindent">On Linux, POSIX message queues are implemented as i-nodes in a virtual file system, and message queue descriptors and open message queue descriptions are implemented as file descriptors and open file descriptions, respectively. However, these are implementation details that are not required by SUSv3 and don&#8217;t hold true on some other UNIX implementations. Nevertheless, we return to this point in <a href="ch52.xhtml#ch52lev1sec07">Section 52.7</a>, because Linux provides some nonstandard features that are made possible by this implementation.</p>
</div>
<div class="image"><img src="../images/f52-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch52fig1"/><strong>Figure 52-1:</strong> Relationship between kernel data structures for POSIX message queues</p>
<p class="noindentb"><span epub:type="pagebreak" id="page_1068"/><a href="ch52.xhtml#ch52fig1">Figure 52-1</a> helps clarify a number of details of the use of message queue descriptors (all of which are analogous to the use of file descriptors):</p>
<p class="bull">&#8226; An open message queue description has an associated set of flags. SUSv3 specifies only one such flag, <span class="literal">O_NONBLOCK</span>, which determines whether I/O is nonblocking.</p>
<p class="bull">&#8226; Two processes can hold message queue descriptors (descriptor <em>x</em> in the diagram) that refer to the same open message queue description. This can occur because a process opens a message queue and then calls <em>fork()</em>. These descriptors share the state of the <span class="literal">O_NONBLOCK</span> flag.</p>
<p class="bull">&#8226; Two processes can hold open message queue descriptors that refer to different message queue descriptions that refer to the same message queue (e.g., descriptor <em>z</em> in process A and descriptor <em>y</em> in process B both refer to <span class="literal">/mq-r</span>). This occurs because the two processes each used <em>mq_open()</em> to open the same queue.</p>
<h3 class="h3" id="ch52lev1sec04"><strong>52.4 Message Queue Attributes</strong></h3>
<p class="noindenta">The <em>mq_open()</em>, <em>mq_getattr()</em>, and <em>mq_setattr()</em> functions all permit an argument that is a pointer to an <em>mq_attr</em> structure. This structure is defined in <span class="literal">&lt;mqueue.h&gt;</span> as follows:</p>
<p class="programs">struct mq_attr {<br/>&#160;&#160;&#160;&#160;long mq_flags;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Message queue description flags: 0 or<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;O_NONBLOCK [mq_getattr(), mq_setattr()] */<br/>&#160;&#160;&#160;&#160;long mq_maxmsg;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Maximum number of messages on queue<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[mq_open(), mq_getattr()] */<br/>&#160;&#160;&#160;&#160;long mq_msgsize;&#160;&#160;&#160;&#160;&#160;&#160;/* Maximum message size (in bytes)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[mq_open(), mq_getattr()] */<br/>&#160;&#160;&#160;&#160;long mq_curmsgs;&#160;&#160;&#160;&#160;&#160;&#160;/* Number of messages currently in queue<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[mq_getattr()] */<br/>};</p>
<p class="noindentb">Before we look at the <em>mq_attr</em> structure in detail, it is worth noting the following points:</p>
<p class="bull">&#8226; Only some of the fields are used by each of the three functions. The fields used by each function are indicated in the comments accompanying the structure definition above.</p>
<p class="bull">&#8226; The structure contains information about the open message queue description (<em>mq_flags</em>) associated with a message queue descriptor and information about the queue referred to by that descriptor (<em>mq_maxmsg</em>, <em>mq_msgsize</em>, <em>mq_curmsgs</em>).</p>
<p class="bull">&#8226; Some of the fields contain information that is fixed at the time the queue is created with <em>mq_open()</em> (<em>mq_maxmsg</em> and <em>mq_msgsize</em>); the others return information about the current state of the message queue description (<em>mq_flags</em>) or message queue (<em>mq_curmsgs</em>).</p>
<h5 class="h5" id="ch52lev3sec05"><strong>Setting message queue attributes during queue creation</strong></h5>
<p class="noindentab">When we create a message queue with <em>mq_open()</em>, the following <em>mq_attr</em> fields determine the attributes of the queue:</p>
<p class="bull">&#8226; The <em>mq_maxmsg</em> field defines the limit on the number of messages that can be placed on the queue using <em>mq_send()</em>. This value must be greater than 0.</p>
<p class="bull"><span epub:type="pagebreak" id="page_1069"/>&#8226; The <em>mq_msgsize</em> field defines the upper limit on the size of each message that may be placed on the queue. This value must be greater than 0.</p>
<p class="noindentt">Together, these two values allow the kernel to determine the maximum amount of memory that this message queue may require.</p>
<p class="indent">The <em>mq_maxmsg</em> and <em>mq_msgsize</em> attributes are fixed when a message queue is created; they can&#8217;t subsequently be changed. In <a href="ch52.xhtml#ch52lev1sec08">Section 52.8</a>, we describe two <span class="literal">/proc</span> files that place system-wide limits on the values that can be specified for the <em>mq_maxmsg</em> and <em>mq_msgsize</em> attributes.</p>
<p class="indent">The program in <a href="ch52.xhtml#ch52ex2">Listing 52-2</a> provides a command-line interface to the <em>mq_open()</em> function and shows how the <em>mq_attr</em> structure is used with <em>mq_open()</em>.</p>
<p class="indent">Two command-line options allow message queue attributes to be specified: <em>&#8211;m</em> for <em>mq_maxmsg</em> and <em>&#8211;s</em> for <em>mq_msgsize</em>. If either of these options is supplied, a non-<span class="literal">NULL</span> <em>attrp</em> argument is passed to <em>mq_open()</em>. Some default values are assigned to the fields of the <em>mq_attr</em> structure to which <em>attrp</em> points, in case only one of the <em>&#8211;m</em> and <em>&#8211;s</em> options is specified on the command line. If neither of these options is supplied, <em>attrp</em> is specified as <span class="literal">NULL</span> when calling <em>mq_open()</em>, which causes the queue to be created with the implementation-defined defaults for the queue attributes.</p>
<p class="examplet"><a id="ch52ex2"/><strong>Listing 52-2:</strong> Creating a POSIX message queue</p>
<p class="programsli">_______________________________________________________ <span class="codestrong">pmsg/pmsg_create.c</span><br/><br/>#include &lt;mqueue.h&gt;<br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>static void<br/>usageError(const char *progName)<br/>{<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "Usage: %s [-cx] [-m maxmsg] [-s msgsize] mq-name "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"[octal-perms]\n", progName);<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-c&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Create queue (O_CREAT)\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-m maxmsg&#160;&#160;&#160;Set maximum # of messages\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-s msgsize&#160;&#160;Set maximum message size\n");<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-x&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Create exclusively (O_EXCL)\n");<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int flags, opt;<br/>&#160;&#160;&#160;&#160;mode_t perms;<br/>&#160;&#160;&#160;&#160;mqd_t mqd;<br/>&#160;&#160;&#160;&#160;struct mq_attr attr, *attrp;<br/><br/>&#160;&#160;&#160;&#160;attrp = NULL;<br/>&#160;&#160;&#160;&#160;attr.mq_maxmsg = 10;<br/>&#160;&#160;&#160;&#160;attr.mq_msgsize = 2048;<br/>&#160;&#160;&#160;&#160;flags = O_RDWR;<br/><br/>&#160;&#160;&#160;&#160;/* Parse command-line options */<br/><br/>&#160;&#160;&#160;&#160;while ((opt = getopt(argc, argv, "cm:s:x")) != -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (opt) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'c':<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flags |= O_CREAT;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'm':<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;attr.mq_maxmsg = atoi(optarg);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;attrp = &#38;attr;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 's':<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;attr.mq_msgsize = atoi(optarg);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;attrp = &#38;attr;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'x':<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flags |= O_EXCL;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (optind &gt;= argc)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0]);<br/><br/>&#160;&#160;&#160;&#160;perms = (argc &lt;= optind + 1) ? (S_IRUSR | S_IWUSR) :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;getInt(argv[optind + 1], GN_BASE_8, "octal-perms");<br/><br/>&#160;&#160;&#160;&#160;mqd = mq_open(argv[optind], flags, perms, attrp);<br/>&#160;&#160;&#160;&#160;if (mqd == (mqd_t) -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mq_open");<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_______________________________________________________ <span class="codestrong">pmsg/pmsg_create.c</span></p>
<h5 class="h5" id="ch52lev3sec06"><span epub:type="pagebreak" id="page_1070"/><strong>Retrieving message queue attributes</strong></h5>
<p class="noindenta">The <em>mq_getattr()</em> function returns an <em>mq_attr</em> structure containing information about the message queue description and the message queue associated with the descriptor <em>mqdes</em>.</p>
<div class="box">
<p class="programsa">#include &lt;mqueue.h&gt;<br/><br/>int <span class="codestrong">mq_getattr</span>(mqd_t <span class="font1">mqdes</span>, struct mq_attr *<span class="font1">attr</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb"><span epub:type="pagebreak" id="page_1071"/>In addition to the <em>mq_maxmsg</em> and <em>mq_msgsize</em> fields, which we have already described, the following fields are returned in the structure pointed to by <em>attr</em>:</p>
<p class="term"><em>mq_flags</em></p>
<p class="termlist">These are flags for the open message queue description associated with the descriptor <em>mqdes</em>. Only one such flag is specified: <span class="literal">O_NONBLOCK</span>. This flag is initialized from the <em>oflag</em> argument of <em>mq_open()</em>, and can be changed using <em>mq_setattr()</em>.</p>
<p class="term"><em>mq_curmsgs</em></p>
<p class="termlist">This is the number of messages that are currently in the queue. This information may already have changed by the time <em>mq_getattr()</em> returns, if other processes are reading messages from the queue or writing messages to it.</p>
<p class="noindentt">The program in <a href="ch52.xhtml#ch52ex3">Listing 52-3</a> employs <em>mq_getattr()</em> to retrieve the attributes for the message queue specified in its command-line argument, and then displays those attributes on standard output.</p>
<p class="examplet"><a id="ch52ex3"/><strong>Listing 52-3:</strong> Retrieving POSIX message queue attributes</p>
<p class="programsli">______________________________________________________ <span class="codestrong">pmsg/pmsg_getattr.c</span><br/><br/>#include &lt;mqueue.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;mqd_t mqd;<br/>&#160;&#160;&#160;&#160;struct mq_attr attr;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s mq-name\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;mqd = mq_open(argv[1], O_RDONLY);<br/>&#160;&#160;&#160;&#160;if (mqd == (mqd_t) -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mq_open");<br/><br/>&#160;&#160;&#160;&#160;if (mq_getattr(mqd, &#38;attr) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mq_getattr");<br/><br/>&#160;&#160;&#160;&#160;printf("Maximum # of messages on queue:&#160;&#160;&#160;%ld\n", attr.mq_maxmsg);<br/>&#160;&#160;&#160;&#160;printf("Maximum message size:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;%ld\n", attr.mq_msgsize);<br/>&#160;&#160;&#160;&#160;printf("# of messages currently on queue: %ld\n", attr.mq_curmsgs);<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>______________________________________________________ <span class="codestrong">pmsg/pmsg_getattr.c</span></p>
<p class="noindent">In the following shell session, we use the program in <a href="ch52.xhtml#ch52ex2">Listing 52-2</a> to create a message queue with implementation-defined default attributes (i.e., the final argument to <em>mq_open()</em> is <span class="literal">NULL</span>), and then use the program in <a href="ch52.xhtml#ch52ex3">Listing 52-3</a> to display the queue attributes so that we can see the default settings on Linux.</p>
<p class="programs"><span epub:type="pagebreak" id="page_1072"/>$ <span class="codestrong">./pmsg_create -cx /mq</span><br/>$ <span class="codestrong">./pmsg_getattr /mq</span><br/>Maximum # of messages on queue:&#160;&#160;&#160;10<br/>Maximum message size:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8192<br/># of messages currently on queue: 0<br/>$ <span class="codestrong">./pmsg_unlink /mq</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Remove message queue</span></p>
<p class="noindent">From the above output, we see that the Linux default values for <em>mq_maxmsg</em> and <em>mq_msgsize</em> are 10 and 8192, respectively.</p>
<p class="indent">There is a wide variation in the implementation-defined defaults for <em>mq_maxmsg</em> and <em>mq_msgsize</em>. Portable applications generally need to choose explicit values for these attributes, rather than relying on the defaults.</p>
<h5 class="h5" id="ch52lev3sec07"><strong>Modifying message queue attributes</strong></h5>
<p class="noindenta">The <em>mq_setattr()</em> function sets attributes of the message queue description associated with the message queue descriptor <em>mqdes</em>, and optionally returns information about the message queue.</p>
<div class="box">
<p class="programsa">#include &lt;mqueue.h&gt;<br/><br/>int <span class="codestrong">mq_setattr</span>(mqd_t <span class="font1">mqdes</span>, const struct mq_attr *<span class="font1">newattr</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct mq_attr *<span class="font1">oldattr</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb">The <em>mq_setattr()</em> function performs the following tasks:</p>
<p class="bull">&#8226; It uses the <em>mq_flags</em> field in the <em>mq_attr</em> structure pointed to by <em>newattr</em> to change the flags of the message queue description associated with the descriptor <em>mqdes</em>.</p>
<p class="bull">&#8226; If <em>oldattr</em> is non-<span class="literal">NULL</span>, it returns an <em>mq_attr</em> structure containing the previous message queue description flags and message queue attributes (i.e., the same task as is performed by <em>mq_getattr()</em>).</p>
<p class="noindentt">The only attribute that SUSv3 specifies that can be changed using <em>mq_setattr()</em> is the state of the <span class="literal">O_NONBLOCK</span> flag.</p>
<p class="indent">Allowing for the possibility that a particular implementation may define other modifiable flags, or that SUSv3 may add new flags in the future, a portable application should change the state of the <span class="literal">O_NONBLOCK</span> flag by using <em>mq_getattr()</em> to retrieve the <em>mq_flags</em> value, modifying the <span class="literal">O_NONBLOCK</span> bit, and calling <em>mq_setattr()</em> to change the <em>mq_flags</em> settings. For example, to enable <span class="literal">O_NONBLOCK</span>, we would do the following:</p>
<p class="programs">if (mq_getattr(mqd, &#38;attr) == -1)<br/>&#160;&#160;&#160;&#160;errExit("mq_getattr");<br/>attr.mq_flags |= O_NONBLOCK;<br/>if (mq_setattr(mqd, &#38;attr, NULL) == -1)<br/>&#160;&#160;&#160;&#160;errExit("mq_setattr");</p>
<h3 class="h3" id="ch52lev1sec05"><span epub:type="pagebreak" id="page_1073"/><strong>52.5 Exchanging Messages</strong></h3>
<p class="noindenta">In this section, we look at the functions that are used to send messages to and receive messages from a queue.</p>
<h4 class="h4" id="ch52lev2sec01"><strong>52.5.1 Sending Messages</strong></h4>
<p class="noindenta">The <em>mq_send()</em> function adds the message in the buffer pointed to by <em>msg_ptr</em> to the message queue referred to by the descriptor <em>mqdes</em>.</p>
<div class="box">
<p class="programsa">#include &lt;mqueue.h&gt;<br/><br/>int <span class="codestrong">mq_send</span>(mqd_t <span class="font1">mqdes</span>, const char *<span class="font1">msg_ptr</span>, size_t <span class="font1">msg_len</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;unsigned int <span class="font1">msg_prio</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>msg_len</em> argument specifies the length of the message pointed to by <em>msg_ptr</em>. This value must be less than or equal to the <em>mq_msgsize</em> attribute of the queue; otherwise, <em>mq_send()</em> fails with the error <span class="literal">EMSGSIZE</span>. Zero-length messages are permitted.</p>
<p class="indent">Each message has a nonnegative integer priority, specified by the <em>msg_prio</em> argument. Messages are ordered within the queue in descending order of priority (i.e., 0 is the lowest priority). When a new message is added to the queue, it is placed after any other messages of the same priority. If an application doesn&#8217;t need to use message priorities, it is sufficient to always specify <em>msg_prio</em> as 0.</p>
<div class="block">
<p class="noindent">As noted at the beginning of this chapter, the type attribute of System V messages provides different functionality. System V messages are always queued in FIFO order, but <em>msgrcv()</em> allows us to select messages in various ways: in FIFO order, by exact type, or by highest type less than or equal to some value.</p>
</div>
<p class="noindent">SUSv3 allows an implementation to advertise its upper limit for message priorities, either by defining the constant <span class="literal">MQ_PRIO_MAX</span> or via the return from <em>sysconf(_SC_MQ_PRIO_MAX)</em>. SUSv3 requires this limit to be at least 32 (<span class="literal">_POSIX_MQ_PRIO_MAX</span>); that is, priorities at least in the range 0 to 31 are available. However, the actual range on implementations is highly variable. For example, on Linux, this constant has the value 32,768; on Solaris, it is 32; and on Tru64, it is 256.</p>
<p class="indent">If the message queue is already full (i.e., the <em>mq_maxmsg</em> limit for the queue has been reached), then a further <em>mq_send()</em> either blocks until space becomes available in the queue, or, if the <span class="literal">O_NONBLOCK</span> flag is in effect, fails immediately with the error <span class="literal">EAGAIN</span>.</p>
<p class="indent">The program in <a href="ch52.xhtml#ch52ex4">Listing 52-4</a> provides a command-line interface to the <em>mq_send()</em> function. We demonstrate the use of this program in the next section.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1074"/><a id="ch52ex4"/><strong>Listing 52-4:</strong> Writing a message to a POSIX message queue</p>
<p class="programsli">_________________________________________________________ <span class="codestrong">pmsg/pmsg_send.c</span><br/><br/>#include &lt;mqueue.h&gt;<br/>#include &lt;fcntl.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* For definition of O_NONBLOCK */<br/>#include "tlpi_hdr.h"<br/><br/>static void<br/>usageError(const char *progName)<br/>{<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "Usage: %s [-n] name msg [prio]\n", progName);<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Use O_NONBLOCK flag\n");<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int flags, opt;<br/>&#160;&#160;&#160;&#160;mqd_t mqd;<br/>&#160;&#160;&#160;&#160;unsigned int prio;<br/><br/>&#160;&#160;&#160;&#160;flags = O_WRONLY;<br/>&#160;&#160;&#160;&#160;while ((opt = getopt(argc, argv, "n")) != -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (opt) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'n':&#160;&#160;&#160;flags |= O_NONBLOCK;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;usageError(argv[0]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (optind + 1 &gt;= argc)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0]);<br/><br/>&#160;&#160;&#160;&#160;mqd = mq_open(argv[optind], flags);<br/>&#160;&#160;&#160;&#160;if (mqd == (mqd_t) -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mq_open");<br/><br/>&#160;&#160;&#160;&#160;prio = (argc &gt; optind + 2) ? atoi(argv[optind + 2]) : 0;<br/><br/>&#160;&#160;&#160;&#160;if (mq_send(mqd, argv[optind + 1], strlen(argv[optind + 1]), prio) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mq_send");<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________________ <span class="codestrong">pmsg/pmsg_send.c</span></p>
<h4 class="h4" id="ch52lev2sec02"><strong>52.5.2 Receiving Messages</strong></h4>
<p class="noindenta">The <em>mq_receive()</em> function removes the oldest message with the highest priority from the message queue referred to by <em>mqdes</em> and returns that message in the buffer pointed to by <em>msg_ptr</em>.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_1075"/>#include &lt;mqueue.h&gt;<br/><br/>ssize_t <span class="codestrong">mq_receive</span>(mqd_t <span class="font1">mqdes</span>, char *<span class="font1">msg_ptr</span>, size_t <span class="font1">msg_len</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;unsigned int *<span class="font1">msg_prio</span>);</p>
<p class="right">Returns number of bytes in received message on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>msg_len</em> argument is used by the caller to specify the number of bytes of space available in the buffer pointed to by <em>msg_ptr</em>.</p>
<p class="indent">Regardless of the actual size of the message, <em>msg_len</em> (and thus the size of the buffer pointed to by <em>msg_ptr</em>) must be greater than or equal to the <em>mq_msgsize</em> attribute of the queue; otherwise, <em>mq_receive()</em> fails with the error <span class="literal">EMSGSIZE</span>. If we don&#8217;t know the value of the <em>mq_msgsize</em> attribute of a queue, we can obtain it using <em>mq_getattr()</em>. (In an application consisting of cooperating processes, the use of <em>mq_getattr()</em> can usually be dispensed with, because the application can typically decide on a queue&#8217;s <em>mq_msgsize</em> setting in advance.)</p>
<p class="indent">If <em>msg_prio</em> is not <span class="literal">NULL</span>, then the priority of the received message is copied into the location pointed to by <em>msg_prio</em>.</p>
<p class="indent">If the message queue is currently empty, then <em>mq_receive()</em> either blocks until a message becomes available, or, if the <span class="literal">O_NONBLOCK</span> flag is in effect, fails immediately with the error <span class="literal">EAGAIN</span>. (There is no equivalent of the pipe behavior where a reader sees end-of-file if there are no writers.)</p>
<p class="indent">The program in <a href="ch52.xhtml#ch52ex5">Listing 52-5</a> provides a command-line interface to the <em>mq_receive()</em> function. The command format for this program is shown in the <em>usageError()</em> function.</p>
<p class="indent">The following shell session demonstrates the use of the programs in <a href="ch52.xhtml#ch52ex4">Listing 52-4</a> and <a href="ch52.xhtml#ch52ex5">Listing 52-5</a>. We begin by creating a message queue and sending a few messages with different priorities:</p>
<p class="programs">$ <span class="codestrong">./pmsg_create -cx /mq</span><br/>$ <span class="codestrong">./pmsg_send /mq msg-a 5</span><br/>$ <span class="codestrong">./pmsg_send /mq msg-b 0</span><br/>$ <span class="codestrong">./pmsg_send /mq msg-c 10</span></p>
<p class="noindent">We then execute a series of commands to retrieve messages from the queue:</p>
<p class="programs">$ <span class="codestrong">./pmsg_receive /mq</span><br/>Read 5 bytes; priority = 10<br/>msg-c<br/>$ <span class="codestrong">./pmsg_receive /mq</span><br/>Read 5 bytes; priority = 5<br/>msg-a<br/>$ <span class="codestrong">./pmsg_receive /mq</span><br/>Read 5 bytes; priority = 0<br/>msg-b</p>
<p class="noindent">As we can see from the above output, the messages were retrieved in order of priority.</p>
<p class="indent">At this point, the queue is now empty. When we perform another blocking receive, the operation blocks:</p>
<p class="programs">$ <span class="codestrong">./pmsg_receive /mq</span><br/><span class="font1">Blocks; we type Control-C to terminate the program</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_1076"/>On the other hand, if we perform a nonblocking receive, the call returns immediately with a failure status:</p>
<p class="programs">$ <span class="codestrong">./pmsg_receive -n /mq</span><br/>ERROR [EAGAIN/EWOULDBLOCK Resource temporarily unavailable] mq_receive</p>
<p class="examplet"><a id="ch52ex5"/><strong>Listing 52-5:</strong> Reading a message from a POSIX message queue</p>
<p class="programsli">______________________________________________________ <span class="codestrong">pmsg/pmsg_receive.c</span><br/><br/>#include &lt;mqueue.h&gt;<br/>#include &lt;fcntl.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* For definition of O_NONBLOCK */<br/>#include "tlpi_hdr.h"<br/><br/>static void<br/>usageError(const char *progName)<br/>{<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "Usage: %s [-n] name\n", progName);<br/>&#160;&#160;&#160;&#160;fprintf(stderr, "&#160;&#160;&#160;&#160;-n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Use O_NONBLOCK flag\n");<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int flags, opt;<br/>&#160;&#160;&#160;&#160;mqd_t mqd;<br/>&#160;&#160;&#160;&#160;unsigned int prio;<br/>&#160;&#160;&#160;&#160;void *buffer;<br/>&#160;&#160;&#160;&#160;struct mq_attr attr;<br/>&#160;&#160;&#160;&#160;ssize_t numRead;<br/><br/>&#160;&#160;&#160;&#160;flags = O_RDONLY;<br/>&#160;&#160;&#160;&#160;while ((opt = getopt(argc, argv, "n")) != -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (opt) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'n':&#160;&#160;&#160;flags |= O_NONBLOCK;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;usageError(argv[0]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (optind &gt;= argc)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageError(argv[0]);<br/><br/>&#160;&#160;&#160;&#160;mqd = mq_open(argv[optind], flags);<br/>&#160;&#160;&#160;&#160;if (mqd == (mqd_t) -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mq_open");<br/><br/>&#160;&#160;&#160;&#160;if (mq_getattr(mqd, &#38;attr) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mq_getattr");<br/><br/>&#160;&#160;&#160;&#160;buffer = malloc(attr.mq_msgsize);<br/>&#160;&#160;&#160;&#160;if (buffer == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("malloc");<br/><br/>&#160;&#160;&#160;&#160;numRead = mq_receive(mqd, buffer, attr.mq_msgsize, &#38;prio);<br/>&#160;&#160;&#160;&#160;if (numRead == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mq_receive");<br/><br/>&#160;&#160;&#160;&#160;printf("Read %ld bytes; priority = %u\n", (long) numRead, prio);<br/>&#160;&#160;&#160;&#160;if (write(STDOUT_FILENO, buffer, numRead) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("write");<br/>&#160;&#160;&#160;&#160;write(STDOUT_FILENO, "\n", 1);<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>______________________________________________________ <span class="codestrong">pmsg/pmsg_receive.c</span></p>
<h4 class="h4" id="ch52lev2sec03"><span epub:type="pagebreak" id="page_1077"/><strong>52.5.3 Sending and Receiving Messages with a Timeout</strong></h4>
<p class="noindenta">The <em>mq_timedsend()</em> and <em>mq_timedreceive()</em> functions are exactly like <em>mq_send()</em> and <em>mq_receive()</em>, except that if the operation can&#8217;t be performed immediately, and the <span class="literal">O_NONBLOCK</span> flag is not in effect for the message queue description, then the <em>abs_timeout</em> argument specifies a limit on the time for which the call will block.</p>
<div class="box">
<p class="programsa">#include &lt;mqueue.h&gt;<br/>#include &lt;time.h&gt;<br/><br/>int <span class="codestrong">mq_timedsend</span>(mqd_t <span class="font1">mqdes</span>, const char *<span class="font1">msg_ptr</span>, size_t <span class="font1">msg_len</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;unsigned int <span class="font1">msg_prio</span>, const struct timespec *<span class="font1">abs_timeout</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
<p class="programsat">ssize_t <span class="codestrong">mq_timedreceive</span>(mqd_t <span class="font1">mqdes</span>, char *<span class="font1">msg_ptr</span>, size_t <span class="font1">msg_len</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;unsigned int *<span class="font1">msg_prio</span>, const struct timespec *<span class="font1">abs_timeout</span>);</p>
<p class="right">Returns number of bytes in received message on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>abs_timeout</em> argument is a <em>timespec</em> structure (<a href="ch23.xhtml#ch23lev2sec02">Section 23.4.2</a>) that specifies the timeout as an absolute value in seconds and nanoseconds since the Epoch. To perform a relative timeout, we can fetch the current value of the <span class="literal">CLOCK_REALTIME</span> clock using <em>clock_gettime()</em> and add the required amount to that value to produce a suitably initialized <em>timespec</em> structure.</p>
<p class="indent">If a call to <em>mq_timedsend()</em> or <em>mq_timedreceive()</em> times out without being able to complete its operation, then the call fails with the error <span class="literal">ETIMEDOUT</span>.</p>
<p class="indent">On Linux, specifying <em>abs_timeout</em> as <span class="literal">NULL</span> means an infinite timeout. However, this behavior is not specified in SUSv3, and portable applications can&#8217;t rely on it.</p>
<p class="indent">The <em>mq_timedsend()</em> and <em>mq_timedreceive()</em> functions originally derive from POSIX.1d (1999) and are not available on all UNIX implementations.</p>
<h3 class="h3" id="ch52lev1sec06"><strong>52.6 Message Notification</strong></h3>
<p class="noindenta">A feature that distinguishes POSIX message queues from their System V counterparts is the ability to receive asynchronous notification of the availability of a message on a previously empty queue (i.e., when the queue transitions from being empty to nonempty). This feature means that instead of making a blocking <em>mq_receive()</em> call <span epub:type="pagebreak" id="page_1078"/>or marking the message queue descriptor nonblocking and performing periodic <em>mq_receive()</em> calls (&#8220;polls&#8221;) on the queue, a process can request a notification of message arrival and then perform other tasks until it is notified. A process can choose to be notified either via a signal or via invocation of a function in a separate thread.</p>
<div class="block">
<p class="noindent">The notification feature of POSIX message queues is similar to the notification facility that we described for POSIX timers in <a href="ch23.xhtml#ch23lev1sec06">Section 23.6</a>. (Both of these APIs originated in POSIX.1b.)</p>
</div>
<p class="noindent">The <em>mq_notify()</em> function registers the calling process to receive a notification when a message arrives on the empty queue referred to by the descriptor <em>mqdes</em>.</p>
<div class="box">
<p class="programsa">#include &lt;mqueue.h&gt;<br/><br/>int <span class="codestrong">mq_notify</span>(mqd_t <span class="font1">mqdes</span>, const struct sigevent *<span class="font1">notification</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb">The <em>notification</em> argument specifies the mechanism by which the process is to be notified. Before going into the details of the <em>notification</em> argument, we note a few points about message notification:</p>
<p class="bull">&#8226; At any time, only one process (&#8220;the registered process&#8221;) can be registered to receive a notification from a particular message queue. If there is already a process registered for a message queue, further attempts to register for that queue fail (<em>mq_notify()</em> fails with the error <span class="literal">EBUSY</span>).</p>
<p class="bull">&#8226; The registered process is notified only when a new message arrives on a queue that was previously empty. If a queue already contains messages at the time of the registration, a notification will occur only after the queue is emptied and a new message arrives.</p>
<p class="bull">&#8226; After one notification is sent to the registered process, the registration is removed, and any process can then register itself for notification. In other words, as long as a process wishes to keep receiving notifications, it must reregister itself after each notification by once again calling <em>mq_notify()</em>.</p>
<p class="bull">&#8226; The registered process is notified only if some other process is not currently blocked in a call to <em>mq_receive()</em> for the queue. If some other process is blocked in <em>mq_receive()</em>, that process will read the message, and the registered process will remain registered.</p>
<p class="bull">&#8226; A process can explicitly deregister itself as the target for message notification by calling <em>mq_notify()</em> with a <em>notification</em> argument of <span class="literal">NULL</span>.</p>
<p class="noindentt">We already showed the <em>sigevent</em> structure that is used to type the <em>notification</em> argument in <a href="ch23.xhtml#ch23lev2sec07">Section 23.6.1</a>. Here, we present the structure in simplified form, showing just those fields relevant to the discussion of <em>mq_notify()</em>:</p>
<p class="programs">union sigval {<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;sival_int;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Integer value for accompanying data */<br/>&#160;&#160;&#160;&#160;void&#160;&#160;*sival_ptr;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Pointer value for accompanying data */<br/>};<br/><br/>struct sigevent {<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;sigev_notify;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Notification method */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;sigev_signo;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Notification signal for SIGEV_SIGNAL */<br/>&#160;&#160;&#160;&#160;union sigval sigev_value;&#160;&#160;&#160;&#160;&#160;/* Value passed to signal handler or<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread function */<br/>&#160;&#160;&#160;&#160;void (*sigev_notify_function) (union sigval);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Thread notification function */<br/>&#160;&#160;&#160;&#160;void&#160;&#160;*sigev_notify_attributes;&#160;&#160;&#160;/* Really 'pthread_attr_t *' */<br/>};</p>
<p class="noindentb"><span epub:type="pagebreak" id="page_1079"/>The <em>sigev_notify</em> field of this structure is set to one of the following values:</p>
<p class="term"><span class="literal">SIGEV_NONE</span></p>
<p class="termlist">Register this process for notification, but when a message arrives on the previously empty queue, don&#8217;t actually notify the process. As usual, the registration is removed when a new message arrives on an empty queue.</p>
<p class="term"><span class="literal">SIGEV_SIGNAL</span></p>
<p class="termlist">Notify the process by generating the signal specified in the <em>sigev_signo</em> field. The <em>sigev_value</em> field specifies data to accompany the signal (<a href="ch22.xhtml#ch22lev2sec01">Section 22.8.1</a>). This data can be retrieved via the <em>si_value</em> field of the <em>siginfo_t</em> structure that is passed to the signal handler or returned by a call to <em>sigwaitinfo()</em> or <em>sigtimedwait()</em>. The following fields in the <em>siginfo_t</em> structure are also filled in: <em>si_code</em>, with the value <span class="literal">SI_MESGQ</span>; <em>si_signo</em>, with the signal number; <em>si_pid</em>, with the process ID of the process that sent the message; and <em>si_uid</em>, with the real user ID of the process that sent the message. (The <em>si_pid</em> and <em>si_uid</em> fields are not set on most other implementations.)</p>
<p class="term"><span class="literal">SIGEV_THREAD</span></p>
<p class="termlist">Notify the process by calling the function specified in <em>sigev_notify_function</em> as if it were the start function in a new thread. The <em>sigev_notify_attributes</em> field can be specified as <span class="literal">NULL</span> or as a pointer to a <em>pthread_attr_t</em> structure that defines attributes for the thread (<a href="ch29.xhtml#ch29lev1sec08">Section 29.8</a>). The union <em>sigval</em> value specified in <em>sigev_value</em> is passed as the argument of this function.</p>
<h4 class="h4" id="ch52lev2sec04"><strong>52.6.1 Receiving Notification via a Signal</strong></h4>
<p class="noindenta"><a href="ch52.xhtml#ch52ex6">Listing 52-6</a> provides an example of message notification using signals. This program performs the following steps:</p>
<ol>
<li class="order"><p class="orderp">Open the message queue named on the command line in nonblocking mode <span class="ent">&#x2460;</span>, determine the <em>mq_msgsize</em> attribute for the queue <span class="ent">&#x2461;</span>, and allocate a buffer of that size for receiving messages <span class="ent">&#x2462;</span>.</p></li>
<li class="order"><p class="orderp">Block the notification signal (<span class="literal">SIGUSR1</span>) and establish a handler for it <span class="ent">&#x2463;</span>.</p></li>
<li class="order"><p class="orderp">Make an initial call to <em>mq_notify()</em> to register the process to receive message notification <span class="ent">&#x2464;</span>.</p></li>
<li class="order"><p class="orderp">Execute an infinite loop that performs the following steps:</p>
<p class="olista">a) Call <em>sigsuspend()</em>, which unblocks the notification signal and waits until the signal is caught <span class="ent">&#x2465;</span>. Return from this system call indicates that a message <span epub:type="pagebreak" id="page_1080"/>notification has occurred. At this point, the process will have been deregistered for message notification.</p>
<p class="olista">b) Call <em>mq_notify()</em> to reregister this process to receive message notification <span class="ent">&#x2466;</span>.</p>
<p class="olista">c) Execute a <span class="literal">while</span> loop that drains the queue by reading as many messages as possible <span class="ent">&#x2467;</span>.</p></li>
</ol>
<p class="examplet"><a id="ch52ex6"/><strong>Listing 52-6:</strong> Receiving message notification via a signal</p>
<p class="programsli">______________________________________________________ <span class="codestrong">pmsg/mq_notify_sig.c</span><br/><br/>&#160;&#160;&#160;#include &lt;signal.h&gt;<br/>&#160;&#160;&#160;#include &lt;mqueue.h&gt;<br/>&#160;&#160;&#160;#include &lt;fcntl.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* For definition of O_NONBLOCK */<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;#define NOTIFY_SIG SIGUSR1<br/><br/>&#160;&#160;&#160;static void<br/>&#160;&#160;&#160;handler(int sig)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Just interrupt sigsuspend() */<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sigevent sev;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;mqd_t mqd;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct mq_attr attr;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;void *buffer;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;ssize_t numRead;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigset_t blockMask, emptyMask;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sigaction sa;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s mq-name\n", argv[0]);<br/><br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;mqd = mq_open(argv[1], O_RDONLY | O_NONBLOCK);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (mqd == (mqd_t) -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mq_open");<br/><br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;if (mq_getattr(mqd, &#38;attr) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mq_getattr");<br/><br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;buffer = malloc(attr.mq_msgsize);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (buffer == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("malloc");<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;blockMask);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigaddset(&#38;blockMask, NOTIFY_SIG);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigprocmask(SIG_BLOCK, &#38;blockMask, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigprocmask");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;sa.sa_mask);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_flags = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sa.sa_handler = handler;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sigaction(NOTIFY_SIG, &#38;sa, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("sigaction");<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;sev.sigev_notify = SIGEV_SIGNAL;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sev.sigev_signo = NOTIFY_SIG;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (mq_notify(mqd, &#38;sev) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mq_notify");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;emptyMask);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (;;) {<br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigsuspend(&#38;emptyMask);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for notification signal */<br/><br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (mq_notify(mqd, &#38;sev) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mq_notify");<br/><br/><span class="ent">&#x2467;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while ((numRead = mq_receive(mqd, buffer, attr.mq_msgsize, NULL)) &gt;= 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Read %ld bytes\n", (long) numRead);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno != EAGAIN)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Unexpected error */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mq_receive");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/>______________________________________________________ <span class="codestrong">pmsg/mq_notify_sig.c</span></p>
<p class="noindentb"><span epub:type="pagebreak" id="page_1081"/>Various aspects of the program in <a href="ch52.xhtml#ch52ex6">Listing 52-6</a> merit further comment:</p>
<p class="bull">&#8226; We block the notification signal and use <em>sigsuspend()</em> to wait for it, rather than <em>pause()</em>, to prevent the possibility of missing a signal that is delivered while the program is executing elsewhere (i.e., is not blocked waiting for signals) in the <span class="literal">for</span> loop. If this occurred, and we were using <em>pause()</em> to wait for signals, then the next call to <em>pause()</em> would block, even though a signal had already been delivered.</p>
<p class="bull">&#8226; We open the queue in nonblocking mode, and, whenever a notification occurs, we use a <span class="literal">while</span> loop to read all messages from the queue. Emptying the queue in this way ensures that a further notification is generated when a new message arrives. Employing nonblocking mode means that the <span class="literal">while</span> loop will terminate (<em>mq_receive()</em> will fail with the error <span class="literal">EAGAIN</span>) when we have emptied the queue. (This approach is analogous to the use of nonblocking I/O with edge-triggered I/O notification, which we describe in <a href="ch63.xhtml#ch63lev2sec01">Section 63.1.1</a>, and is employed for similar reasons.)</p>
<p class="bull">&#8226; Within the <span class="literal">for</span> loop, it is important that we reregister for message notification <em>before</em> reading all messages from the queue. If we reversed these steps, the following sequence could occur: all messages are read from the queue, and the <span class="literal">while</span> loop terminates; another message is placed on the queue; <em>mq_notify()</em> is called to reregister for message notification. At this point, no further notification signal would be generated, because the queue is already nonempty. Consequently, the program would remain permanently blocked in its next call to <em>sigsuspend()</em>.</p>
<h4 class="h4" id="ch52lev2sec05"><span epub:type="pagebreak" id="page_1082"/><strong>52.6.2 Receiving Notification via a Thread</strong></h4>
<p class="noindentab"><a href="ch52.xhtml#ch52ex7">Listing 52-7</a> provides an example of message notification using threads. This program shares a number of design features with the program in <a href="ch52.xhtml#ch52ex6">Listing 52-6</a>:</p>
<p class="bull">&#8226; When message notification occurs, the program reenables notification before draining the queue <span class="ent">&#x2461;</span>.</p>
<p class="bull">&#8226; Nonblocking mode is employed so that, after receiving a notification, we can completely drain the queue without blocking <span class="ent">&#x2464;</span>.</p>
<p class="examplet"><a id="ch52ex7"/><strong>Listing 52-7:</strong> Receiving message notification via a thread</p>
<p class="programsli">___________________________________________________ <span class="codestrong">pmsg/mq_notify_thread.c</span><br/><br/>&#160;&#160;&#160;#include &lt;pthread.h&gt;<br/>&#160;&#160;&#160;#include &lt;mqueue.h&gt;<br/>&#160;&#160;&#160;#include &lt;fcntl.h&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* For definition of O_NONBLOCK */<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;static void notifySetup(mqd_t *mqdp);<br/><br/>&#160;&#160;&#160;static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Thread notification function */<br/><span class="ent">&#x2460;</span> threadFunc(union sigval sv)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;ssize_t numRead;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;mqd_t *mqdp;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;void *buffer;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct mq_attr attr;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;mqdp = sv.sival_ptr;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (mq_getattr(*mqdp, &#38;attr) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mq_getattr");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;buffer = malloc(attr.mq_msgsize);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (buffer == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("malloc");<br/><br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;notifySetup(mqdp);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;while ((numRead = mq_receive(*mqdp, buffer, attr.mq_msgsize, NULL)) &gt;= 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Read %ld bytes\n", (long) numRead);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno != EAGAIN)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Unexpected error */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mq_receive");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;free(buffer);<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;static void<br/>&#160;&#160;&#160;notifySetup(mqd_t *mqdp)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sigevent sev;<br/><br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;sev.sigev_notify = SIGEV_THREAD;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Notify via thread */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sev.sigev_notify_function = threadFunc;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sev.sigev_notify_attributes = NULL;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Could be pointer to pthread_attr_t structure */<br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;sev.sigev_value.sival_ptr = mqdp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Argument to threadFunc() */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (mq_notify(*mqdp, &#38;sev) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mq_notify");<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;mqd_t mqd;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s mq-name\n", argv[0]);<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;mqd = mq_open(argv[1], O_RDONLY | O_NONBLOCK);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (mqd == (mqd_t) -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mq_open");<br/><br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;notifySetup(&#38;mqd);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;pause();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wait for notifications via thread function */<br/>&#160;&#160;&#160;}<br/>___________________________________________________ <span class="codestrong">pmsg/mq_notify_thread.c</span></p>
<p class="noindentb"><span epub:type="pagebreak" id="page_1083"/>Note the following further points regarding the design of the program in <a href="ch52.xhtml#ch52ex7">Listing 52-7</a>:</p>
<p class="bull">&#8226; The program requests notification via a thread, by specifying <span class="literal">SIGEV_THREAD</span> in the <em>sigev_notify</em> field of the <em>sigevent</em> structure passed to <em>mq_notify()</em>. The thread&#8217;s start function, <em>threadFunc()</em>, is specified in the <em>sigev_notify_function</em> field <span class="ent">&#x2462;</span>.</p>
<p class="bull">&#8226; After enabling message notification, the main program pauses indefinitely <span class="ent">&#x2465;</span>; message notifications are delivered by invocations of <em>threadFunc()</em> in a separate thread <span class="ent">&#x2460;</span>.</p>
<p class="bull">&#8226; We could have made the message queue descriptor, <em>mqd</em>, visible in <em>threadFunc()</em> by making it a global variable. However, we adopted a different approach to illustrate the alternative: we place the address of the message queue descriptor in the <em>sigev_value.sival_ptr</em> field that is passed to <em>mq_notify()</em> <span class="ent">&#x2463;</span>. When <em>threadFunc()</em> is later invoked, this address is passed as its argument.</p>
<div class="block">
<p class="noindent">We must assign a pointer to the message queue descriptor to <em>sigev_value.sival_ptr</em>, rather than (some cast version of) the descriptor itself because, other than the stipulation that it is not an array type, SUSv3 makes no guarantee about the nature or size of the type used to represent the <em>mqd_t</em> data type.</p>
</div>
<h3 class="h3" id="ch52lev1sec07"><strong>52.7 Linux-Specific Features</strong></h3>
<p class="noindenta">The Linux implementation of POSIX message queues provides a number of features that are unstandardized but nevertheless useful.</p>
<h5 class="h5" id="ch52lev3sec08"><span epub:type="pagebreak" id="page_1084"/><strong>Displaying and deleting message queue objects via the command line</strong></h5>
<p class="noindenta">In <a href="ch51.xhtml#ch51">Chapter 51</a>, we mentioned that POSIX IPC objects are implemented as files in virtual file systems, and that these files can be listed and removed with <em>ls</em> and <em>rm</em>. In order to do this with POSIX message queues, we must mount the message queue file system using a command of the following form:</p>
<p class="programs"># <span class="codestrong">mount -t mqueue <span class="codeitalic">source</span> <span class="codeitalic">target</span></span></p>
<p class="noindent">The <em>source</em> can be any name at all (specifying the string <em>none</em> is typical). Its only significance is that it appears in <span class="literal">/proc/mounts</span> and is displayed by the <em>mount</em> and <em>df</em> commands. The <em>target</em> is the mount point for the message queue file system.</p>
<p class="indent">The following shell session shows how to mount the message queue file system and display its contents. We begin by creating a mount point for the file system and mounting it:</p>
<p class="programs">$ <span class="codestrong">su</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Privilege is required for mount</span><br/>Password:<br/># <span class="codestrong">mkdir /dev/mqueue</span><br/># <span class="codestrong">mount -t mqueue none /dev/mqueue</span><br/># <span class="codestrong">exit</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Terminate root shell session</span></p>
<p class="noindent">Next, we display the record in <span class="literal">/proc/mounts</span> for the new mount, and then display the permissions for the mount directory:</p>
<p class="programs">$ <span class="codestrong">cat /proc/mounts | grep mqueue</span><br/>none /dev/mqueue mqueue rw 0 0<br/>$ <span class="codestrong">ls -ld /dev/mqueue</span><br/>drwxrwxrwt&#160;&#160;2 root root 40 Jul 26 12:09 /dev/mqueue</p>
<p class="noindent">One point to note from the output of the <em>ls</em> command is that the message queue file system is automatically mounted with the sticky bit set for the mount directory. (We see this from the fact that there is a <em>t</em> in the other-execute permission field displayed by <em>ls</em>.) This means that an unprivileged process can unlink only message queues that it owns.</p>
<p class="indent">Next, we create a message queue, use <em>ls</em> to show that it is visible in the file system, and then delete the message queue:</p>
<p class="programs">$ <span class="codestrong">./pmsg_create -c /newq</span><br/>$ <span class="codestrong">ls /dev/mqueue</span><br/>newq<br/>$ <span class="codestrong">rm /dev/mqueue/newq</span></p>
<h5 class="h5" id="ch52lev3sec09"><strong>Obtaining information about a message queue</strong></h5>
<p class="noindenta">We can display the contents of the files in the message queue file system. Each of these virtual files contains information about the associated message queue:</p>
<p class="programs">$ <span class="codestrong">./pmsg_create -c /mq</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create a queue</span><br/>$ <span class="codestrong">./pmsg_send /mq abcdefg</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Write 7 bytes to the queue</span><br/>$ <span class="codestrong">cat /dev/mqueue/mq</span><br/>QSIZE:7&#160;&#160;&#160;&#160;&#160;&#160;&#160;NOTIFY:0&#160;&#160;&#160;&#160;SIGNO:0&#160;&#160;&#160;&#160;NOTIFY_PID:0</p>
<p class="noindentb"><span epub:type="pagebreak" id="page_1085"/>The <span class="literal">QSIZE</span> field is a count of the total number of bytes of data in the queue. The remaining fields relate to message notification. If <span class="literal">NOTIFY_PID</span> is nonzero, then the process with the specified process ID has registered for message notification from this queue, and the remaining fields provide information about the kind of notification:</p>
<p class="bull">&#8226; <span class="literal">NOTIFY</span> is a value corresponding to one of the <em>sigev_notify</em> constants: 0 for <span class="literal">SIGEV_SIGNAL</span>, 1 for <span class="literal">SIGEV_NONE</span>, or 2 for <span class="literal">SIGEV_THREAD</span>.</p>
<p class="bull">&#8226; If the notification method is <span class="literal">SIGEV_SIGNAL</span>, the <span class="literal">SIGNO</span> field indicates which signal is delivered for message notification.</p>
<p class="noindentt">The following shell session illustrates the information that appears in these fields:</p>
<p class="programs">$ <span class="codestrong">./mq_notify_sig /mq &#38;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Notify using</span> SIGUSR1 <span class="font1">(signal 10 on x86)</span><br/>[1] 18158<br/>$ <span class="codestrong">cat /dev/mqueue/mq</span><br/>QSIZE:7&#160;&#160;&#160;&#160;&#160;&#160;&#160;NOTIFY:0&#160;&#160;&#160;&#160;SIGNO:10&#160;&#160;&#160;NOTIFY_PID:18158<br/>$ <span class="codestrong">kill %1</span><br/>[1]&#160;&#160;&#160;Terminated&#160;&#160;&#160;&#160;./mq_notify_sig /mq<br/>$ <span class="codestrong">./mq_notify_thread /mq &#38;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Notify using a thread</span><br/>[2] 18160<br/>$ <span class="codestrong">cat /dev/mqueue/mq</span><br/>QSIZE:7&#160;&#160;&#160;&#160;&#160;&#160;&#160;NOTIFY:2&#160;&#160;&#160;&#160;SIGNO:0&#160;&#160;&#160;&#160;NOTIFY_PID:18160</p>
<h5 class="h5" id="ch52lev3sec10"><strong>Using message queues with alternative I/O models</strong></h5>
<p class="noindenta">In the Linux implementation, a message queue descriptor is really a file descriptor. We can monitor this file descriptor using I/O multiplexing system calls (<em>select()</em> and <em>poll()</em>) or the <em>epoll</em> API. (See <a href="ch63.xhtml#ch63">Chapter 63</a> for further details of these APIs.) This allows us to avoid the difficulty that we encounter with System V messages queues when trying to wait for input on both a message queue and a file descriptor (refer to <a href="ch46.xhtml#ch46lev1sec09">Section 46.9</a>). However, this feature is nonstandard; SUSv3 doesn&#8217;t require that message queue descriptors are implemented as file descriptors.</p>
<h3 class="h3" id="ch52lev1sec08"><strong>52.8 Message Queue Limits</strong></h3>
<p class="noindentab">SUSv3 defines two limits for POSIX message queues:</p>
<p class="term"><span class="literal">MQ_PRIO_MAX</span></p>
<p class="termlist">We described this limit, which defines the maximum priority for a message, in <a href="ch52.xhtml#ch52lev2sec01">Section 52.5.1</a>.</p>
<p class="term"><span class="literal">MQ_OPEN_MAX</span></p>
<p class="termlist">An implementation can define this limit to indicate the maximum number of message queues that a process can hold open. SUSv3 requires this limit to be at least <span class="literal">_POSIX_MQ_OPEN_MAX</span> (8). Linux doesn&#8217;t define this limit. Instead, because Linux implements message queue descriptors as file descriptors (<a href="ch52.xhtml#ch52lev1sec07">Section 52.7</a>), the applicable limits are those that apply to file descriptors. (In other words, on Linux, the per-process and system-wide limits on the number of file descriptors actually apply to the sum of file descriptors and message queue descriptors.) For further details on the applicable limits, see the discussion of the <span class="literal">RLIMIT_NOFILE</span> resource limit in <a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a>.</p>
<p class="noindenttb"><span epub:type="pagebreak" id="page_1086"/>As well as the above SUSv3-specified limits, Linux provides a number of <span class="literal">/proc</span> files for viewing and (with privilege) changing limits that control the use of POSIX message queues. The following three files reside in the directory <span class="literal">/proc/sys/fs/mqueue</span>:</p>
<p class="term"><span class="literal">msg_max</span></p>
<p class="termlist">This limit specifies a ceiling for the <em>mq_maxmsg</em> attribute of new message queues (i.e., a ceiling for <em>attr.mq_maxmsg</em> when creating a queue with <em>mq_open()</em>). The default value for this limit is 10. The minimum value is 1 (10 in kernels before Linux 2.6.28). The maximum value is defined by the kernel constant <span class="literal">HARD_MSGMAX</span>. The value for this constant is calculated as (131,072 / <em>sizeof(void *)</em>), which evaluates to 32,768 on Linux/x86-32. When a privileged process (<span class="literal">CAP_SYS_RESOURCE</span>) calls <em>mq_open()</em>, the <span class="literal">msg_max</span> limit is ignored, but <span class="literal">HARD_MSGMAX</span> still acts as a ceiling for <em>attr.mq_maxmsg</em>.</p>
<p class="term"><span class="literal">msgsize_max</span></p>
<p class="termlist">This limit specifies a ceiling for the <em>mq_msgsize</em> attribute of new message queues created by unprivileged processes (i.e., a ceiling for <em>attr.mq_msgsize</em> when creating a queue with <em>mq_open()</em>). The default value for this limit is 8192. The minimum value is 128 (8192 in kernels before Linux 2.6.28). The maximum value is 1,048,576 (<span class="literal">INT_MAX</span> in kernels before 2.6.28). This limit is ignored when a privileged process (<span class="literal">CAP_SYS_RESOURCE</span>) calls <em>mq_open()</em>.</p>
<p class="term"><span class="literal">queues_max</span></p>
<p class="termlist">This is a system-wide limit on the number of message queues that may be created. Once this limit is reached, only a privileged process (<span class="literal">CAP_SYS_RESOURCE</span>) can create new queues. The default value for this limit is 256. It can be changed to any value in the range 0 to <span class="literal">INT_MAX</span>.</p>
<p class="noindentt">Linux also provides the <span class="literal">RLIMIT_MSGQUEUE</span> resource limit, which can be used to place a ceiling on the amount of space that can be consumed by all of the message queues belonging to the real user ID of the calling process. See <a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a> for details.</p>
<h3 class="h3" id="ch52lev1sec09"><strong>52.9 Comparison of POSIX and System V Message Queues</strong></h3>
<p class="noindenta"><a href="ch51.xhtml#ch51lev1sec02">Section 51.2</a> listed various advantages of the POSIX IPC interface over the System V IPC interface: the POSIX IPC interface is simpler and more consistent with the traditional UNIX file model, and POSIX IPC objects are reference counted, which simplifies the task of determining when to delete an object. These general advantages also apply to POSIX message queues.</p>
<p class="indentb">POSIX message queues also have the following specific advantages over System V message queues:</p>
<p class="bull">&#8226; The message notification feature allows a (single) process to be asynchronously notified via a signal or the instantiation of a thread when a message arrives on a previously empty queue.</p>
<p class="bull">&#8226; On Linux (but not other UNIX implementations), POSIX message queues can be monitored using <em>poll()</em>, <em>select()</em>, and <em>epoll</em>. System V message queues don&#8217;t provide this feature.</p>
<p class="noindenttb"><span epub:type="pagebreak" id="page_1087"/>However, POSIX message queues also have some disadvantages compared to System V message queues:</p>
<p class="bull">&#8226; POSIX message queues are less portable. This problem applies even across Linux systems, since message queue support is available only since kernel 2.6.6.</p>
<p class="bull">&#8226; The facility to select System V messages by type provides slightly greater flexibility than the strict priority ordering of POSIX messages.</p>
<div class="block">
<p class="noindent">There is a wide variation in the manner in which POSIX message queues are implemented on UNIX systems. Some systems provide implementations in user space, and on at least one such implementation (Solaris 10), the <em>mq_open()</em> manual page explicitly notes that the implementation can&#8217;t be considered secure. On Linux, one of the motives for selecting a kernel implementation of message queues was that it was not deemed possible to provide a secure user-space implementation.</p>
</div>
<h3 class="h3" id="ch52lev1sec10"><strong>52.10 Summary</strong></h3>
<p class="noindenta">POSIX message queues allow processes to exchange data in the form of messages. Each message has an associated integer priority, and messages are queued (and thus received) in order of priority.</p>
<p class="indent">POSIX message queues have some advantages over System V message queues, notably that they are reference counted and that a process can be asynchronously notified of the arrival of a message on an empty queue. However, POSIX message queues are less portable than System V message queues.</p>
<h5 class="h5" id="ch52lev3sec11"><strong>Further information</strong></h5>
<p class="noindenta">[<a href="bib.xhtml#bib90">Stevens, 1999</a>] provides an alternative presentation of POSIX message queues and shows a user-space implementation using memory-mapped files. POSIX message queues are also described in some detail in [<a href="bib.xhtml#bib28">Gallmeister, 1995</a>].</p>
<h3 class="h3" id="ch52lev1sec11"><strong>52.11 Exercises</strong></h3>
<p class="exer"><a id="ch52exe1"/><strong>52-1.</strong>&#160;&#160;&#160;Modify the program in <a href="ch52.xhtml#ch52ex5">Listing 52-5</a> (<span class="literal">pmsg_receive.c</span>) to accept a timeout (a relative number of seconds) on the command line, and use <em>mq_timedreceive()</em> instead of <em>mq_receive()</em>.</p>
<p class="exer"><a id="ch52exe2"/><strong>52-2.</strong>&#160;&#160;&#160;Recode the sequence-number client-server application of <a href="ch44.xhtml#ch44lev1sec08">Section 44.8</a> to use POSIX message queues.</p>
<p class="exer"><a id="ch52exe3"/><strong>52-3.</strong>&#160;&#160;&#160;Rewrite the file-server application of <a href="ch46.xhtml#ch46lev1sec08">Section 46.8</a> to use POSIX message queues instead of System V message queues.</p>
<p class="exer"><a id="ch52exe4"/><strong>52-4.</strong>&#160;&#160;&#160;Write a simple chat program (similar to <em>talk(1)</em>, but without the <em>curses</em> interface) using POSIX messages queues.</p>
<p class="exer"><a id="ch52exe5"/><strong>52-5.</strong>&#160;&#160;&#160;Modify the program in <a href="ch52.xhtml#ch52ex6">Listing 52-6</a> (<span class="literal">mq_notify_sig.c</span>) to demonstrate that message notification established by <em>mq_notify()</em> occurs just once. This can be done by removing the <em>mq_notify()</em> call inside the <span class="literal">for</span> loop.</p>
<p class="exer"><span epub:type="pagebreak" id="page_1088"/><a id="ch52exe6"/><strong>52-6.</strong>&#160;&#160;&#160;Replace the use of a signal handler in <a href="ch52.xhtml#ch52ex6">Listing 52-6</a> (<span class="literal">mq_notify_sig.c</span>) with the use of <em>sigwaitinfo()</em>. Upon return from <em>sigwaitinfo()</em>, display the values in the returned <em>siginfo_t</em> structure. How could the program obtain the message queue descriptor in the <em>siginfo_t</em> structure returned by <em>sigwaitinfo()</em>?</p>
<p class="exer"><a id="ch52exe7"/><strong>52-7.</strong>&#160;&#160;&#160;In <a href="ch52.xhtml#ch52ex7">Listing 52-7</a>, could <em>buffer</em> be made a global variable and its memory allocated just once (in the main program)? Explain your answer.</p>
</body>
</html>
