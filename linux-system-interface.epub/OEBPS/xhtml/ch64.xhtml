<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch64"><span epub:type="pagebreak" id="page_1375"/><strong><span class="big">64</span></strong><br/><strong>PSEUDOTERMINALS</strong></h2>
<p class="noindenta">A <em>pseudoterminal</em> is a virtual device that provides an IPC channel. On one end of the channel is a program that expects to be connected to a terminal device. On the other end is a program that drives the terminal-oriented program by using the channel to send it input and read its output.</p>
<p class="indent">This chapter describes the use of pseudoterminals, showing how they are employed in applications such as terminal emulators, the <em>script(1)</em> program, and programs such as <em>ssh</em>, which provide network login services.</p>
<h3 class="h3" id="ch64lev1sec01"><strong>64.1 Overview</strong></h3>
<p class="noindenta"><a href="ch64.xhtml#ch64fig1">Figure 64-1</a> illustrates one of the problems that pseudoterminals help us solve: how can we enable a user on one host to operate a terminal-oriented program (e.g., <em>vi</em>) on another host connected via a network?</p>
<p class="indent">As shown in the diagram, by permitting communication over a network, sockets provide part of the machinery needed to solve this problem. However, we can&#8217;t connect the standard input, output, and error of a terminal-oriented program directly to a socket. This is because a terminal-oriented program expects to be connected to a terminal&#8212;to be able to perform the terminal-oriented operations described in <a href="ch34.xhtml#ch34">Chapters 34</a> and <a href="ch62.xhtml#ch62">62</a>. Such operations include placing the terminal in noncanonical mode, turning echoing on and off, and setting the terminal foreground process group. If a program tries to perform these operations on a socket, then the relevant system calls will fail.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1376"/>Furthermore, a terminal-oriented program expects a terminal driver to perform certain kinds of processing of its input and output. For example, in canonical mode, when the terminal driver sees the end-of-file character (normally <em>Control-D</em>) at the start of a line, it causes the next <em>read()</em> to return no data.</p>
<p class="indent">Finally, a terminal-oriented program must have a controlling terminal. This allows the program to obtain a file descriptor for the controlling terminal by opening <span class="literal">/dev/tty</span>, and also makes it possible to generate job-control and terminal-related signals (e.g., <span class="literal">SIGTSTP</span>, <span class="literal">SIGTTIN</span>, and <span class="literal">SIGINT</span>) for the program.</p>
<p class="indent">From this description, it should be clear that the definition of a terminal-oriented program is quite broad. It encompasses a wide range of programs that we would normally run in an interactive terminal session.</p>
<div class="image"><img src="../images/f64-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch64fig1"/><strong>Figure 64-1:</strong> The problem: how to operate a terminal-oriented program over a network?</p>
<h5 class="h5" id="ch64lev3sec01"><strong>The pseudoterminal master and slave devices</strong></h5>
<p class="noindenta">A pseudoterminal provides the missing link for creating a network connection to a terminal-oriented program. A pseudoterminal is a pair of connected virtual devices: a <em>pseudoterminal master</em> and a <em>pseudoterminal slave</em>, sometimes jointly referred to as a <em>pseudoterminal pair</em>. A pseudoterminal pair provides an IPC channel somewhat like a bidirectional pipe&#8212;two processes can open the master and slave and then transfer data in either direction through the pseudoterminal.</p>
<p class="indent">The key point about a pseudoterminal is that the slave device appears just like a standard terminal. All of the operations that can be applied to a terminal device can also be applied to a pseudoterminal slave device. Some of these operations aren&#8217;t meaningful for a pseudoterminal (e.g., setting the terminal line speed or parity), but that&#8217;s okay, because the pseudoterminal slave silently ignores them.</p>
<h5 class="h5" id="ch64lev3sec02"><strong>How programs use pseudoterminals</strong></h5>
<p class="noindenta"><a href="ch64.xhtml#ch64fig2">Figure 64-2</a> shows how two programs typically employ a pseudoterminal. (The abbreviation <em>pty</em> in this diagram is a commonly used shorthand for <em>pseudoterminal</em>, <span epub:type="pagebreak" id="page_1377"/>and we employ this abbreviation in various diagrams and function names in this chapter.) The standard input, output, and error of the terminal-oriented program are connected to the pseudoterminal slave, which is also the controlling terminal for the program. On the other side of the pseudoterminal, a driver program acts as a proxy for the user, supplying input to the terminal-oriented program and reading that program&#8217;s output.</p>
<div class="image"><img src="../images/f64-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch64fig2"/><strong>Figure 64-2:</strong> Two programs communicating via a pseudoterminal</p>
<p class="noindent">Typically, the driver program is simultaneously reading from and writing to another I/O channel. It is acting as a relay, passing data in both directions between the pseudoterminal and another program. In order to do this, the driver program must simultaneously monitor input arriving from either direction. Typically, this is done using I/O multiplexing (<em>select()</em> or <em>poll()</em>), or using a pair of processes or threads to perform data transfer in each direction.</p>
<p class="indent">An application that uses a pseudoterminal typically does so as follows:</p>
<ol>
<li class="order"><p class="orderp">The driver program opens the pseudoterminal master device.</p></li>
<li class="order"><p class="orderp">The driver program calls <em>fork()</em> to create a child process. The child performs the following steps:</p>
<p class="olista">a) Call <em>setsid()</em> to start a new session, of which the child is the session leader (<a href="ch34.xhtml#ch34lev1sec03">Section 34.3</a>). This step also causes the child to lose its controlling terminal.</p>
<p class="olista">b) Open the pseudoterminal slave device that corresponds to the master device. Since the child process is a session leader, and it doesn&#8217;t have a controlling terminal, the pseudoterminal slave becomes the controlling terminal for the child process.</p>
<p class="olista">c) Use <em>dup()</em> (or similar) to duplicate the file descriptor for the slave device on standard input, output, and error.</p>
<p class="olista">d) Call <em>exec()</em> to start the terminal-oriented program that is to be connected to the pseudoterminal slave.</p></li>
</ol>
<p class="noindent">At this point, the two programs can now communicate via the pseudoterminal. Anything that the driver program writes to the master appears as input to the terminal-oriented program on the slave, and anything that the terminal-oriented program writes to the slave can be read by the driver program on the master. We consider further details of pseudoterminal I/O in <a href="ch64.xhtml#ch64lev1sec05">Section 64.5</a>.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_1378"/>Pseudoterminals can also be used to connect an arbitrary pair of processes (i.e., not necessarily a parent and child). All that is required is that the process that opens the pseudoterminal master informs the other process of the name of the corresponding slave device, perhaps by writing that name to a file or by transmitting it using some other IPC mechanism. (When we use <em>fork()</em> in the manner described above, the child automatically inherits sufficient information from the parent to enable it to determine the name of the slave.)</p>
</div>
<p class="noindent">So far, our discussion of the use of pseudoterminals has been abstract. <a href="ch64.xhtml#ch64fig3">Figure 64-3</a> shows a specific example: the use of a pseudoterminal by <em>ssh</em>, an application that allows a user to securely run a login session on a remote system connected via a network. (In effect, this diagram combines the information from <a href="ch64.xhtml#ch64fig1">Figure 64-1</a> and <a href="ch64.xhtml#ch64fig2">Figure 64-2</a>.) On the remote host, the driver program for the pseudoterminal master is the <em>ssh</em> server (<em>sshd</em>), and the terminal-oriented program connected to the pseudoterminal slave is the login shell. The <em>ssh</em> server is the glue that connects the pseudoterminal via a socket to the <em>ssh</em> client. Once all of the details of logging in have been completed, the primary purpose of the <em>ssh</em> server and client is to relay characters in either direction between the user&#8217;s terminal on the local host and the shell on the remote host.</p>
<div class="block">
<p class="noindent">We omit describing many details of the <em>ssh</em> client and server. For example, these programs encrypt the data transmitted in either direction across the network. We show a single <em>ssh</em> server process on the remote host, but, in fact, the <em>ssh</em> server is a concurrent network server. It becomes a daemon and creates a passive TCP socket to listen for incoming connections from <em>ssh</em> clients. For each connection, the master <em>ssh</em> server forks a child process that handles all of the details for a single client login session. (We refer to this child process as the <em>ssh</em> server in <a href="ch64.xhtml#ch64fig3">Figure 64-3</a>.) Aside from the details of pseudoterminal setup described above, the <em>ssh</em> server child authenticates the user, updates the login accounting files on the remote host (as described in <a href="ch40.xhtml#ch40">Chapter 40</a>), and then execs the login shell.</p>
</div>
<div class="image"><img src="../images/f64-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch64fig3"/><strong>Figure 64-3:</strong> How <em>ssh</em> uses a pseudoterminal</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1379"/>In some cases, multiple processes may be connected to the slave side of the pseudoterminal. Our <em>ssh</em> example illustrates this point. The session leader for the slave is a shell, which creates process groups to execute the commands entered by the remote user. All of these processes have the pseudoterminal slave as their controlling terminal. As with a conventional terminal, one of these process groups can be the foreground process group for the pseudoterminal slave, and only this process group is allowed to read from the slave and (if the <span class="literal">TOSTOP</span> bit has been set) write to it.</p>
<h5 class="h5" id="ch64lev3sec03"><strong>Applications of pseudoterminals</strong></h5>
<p class="noindentab">Pseudoterminals are also used in many applications other than network services. Examples include the following:</p>
<p class="bull">&#8226; The <em>expect(1)</em> program uses a pseudoterminal to allow an interactive terminal-oriented program to be driven from a script file.</p>
<p class="bull">&#8226; Terminal emulators such as <em>xterm</em> employ pseudoterminals to provide the terminal-related functionality that goes with a terminal window.</p>
<p class="bull">&#8226; The <em>screen(1)</em> program uses pseudoterminals to multiplex a single physical terminal (or terminal window) between multiple processes (e.g., multiple shell sessions).</p>
<p class="bull">&#8226; Pseudoterminals are used in the <em>script(1)</em> program, which records all of the input and output that occurs during a shell session.</p>
<p class="bull">&#8226; Sometimes a pseudoterminal is useful to circumvent the default block buffering performed by the <em>stdio</em> functions when writing output to a disk file or pipe, as opposed to the line buffering used for terminal output. (We consider this point further in <a href="ch64.xhtml#ch64exe7">Exercise 64-7</a>.)</p>
<h5 class="h5" id="ch64lev3sec04"><strong>System V (UNIX 98) and BSD pseudoterminals</strong></h5>
<p class="noindenta">BSD and System V provided different interfaces for finding and opening the two halves of a pseudoterminal pair. The BSD pseudoterminal implementation was historically the better known, since it was used with many sockets-based network applications. For compatibility reasons, many UNIX implementations eventually came to support both styles of pseudoterminals.</p>
<p class="indent">The System V interface is somewhat simpler to use than the BSD interface, and the SUSv3 specification of pseudoterminals is based on the System V interface. (A pseudoterminal specification first appeared in SUSv1.) For historical reasons, on Linux systems, this type of pseudoterminal is commonly referred to as a <em>UNIX 98</em> pseudoterminal, even though the UNIX 98 standard (i.e., SUSv2) required pseudoterminals to be STREAMS-based, and the Linux implementation of pseudoterminals is not. (SUSv3 doesn&#8217;t require a STREAMS-based implementation.)</p>
<p class="indent">Early versions of Linux supported only BSD-style pseudoterminals, but, since kernel 2.2, Linux has supported both types of pseudoterminals. In this chapter, we focus on UNIX 98 pseudoterminals. We describe the differences for BSD pseudoterminals in <a href="ch64.xhtml#ch64lev1sec08">Section 64.8</a>.</p>
<h3 class="h3" id="ch64lev1sec02"><span epub:type="pagebreak" id="page_1380"/><strong>64.2 UNIX 98 Pseudoterminals</strong></h3>
<p class="noindentab">Bit by bit, we&#8217;ll work toward the development of a function, <em>ptyFork()</em>, that does most of the work to create the setup shown in <a href="ch64.xhtml#ch64fig2">Figure 64-2</a>. We&#8217;ll then use this function to implement the <em>script(1)</em> program. Before doing this though, we look at the various library functions used with UNIX 98 pseudoterminals:</p>
<p class="bull">&#8226; The <em>posix_openpt()</em> function opens an unused pseudoterminal master device, returning a file descriptor that is used to refer to the device in later calls.</p>
<p class="bull">&#8226; The <em>grantpt()</em> function changes the ownership and permissions of the slave device corresponding to a pseudoterminal master device.</p>
<p class="bull">&#8226; The <em>unlockpt()</em> function unlocks the slave device corresponding to a pseudoterminal master device, so that the slave device can be opened.</p>
<p class="bull">&#8226; The <em>ptsname()</em> function returns the name of the slave device corresponding to a pseudoterminal master device. The slave device can then be opened using <em>open()</em>.</p>
<h4 class="h4" id="ch64lev2sec01"><strong>64.2.1 Opening an Unused Master: <em>posix_openpt()</em></strong></h4>
<p class="noindenta">The <em>posix_openpt()</em> function finds and opens an unused pseudoterminal master device, and returns a file descriptor that can later be used to refer to this device.</p>
<div class="box">
<p class="programsa">#define _XOPEN_SOURCE 600<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;fcntl.h&gt;<br/><br/>int <span class="codestrong">posix_openpt</span>(int <span class="font1">flags</span>);</p>
<p class="right">Returns file descriptor on success, or &#8211;1 on error</p>
</div>
<p class="noindentb">The <em>flags</em> argument is constructed by ORing zero or more of the following constants together:</p>
<p class="term"><span class="literal">O_RDWR</span></p>
<p class="termlist">Open the device for both reading and writing. Normally, we would always include this constant in <em>flags</em>.</p>
<p class="term"><span class="literal">O_NOCTTY</span></p>
<p class="termlist">Don&#8217;t make this terminal the controlling terminal for the process. On Linux, a pseudoterminal master can&#8217;t become a controlling terminal for a process, regardless of whether the <span class="literal">O_NOCTTY</span> flag is specified when calling <em>posix_openpt()</em>. (This makes sense because the pseudoterminal master isn&#8217;t really a terminal; it is the other side of a terminal to which the slave is connected.) However, on some implementations, <span class="literal">O_NOCTTY</span> is required if we want to prevent a process from acquiring a controlling terminal as a consequence of opening a pseudoterminal master device.</p>
<p class="noindentt">Like <em>open()</em>, <em>posix_openpt()</em> uses the lowest available file descriptor to open the pseudoterminal master.</p>
<p class="indent">Calling <em>posix_openpt()</em> also results in the creation of a corresponding pseudoterminal slave device file in the <span class="literal">/dev/pts</span> directory. We say more about this file when we describe the <em>ptsname()</em> function below.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1381"/>The <em>posix_openpt()</em> function is new in SUSv3, and was an invention of the POSIX committee. In the original System V pseudoterminal implementation, obtaining an available pseudoterminal master was accomplished by opening the <em>pseudoterminal master clone device</em>, <span class="literal">/dev/ptmx</span>. Opening this virtual device automatically locates and opens the next unused pseudoterminal master, and returns a file descriptor for it. This device is provided on Linux, where <em>posix_openpt()</em> is implemented as follows:</p>
<p class="programs">int<br/>posix_openpt(int flags)<br/>{<br/>&#160;&#160;&#160;&#160;return open("/dev/ptmx", flags);<br/>}</p>
<h5 class="h5" id="ch64lev3sec05"><strong>Limits on the number of UNIX 98 pseudoterminals</strong></h5>
<p class="noindenta">Because each pseudoterminal pair in use consumes a small amount of nonswappable kernel memory, the kernel imposes a limit on the number of UNIX 98 pseudoterminal pairs on the system. In kernels up to 2.6.3, this limit is controlled by a kernel configuration option (<span class="literal">CONFIG_UNIX98_PTYS</span>). The default value for this option is 256, but we can change the limit to any value in the range 0 to 2048.</p>
<p class="indent">From Linux 2.6.4 onward, the <span class="literal">CONFIG_UNIX98_PTYS</span> kernel configuration option is discarded in favor of a more flexible approach. Instead, the limit on the number of pseudoterminals is defined by the value in the Linux-specific <span class="literal">/proc/sys/kernel/pty/max</span> file. The default value for this file is 4096, and it can be set to any value up to 1,048,576. A related read-only file, <span class="literal">/proc/sys/kernel/pty/nr</span>, shows how many UNIX 98 pseudoterminals are currently in use.</p>
<h4 class="h4" id="ch64lev2sec02"><strong>64.2.2 Changing Slave Ownership and Permissions: <em>grantpt()</em></strong></h4>
<p class="noindenta">SUSv3 specifies the use of <em>grantpt()</em> to change the ownership and permissions of the slave device that corresponds to the pseudoterminal master referred to by the file descriptor <em>mfd</em>. On Linux, calling <em>grantpt()</em> is not actually necessary. However, the use of <em>grantpt()</em> is required on some implementations, and portable applications should call it after calling <em>posix_openpt()</em>.</p>
<div class="box">
<p class="programsa">#define _XOPEN_SOURCE<br/>#include &lt;stdlib.h&gt;<br/><br/>int <span class="codestrong">grantpt</span>(int <span class="font1">mfd</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb">On systems where <em>grantpt()</em> is required, this function creates a child process that executes a set-user-ID-<em>root</em> program. This program, usually called <em>pt_chown</em>, performs the following operations on the pseudoterminal slave device:</p>
<p class="bull">&#8226; change the ownership of the slave to be the same as the real user ID of the calling process;</p>
<p class="bull">&#8226; change the group of the slave to <em>tty</em>; and</p>
<p class="bull"><span epub:type="pagebreak" id="page_1382"/>&#8226; change the permissions on the slave so that the owner has read and write permissions, and group has write permission.</p>
<p class="noindentt">The reason for changing the group of the terminal to <em>tty</em> and enabling group write permission is that the <em>wall(1)</em> and <em>write(1)</em> programs are set-group-ID programs owned by the <em>tty</em> group.</p>
<p class="indent">On Linux, a pseudoterminal slave is automatically configured in the above manner, which is why calling <em>grantpt()</em> isn&#8217;t needed (but still should be done).</p>
<div class="block">
<p class="noindent">Because it may create a child process, SUSv3 says that the behavior of <em>grantpt()</em> is unspecified if the calling program has installed a handler for <span class="literal">SIGCHLD</span>.</p>
</div>
<h4 class="h4" id="ch64lev2sec03"><strong>64.2.3 Unlocking the Slave: <em>unlockpt()</em></strong></h4>
<p class="noindenta">The <em>unlockpt()</em> function removes an internal lock on the slave corresponding to the pseudoterminal master referred to by the file descriptor <em>mfd</em>. The purpose of this locking mechanism is to allow the calling process to perform whatever initialization is required for the pseudoterminal slave (e.g., calling <em>grantpt()</em>) before another process is allowed to open it.</p>
<div class="box">
<p class="programsa">#define _XOPEN_SOURCE<br/>#include &lt;stdlib.h&gt;<br/><br/>int <span class="codestrong">unlockpt</span>(int <span class="font1">mfd</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">An attempt to open a pseudoterminal slave before it has been unlocked with <em>unlockpt()</em> fails with the error <span class="literal">EIO</span>.</p>
<h4 class="h4" id="ch64lev2sec04"><strong>64.2.4 Obtaining the Name of the Slave: <em>ptsname()</em></strong></h4>
<p class="noindenta">The <em>ptsname()</em> function returns the name of the pseudoterminal slave corresponding to the pseudoterminal master referred to by the file descriptor <em>mfd</em>.</p>
<div class="box">
<p class="programsa">#define _XOPEN_SOURCE<br/>#include &lt;stdlib.h&gt;<br/><br/>char *<span class="codestrong">ptsname</span>(int <span class="font1">mfd</span>);</p>
<p class="right">Returns pointer to (possibly statically allocated) string on success, or <span class="literal">NULL</span> on error</p>
</div>
<p class="noindent">On Linux (as on most implementations), <em>ptsname()</em> returns a name of the form <span class="literal">/dev/pts/</span><em>nn</em>, where <em>nn</em> is replaced by a number that uniquely identifies this pseudoterminal slave.</p>
<p class="indent">The buffer used to return the slave name is normally statically allocated. It is thus overwritten by subsequent calls to <em>ptsname()</em>.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_1383"/>The GNU C library provides a reentrant analog of <em>ptsname()</em> in the form of <em>ptsname_r(mfd, strbuf, buflen)</em>. However, this function is nonstandard and is available on few other UNIX implementations. The <span class="literal">_GNU_SOURCE</span> feature test macro must be defined in order to obtain the declaration of <em>ptsname_r()</em> from <span class="literal">&lt;stdlib.h&gt;</span>.</p>
</div>
<p class="noindent">Once we have unlocked the slave device with <em>unlockpt()</em>, we can open it using the traditional <em>open()</em> system call.</p>
<div class="block">
<p class="noindent">On System V derivatives that employ STREAMS, it may be necessary to perform some further steps (pushing STREAMS modules onto the slave device after opening it). An example of how to perform these steps can be found in [<a href="bib.xhtml#bib94">Stevens &#38; Rago, 2005</a>].</p>
</div>
<h3 class="h3" id="ch64lev1sec03"><strong>64.3 Opening a Master: <em>ptyMasterOpen()</em></strong></h3>
<p class="noindentab">We now present a function, <em>ptyMasterOpen()</em>, that employs the functions described in the previous sections to open a pseudoterminal master and obtain the name of the corresponding pseudoterminal slave. Our reasons for providing such a function are twofold:</p>
<p class="bull">&#8226; Most programs perform these steps in exactly the same way, so it is convenient to encapsulate them in a single function.</p>
<p class="bull">&#8226; Our <em>ptyMasterOpen()</em> function hides all of the details that are specific to UNIX 98 pseudoterminals. In <a href="ch64.xhtml#ch64lev1sec08">Section 64.8</a>, we present a reimplementation of this function that uses BSD-style pseudoterminals. All of the code that we present in the remainder of this chapter can work with either of these implementations.</p>
<div class="box">
<p class="programsa">#include "pty_master_open.h"<br/><br/>int <span class="codestrong">ptyMasterOpen</span>(char *<span class="font1">slaveName</span>, size_t <span class="font1">snLen</span>);</p>
<p class="right">Returns file descriptor on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>ptyMasterOpen()</em> function opens an unused pseudoterminal master, calls <em>grantpt()</em> and <em>unlockpt()</em> on it, and copies the name of the corresponding pseudoterminal slave into the buffer pointed to by <em>slaveName</em>. The caller must specify the amount of space available in this buffer in the argument <em>snLen</em>. We show the implementation of this function in <a href="ch64.xhtml#ch64ex1">Listing 64-1</a>.</p>
<div class="block">
<p class="noindent">It would be equally possible to omit the use of the <em>slaveName</em> and <em>snLen</em> arguments, and have the caller of <em>ptyMasterOpen()</em> call <em>ptsname()</em> directly in order to obtain the name of the pseudoterminal slave. However, we employ the <em>slaveName</em> and <em>snLen</em> arguments because BSD pseudoterminals don&#8217;t provide an equivalent of the <em>ptsname()</em> function, and our implementation of the equivalent function for BSD-style pseudoterminals (<a href="ch64.xhtml#ch64ex4">Listing 64-4</a>) encapsulates the BSD technique for obtaining the name of the slave.</p>
</div>
<p class="examplet"><span epub:type="pagebreak" id="page_1384"/><a id="ch64ex1"/><strong>Listing 64-1:</strong> Implementation of <em>ptyMasterOpen()</em></p>
<p class="programsli">_____________________________________________________ <span class="codestrong">pty/pty_master_open.c</span><br/><br/>#define _XOPEN_SOURCE 600<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include "pty_master_open.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declares ptyMasterOpen() */<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>ptyMasterOpen(char *slaveName, size_t snLen)<br/>{<br/>&#160;&#160;&#160;&#160;int masterFd, savedErrno;<br/>&#160;&#160;&#160;&#160;char *p;<br/><br/>&#160;&#160;&#160;&#160;masterFd = posix_openpt(O_RDWR | O_NOCTTY); /* Open pty master */<br/>&#160;&#160;&#160;&#160;if (masterFd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/>&#160;&#160;&#160;&#160;if (grantpt(masterFd) == -1) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Grant access to slave pty */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;savedErrno = errno;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;close(masterFd);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Might change 'errno' */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errno = savedErrno;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (unlockpt(masterFd) == -1) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Unlock slave pty */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;savedErrno = errno;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;close(masterFd);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Might change 'errno' */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errno = savedErrno;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;p = ptsname(masterFd);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get slave pty name */<br/>&#160;&#160;&#160;&#160;if (p == NULL) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;savedErrno = errno;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;close(masterFd);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Might change 'errno' */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errno = savedErrno;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (strlen(p) &lt; snLen) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;strncpy(slaveName, p, snLen);<br/>&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Return an error if buffer too small */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;close(masterFd);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errno = EOVERFLOW;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;return masterFd;<br/>}<br/>_____________________________________________________ <span class="codestrong">pty/pty_master_open.c</span></p>
<h3 class="h3" id="ch64lev1sec04"><span epub:type="pagebreak" id="page_1385"/><strong>64.4 Connecting Processes with a Pseudoterminal: <em>ptyFork()</em></strong></h3>
<p class="noindenta">We are now ready to implement a function that does all of the work of setting up a connection between two processes using a pseudoterminal pair, as shown in <a href="ch64.xhtml#ch64fig2">Figure 64-2</a>. The <em>ptyFork()</em> function creates a child process that is connected to the parent by a pseudoterminal pair.</p>
<div class="box">
<p class="programsa">#include "pty_fork.h"<br/><br/>pid_t <span class="codestrong">ptyFork</span>(int *<span class="font1">masterFd</span>, char *<span class="font1">slaveName</span>, size_t <span class="font1">snLen</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const struct termios *<span class="font1">slaveTermios</span>, const struct winsize *<span class="font1">slaveWS</span>);</p>
<p class="right">In parent: returns process ID of child on success, or &#8211;1 on error; in successfully created child: always returns 0</p>
</div>
<p class="noindentb">The implementation of <em>ptyFork()</em> is shown in <a href="ch64.xhtml#ch64ex2">Listing 64-2</a>. This function performs the following steps:</p>
<p class="bull">&#8226; Open a pseudoterminal master using <em>ptyMasterOpen()</em> (<a href="ch64.xhtml#ch64ex1">Listing 64-1</a>) <span class="ent">&#x2460;</span>.</p>
<p class="bull">&#8226; If the <em>slaveName</em> argument is not <span class="literal">NULL</span>, copy the name of the pseudoterminal slave into this buffer <span class="ent">&#x2461;</span>. (If <em>slaveName</em> is not <span class="literal">NULL</span>, then it must point to a buffer of at least <em>snLen</em> bytes.) The caller can use this name to update the login accounting files (<a href="ch40.xhtml#ch40">Chapter 40</a>), if appropriate. Updating the login accounting files would be appropriate for applications that provide login services&#8212;for example, <em>ssh</em>, <em>rlogin</em>, and <em>telnet</em>. On the other hand, programs such as <em>script(1)</em> (<a href="ch64.xhtml#ch64lev1sec06">Section 64.6</a>) do not update the login accounting files, because they don&#8217;t provide login services.</p>
<p class="bull">&#8226; Call <em>fork()</em> to create a child process <span class="ent">&#x2462;</span>.</p>
<p class="bull">&#8226; All that the parent does after the <em>fork()</em> is to ensure that the file descriptor for the pseudoterminal master is returned to the caller in the integer pointed to by <em>masterFd</em> <span class="ent">&#x2463;</span>.</p>
<p class="bull">&#8226; After the <em>fork()</em>, the child performs the following steps:</p>
<p class="dash1">&#8211; Call <em>setsid()</em>, to create a new session (<a href="ch34.xhtml#ch34lev1sec03">Section 34.3</a>) <span class="ent">&#x2464;</span>. The child is the leader of the new session and loses its controlling terminal (if it had one).</p>
<p class="dash1">&#8211; Close the file descriptor for the pseudoterminal master, since it is not required in the child <span class="ent">&#x2465;</span>.</p>
<p class="dash1">&#8211; Open the pseudoterminal slave <span class="ent">&#x2466;</span>. Since the child lost its controlling terminal in the previous step, this step causes the pseudoterminal slave to become the controlling terminal for the child.</p>
<p class="dash1">&#8211; If the <span class="literal">TIOCSCTTY</span> macro is defined, perform a <span class="literal">TIOCSCTTY</span> <em>ioctl()</em> operation on the file descriptor for the pseudoterminal slave <span class="ent">&#x2467;</span>. This code allows our <em>ptyFork()</em> function to work on BSD platforms, where a controlling terminal can be acquired only as a consequence of an explicit <span class="literal">TIOCSCTTY</span> operation (refer to <a href="ch34.xhtml#ch34lev1sec04">Section 34.4</a>).</p>
<p class="dash1">&#8211; If the <em>slaveTermios</em> argument is non-<span class="literal">NULL</span>, call <em>tcsetattr()</em> to set the terminal attributes of the slave to the values in the <em>termios</em> structure pointed to by <span epub:type="pagebreak" id="page_1386"/>this argument <span class="ent">&#x2468;</span>. Use of this argument is a convenience for certain interactive programs (e.g., <em>script(1)</em>) that use a pseudoterminal and need to set the attributes of the slave device to be the same as those of the terminal under which the program is run.</p>
<p class="dash1">&#8211; If the <em>slaveWS</em> argument is non-<span class="literal">NULL</span>, perform an <em>ioctl()</em> <span class="literal">TIOCSWINSZ</span> operation to set the window size of the pseudoterminal slave to the values in the <em>winsize</em> structure pointed to by this argument <span class="ent">&#x2469;</span>. This step is performed for the same reason as the previous step.</p>
<p class="dash1">&#8211; Use <em>dup2()</em> to duplicate the slave file descriptor to be the standard input, output, and error for the child <span class="ent">&#x246A;</span>. At this point, the child can now exec an arbitrary program, and that program can use the standard file descriptors to communicate with the pseudoterminal. The execed program can perform all of the usual terminal-oriented operations that can be performed by a program running on a conventional terminal.</p>
<p class="noindentt">As with <em>fork()</em>, <em>ptyFork()</em> returns the process ID of the child in the parent process, 0 in the child process, or &#8211;1 on error.</p>
<p class="indent">Eventually, the child process created by <em>ptyFork()</em> will terminate. If the parent doesn&#8217;t terminate at the same time, then it must wait on the child to eliminate the resulting zombie. However, this step can often be eliminated, since applications that employ pseudoterminals are commonly designed so that the parent does terminate at the same time as the child.</p>
<div class="block">
<p class="noindent">BSD derivatives provide two related, nonstandard functions for working with pseudoterminals. The first of these is <em>openpty()</em>, which opens a pseudoterminal pair, returns the file descriptors for the master and slave, optionally returns the name of the slave device, and optionally sets the terminal attributes and window size from arguments analogous to <em>slaveTermios</em> and <em>slaveWS</em>. The other function, <em>forkpty()</em>, is the same as our <em>ptyFork()</em>, except that it doesn&#8217;t provide an analog of the <em>snLen</em> argument. On Linux, both of these functions are provided by <em>glibc</em> and are documented in the <em>openpty(3)</em> manual page.</p>
</div>
<p class="examplet"><a id="ch64ex2"/><strong>Listing 64-2:</strong> Implementation of <em>ptyFork()</em></p>
<p class="programsli">___________________________________________________________ <span class="codestrong">pty/pty_fork.c</span><br/><br/>&#160;&#160;&#160;#include &lt;fcntl.h&gt;<br/>&#160;&#160;&#160;#include &lt;termios.h&gt;<br/>&#160;&#160;&#160;#include &lt;sys/ioctl.h&gt;<br/>&#160;&#160;&#160;#include "pty_master_open.h"<br/>&#160;&#160;&#160;#include "pty_fork.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declares ptyFork() */<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;#define MAX_SNAME 1000<br/><br/>&#160;&#160;&#160;pid_t<br/>&#160;&#160;&#160;ptyFork(int *masterFd, char *slaveName, size_t snLen,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const struct termios *slaveTermios, const struct winsize *slaveWS)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int mfd, slaveFd, savedErrno;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;pid_t childPid;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char slname[MAX_SNAME];<br/><br/><span epub:type="pagebreak" id="page_1387"/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;mfd = ptyMasterOpen(slname, MAX_SNAME);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (mfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;if (slaveName != NULL) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Return slave name to caller */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (strlen(slname) &lt; snLen) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;strncpy(slaveName, slname, snLen);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* 'slaveName' was too small */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;close(mfd);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errno = EOVERFLOW;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;childPid = fork();<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (childPid == -1) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* fork() failed */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;savedErrno = errno;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* close() might change 'errno' */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;close(mfd);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Don't leak file descriptors */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errno = savedErrno;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;if (childPid != 0) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*masterFd = mfd;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Only parent gets master fd */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return childPid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Like parent of fork() */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child falls through to here */<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;if (setsid() == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Start a new session */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;err_exit("ptyFork:setsid");<br/><br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;close(mfd);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Not needed in child */<br/><br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;slaveFd = open(slname, O_RDWR);&#160;&#160;&#160;&#160;&#160;/* Becomes controlling tty */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (slaveFd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;err_exit("ptyFork:open-slave");<br/><br/><span class="ent">&#x2467;</span> #ifdef TIOCSCTTY&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Acquire controlling tty on BSD */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (ioctl(slaveFd, TIOCSCTTY, 0) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;err_exit("ptyFork:ioctl-TIOCSCTTY");<br/>&#160;&#160;&#160;#endif<br/><br/><span class="ent">&#x2468;</span>&#160;&#160;&#160;&#160;&#160;if (slaveTermios != NULL)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Set slave tty attributes */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (tcsetattr(slaveFd, TCSANOW, slaveTermios) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;err_exit("ptyFork:tcsetattr");<br/><br/><span class="ent">&#x2469;</span>&#160;&#160;&#160;&#160;&#160;if (slaveWS != NULL)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Set slave tty window size */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (ioctl(slaveFd, TIOCSWINSZ, slaveWS) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;err_exit("ptyFork:ioctl-TIOCSWINSZ");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Duplicate pty slave to be child's stdin, stdout, and stderr */<br/><br/><span class="ent">&#x246A;</span>&#160;&#160;&#160;&#160;&#160;if (dup2(slaveFd, STDIN_FILENO) != STDIN_FILENO)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;err_exit("ptyFork:dup2-STDIN_FILENO");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (dup2(slaveFd, STDOUT_FILENO) != STDOUT_FILENO)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;err_exit("ptyFork:dup2-STDOUT_FILENO");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (dup2(slaveFd, STDERR_FILENO) != STDERR_FILENO)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;err_exit("ptyFork:dup2-STDERR_FILENO");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (slaveFd &gt; STDERR_FILENO)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Safety check */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;close(slaveFd);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* No longer need this fd */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;return 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Like child of fork() */<br/>&#160;&#160;&#160;}<br/>___________________________________________________________ <span class="codestrong">pty/pty_fork.c</span></p>
<h3 class="h3" id="ch64lev1sec05"><span epub:type="pagebreak" id="page_1388"/><strong>64.5 Pseudoterminal I/O</strong></h3>
<p class="noindenta">A pseudoterminal pair is similar to a bidirectional pipe. Anything that is written on the master appears as input on the slave, and anything that is written on the slave appears as input on the master.</p>
<p class="indent">The point that distinguishes a pseudoterminal pair from a bidirectional pipe is that the slave side operates like a terminal device. The slave interprets input in the same way as a normal controlling terminal would interpret keyboard input. For example, if we write a <em>Control-C</em> character (the usual terminal <em>interrupt</em> character) to the pseudoterminal master, the slave will generate a <span class="literal">SIGINT</span> signal for its foreground process group. Just as with a conventional terminal, when a pseudoterminal slave operates in canonical mode (the default), input is buffered line by line. In other words, the program reading from the pseudoterminal slave will see (a line of) input only when we write a newline character to the pseudoterminal master.</p>
<p class="indent">Like pipes, pseudoterminals have a limited capacity. If we exhaust this capacity, then further writes are blocked until the process on the other side of the pseudoterminal has consumed some bytes.</p>
<div class="block">
<p class="noindent">On Linux, the pseudoterminal capacity is about 4 kB in each direction.</p>
</div>
<p class="noindentb">If we close all file descriptors referring to the pseudoterminal master, then:</p>
<p class="bull">&#8226; If the slave device has a controlling process, a <span class="literal">SIGHUP</span> signal is sent to that process (see <a href="ch34.xhtml#ch34lev1sec06">Section 34.6</a>).</p>
<p class="bull">&#8226; A <em>read()</em> from the slave device returns end-of-file (0).</p>
<p class="bull">&#8226; A <em>write()</em> to the slave device fails with the error <span class="literal">EIO</span>. (On some other UNIX implementations, <em>write()</em> fails with the error <span class="literal">ENXIO</span> in this case.)</p>
<p class="noindenttb">If we close all file descriptors referring to the pseudoterminal slave, then:</p>
<p class="bull">&#8226; A <em>read()</em> from the master device fails with the error <span class="literal">EIO</span>. (On some other UNIX implementations, a <em>read()</em> returns end-of-file in this case.)</p>
<p class="bull"><span epub:type="pagebreak" id="page_1389"/>&#8226; A <em>write()</em> to the master device succeeds, unless the input queue of the slave device is full, in which case the <em>write()</em> blocks. If the slave device is subsequently reopened, these bytes can be read.</p>
<p class="noindentt">UNIX implementations vary widely in their behavior for the last case. On some UNIX implementations, <em>write()</em> fails with the error <span class="literal">EIO</span>. On other implementations, <em>write()</em> succeeds, but the output bytes are discarded (i.e., they can&#8217;t be read if the slave is reopened). In general, these variations don&#8217;t present a problem. Normally, the process on the master side detects that the slave has been closed because a <em>read()</em> from the master returns end-of-file or fails. At this point, the process performs no further writes to the master.</p>
<h5 class="h5" id="ch64lev3sec06"><strong>Packet mode</strong></h5>
<p class="noindentab"><em>Packet mode</em> is a mechanism that allows the process running above a pseudoterminal master to be informed when the following events related to software flow control occur on the pseudoterminal slave:</p>
<p class="bull">&#8226; the input or output queue is flushed;</p>
<p class="bull">&#8226; terminal output is stopped or started (<em>Control-S/Control-Q</em>); or</p>
<p class="bull">&#8226; flow control was enabled or disabled.</p>
<p class="noindentt">Packet mode helps with handling software flow control in certain pseudoterminal applications that provide network login services (e.g., <em>telnet</em> and <em>rlogin</em>).</p>
<p class="indent">Packet mode is enabled by applying the <em>ioctl()</em> <span class="literal">TIOCPKT</span> operation to the file descriptor referring to the pseudoterminal master:</p>
<p class="programs">int arg;<br/><br/>arg = 1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* 1 == enable; 0 == disable */<br/>if (ioctl(mfd, TIOCPKT, &#38;arg) == -1)<br/>&#160;&#160;&#160;&#160;errExit("ioctl");</p>
<p class="noindent">When packet mode is in operation, reads from the pseudoterminal master return either a single nonzero control byte, which is a bit mask indicating the state change(s) that occurred on the slave device, or a 0 byte followed by one or more bytes of data that were written on the pseudoterminal slave.</p>
<p class="indent">When a state change occurs on a pseudoterminal that is operating in packet mode, <em>select()</em> indicates that an exceptional condition (the <em>exceptfds</em> argument) has occurred on the master, and <em>poll()</em> returns <span class="literal">POLLPRI</span> in the <em>revents</em> field. (Refer to <a href="ch63.xhtml#ch63">Chapter 63</a> for descriptions of <em>select()</em> and <em>poll()</em>.)</p>
<p class="indent">Packet mode is not standardized in SUSv3, and some details vary on other UNIX implementations. Further details of packet mode on Linux, including the bit-mask values used to indicate state changes, can be found in the <em>tty_ioctl(4)</em> manual page.</p>
<h3 class="h3" id="ch64lev1sec06"><span epub:type="pagebreak" id="page_1390"/><strong>64.6 Implementing <em>script(1)</em></strong></h3>
<p class="noindenta">We are now ready to implement a simple version of the standard <em>script(1)</em> program. This program starts a new shell session, and records all input and output from the session to a file. Most of the shell sessions shown in this book were recorded using <em>script</em>.</p>
<p class="indent">In a normal login session, the shell is connected directly to the user&#8217;s terminal. When we run <em>script</em>, it places itself between the user&#8217;s terminal and the shell, and uses a pseudoterminal pair to create a communication channel between itself and the shell (see <a href="ch64.xhtml#ch64fig4">Figure 64-4</a>). The shell is connected to the pseudoterminal slave. The <em>script</em> process is connected to the pseudoterminal master. The <em>script</em> process acts as a proxy for the user, taking input entered at the terminal and writing it to the pseudoterminal master, and reading output from the pseudoterminal master and writing it to the user&#8217;s terminal.</p>
<p class="indent">In addition, <em>script</em> produces an output file (named <span class="literal">typescript</span> by default) that contains a copy of all bytes that are output on the pseudoterminal master. This has the effect of recording not only the output produced by the shell session, but also the input that is supplied to it. The input is recorded because, just as with a conventional terminal device, the kernel echoes input characters by copying them to the terminal output queue (see <a href="ch62.xhtml#ch62fig1">Figure 62-1</a>, on <a href="ch62.xhtml#page_1291">page 1291</a>). However, when terminal echoing is disabled, as is done by programs that read passwords, the pseudoterminal slave input is not copied to the slave output queue, and thus is not copied to the script output file.</p>
<div class="image"><img src="../images/f64-04.jpg" alt="image"/></div>
<p class="figcap"><a id="ch64fig4"/><strong>Figure 64-4:</strong> The <em>script</em> program</p>
<p class="noindentb"><span epub:type="pagebreak" id="page_1391"/>Our implementation of <em>script</em> is shown in <a href="ch64.xhtml#ch64ex3">Listing 64-3</a>. This program performs the following steps:</p>
<p class="bull">&#8226; Retrieve the attributes and window size of the terminal under which the program is run <span class="ent">&#x2460;</span>. These are passed to the subsequent call to <em>ptyFork()</em>, which uses them to set the corresponding values for the pseudoterminal slave device.</p>
<p class="bull">&#8226; Call our <em>ptyFork()</em> function (<a href="ch64.xhtml#ch64ex2">Listing 64-2</a>) to create a child process that is connected to the parent via a pseudoterminal pair <span class="ent">&#x2461;</span>.</p>
<p class="bull">&#8226; After the <em>ptyFork()</em> call, the child execs a shell <span class="ent">&#x2463;</span>. The choice of shell is determined by the setting of the <span class="literal">SHELL</span> environment variable <span class="ent">&#x2462;</span>. If the <span class="literal">SHELL</span> variable is not set or its value is an empty string, then the child execs <span class="literal">/bin/sh</span>.</p>
<p class="bull">&#8226; After the <em>ptyFork()</em> call, the parent performs the following steps:</p>
<p class="dash1">&#8211; Open the output script file <span class="ent">&#x2464;</span>. If a command-line argument is supplied, this is used as the name of the script file. If no command-line argument is supplied, the default name <span class="literal">typescript</span> is used.</p>
<p class="dash1">&#8211; Place the terminal in raw mode (using the <em>ttySetRaw()</em> function shown in <a href="ch62.xhtml#ch62ex3">Listing 62-3</a>, on <a href="ch62.xhtml#page_1310">page 1310</a>), so that all input characters are passed directly to the <em>script</em> program without being modified by the terminal driver <span class="ent">&#x2465;</span>. Characters output by the <em>script</em> program are likewise not modified by the terminal driver.</p>
<div class="block1b">
<p class="noindent">The fact that the terminal is in raw mode doesn&#8217;t mean that raw, uninterpreted control characters will be transmitted to the shell, or whatever other process group is in the foreground for the pseudoterminal slave device, nor that output from that process group is passed raw to the user&#8217;s terminal. Instead, interpretation of terminal special characters is taking place within the slave device (unless the slave was also explicitly placed in raw mode by an application). By placing the user&#8217;s terminal in raw mode, we prevent a <em>second</em> round of interpretation of input and output characters from occurring.</p>
</div>
<p class="dash1">&#8211; Call <em>atexit()</em> to install an exit handler that resets the terminal to its original mode when the program terminates <span class="ent">&#x2466;</span>.</p>
<p class="dash1">&#8211; Execute a loop that transfers data in both directions between the terminal and the pseudoterminal master <span class="ent">&#x2467;</span>. In each loop iteration, the program first uses <em>select()</em> (<a href="ch63.xhtml#ch63lev2sec03">Section 63.2.1</a>) to monitor both the terminal and the pseudoterminal master for input <span class="ent">&#x2468;</span>. If the terminal has input available, then the program reads some of that input and writes it to the pseudoterminal master <span class="ent">&#x2469;</span>. Similarly, if the pseudoterminal master has input available, the program reads some of that input and writes it to the terminal and to the script file <span class="ent">&#x246A;</span>. The loop executes until end-of-file or an error is detected on one of the monitored file descriptors.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1392"/><a id="ch64ex3"/><strong>Listing 64-3:</strong> A simple implementation of <em>script(1)</em></p>
<p class="programsli">____________________________________________________________ <span class="codestrong">pty/script.c</span><br/><br/>&#160;&#160;&#160;#include &lt;sys/stat.h&gt;<br/>&#160;&#160;&#160;#include &lt;fcntl.h&gt;<br/>&#160;&#160;&#160;#include &lt;libgen.h&gt;<br/>&#160;&#160;&#160;#include &lt;termios.h&gt;<br/>&#160;&#160;&#160;#include &lt;sys/select.h&gt;<br/>&#160;&#160;&#160;#include "pty_fork.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declaration of ptyFork() */<br/>&#160;&#160;&#160;#include "tty_functions.h"&#160;&#160;&#160;&#160;&#160;&#160;/* Declaration of ttySetRaw() */<br/>&#160;&#160;&#160;#include "tlpi_hdr.h"<br/><br/>&#160;&#160;&#160;#define BUF_SIZE 256<br/>&#160;&#160;&#160;#define MAX_SNAME 1000<br/><br/>&#160;&#160;&#160;struct termios ttyOrig;<br/><br/>&#160;&#160;&#160;static void&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Reset terminal mode on program exit */<br/>&#160;&#160;&#160;ttyReset(void)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (tcsetattr(STDIN_FILENO, TCSANOW, &#38;ttyOrig) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("tcsetattr");<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char slaveName[MAX_SNAME];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char *shell;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int masterFd, scriptFd;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct winsize ws;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;fd_set inFds;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char buf[BUF_SIZE];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;ssize_t numRead;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;pid_t childPid;<br/><br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;if (tcgetattr(STDIN_FILENO, &#38;ttyOrig) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("tcgetattr");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (ioctl(STDIN_FILENO, TIOCGWINSZ, &#38;ws) &lt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("ioctl-TIOCGWINSZ");<br/><br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;childPid = ptyFork(&#38;masterFd, slaveName, MAX_SNAME, &#38;ttyOrig, &#38;ws);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (childPid == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("ptyFork");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (childPid == 0) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child: execute a shell on pty slave */<br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shell = getenv("SHELL");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (shell == NULL || *shell == '\0')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shell = "/bin/sh";<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;execlp(shell, shell, (char *) NULL);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("execlp");&#160;&#160;&#160;&#160;&#160;&#160;/* If we get here, something went wrong */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent: relay data between terminal and pty master */<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;scriptFd = open((argc &gt; 1) ? argv[1] : "typescript",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;O_WRONLY | O_CREAT | O_TRUNC,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP |<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S_IROTH | S_IWOTH);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (scriptFd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open typescript");<br/><br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;ttySetRaw(STDIN_FILENO, &#38;ttyOrig);<br/><br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;if (atexit(ttyReset) != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("atexit");<br/><br/><span class="ent">&#x2467;</span>&#160;&#160;&#160;&#160;&#160;for (;;) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;FD_ZERO(&#38;inFds);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;FD_SET(STDIN_FILENO, &#38;inFds);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;FD_SET(masterFd, &#38;inFds);<br/><br/><span class="ent">&#x2468;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (select(masterFd + 1, &#38;inFds, NULL, NULL, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("select");<br/><br/><span class="ent">&#x2469;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (FD_ISSET(STDIN_FILENO, &#38;inFds)) {&#160;&#160;&#160;/* stdin --&gt; pty */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numRead = read(STDIN_FILENO, buf, BUF_SIZE);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead &lt;= 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (write(masterFd, buf, numRead) != numRead)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("partial/failed write (masterFd)");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/><span class="ent">&#x246A;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (FD_ISSET(masterFd, &#38;inFds)) {&#160;&#160;&#160;&#160;&#160;&#160;/* pty --&gt; stdout+file */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numRead = read(masterFd, buf, BUF_SIZE);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead &lt;= 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (write(STDOUT_FILENO, buf, numRead) != numRead)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("partial/failed write (STDOUT_FILENO)");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (write(scriptFd, buf, numRead) != numRead)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("partial/failed write (scriptFd)");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/>____________________________________________________________ <span class="codestrong">pty/script.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_1393"/>In the following shell session, we demonstrate the use of the program in <a href="ch64.xhtml#ch64ex3">Listing 64-3</a>. We begin by displaying the name of the pseudoterminal used by the <em>xterm</em> on which the login shell is running and the process ID of the login shell. This information is useful later in the shell session.</p>
<p class="programs">$ <span class="codestrong">tty</span><br/>/dev/pts/1<br/>$ <span class="codestrong">echo $$</span><br/>7979</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1394"/>We then start an instance of our <em>script</em> program, which invokes a subshell. Once more, we display the name of the terminal on which the shell is running and the process ID of the shell:</p>
<p class="programs">$ <span class="codestrong">./script</span><br/>$ <span class="codestrong">tty</span><br/>/dev/pts/24&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Pseudoterminal slave opened by script</span><br/>$ <span class="codestrong">echo $$</span><br/>29825&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">PID of subshell process started by script</span></p>
<p class="noindent">Now we use <em>ps(1)</em> to display information about the two shells and the process running <em>script</em>, and then terminate the shell started by <em>script</em>:</p>
<p class="programs">$ <span class="codestrong">ps -p 7979 -p 29825 -C script -o "pid ppid sid tty cmd"</span><br/>&#160;&#160;PID&#160;&#160;PPID&#160;&#160;&#160;SID TT&#160;&#160;&#160;&#160;&#160;&#160;&#160;CMD<br/>&#160;7979&#160;&#160;7972&#160;&#160;7979 pts/1&#160;&#160;&#160;&#160;/bin/bash<br/>29824&#160;&#160;7979&#160;&#160;7979 pts/1&#160;&#160;&#160;&#160;./script<br/>29825 29824 29825 pts/24&#160;&#160;&#160;/bin/bash<br/>$ <span class="codestrong">exit</span></p>
<p class="noindent">The output of <em>ps(1)</em> shows the parent-child relationships between the login shell, the process running <em>script</em>, and the subshell started by <em>script</em>.</p>
<p class="indent">At this point, we have returned to the login shell. Displaying the contents of the file <span class="literal">typescript</span> shows a record of all input and output that was produced while <em>script</em> was running:</p>
<p class="programs">$ <span class="codestrong">cat typescript</span><br/>$ tty<br/>/dev/pts/24<br/>$ echo $$<br/>29825<br/>$ ps -p 7979 -p 29825 -C script -o "pid ppid sid tty cmd"<br/>&#160;&#160;PID&#160;&#160;PPID&#160;&#160;&#160;SID TT&#160;&#160;&#160;&#160;&#160;&#160;&#160;CMD<br/>&#160;7979&#160;&#160;7972&#160;&#160;7979 pts/1&#160;&#160;&#160;&#160;/bin/bash<br/>29824&#160;&#160;7979&#160;&#160;7979 pts/1&#160;&#160;&#160;&#160;./script<br/>29825 29824 29825 pts/24&#160;&#160;&#160;/bin/bash<br/>$ exit</p>
<h3 class="h3" id="ch64lev1sec07"><strong>64.7 Terminal Attributes and Window Size</strong></h3>
<p class="noindenta">The master and slave device share terminal attributes (<em>termios</em>) and window size (<em>winsize</em>) structures. (Both of these structures are described in <a href="ch62.xhtml#ch62">Chapter 62</a>.) This means that the program running above the pseudoterminal master can change these attributes for the pseudoterminal slave by applying <em>tcsetattr()</em> and <em>ioctl()</em> to the file descriptor of the master device.</p>
<p class="indent">One example of where changing terminal attributes can be useful is in the <em>script</em> program. Suppose we are running <em>script</em> in a terminal emulator window, and we change the size of the window. In this case, the terminal emulator program will inform the kernel of the change in the size of the corresponding terminal device, but this change is not reflected in the separate kernel record for the pseudoterminal slave (see <a href="ch64.xhtml#ch64fig4">Figure 64-4</a>). As a consequence, screen-oriented programs (e.g., <em>vi</em>) running above the pseudoterminal slave will produce confusing output, since their <span epub:type="pagebreak" id="page_1395"/>understanding of the terminal window size differs from the actual size of the terminal. We can solve this problem as follows:</p>
<ol>
<li class="order"><p class="orderp">Install a handler for <span class="literal">SIGWINCH</span> in the <em>script</em> parent process, so that it is signaled when the size of the terminal window changes.</p></li>
<li class="order"><p class="orderp">When the <em>script</em> parent receives a <span class="literal">SIGWINCH</span> signal, it uses an <em>ioctl()</em> <span class="literal">TIOCGWINSZ</span> operation to retrieve a <em>winsize</em> structure for the terminal window associated with its standard input. It then uses this structure in an <em>ioctl()</em> <span class="literal">TIOCSWINSZ</span> operation that sets the window size of the pseudoterminal master.</p></li>
<li class="order"><p class="orderp">If the new pseudoterminal window size is different from the old size, then the kernel generates a <span class="literal">SIGWINCH</span> signal for the foreground process group of the pseudoterminal slave. Screen-handling programs such as <em>vi</em> are designed to catch this signal and perform an <em>ioctl()</em> <span class="literal">TIOCGWINSZ</span> operation to update their understanding of the terminal window size.</p></li>
</ol>
<p class="noindent">We described the details of terminal window sizes and the <em>ioctl()</em> <span class="literal">TIOCGWINSZ</span> and <span class="literal">TIOCSWINSZ</span> operations in <a href="ch62.xhtml#ch62lev1sec09">Section 62.9</a>.</p>
<h3 class="h3" id="ch64lev1sec08"><strong>64.8 BSD Pseudoterminals</strong></h3>
<p class="noindenta">For most of this chapter, we have focused on UNIX 98 pseudoterminals, since this is the style of pseudoterminal that is standardized in SUSv3 and thus should be used in all new programs. However, we may sometimes encounter BSD pseudoterminals in older applications or when porting programs to Linux from other UNIX implementations. Therefore, we now consider the details of BSD pseudoterminals.</p>
<div class="block">
<p class="noindent">The use of BSD pseudoterminals is deprecated on Linux. From Linux 2.6.4 onward, BSD pseudoterminal support is an optional kernel component that can be configured via the <span class="literal">CONFIG_LEGACY_PTYS</span> option.</p>
</div>
<p class="noindent">BSD pseudoterminals differ from their UNIX 98 counterparts only in the details of how pseudoterminal master and slave devices are found and opened. Once the master and slave have been opened, BSD pseudoterminals operate in the same way as UNIX 98 pseudoterminals.</p>
<p class="indent">With UNIX 98 pseudoterminals, we obtain an unused pseudoterminal master by calling <em>posix_openpt()</em>, which opens <span class="literal">/dev/ptmx</span>, the pseudoterminal master clone device. We then obtain the name of the corresponding pseudoterminal slave using <em>ptsname()</em>. By contrast, with BSD pseudoterminals, the master and slave device pairs are precreated entries in the <span class="literal">/dev</span> directory. Each master device has a name of the form <span class="literal">/dev/pty</span><em>xy</em>, where <em>x</em> is replaced by a letter in the 16-letter range <span class="literal">[p-za-e]</span> and <em>y</em> is replaced by a letter in the 16-letter range <span class="literal">[0-9a-f]</span>. The slave corresponding to a particular pseudoterminal master has a name of the form <span class="literal">/dev/tty</span><em>xy</em>. Thus, for example, the devices <span class="literal">/dev/ptyp0</span> and <span class="literal">/dev/ttyp0</span> constitute a BSD pseudoterminal pair.</p>
<div class="block">
<p class="noindent">UNIX implementations vary in the number and names of BSD pseudoterminal pairs that they supply, with some supplying as few as 32 pairs by default. Most implementations provide at least the 32 master devices with names in the range <span class="literal">/dev/pty[pq][0-9a-f]</span>, along with the corresponding slave devices.</p>
</div>
<p class="noindentb"><span epub:type="pagebreak" id="page_1396"/>To find an unused pseudoterminal pair, we execute a loop that attempts to open each master device in turn, until one of them is opened successfully. While executing this loop, there are two errors that we may encounter when calling <em>open()</em>:</p>
<p class="bull">&#8226; If a given master device name doesn&#8217;t exist, <em>open()</em> fails with the error <span class="literal">ENOENT</span>. Typically, this means we&#8217;ve run through the complete set of pseudoterminal master names on the system without finding a free device (i.e., there was not the full range of devices listed above).</p>
<p class="bull">&#8226; If the master device is in use, <em>open()</em> fails with the error <span class="literal">EIO</span>. We can just ignore this error and try the next device.</p>
<div class="block1">
<p class="noindent">On HP-UX 11, <em>open()</em> fails with the error <span class="literal">EBUSY</span> on an attempt to open a BSD pseudoterminal master that is in use.</p>
</div>
<p class="noindent">Once we have found an available master device, we can obtain the name of the corresponding slave by substituting <span class="literal">tty</span> for <span class="literal">pty</span> in the name of the master. We can then open the slave using <em>open()</em>.</p>
<div class="block">
<p class="noindent">With BSD pseudoterminals, there is no equivalent of <em>grantpt()</em> to change the ownership and permissions of the pseudoterminal slave. If we need to do this, then we must make explicit calls to <em>chown()</em> (only possible in a privileged program) and <em>chmod()</em>, or write a set-user-ID program (like <em>pt_chown</em>) that performs this task for an unprivileged program.</p>
</div>
<p class="noindent"><a href="ch64.xhtml#ch64ex4">Listing 64-4</a> shows a reimplementation of the <em>ptyMasterOpen()</em> function of <a href="ch64.xhtml#ch64lev1sec03">Section 64.3</a> using BSD pseudoterminals. Substituting this implementation is all that is required to make our <em>script</em> program (<a href="ch64.xhtml#ch64lev1sec06">Section 64.6</a>) work with BSD pseudoterminals.</p>
<p class="examplet"><a id="ch64ex4"/><strong>Listing 64-4:</strong> Implementation of <em>ptyMasterOpen()</em> using BSD pseudoterminals</p>
<p class="programsli">_________________________________________________ <span class="codestrong">pty/pty_master_open_bsd.c</span><br/><br/>#include &lt;fcntl.h&gt;<br/>#include "pty_master_open.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declares ptyMasterOpen() */<br/>#include "tlpi_hdr.h"<br/><br/>#define PTYM_PREFIX&#160;&#160;&#160;&#160;"/dev/pty"<br/>#define PTYS_PREFIX&#160;&#160;&#160;&#160;"/dev/tty"<br/>#define PTY_PREFIX_LEN (sizeof(PTYM_PREFIX) - 1)<br/>#define PTY_NAME_LEN&#160;&#160;&#160;(PTY_PREFIX_LEN + sizeof("XY"))<br/>#define X_RANGE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"pqrstuvwxyzabcde"<br/>#define Y_RANGE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"0123456789abcdef"<br/><br/>int<br/>ptyMasterOpen(char *slaveName, size_t snLen)<br/>{<br/>&#160;&#160;&#160;&#160;int masterFd, n;<br/>&#160;&#160;&#160;&#160;char *x, *y;<br/>&#160;&#160;&#160;&#160;char masterName[PTY_NAME_LEN];<br/><br/>&#160;&#160;&#160;&#160;if (PTY_NAME_LEN &gt; snLen) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errno = EOVERFLOW;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;memset(masterName, 0, PTY_NAME_LEN);<br/>&#160;&#160;&#160;&#160;strncpy(masterName, PTYM_PREFIX, PTY_PREFIX_LEN);<br/><br/>&#160;&#160;&#160;&#160;for (x = X_RANGE; *x != '\0'; x++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;masterName[PTY_PREFIX_LEN] = *x;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (y = Y_RANGE; *y != '\0'; y++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;masterName[PTY_PREFIX_LEN + 1] = *y;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;masterFd = open(masterName, O_RDWR);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (masterFd == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno == ENOENT)&#160;&#160;&#160;&#160;/* No such file */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Probably no more pty devices */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Other error (e.g., pty busy) */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Return slave name corresponding to master */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;n = snprintf(slaveName, snLen, "%s%c%c", PTYS_PREFIX, *x, *y);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (n &gt;= snLen) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errno = EOVERFLOW;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else if (n == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return masterFd;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;return -1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Tried all ptys without success */<br/>}<br/>_________________________________________________ <span class="codestrong">pty/pty_master_open_bsd.c</span></p>
<h3 class="h3" id="ch64lev1sec09"><span epub:type="pagebreak" id="page_1397"/><strong>64.9 Summary</strong></h3>
<p class="noindenta">A pseudoterminal pair consists of a connected master device and slave device. Together, these two devices provide a bidirectional IPC channel. The benefit of a pseudoterminal is that, on the slave side of the pair, we can connect a terminal-oriented program that is driven by the program that has opened the master device. The pseudoterminal slave behaves just like a conventional terminal. All of the operations that can be applied to a conventional terminal can be applied to the slave, and input transmitted from the master to the slave is interpreted in the same manner as keyboard input is interpreted on a conventional terminal.</p>
<p class="indent">One common use of pseudoterminals is in applications that provide network login services. However, pseudoterminals are also used in many other programs, such as terminal emulators and the <em>script(1)</em> program.</p>
<p class="indent">Different pseudoterminals APIs arose on System V and BSD. Linux supports both APIs, but the System V API forms the basis for the pseudoterminal API that is standardized in SUSv3.</p>
<h3 class="h3" id="ch64lev1sec10"><span epub:type="pagebreak" id="page_1398"/><strong>64.10 Exercises</strong></h3>
<p class="exer"><a id="ch64exe1"/><strong>64-1.</strong>&#160;&#160;&#160;In what order do the <em>script</em> parent process and the child shell process terminate when the user types the end-of-file character (usually <em>Control-D</em>) while running the program in <a href="ch64.xhtml#ch64ex3">Listing 64-3</a>? Why?</p>
<p class="exer"><a id="ch64exe2"/><strong>64-2.</strong>&#160;&#160;&#160;Make the following modifications to the program in <a href="ch64.xhtml#ch64ex3">Listing 64-3</a> (<span class="literal">script.c</span>):</p>
<p class="olista1">a) The standard <em>script(1)</em> program adds lines to the beginning and the end of the output file showing the time the script started and finished. Add this feature.</p>
<p class="olista1">b) Add code to handle changes to the terminal window size as described in <a href="ch64.xhtml#ch64lev1sec07">Section 64.7</a>. You may find the program in <a href="ch62.xhtml#ch62ex5">Listing 62-5</a> (<span class="literal">demo_SIGWINCH.c</span>) useful for testing this feature.</p>
<p class="exer"><a id="ch64exe3"/><strong>64-3.</strong>&#160;&#160;&#160;Modify the program in <a href="ch64.xhtml#ch64ex3">Listing 64-3</a> (<span class="literal">script.c</span>) to replace the use of <em>select()</em> by a pair of processes: one to handle data transfer from the terminal to the pseudoterminal master, and the other to handle data transfer in the opposite direction.</p>
<p class="exer"><a id="ch64exe4"/><strong>64-4.</strong>&#160;&#160;&#160;Modify the program in <a href="ch64.xhtml#ch64ex3">Listing 64-3</a> (<span class="literal">script.c</span>) to add a time-stamped recording feature. Each time the program writes a string to the <span class="literal">typescript</span> file, it should also write a time-stamped string to a second file (say, <span class="literal">typescript.timed</span>). Records written to this second file might have the following general form:</p>
<p class="programs1">&lt;timestamp&gt; &lt;space&gt; &lt;string&gt; &lt;newline&gt;</p>
<p class="exerp">The <em>timestamp</em> should be recorded in text form as the number of milliseconds since the start of the script session. Recording the timestamp in text form has the advantage that the resulting file is human-readable. Within <em>string</em>, real newline characters will need to be escaped. One possibility is to record a newline as the 2-character sequence <span class="literal">\n</span> and a backslash as <span class="literal">\\</span>.</p>
<p class="exerpi">Write a second program, <span class="literal">script_replay.c</span>, that reads the time-stamped script file and displays its contents on standard output at the same rate at which they were originally written. Together, these two programs provide a simple recording and playback feature for shell session logs.</p>
<p class="exer"><a id="ch64exe5"/><strong>64-5.</strong>&#160;&#160;&#160;Implement client and server programs to provide a simple <em>telnet</em>-style remote login facility. Design the server to handle clients concurrently (<a href="ch60.xhtml#ch60lev1sec01">Section 60.1</a>). <a href="ch64.xhtml#ch64fig3">Figure 64-3</a> shows the setup that needs to be established for each client login. What isn&#8217;t shown in that diagram is the parent server process, which handles incoming socket connections from clients and creates a server child to handle each connection. Note that all of the work of authenticating the user and starting a login shell can be dealt with in each server child by having the (grand)child created by <em>ptyFork()</em> go on to exec <em>login(1)</em>.</p>
<p class="exer"><a id="ch64exe6"/><strong>64-6.</strong>&#160;&#160;&#160;Add code to the program developed in the previous exercise to update the login accounting files at the start and end of the login session (<a href="ch40.xhtml#ch40">Chapter 40</a>).</p>
<p class="exer"><a id="ch64exe7"/><strong>64-7.</strong>&#160;&#160;&#160;Suppose we execute a long-running program that slowly generates output that is redirected to a file or pipe, as in this example:</p>
<p class="programs1">$ <span class="codestrong">longrunner | grep str</span></p>
<p class="exerp"><span epub:type="pagebreak" id="page_1399"/>One problem with the above scenario is that, by default, the <em>stdio</em> package flushes standard output only when the <em>stdio</em> buffer is filled. This means that the output from the <em>longrunner</em> program will appear in bursts separated by long intervals of time. One way to circumvent this problem is to write a program that does the following:</p>
<p class="olista1">a) Create a pseudoterminal.</p>
<p class="olista1">b) Exec the program named in its command-line arguments with the standard file descriptors connected to the pseudoterminal slave.</p>
<p class="olista1">c) Read output from the pseudoterminal master and write it immediately to standard output (<span class="literal">STDOUT_FILENO</span>, file descriptor 1), and, at the same time, read input from the terminal and write it to the pseudoterminal master, so that it can be read by the execed program.</p>
<p class="exerp">Such a program, which we&#8217;ll call <em>unbuffer</em>, would be used as follows:</p>
<p class="programs1">$ <span class="codestrong">./unbuffer longrunner | grep str</span></p>
<p class="exerp">Write the <em>unbuffer</em> program. (Much of the code for this program will be similar to that of <a href="ch64.xhtml#ch64ex3">Listing 64-3</a>.)</p>
<p class="exer"><a id="ch64exe8"/><strong>64-8.</strong>&#160;&#160;&#160;Write a program that implements a scripting language that can be used to drive <em>vi</em> in a noninteractive mode. Since <em>vi</em> expects to be run from a terminal, the program will need to employ a pseudoterminal.<span epub:type="pagebreak" id="page_1400"/></p>
</body>
</html>
