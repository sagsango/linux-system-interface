<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch45"><span epub:type="pagebreak" id="page_921"/><strong><span class="big">45</span></strong><br/><strong>INTRODUCTION TO SYSTEM V IPC</strong></h2>
<p class="noindentab">System V IPC is the label used to refer to three different mechanisms for interprocess communication:</p>
<p class="bull">&#8226; <em>Message queues</em> can be used to pass messages between processes. Message queues are somewhat like pipes, but differ in two important respects. First, message boundaries are preserved, so that readers and writers communicate in units of messages, rather than via an undelimited byte stream. Second, each message includes an integer <em>type</em> field, and it is possible to select messages by type, rather than reading them in the order in which they were written.</p>
<p class="bull">&#8226; <em>Semaphores</em> permit multiple processes to synchronize their actions. A semaphore is a kernel-maintained integer value that is visible to all processes that have the necessary permissions. A process indicates to its peers that it is performing some action by making an appropriate modification to the value of the semaphore.</p>
<p class="bull">&#8226; <em>Shared memory</em> enables multiple processes to share the same region (called a <em>segment</em>) of memory (i.e., the same page frames are mapped into the virtual memory of multiple processes). Since access to user-space memory is a fast operation, shared memory is one of the quickest methods of IPC: once one process has updated the shared memory, the change is immediately visible to other processes sharing the same segment.</p>
<p class="noindentt">Although these three IPC mechanisms are quite diverse in function, there are good reasons for discussing them together. One reason is that they were developed <span epub:type="pagebreak" id="page_922"/>together, first appearing in the late 1970s in Columbus UNIX. This was a Bell-internal UNIX implementation used for database and transaction-processing systems for telephone company record keeping and administration. Around 1983, these IPC mechanisms made their way into mainstream UNIX by appearing in System V&#8212;hence the appellation System V IPC.</p>
<p class="indent">A more significant reason for discussing the System V IPC mechanisms together is that their programming interfaces share a number of common characteristics, so that many of the same concepts apply to all of these mechanisms.</p>
<div class="block">
<p class="noindent">Because System V IPC is required by SUSv3 for XSI conformance, it is sometimes alternatively labeled <em>XSI IPC</em>.</p>
</div>
<p class="noindent">This chapter provides an overview of the System V IPC mechanisms and details those features that are common to all three mechanisms. The three mechanisms are then discussed individually in the following chapters.</p>
<div class="block">
<p class="noindent">System V IPC is a kernel option that is configured via the <span class="literal">CONFIG_SYSVIPC</span> option.</p>
</div>
<h3 class="h3" id="ch45lev1sec01"><strong>45.1 API Overview</strong></h3>
<p class="noindenta"><a href="ch45.xhtml#ch45table1">Table 45-1</a> summarizes the header files and system calls used for working with System V IPC objects.</p>
<p class="indent">Some implementations require the inclusion of <span class="literal">&lt;sys/types.h&gt;</span> before including the header files shown in <a href="ch45.xhtml#ch45table1">Table 45-1</a>. Some older UNIX implementations may also require the inclusion of <span class="literal">&lt;sys/ipc.h&gt;</span>. (No versions of the Single UNIX Specification required these header files.)</p>
<div class="block">
<p class="noindent">On most hardware architectures on which Linux is implemented, a single system call (<em>ipc(2)</em>) acts as the entry point to the kernel for all System V IPC operations, and all of the calls listed in <a href="ch45.xhtml#ch45table1">Table 45-1</a> are actually implemented as library functions layered on top of this system call. (Two exceptions to this arrangement are Alpha and IA-64, where the functions listed in the table really are implemented as individual system calls.) This somewhat unusual approach is an artifact of the initial implementation of System V IPC as a loadable kernel module. Although they are actually library functions on most Linux architectures, throughout this chapter, we&#8217;ll refer to the functions in <a href="ch45.xhtml#ch45table1">Table 45-1</a> as system calls. Only implementers of C libraries need to use <em>ipc(2)</em>; any other use in applications is not portable.</p>
</div>
<p class="tablecap"><a id="ch45table1"/><strong>Table 45-1:</strong> Summary of programming interfaces for System V IPC objects</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Interface</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Message queues</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Semaphores</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Shared memory</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Header file</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">&lt;sys/msg.h&gt;</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">&lt;sys/sem.h&gt;</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><span class="literal">&lt;sys/shm.h&gt;</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Associated data structure</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>msqid_ds</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>semid_ds</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>shmid_ds</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Create/open object</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>msgget()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>semget()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>shmget()</em> + <em>shmat()</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Close object</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">(none)</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">(none)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>shmdt()</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table">Control operations</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>msgctl()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>semctl()</em></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>shmctl()</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table">Performing IPC</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><em>msgsnd()</em>&#8212;write message<br/><em>msgrcv()</em>&#8212;read message</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table"><em>semop()</em>&#8212;test/adjust semaphore</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">access memory in shared region</p></td>
</tr>
</tbody>
</table>
<h5 class="h5" id="ch45lev3sec01"><span epub:type="pagebreak" id="page_923"/><strong>Creating and opening a System V IPC object</strong></h5>
<p class="noindentab">Each System V IPC mechanism has an associated <em>get</em> system call (<em>msgget()</em>, <em>semget()</em>, or <em>shmget()</em>), which is analogous to the <em>open()</em> system call used for files. Given an integer <em>key</em> (analogous to a filename), the <em>get</em> call either:</p>
<p class="bull">&#8226; creates a new IPC object with the given key and returns a unique identifier for that object; or</p>
<p class="bull">&#8226; returns the identifier of an existing IPC object with the given key.</p>
<p class="noindentt">We&#8217;ll (loosely) term the second use <em>opening</em> an existing IPC object. In this case, all that the <em>get</em> call is doing is converting one number (the key) into another number (the identifier).</p>
<div class="block">
<p class="noindent">In the context of System V IPC, the <em>object</em> doesn&#8217;t carry any of the connotations associated with object-oriented programming. The term merely serves to distinguish the System V IPC mechanisms from files. Although there are several analogies between files and System V IPC objects, the use of IPC objects differs in several important respects from the standard UNIX file I/O model, and this is a source of some complications when using the System V IPC mechanisms.</p>
</div>
<p class="noindent">An IPC <em>identifier</em> is analogous to a file descriptor in that it is used in all subsequent system calls to refer to the IPC object. There is, however, an important semantic difference. Whereas a file descriptor is a process attribute, an IPC identifier is a property of the object itself and is visible system-wide. All processes accessing the same object use the same identifier. This means that if we know an IPC object already exists, we can skip the <em>get</em> call, provided we have some other means of knowing the identifier of the object. For example, the process that created the object might write the identifier to a file that can then be read by other processes.</p>
<p class="indent">The following example shows how to create a System V message queue:</p>
<p class="programs">id = msgget(key, IPC_CREAT | S_IRUSR | S_IWUSR);<br/>if (id == -1)<br/>&#160;&#160;&#160;&#160;errExit("msgget");</p>
<p class="noindent">As with all of the <em>get</em> calls, the key is the first argument, and the identifier is returned as the function result. We specify the permissions to be placed on the new object as part of the final (<em>flags</em>) argument to the <em>get</em> call, using the same bit-mask constants as are used for files (<a href="ch15.xhtml#ch15table4">Table 15-4</a>, on <a href="ch15.xhtml#page_295">page 295</a>). In the above example, permission is granted to just the owner of the object to read and write messages on the queue.</p>
<p class="indent">The process umask (<a href="ch15.xhtml#ch15lev2sec10">Section 15.4.6</a>) is not applied to the permissions placed on a newly created IPC object.</p>
<div class="block">
<p class="noindent">Several UNIX implementations define the following bit-mask constants for IPC permissions: <span class="literal">MSG_R</span>, <span class="literal">MSG_W</span>, <span class="literal">SEM_R</span>, <span class="literal">SEM_A</span>, <span class="literal">SHM_R</span>, and <span class="literal">SHM_W</span>. These correspond to owner (user) read and write permissions for each IPC mechanism. To get the corresponding group and other permission bit masks, these constants can be right-shifted 3 and 6 bits. These constants are not specified by SUSv3, which employs the same bit masks as are used for files, and are not defined in <em>glibc</em> headers.</p>
</div>
<p class="noindent">Each process that wants to access the same IPC object performs a <em>get</em> call specifying the same key in order to obtain the same identifier for that object. We consider how to choose a key for an application in <a href="ch45.xhtml#ch45lev1sec02">Section 45.2</a>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_924"/>If no IPC object corresponding to the given key currently exists, and <span class="literal">IPC_CREAT</span> (analogous to the <em>open()</em> <span class="literal">O_CREAT</span> flag) was specified as part of the <em>flags</em> argument, then the <em>get</em> call creates a new IPC object. If no corresponding IPC object currently exists, and <span class="literal">IPC_CREAT</span> was not specified (and the key was not specified as <span class="literal">IPC_PRIVATE</span>, described in <a href="ch45.xhtml#ch45lev1sec02">Section 45.2</a>), then the <em>get</em> call fails with the error <span class="literal">ENOENT</span>.</p>
<p class="indent">A process can guarantee that it is the one creating an IPC object by specifying the <span class="literal">IPC_EXCL</span> flag (analogous to the <em>open()</em> <span class="literal">O_EXCL</span> flag). If <span class="literal">IPC_EXCL</span> is specified and the IPC object corresponding to the given key already exists, then the <em>get</em> call fails with the error <span class="literal">EEXIST</span>.</p>
<h5 class="h5" id="ch45lev3sec02"><strong>IPC object deletion and object persistence</strong></h5>
<p class="noindenta">The <em>ctl</em> system call (<em>msgctl()</em>, <em>semctl()</em>, <em>shmctl()</em>) for each System V IPC mechanism performs a range of <em>control operations</em> for the object. Many of these operations are specific to the IPC mechanism, but a few are generic to all IPC mechanisms. An example of a generic control operation is <span class="literal">IPC_RMID</span>, which is used to delete an object. For example, we can use the following call to delete a shared memory object:</p>
<p class="programs">if (shmctl(id, IPC_RMID, NULL) == -1)<br/>&#160;&#160;&#160;&#160;errExit("shmctl");</p>
<p class="noindent">For message queues and semaphores, deletion of the IPC object is immediate, and any information contained within the object is destroyed, regardless of whether any other process is still using the object. (This is one of a number of points where the operation of System V IPC objects is not analogous to files. In <a href="ch18.xhtml#ch18lev1sec03">Section 18.3</a>, we saw that if we remove the last link to a file, then the file is actually removed only after all open file descriptors referring to it have been closed.)</p>
<p class="indent">Deletion of shared memory objects occurs differently. Following the <em>shmctl(id, IPC_RMID, NULL)</em> call, the shared memory segment is removed only after all processes using the segment detach it (using <em>shmdt()</em>). (This is much closer to the situation with file deletion.)</p>
<p class="indentb">System V IPC objects have kernel persistence. Once created, an object continues to exist until it is explicitly deleted or the system is shut down. This property of System V IPC objects can be advantageous. It is possible for a process to create an object, modify its state, and then exit, leaving the object to be accessed by some process that is started at a later time. It can also be disadvantageous for the following reasons:</p>
<p class="bull">&#8226; There are system-imposed limits on the number of IPC objects of each type. If we fail to remove unused objects, we may eventually encounter application errors as a result of reaching these limits.</p>
<p class="bull">&#8226; When deleting a message queue or semaphore object, a multiprocess application may not be able to easily determine which will be the last process requiring access to the object, and thus when the object can be safely deleted. The problem is that these objects are <em>connectionless</em>&#8212;the kernel doesn&#8217;t keep a record of which processes have the object open. (This disadvantage doesn&#8217;t apply for shared memory segments, because of their different deletion semantics, described above.)</p>
<h3 class="h3" id="ch45lev1sec02"><span epub:type="pagebreak" id="page_925"/><strong>45.2 IPC Keys</strong></h3>
<p class="noindenta">System V IPC keys are integer values represented using the data type <em>key_t</em>. The IPC <em>get</em> calls translate a key into the corresponding integer IPC identifier. These calls guarantee that if we create a new IPC object, then that object will have a unique identifier, and that if we specify the key of an existing object, then we&#8217;ll always obtain the (same) identifier for that object. (Internally, the kernel maintains data structures mapping keys to identifiers for each IPC mechanism, as described in <a href="ch45.xhtml#ch45lev1sec05">Section 45.5</a>.)</p>
<p class="indentb">So, how do we provide a unique key&#8212;one that guarantees that we won&#8217;t accidentally obtain the identifier of an existing IPC object used by some other application? There are three possibilities:</p>
<p class="bull">&#8226; Randomly choose some integer key value, which is typically placed in a header file included by all programs using the IPC object. The difficulty with this approach is that we may accidentally choose a value used by another application.</p>
<p class="bull">&#8226; Specify the <span class="literal">IPC_PRIVATE</span> constant as the <em>key</em> value to the <em>get</em> call when creating the IPC object, which always results in the creation of a new IPC object that is guaranteed to have a unique identifier.</p>
<p class="bull">&#8226; Employ the <em>ftok()</em> function to generate a (likely unique) key.</p>
<p class="noindentt">Using either <span class="literal">IPC_PRIVATE</span> or <em>ftok()</em> is the usual technique.</p>
<h5 class="h5" id="ch45lev3sec03"><strong>Generating a unique identifier with</strong> <span class="literal"><span class="codestrong">IPC_PRIVATE</span></span></h5>
<p class="noindenta">When creating a new IPC object, the key may be specified as <span class="literal">IPC_PRIVATE</span>, as follows:</p>
<p class="programs">id = msgget(IPC_PRIVATE, S_IRUSR | S_IWUSR);</p>
<p class="noindent">In this case, it is not necessary to specify the <span class="literal">IPC_CREAT</span> or <span class="literal">IPC_EXCL</span> flags.</p>
<p class="indent">This technique is especially useful in multiprocess applications where the parent process creates the IPC object prior to performing a <em>fork()</em>, with the result that the child inherits the identifier of the IPC object. We can also use this technique in client-server applications (i.e., those involving unrelated processes), but the clients must have a means of obtaining the identifiers of the IPC objects created by the server (and vice versa). For example, after creating an IPC object, the server could then write its identifier to a file that can be read by the clients.</p>
<h5 class="h5" id="ch45lev3sec04"><strong>Generating a unique key with <em>ftok()</em></strong></h5>
<p class="noindenta">The <em>ftok()</em> (<em>file to key</em>) function returns a key value suitable for use in a subsequent call to one of the System V IPC <em>get</em> system calls.</p>
<div class="box">
<p class="programsa">#include &lt;sys/ipc.h&gt;<br/><br/>key_t <span class="codestrong">ftok</span>(char *<span class="font1">pathname</span>, int <span class="font1">proj</span>);</p>
<p class="right">Returns integer key on success, or &#8211;1 on error</p>
</div>
<p class="noindentb"><span epub:type="pagebreak" id="page_926"/>This key value is generated from the supplied <em>pathname</em> and <em>proj</em> value using an implementation-defined algorithm. SUSv3 makes the following requirements:</p>
<p class="bull">&#8226; Only the least significant 8 bits of <em>proj</em> are employed by the algorithm.</p>
<p class="bull">&#8226; The application must ensure that the <em>pathname</em> refers to an existing file to which <em>stat()</em> can be applied (otherwise, <em>ftok()</em> returns &#8211;1).</p>
<p class="bull">&#8226; If different pathnames (links) referring to the same file (i.e., i-node) are supplied to <em>ftok()</em> with the same <em>proj</em> value, the same key value must be returned.</p>
<p class="noindentt">To put things another way, <em>ftok()</em> uses the i-node number rather than the name of the file to generate the key value. (Because the <em>ftok()</em> algorithm depends on the i-node number, the file should not be removed and re-created during the life of the application, since it is likely that the file will be re-created with a different i-node number.) The purpose of the <em>proj</em> value is simply to allow us to generate multiple keys from the same file, which is useful when an application needs to create multiple IPC objects of the same type. Historically, the <em>proj</em> argument was of type <em>char</em>, and it is often specified as such in calls to <em>ftok()</em>.</p>
<div class="block">
<p class="noindent">SUSv3 leaves the behavior of <em>ftok()</em> unspecified if <em>proj</em> is 0. Under AIX 5.1, <em>ftok()</em> returns &#8211;1 if <em>proj</em> is specified as 0. On Linux, this value has no special meaning. Nevertheless, portable applications should avoid specifying <em>proj</em> as 0; this still leaves a choice of 255 other values.</p>
</div>
<p class="noindent">Normally, the <em>pathname</em> given to <em>ftok()</em> refers to one of the files or directories that forms part of, or is created by, the application, and cooperating processes pass the same <em>pathname</em> to <em>ftok()</em>.</p>
<p class="indent">On Linux, the key returned by <em>ftok()</em> is a 32-bit value, created by taking the least significant 8 bits from the <em>proj</em> argument, the least significant 8 bits of the device number (i.e., the minor device number) of the device containing the file system in which the file resides, and the least significant 16 bits of the i-node number of the file referred to by <em>pathname</em>. (The last two pieces of information are obtained by calling <em>stat()</em> on <em>pathname</em>.)</p>
<p class="indent">The <em>glibc ftok()</em> algorithm is similar to that employed on other UNIX implementations, and suffers a similar limitation: there is a (very small) possibility that two different files could yield the same key value. This can occur because there is a chance that the least significant bits of an i-node number could be the same for two files on different file systems, coupled with the possibility that two different disk devices (on a system with multiple disk controllers) could have the same minor device number. However, in practice, the possibility of colliding key values for different applications is small enough that the use of <em>ftok()</em> for key generation is a viable technique.</p>
<p class="indent">A typical usage of <em>ftok()</em> is the following:</p>
<p class="programs">key_t key;<br/>int id;<br/><br/>key = ftok("/mydir/myfile", 'x');<br/>if (key == -1)<br/>&#160;&#160;&#160;&#160;errExit("ftok");<br/>id = msgget(key, IPC_CREAT | S_IRUSR | S_IWUSR);<br/>if (id == -1)<br/>&#160;&#160;&#160;&#160;errExit("msgget");</p>
<h3 class="h3" id="ch45lev1sec03"><span epub:type="pagebreak" id="page_927"/><strong>45.3 Associated Data Structure and Object Permissions</strong></h3>
<p class="noindenta">The kernel maintains an associated data structure for each instance of a System V IPC object. The form of this data structure varies according to the IPC mechanism (message queue, semaphore, or shared memory) and is defined in the corresponding header file for the IPC mechanism (see <a href="ch45.xhtml#ch45table1">Table 45-1</a>). We discuss mechanism-specific details of each of these data structures in the following chapters.</p>
<p class="indent">The associated data structure for an IPC object is initialized when the object is created via the appropriate <em>get</em> system call. Once the object has been created, a program can obtain a copy of this data structure using the appropriate <em>ctl</em> system call, by specifying an operation type of <span class="literal">IPC_STAT</span>. Conversely, some parts of the data structure can be modified using the <span class="literal">IPC_SET</span> operation.</p>
<p class="indent">As well as data specific to the type of IPC object, the associated data structure for all three IPC mechanisms includes a substructure, <em>ipc_perm</em>, that holds information used to determine permissions granted on the object:</p>
<p class="programs">struct ipc_perm {<br/>&#160;&#160;&#160;&#160;key_t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;__key;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Key, as supplied to 'get' call */<br/>&#160;&#160;&#160;&#160;uid_t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;uid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Owner's user ID */<br/>&#160;&#160;&#160;&#160;gid_t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;gid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Owner's group ID */<br/>&#160;&#160;&#160;&#160;uid_t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cuid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Creator's user ID */<br/>&#160;&#160;&#160;&#160;gid_t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cgid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Creator's group ID */<br/>&#160;&#160;&#160;&#160;unsigned short mode;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Permissions */<br/>&#160;&#160;&#160;&#160;unsigned short __seq;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Sequence number */<br/>};</p>
<p class="noindent">SUSv3 mandates all of the <em>ipc_perm</em> fields shown here, except <em>__key</em> and <em>__seq</em>. However, most UNIX implementations provide some version of these fields.</p>
<p class="indent">The <em>uid</em> and <em>gid</em> fields specify the ownership of the IPC object. The <em>cuid</em> and <em>cgid</em> fields hold the user and group IDs of the process that created the object. Initially, the corresponding user and creator ID fields have the same values, which are taken from the effective IDs of the calling processes. The creator IDs are immutable, but the owner IDs can be changed via the <span class="literal">IPC_SET</span> operation. The following code demonstrates how to change the <em>uid</em> field for a shared memory segment (the associated data structure is of type <em>shmid_ds</em>):</p>
<p class="programs">struct shmid_ds shmds;<br/><br/>if (shmctl(id, IPC_STAT, &#38;shmds) == -1)&#160;&#160;&#160;&#160;&#160;/* Fetch from kernel */<br/>&#160;&#160;&#160;&#160;errExit("shmctl");<br/>shmds.shm_perm.uid = newuid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Change owner UID */<br/>if (shmctl(id, IPC_SET, &#38;shmds) == -1)&#160;&#160;&#160;&#160;&#160;&#160;/* Update kernel copy */<br/>&#160;&#160;&#160;&#160;errExit("shmctl");</p>
<p class="noindent">The <em>mode</em> field of the <em>ipc_perm</em> substructure holds the permissions mask for the IPC object. These permissions are initialized using the lower 9 bits of the <em>flags</em> specified <span epub:type="pagebreak" id="page_928"/>in the <em>get</em> system call used to create the object, but can be changed subsequently using the <span class="literal">IPC_SET</span> operation.</p>
<p class="indentb">As with files, permissions are broken into three categories&#8212;<em>owner</em> (also known as <em>user</em>), <em>group</em>, and <em>other</em>&#8212;and it is possible to specify different permissions for each category. There are, however, some notable differences from the scheme used for files:</p>
<p class="bull">&#8226; Only read and write permissions are meaningful for IPC objects. (For semaphores, write permission is commonly referred to as <em>alter</em> permission.) Execute permission is meaningless, and is ignored when performing most access checks.</p>
<p class="bull">&#8226; Permission checks are made according to a process&#8217;s effective user ID, effective group IDs, and supplementary group IDs. (This contrasts with file-system permission checks on Linux, which are performed using the process&#8217;s file-system IDs, as described in <a href="ch09.xhtml#ch09lev1sec05">Section 9.5</a>.)</p>
<p class="noindentt">The precise rules governing the permissions a process is granted on an IPC object are as follows:</p>
<ol>
<li class="order"><p class="orderp">If the process is privileged (<span class="literal">CAP_IPC_OWNER</span>), then all permissions are granted on the IPC object.</p></li>
<li class="order"><p class="orderp">If the effective user ID of the process matches either the owner or the creator user ID of the IPC object, then the process is granted the permissions defined for the <em>owner</em> (<em>user</em>) of the object.</p></li>
<li class="order"><p class="orderp">If the effective group ID or any of the supplementary group IDs of the process match either the owner group ID or the creator group ID of the IPC object, then the process is granted the <em>group</em> permissions defined for the object.</p></li>
<li class="order"><p class="orderp">Otherwise, the process is granted the permissions defined for <em>other</em>.</p>
<div class="block1b">
<p class="noindent">In the kernel code, the above tests are constructed so that the test to see whether a process is privileged is performed only if the process is not granted the permissions it needs via one of the other tests. This is done to avoid unnecessarily setting the <span class="literal">ASU</span> process accounting flag, which indicates that the process made use of superuser privileges (<a href="ch28.xhtml#ch28lev1sec01">Section 28.1</a>).</p>
<p class="indent">Note that neither the use of the <span class="literal">IPC_PRIVATE</span> key value nor the presence of <span class="literal">IPC_EXCL</span> flag has any bearing on which processes may access an IPC object; such access is determined solely by the ownership and permissions of the object.</p>
</div></li>
</ol>
<p class="noindent">How read and write permissions are interpreted for an object, and whether they are required, depend on the type of object and on the operation being performed.</p>
<p class="indent">When a <em>get</em> call is performed to obtain the identifier of an existing IPC object, an initial permission check is made to ascertain whether the permissions specified in the <em>flags</em> argument are compatible with those on the existing object. If not, then the <em>get</em> call fails with the error <span class="literal">EACCES</span>. (Except as otherwise noted, this error code is also returned when permissions are denied in each of the cases listed below.) To illustrate, consider the example of two different users in the same group, with one user creating a message queue using the following call:</p>
<p class="programs">msgget(key, IPC_CREAT | S_IRUSR | S_IWUSR | S_IRGRP);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* rw-r----- */</p>
<p class="noindent"><span epub:type="pagebreak" id="page_929"/>An attempt by the second user to obtain an identifier for this message queue using the following call would fail, since the user is not permitted write access to the message queue:</p>
<p class="programs">msgget(key, S_IRUSR | S_IWUSR);</p>
<p class="noindent">The second user could bypass this check by specifying 0 for the second argument of the <em>msgget()</em> call, in which case an error would occur only when the program attempted an operation requiring write permission on the IPC object (e.g., writing a message with <em>msgsnd()</em>).</p>
<div class="block">
<p class="noindent">The <em>get</em> call represents the one case where execute permission is not ignored. Even though it has no meaning for IPC objects, if execute permission is requested in a <em>get</em> call for an existing object, then a check is made to see if that permission is granted.</p>
</div>
<p class="noindentb">The permissions required for other common operations are as follows:</p>
<p class="bull">&#8226; To retrieve information from the object (e.g., to read a message from a message queue, obtain the value of a semaphore, or attach a shared memory segment for read access) requires read permission.</p>
<p class="bull">&#8226; To update information within the object (e.g., to write a message to a message queue, change the value of a semaphore, or attach a shared memory segment for write access) requires write permission.</p>
<p class="bull">&#8226; To obtain a copy of the associated data structure for an IPC object (the <span class="literal">IPC_STAT</span> <em>ctl</em> operation) requires read permission.</p>
<p class="bull">&#8226; To remove an IPC object (the <span class="literal">IPC_RMID</span> <em>ctl</em> operation) or change its associated data structure (the <span class="literal">IPC_SET</span> <em>ctl</em> operation) requires neither read nor write permission. Rather, the calling process must either be privileged (<span class="literal">CAP_SYS_ADMIN</span>) or have an effective user ID matching either the owner user ID or the creator user ID of the object (otherwise, the error <span class="literal">EPERM</span> results).</p>
<div class="block">
<p class="noindent">It is possible to set the permissions on an IPC object so that the owner or creator can no longer use <span class="literal">IPC_STAT</span> to obtain the associated data structure containing the object permissions (which means that the object won&#8217;t be displayed by the <em>ipcs(1)</em> command described in <a href="ch45.xhtml#ch45lev1sec06">Section 45.6</a>), although <span class="literal">IPC_SET</span> can still be used to change them.</p>
</div>
<p class="noindent">Various other mechanism-specific operations require read or write permission, or the <span class="literal">CAP_IPC_OWNER</span> capability. We note the required permissions in the following chapters as the operations are described.</p>
<h3 class="h3" id="ch45lev1sec04"><strong>45.4 IPC Identifiers and Client-Server Applications</strong></h3>
<p class="noindenta">In client-server applications, the server typically creates the System V IPC objects, while the client simply accesses them. In other words, the server performs an IPC <em>get</em> call specifying the flag <span class="literal">IPC_CREAT</span>, while the client omits this flag in its <em>get</em> call.</p>
<p class="indent"><span epub:type="pagebreak" id="page_930"/>Suppose a client engages in an extended dialogue with a server, with multiple IPC operations being performed by each process (e.g., multiple messages exchanged, a sequence of semaphore operations, or multiple updates to shared memory). What happens if the server process crashes or is deliberately halted and then restarted? At this point, it would make no sense to blindly reuse the existing IPC object created by the previous server process, since the new server process has no knowledge of the historical information associated with the current state of the IPC object. (For example, there may be a secondary request within a message queue that was sent by a client in response to an earlier message from the old server process.)</p>
<p class="indent">In such a scenario, the only option for the server may be to abandon all existing clients, delete the IPC objects created by the previous server process, and create new instances of the IPC objects. A newly started server handles the possibility that a previous instance of the server terminated prematurely by first trying to create an IPC object by specifying both the <span class="literal">IPC_CREAT</span> and the <span class="literal">IPC_EXCL</span> flags within the <em>get</em> call. If the <em>get</em> call fails because an object with the specified key already exists, then the server assumes the object was created by an old server process; it therefore uses the <span class="literal">IPC_RMID</span> <em>ctl</em> operation to delete the object, and once more performs a <em>get</em> call to create the object. (This may be combined with other steps to ensure that another server process is not currently running, such as those described in <a href="ch55.xhtml#ch55lev1sec06">Section 55.6</a>.) For a message queue, these steps might appear as shown in <a href="ch45.xhtml#ch45ex1">Listing 45-1</a>.</p>
<p class="examplet"><a id="ch45ex1"/><strong>Listing 45-1:</strong> Cleanup of IPC objects within a server</p>
<p class="programsli">_________________________________________________ <span class="codestrong">svipc/svmsg_demo_server.c</span><br/><br/>#include &lt;sys/types.h&gt;<br/>#include &lt;sys/ipc.h&gt;<br/>#include &lt;sys/msg.h&gt;<br/>#include &lt;sys/stat.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>#define KEY_FILE "/some-path/some-file"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Should be an existing file or one<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;that this program creates */<br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int msqid;<br/>&#160;&#160;&#160;&#160;key_t key;<br/>&#160;&#160;&#160;&#160;const int MQ_PERMS = S_IRUSR | S_IWUSR | S_IWGRP; /* rw--w---- */<br/><br/>&#160;&#160;&#160;&#160;/* Optional code here to check if another server process is<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;already running */<br/><br/>&#160;&#160;&#160;&#160;/* Generate the key for the message queue */<br/><br/>&#160;&#160;&#160;&#160;key = ftok(KEY_FILE, 1);<br/>&#160;&#160;&#160;&#160;if (key == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("ftok");<br/><br/>&#160;&#160;&#160;&#160;/* While msgget() fails, try creating the queue exclusively */<br/><br/>&#160;&#160;&#160;&#160;while ((msqid = msgget(key, IPC_CREAT | IPC_EXCL | MQ_PERMS)) == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno == EEXIST) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* MQ with the same key already<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exists - remove it and try again */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msqid = msgget(key, 0);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (msqid == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msgget() failed to retrieve old queue ID");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (msgctl(msqid, IPC_RMID, NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msgget() failed to delete old queue");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Removed old message queue (id=%d)\n", msqid);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Some other error --&gt; give up */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msgget() failed");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;/* Upon loop exit, we've successfully created the message queue,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;and we can then carry on to do other work... */<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________ <span class="codestrong">svipc/svmsg_demo_server.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_931"/>Even if a restarted server re-created the IPC objects, there still would be a potential problem if supplying the same key to the <em>get</em> call always generated the same identifier whenever a new IPC object was created. Consider the solution just outlined from the point of view of the client. If the IPC objects re-created by the server use the same identifiers, then the client would have no way of becoming aware that the server has been restarted and that the IPC objects don&#8217;t contain the expected historical information.</p>
<p class="indent">To solve this problem, the kernel employs an algorithm (described in the next section) that normally ensures that when a new IPC object is created, the object&#8217;s identifier will be different, even when the same key is supplied. Consequently, any clients of the old server process that attempt to use the old identifier will receive an error from the relevant IPC system call.</p>
<div class="block">
<p class="noindent">Solutions such as that shown in <a href="ch45.xhtml#ch45ex1">Listing 45-1</a> don&#8217;t completely solve the problem of identifying a server restart when using System V shared memory, since a shared memory object is deleted only when all processes have detached it from their virtual address space. However, shared memory objects are typically used in conjunction with System V semaphores, which <em>are</em> immediately deleted in response to an <span class="literal">IPC_RMID</span> operation. This means that a client process will become aware of a server restart when it tries to access the deleted semaphore object.</p>
</div>
<h3 class="h3" id="ch45lev1sec05"><strong>45.5 Algorithm Employed by System V IPC <em>get</em> Calls</strong></h3>
<p class="noindenta"><a href="ch45.xhtml#ch45fig1">Figure 45-1</a> shows some of the structures used internally by the kernel to represent information about System V IPC objects (in this case semaphores, but the details are similar for other IPC mechanisms), including the fields used to calculate IPC keys. For each IPC mechanism (shared memory, message queue, or semaphore), <span epub:type="pagebreak" id="page_932"/>the kernel maintains an associated <em>ipc_ids</em> structure that records various global information about all instances of that IPC mechanism. This information includes a dynamically sized array of pointers, <em>entries</em>, to the associated data structure for each object instance (<em>semid_ds</em> structures in the case of semaphores). The current size of the <em>entries</em> array is recorded in the <em>size</em> field, with the <em>max_id</em> field holding the index of the highest currently in-use element.</p>
<div class="image"><img src="../images/f45-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch45fig1"/><strong>Figure 45-1:</strong> Kernel data structures used to represent System V IPC (semaphore) objects</p>
<p class="noindent">When an IPC <em>get</em> call is made, the algorithm used on Linux (other systems use similar algorithms) is approximately as follows:</p>
<ol>
<li class="order"><p class="orderp">The list of associated data structures (pointed to by elements of the <em>entries</em> array) is searched for one whose <em>key</em> field matches that specified in the <em>get</em> call.</p>
<p class="olista">a) If no match is found, and <span class="literal">IPC_CREAT</span> was not specified, then the error <span class="literal">ENOENT</span> is returned.</p>
<p class="olista">b) If a match is found, but both <span class="literal">IPC_CREAT</span> and <span class="literal">IPC_EXCL</span> were specified, then the error <span class="literal">EEXIST</span> is returned.</p>
<p class="olista">c) Otherwise, if a match is found, then the following step is skipped.</p></li>
<li class="order"><p class="orderp">If no match was found, and <span class="literal">IPC_CREAT</span> was specified, then a new mechanism-specific associated data structure (<em>semid_ds</em> in <a href="ch45.xhtml#ch45fig1">Figure 45-1</a>) is allocated and initialized. This also involves updating various fields of the <em>ipc_ids</em> structure, and may involve resizing the <em>entries</em> array. A pointer to the new structure is placed in the first free element of <em>entries</em>. Two substeps are included as part of this initialization:</p>
<p class="olista">a) The <em>key</em> value supplied in the <em>get</em> call is copied into the <em>xxx_perm.__key</em> field of the newly allocated structure.</p>
<p class="olista">b) The current value of the <em>seq</em> field of the <em>ipc_ids</em> structure is copied into the <em>xxx_perm.__seq</em> field of the associated data structure, and the <em>seq</em> field is incremented by one.</p></li>
<li class="order"><p class="orderp"><span epub:type="pagebreak" id="page_933"/>The identifier for the IPC object is calculated using the following formula:</p>
<p class="programs">identifier = index + xxx_perm.__seq * SEQ_MULTIPLIER</p></li>
</ol>
<p class="noindent">In the formula used to calculate the IPC identifier, <em>index</em> is the index of this object instance within the <em>entries</em> array, and <span class="literal">SEQ_MULTIPLIER</span> is a constant defined with the value 32,768 (<span class="literal">IPCMNI</span> in the kernel source file <span class="literal">include/linux/ipc.h</span>). For example, in <a href="ch45.xhtml#ch45fig1">Figure 45-1</a>, the identifier generated for the semaphore with the <em>key</em> value <span class="literal">0x4b079002</span> would be (2 + 5 * 32,768) = 163,842.</p>
<p class="indentb">Note the following points about the algorithm employed by the <em>get</em> calls:</p>
<p class="bull">&#8226; Even if a new IPC object is created with the same key, it will almost certainly have a different identifier, since the identifier is calculated based on the <em>seq</em> value saved in the associated data structure, and this value is incremented by one during the creation of each object of this type.</p>
<div class="block1">
<p class="noindent">The algorithm employed within the kernel wraps the <em>seq</em> value back to 0 when it reaches the value <span class="literal">(INT_MAX / IPCMNI)</span>&#8212;that is, 2,147,483,647 / 32,768 = 65,535. Thus, a new IPC object could have the same identifier as a previous object if 65,535 objects are created in the interim and the new object reuses the same element in the <em>entries</em> array as the previous object (i.e., this element must also have been freed in the interim). However, the chances of this occurring are small.</p>
</div>
<p class="bull">&#8226; The algorithm generates a distinct set of identifier values for each index of the <em>entries</em> array.</p>
<p class="bull">&#8226; Since the constant <span class="literal">IPCMNI</span> defines an upper limit on the number of System V objects of each type, the algorithm guarantees that each existing IPC object has a unique identifier.</p>
<p class="bull">&#8226; Given an identifier value, the corresponding index into the <em>entries</em> array can be quickly calculated using this equation:</p>
<p class="programsbl">index = identifier % SEQ_MULTIPLIER</p>
<p class="bullp">Being able to rapidly perform this calculation is necessary for the efficient operation of those IPC system calls that are supplied with the identifier of an IPC object (i.e., those calls in <a href="ch45.xhtml#ch45table1">Table 45-1</a> other than the <em>get</em> calls).</p>
<p class="noindentt">In passing, it is worth noting that two different errors can result if a process makes an IPC system call (e.g., <em>msgctl()</em>, <em>semop()</em>, or <em>shmat()</em>) that specifies an identifier that doesn&#8217;t correspond to an existing object. If the corresponding index of <em>entries</em> is empty, the error <span class="literal">EINVAL</span> results. If the index points to an associated data structure, but the sequence number stored in that structure doesn&#8217;t yield the same identifier value, then it is assumed that an old object pointed to by this array index has been deleted and the index reused. This scenario is diagnosed with the error <span class="literal">EIDRM</span>.</p>
<h3 class="h3" id="ch45lev1sec06"><span epub:type="pagebreak" id="page_934"/><strong>45.6 The <em>ipcs</em> and <em>ipcrm</em> Commands</strong></h3>
<p class="noindenta">The <em>ipcs</em> and <em>ipcrm</em> commands are the System V IPC analogs of the <em>ls</em> and <em>rm</em> file commands. Using <em>ipcs</em>, we can obtain information about IPC objects on the system. By default, <em>ipcs</em> displays all objects, as in the following example:</p>
<p class="programs">$ <span class="codestrong">ipcs</span><br/><br/>------ Shared Memory Segments --------<br/>key&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shmid&#160;&#160;&#160;&#160;&#160;owner&#160;&#160;&#160;&#160;&#160;perms&#160;&#160;&#160;&#160;bytes&#160;&#160;&#160;&#160;nattch&#160;&#160;&#160;status<br/>0x6d0731db 262147&#160;&#160;&#160;&#160;mtk&#160;&#160;&#160;&#160;&#160;&#160;&#160;600&#160;&#160;&#160;&#160;&#160;&#160;8192&#160;&#160;&#160;&#160;&#160;2<br/><br/>------ Semaphore Arrays --------<br/>key&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;semid&#160;&#160;&#160;&#160;&#160;owner&#160;&#160;&#160;&#160;&#160;perms&#160;&#160;&#160;&#160;nsems<br/>0x6107c0b8 0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cecilia&#160;&#160;&#160;660&#160;&#160;&#160;&#160;&#160;&#160;6<br/>0x6107c0b6 32769&#160;&#160;&#160;&#160;&#160;britta&#160;&#160;&#160;&#160;660&#160;&#160;&#160;&#160;&#160;&#160;1<br/><br/>------ Message Queues --------<br/>key&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msqid&#160;&#160;&#160;&#160;&#160;owner&#160;&#160;&#160;&#160;&#160;perms&#160;&#160;&#160;&#160;used-bytes&#160;&#160;messages<br/>0x71075958 229376&#160;&#160;&#160;&#160;cecilia&#160;&#160;&#160;620&#160;&#160;&#160;&#160;&#160;&#160;12&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2</p>
<p class="noindent">On Linux, <em>ipcs(1)</em> displays information only about IPC objects for which we have read permission, regardless of whether we own the objects. On some UNIX implementations, <em>ipcs</em> shows the same behavior as on Linux. However, on other implementations, <em>ipcs</em> displays all objects regardless of whether read permission is granted to the user.</p>
<p class="indentb">By default, for each object, <em>ipcs</em> displays the key, the identifier, the owner, and the permissions (expressed as an octal number), followed by information specific to the object:</p>
<p class="bull">&#8226; For shared memory, <em>ipcs</em> displays the size of the shared memory region, the number of processes that currently have the shared memory region attached to their virtual address space, and status flags. The status flags indicate whether the region has been locked into RAM to prevent swapping (<a href="ch48.xhtml#ch48lev1sec07">Section 48.7</a>) and whether the region has been marked to be destroyed when all processes have detached it.</p>
<p class="bull">&#8226; For semaphores, <em>ipcs</em> displays the size of the semaphore set.</p>
<p class="bull">&#8226; For message queues, <em>ipcs</em> displays the total number of bytes of data and the number of messages in the queue.</p>
<p class="noindentt">The <em>ipcs(1)</em> manual page documents various options for displaying other information about IPC objects.</p>
<p class="indent">The <em>ipcrm</em> command deletes an IPC object. The general form of this command is one of the following:</p>
<p class="programs">$ <span class="codestrong">ipcrm -<span class="codeitalic">X key</span></span><br/>$ <span class="codestrong">ipcrm -<span class="codeitalic">x id</span></span></p>
<p class="noindent">In the above, we either specify <em>key</em> as an IPC object key or <em>id</em> as an IPC object identifier, and the letter <em>x</em> is replaced by an uppercase or lowercase <em>q</em> (for message queues), <em>s</em> (for semaphores), or <em>m</em> (for shared memory). Thus, we could use the following command to delete the semaphore set with the identifier 65538:</p>
<p class="programs">$ <span class="codestrong">ipcrm -s 65538</span></p>
<h3 class="h3" id="ch45lev1sec07"><span epub:type="pagebreak" id="page_935"/><strong>45.7 Obtaining a List of All IPC Objects</strong></h3>
<p class="noindentab">Linux provides two nonstandard methods of obtaining a list of all IPC objects on the system:</p>
<p class="bull">&#8226; files within the <span class="literal">/proc/sysvipc</span> directory that list all IPC objects; and</p>
<p class="bull">&#8226; the use of Linux-specific <em>ctl</em> calls.</p>
<p class="noindentt">We describe the files in <span class="literal">/proc/sysvipc</span> directory here, and defer discussion of the <em>ctl</em> calls until <a href="ch46.xhtml#ch46lev1sec06">Section 46.6</a>, where we provide an example program that lists all System V message queues on the system.</p>
<div class="block">
<p class="noindent">Some other UNIX implementations have their own nonstandard methods of obtaining a list of all IPC identifiers; for example, Solaris provides the <em>msgids()</em>, <em>semids()</em>, and <em>shmids()</em> system calls for this purpose.</p>
</div>
<p class="noindentb">Three read-only files in the <span class="literal">/proc/sysvipc</span> directory provide the same information as can be obtained via <em>ipcs</em>:</p>
<p class="bull">&#8226; <span class="literal">/proc/sysvipc/msg</span> lists all messages queues and their attributes.</p>
<p class="bull">&#8226; <span class="literal">/proc/sysvipc/sem</span> lists all semaphore sets and their attributes.</p>
<p class="bull">&#8226; <span class="literal">/proc/sysvipc/shm</span> lists all shared memory segments and their attributes.</p>
<p class="noindentt">Unlike the <em>ipcs</em> command, these files always show all objects of the corresponding type, regardless of whether read permission is available on the objects.</p>
<p class="indent">An example of the contents of <span class="literal">/proc/sysvipc/sem</span> is the following (with some white space removed to fit this example on the page):</p>
<p class="programs">$ <span class="codestrong">cat /proc/sysvipc/sem</span><br/>key&#160;&#160;&#160;&#160;&#160;semid perms&#160;&#160;&#160;nsems&#160;&#160;&#160;uid&#160;&#160;&#160;gid&#160;&#160;&#160;cuid&#160;&#160;cgid&#160;&#160;&#160;&#160;&#160;otime&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ctime<br/>&#160;&#160;0&#160;&#160;16646144&#160;&#160;&#160;600&#160;&#160;&#160;&#160;&#160;&#160;&#160;4&#160;&#160;1000&#160;&#160;&#160;100&#160;&#160;&#160;1000&#160;&#160;&#160;100&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0&#160;&#160;&#160;1010166460</p>
<p class="noindent">The three <span class="literal">/proc/sysvipc</span> files provide a (nonportable) method for programs and scripts to walk through a list of all of the existing IPC objects of a given type.</p>
<div class="block">
<p class="noindent">The best that we can achieve by way of a portable approach to obtaining a list of all IPC objects of a given type is to parse the output of <em>ipcs(1)</em>.</p>
</div>
<h3 class="h3" id="ch45lev1sec08"><strong>45.8 IPC Limits</strong></h3>
<p class="noindenta">Since System V IPC objects consume system resources, the kernel places various limits on each class of IPC object in order to prevent resources from being exhausted. The methods for placing limits on System V IPC objects are not specified by SUSv3, but most UNIX implementations (including Linux) follow a similar framework for the types of limits that may be placed. As we cover each System V IPC mechanism in the following chapters, we discuss the associated limits and note differences from other UNIX implementations.</p>
<p class="indent">Although the types of limits that can be placed on each class of IPC object are generally similar across various UNIX implementations, the methods of viewing and changing these limits are not. The methods described in the following chapters are Linux-specific (they generally involve the use of files in the <span class="literal">/proc/sys/kernel</span> directory); things are done differently on other implementations.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_936"/>On Linux, the <em>ipcs &#8211;l</em> command can be used to list the limits on each of the IPC mechanisms. Programs can employ the Linux-specific <span class="literal">IPC_INFO</span> <em>ctl</em> operation to retrieve the same information.</p>
</div>
<h3 class="h3" id="ch45lev1sec09"><strong>45.9 Summary</strong></h3>
<p class="noindenta">System V IPC is the name given to three IPC mechanisms that first appeared widely in System V, and have subsequently been ported to most UNIX implementations and incorporated into various standards. The three IPC mechanisms are message queues, which allow processes to exchange messages; semaphores, which allow processes to synchronize access to shared resources; and shared memory, which allows two or more processes to share the same pages of memory.</p>
<p class="indent">The three IPC mechanisms have many similarities in their APIs and semantics. For each IPC mechanism, a <em>get</em> system call creates or opens an object. Given an integer <em>key</em>, the <em>get</em> calls return an integer <em>identifier</em> used to refer to the object in subsequent system calls. Each IPC mechanism also has a corresponding <em>ctl</em> call that is used to delete an object and to retrieve and modify various attributes (e.g., ownership and permissions) in an object&#8217;s associated data structure.</p>
<p class="indent">The algorithm used to generate identifiers for new IPC objects is designed to minimize the possibility of the same identifier being (immediately) reused if an object is deleted, even if the same key is used to create a new object. This enables client-server applications to function correctly&#8212;a restarted server process is able to detect and remove IPC objects created by its predecessor, and this action invalidates the identifiers held by any clients of the previous server process.</p>
<p class="indent">The <em>ipcs</em> command lists the System V IPC objects that currently exist on the system. The <em>ipcrm</em> command is used to remove System V IPC objects.</p>
<p class="indent">On Linux, files in the <span class="literal">/proc/sysvipc</span> directory can be used to obtain information about all of the System V IPC objects on the system.</p>
<p class="indent">Each IPC mechanism has an associated set of limits that can be used to avoid exhaustion of system resources by preventing the creation of an arbitrary number of IPC objects. Various files under the <span class="literal">/proc/sys/kernel</span> directory can be used to view and modify these limits.</p>
<h5 class="h5" id="ch45lev3sec05"><strong>Further information</strong></h5>
<p class="noindenta">Information about the implementation of System V IPC on Linux can be found in [<a href="bib.xhtml#bib63">Maxwell, 1999</a>] and [<a href="bib.xhtml#bib09">Bovet &#38; Cesati, 2005</a>]. [<a href="bib.xhtml#bib35">Goodheart &#38; Cox, 1994</a>] describes the implementation of System V IPC for System V Release 4.</p>
<h3 class="h3" id="ch45lev1sec10"><strong>45.10 Exercises</strong></h3>
<p class="exer"><a id="ch45exe1"/><strong>45-1.</strong>&#160;&#160;&#160;Write a program to verify that the algorithm employed by <em>ftok()</em> uses the file&#8217;s i-node number, minor device number, and <em>proj</em> value, as described in <a href="ch45.xhtml#ch45lev1sec02">Section 45.2</a>. (It is sufficient to print all of these values, as well as the return value from <em>ftok()</em>, in hexadecimal, and inspect the results for a few examples.)</p>
<p class="exer"><a id="ch45exe2"/><strong>45-2.</strong>&#160;&#160;&#160;Implement <em>ftok()</em>.</p>
<p class="exer"><a id="ch45exe3"/><strong>45-3.</strong>&#160;&#160;&#160;Verify (by experiment) the statements made in <a href="ch45.xhtml#ch45lev1sec05">Section 45.5</a> about the algorithm used to generate System V IPC identifiers.</p>
</body>
</html>
