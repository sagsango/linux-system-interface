<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_167"/><strong><span class="big">9</span></strong><br/><strong>PROCESS CREDENTIALS</strong></h2>
<p class="noindentab">Every process has a set of associated numeric user identifiers (UIDs) and group identifiers (GIDs). Sometimes, these are referred to as process credentials. These identifiers are as follows:</p>
<p class="bull">&#8226; real user ID and group ID;</p>
<p class="bull">&#8226; effective user ID and group ID;</p>
<p class="bull">&#8226; saved set-user-ID and saved set-group-ID;</p>
<p class="bull">&#8226; file-system user ID and group ID (Linux-specific); and</p>
<p class="bull">&#8226; supplementary group IDs.</p>
<p class="noindentt">In this chapter, we look in detail at the purpose of these process identifiers and describe the system calls and library functions that can be used to retrieve and change them. We also discuss the notion of privileged and unprivileged processes, and the use of the set-user-ID and set-group-ID mechanisms, which allow the creation of programs that run with the privileges of a specified user or group.</p>
<h3 class="h3" id="ch09lev1sec01"><strong>9.1 Real User ID and Real Group ID</strong></h3>
<p class="noindenta">The real user ID and group ID identify the user and group to which the process belongs. As part of the login process, a login shell gets its real user and group IDs from the third and fourth fields of the user&#8217;s password record in the <span class="literal">/etc/passwd</span> file <span epub:type="pagebreak" id="page_168"/>(<a href="ch08.xhtml#ch08lev1sec01">Section 8.1</a>). When a new process is created (e.g., when the shell executes a program), it inherits these identifiers from its parent.</p>
<h3 class="h3" id="ch09lev1sec02"><strong>9.2 Effective User ID and Effective Group ID</strong></h3>
<p class="noindenta">On most UNIX implementations (Linux is a little different, as explained in <a href="ch09.xhtml#ch09lev1sec05">Section 9.5</a>), the effective user ID and group ID, in conjunction with the supplementary group IDs, are used to determine the permissions granted to a process when it tries to perform various operations (i.e., system calls). For example, these identifiers determine the permissions granted to a process when it accesses resources such as files and System V interprocess communication (IPC) objects, which themselves have associated user and group IDs determining to whom they belong. As we&#8217;ll see in <a href="ch20.xhtml#ch20lev1sec05">Section 20.5</a>, the effective user ID is also used by the kernel to determine whether one process can send a signal to another.</p>
<p class="indent">A process whose effective user ID is 0 (the user ID of <em>root</em>) has all of the privileges of the superuser. Such a process is referred to as a <em>privileged process</em>. Certain system calls can be executed only by privileged processes.</p>
<div class="block">
<p class="noindent">In <a href="ch39.xhtml#ch39">Chapter 39</a>, we describe Linux&#8217;s implementation of capabilities, a scheme that divides the privileges granted to the superuser into a number of distinct units that can be independently enabled and disabled.</p>
</div>
<p class="noindent">Normally, the effective user and group IDs have the same values as the corresponding real IDs, but there are two ways in which the effective IDs can assume different values. One way is through the use of system calls that we discuss in <a href="ch09.xhtml#ch09lev1sec07">Section 9.7</a>. The second way is through the execution of set-user-ID and set-group-ID programs.</p>
<h3 class="h3" id="ch09lev1sec03"><strong>9.3 Set-User-ID and Set-Group-ID Programs</strong></h3>
<p class="noindenta">A set-user-ID program allows a process to gain privileges it would not normally have, by setting the process&#8217;s effective user ID to the same value as the user ID (owner) of the executable file. A set-group-ID program performs the analogous task for the process&#8217;s effective group ID. (The terms <em>set-user-ID program</em> and <em>set-group-ID</em> program are sometimes abbreviated as <em>set-UID program</em> and <em>set-GID program</em>.)</p>
<p class="indent">Like any other file, an executable program file has an associated user ID and group ID that define the ownership of the file. In addition, an executable file has two special permission bits: the set-user-ID and set-group-ID bits. (In fact, every file has these two permission bits, but it is their use with executable files that interests us here.) These permission bits are set using the <em>chmod</em> command. An unprivileged user can set these bits for files that they own. A privileged user (<span class="literal">CAP_FOWNER</span>) can set these bits for any file. Here&#8217;s an example:</p>
<p class="programs">$ <span class="codestrong">su</span><br/>Password:<br/># <span class="codestrong">ls -l prog</span><br/>-rwxr-xr-x&#160;&#160;&#160;&#160;1 root&#160;&#160;&#160;&#160;&#160;root&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;302585 Jun 26 15:05 prog<br/># <span class="codestrong">chmod u+s prog</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Turn on set-user-ID permission bit</span><br/># <span class="codestrong">chmod g+s prog</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Turn on set-group-ID permission bit</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_169"/>As shown in this example, it is possible for a program to have both of these bits set, although this is uncommon. When <em>ls &#8211;l</em> is used to list the permissions for a program that has the set-user-ID or set-group-ID permission bit set, then the <em>x</em> that is normally used to indicate that execute permission is set is replaced by an <em>s</em>:</p>
<p class="programs"># <span class="codestrong">ls -l prog</span><br/>-rwsr-sr-x&#160;&#160;&#160;&#160;1 root&#160;&#160;&#160;&#160;&#160;root&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;302585 Jun 26 15:05 prog</p>
<p class="noindent">When a set-user-ID program is run (i.e., loaded into a process&#8217;s memory by an <em>exec()</em>), the kernel sets the effective user ID of the process to be the same as the user ID of the executable file. Running a set-group-ID program has an analogous effect for the effective group ID of the process. Changing the effective user or group ID in this way gives a process (in other words, the user executing the program) privileges it would not normally have. For example, if an executable file is owned by <em>root</em> (superuser) and has the set-user-ID permission bit enabled, then the process gains superuser privileges when that program is run.</p>
<p class="indent">Set-user-ID and set-group-ID programs can also be designed to change the effective IDs of a process to something other than <em>root</em>. For example, to provide access to a protected file (or other system resource), it may suffice to create a special-purpose user (group) ID that has the privileges required to access the file, and create a set-user-ID (set-group-ID) program that changes the effective user (group) ID of a process to that ID. This permits the program to access the file without allowing it all of the privileges of the superuser.</p>
<p class="indent">Sometimes, we&#8217;ll use the term set-user-ID-<em>root</em> to distinguish a set-user-ID program that is owned by <em>root</em> from one owned by another user, which merely gives a process the privileges accorded to that user.</p>
<div class="block">
<p class="noindent">We have now started using the term <em>privileged</em> in two different senses. One is the sense defined earlier: a process with an effective user ID of 0, which has all of the privileges accorded to <em>root</em>. However, when we are talking about a set-user-ID program owned by a user other than <em>root</em>, we&#8217;ll sometimes refer to a process as gaining the privileges accorded to the user ID of the set-user-ID program. Which sense of the term <em>privileged</em> we mean in each case should be clear from the context.</p>
<p class="indent">For reasons that we explain in <a href="ch38.xhtml#ch38lev1sec03">Section 38.3</a>, the set-user-ID and set-group-ID permission bits don&#8217;t have any effect for shell scripts on Linux.</p>
</div>
<p class="noindent">Examples of commonly used set-user-ID programs on Linux include: <em>passwd(1)</em>, which changes a user&#8217;s password; <em>mount(8)</em> and <em>umount(8)</em>, which mount and unmount file systems; and <em>su(1)</em>, which allows a user to run a shell under a different user ID. An example of a set-group-ID program is <em>wall(1)</em>, which writes a message to all terminals owned by the <em>tty</em> group (normally, every terminal is owned by this group).</p>
<p class="indent">In <a href="ch08.xhtml#ch08lev1sec05">Section 8.5</a>, we noted that the program in <a href="ch08.xhtml#ch8ex2">Listing 8-2</a> needed to be run from a <em>root</em> login so that it could access the <span class="literal">/etc/shadow</span> file. We could make this program runnable by any user by making it a set-user-ID-<em>root</em> program, as follows:</p>
<p class="programs">$ <span class="codestrong">su</span><br/>Password:<br/># <span class="codestrong">chown root check_password</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Make this program owned by root</span><br/># <span class="codestrong">chmod u+s check_password</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">With the set-user-ID bit enabled</span><br/># <span class="codestrong">ls -l check_password</span><br/>-rwsr-xr-x&#160;&#160;&#160;&#160;1 root&#160;&#160;&#160;users&#160;&#160;&#160;&#160;18150 Oct 28 10:49 check_password<br/># <span class="codestrong">exit</span><br/>$ <span class="codestrong">whoami</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">This is an unprivileged login</span><br/>mtk<br/>$ <span class="codestrong">./check_password</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">But we can now access the shadow</span><br/>Username: <span class="codestrong">avr</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">password file using this program</span><br/>Password:<br/>Successfully authenticated: UID=1001</p>
<p class="noindent"><span epub:type="pagebreak" id="page_170"/>The set-user-ID/set-group-ID technique is a useful and powerful tool, but one that can result in security breaches in applications that are poorly designed. In <a href="ch38.xhtml#ch38">Chapter 38</a>, we list a set of good practices that should be observed when writing set-user-ID and set-group-ID programs.</p>
<h3 class="h3" id="ch09lev1sec04"><strong>9.4 Saved Set-User-ID and Saved Set-Group-ID</strong></h3>
<p class="noindenta">The saved set-user-ID and saved set-group-ID are designed for use with set-user-ID and set-group-ID programs. When a program is executed, the following steps (among many others) occur:</p>
<ol>
<li class="order"><p class="orderp">If the set-user-ID (set-group-ID) permission bit is enabled on the executable, then the effective user (group) ID of the process is made the same as the owner of the executable. If the set-user-ID (set-group-ID) bit is not set, then no change is made to the effective user (group) ID of the process.</p></li>
<li class="order"><p class="orderp">The values for the saved set-user-ID and saved set-group-ID are copied from the corresponding effective IDs. This copying occurs regardless of whether the set-user-ID or set-group-ID bit is set on the file being executed.</p></li>
</ol>
<p class="noindent">As an example of the effect of the above steps, suppose that a process whose real user ID, effective user ID, and saved set-user-ID are all 1000 execs a set-user-ID program owned by <em>root</em> (user ID 0). After the exec, the user IDs of the process will be changed as follows:</p>
<p class="programs">real=1000 effective=0 saved=0</p>
<p class="noindent">Various system calls allow a set-user-ID program to switch its effective user ID between the values of the real user ID and the saved set-user-ID. Analogous system calls allow a set-group-ID program to modify its effective group ID. In this manner, the program can temporarily drop and regain whatever privileges are associated with the user (group) ID of the execed file. (In other words, the program can move between the states of potentially being privileged and actually operating with privilege.) As we&#8217;ll elaborate in <a href="ch38.xhtml#ch38lev1sec02">Section 38.2</a>, it is secure programming practice for set-user-ID and set-group-ID programs to operate under the unprivileged (i.e., real) ID whenever the program doesn&#8217;t actually need to perform any operations associated with the privileged (i.e., saved set) ID.</p>
<div class="block">
<p class="noindent">The saved set-user-ID and saved set-group-ID are sometimes synonymously referred to as the <em>saved user ID</em> and <em>saved group ID</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_171"/>The saved set IDs are a System V invention adopted by POSIX. They were not provided on releases of BSD prior to 4.4. The initial POSIX.1 standard made support for these IDs optional, but later standards (starting with FIPS 151-1 in 1988) made support mandatory.</p>
</div>
<h3 class="h3" id="ch09lev1sec05"><strong>9.5 File-System User ID and File-System Group ID</strong></h3>
<p class="noindenta">On Linux, it is the file-system user and group IDs, rather than the effective user and group IDs, that are used (in conjunction with the supplementary group IDs) to determine permissions when performing file-system operations such as opening files, changing file ownership, and modifying file permissions. (The effective IDs are still used, as on other UNIX implementations, for the other purposes described earlier.)</p>
<p class="indent">Normally, the file-system user and group IDs have the same values as the corresponding effective IDs (and thus typically are the same as the corresponding real IDs). Furthermore, whenever the effective user or group ID is changed, either by a system call or by execution of a set-user-ID or set-group-ID program, the corresponding file-system ID is also changed to the same value. Since the file-system IDs follow the effective IDs in this way, this means that Linux effectively behaves just like any other UNIX implementation when privileges and permissions are being checked. The file-system IDs differ from the corresponding effective IDs, and hence Linux differs from other UNIX implementations, only when we use two Linux-specific system calls, <em>setfsuid()</em> and <em>setfsgid()</em>, to explicitly make them different.</p>
<p class="indent">Why does Linux provide the file-system IDs and in what circumstances would we want the effective and file-system IDs to differ? The reasons are primarily historical. The file-system IDs first appeared in Linux 1.2. In that kernel version, one process could send a signal to another if the effective user ID of the sender matched the real or effective user ID of the target process. This affected certain programs such as the Linux NFS (Network File System) server program, which needed to be able to access files as though it had the effective IDs of the corresponding client process. However, if the NFS server changed its effective user ID, it would be vulnerable to signals from unprivileged user processes. To prevent this possibility, the separate file-system user and group IDs were devised. By leaving its effective IDs unchanged, but changing its file-system IDs, the NFS server could masquerade as another user for the purpose of accessing files without being vulnerable to signals from user processes.</p>
<p class="indent">From kernel 2.0 onward, Linux adopted the SUSv3-mandated rules regarding permission for sending signals, and these rules don&#8217;t involve the effective user ID of the target process (refer to <a href="ch20.xhtml#ch20lev1sec05">Section 20.5</a>). Thus, the file-system ID feature is no longer strictly necessary (a process can nowadays achieve the desired results by making judicious use of the system calls described later in this chapter to change the value of the effective user ID to and from an unprivileged value, as required), but it remains for compatibility with existing software.</p>
<p class="indent">Since the file-system IDs are something of an oddity, and they normally have the same values as the corresponding effective IDs, in the remainder of this book, we&#8217;ll generally describe various file permission checks, as well as the setting of the <span epub:type="pagebreak" id="page_172"/>ownership of new files, in terms of the effective IDs of a process. Even though the process&#8217;s file-system IDs are really used for these purposes on Linux, in practice, their presence seldom makes an effective difference.</p>
<h3 class="h3" id="ch09lev1sec06"><strong>9.6 Supplementary Group IDs</strong></h3>
<p class="noindenta">The supplementary group IDs are a set of additional groups to which a process belongs. A new process inherits these IDs from its parent. A login shell obtains its supplementary group IDs from the system group file. As noted above, these IDs are used in conjunction with the effective and file-system IDs to determine permissions for accessing files, System V IPC objects, and other system resources.</p>
<h3 class="h3" id="ch09lev1sec07"><strong>9.7 Retrieving and Modifying Process Credentials</strong></h3>
<p class="noindenta">Linux provides a range of system calls and library functions for retrieving and changing the various user and group IDs that we have described in this chapter. Only some of these APIs are specified in SUSv3. Of the remainder, several are widely available on other UNIX implementations and a few are Linux-specific. We note portability issues as we describe each interface. Toward the end of this chapter, <a href="ch09.xhtml#ch9table1">Table 9-1</a> summarizes the operation of all of the interfaces used to change process credentials.</p>
<p class="indent">As an alternative to using the system calls described in the following pages, the credentials of any process can be found by examining the <span class="literal">Uid</span>, <span class="literal">Gid</span>, and <span class="literal">Groups</span> lines provided in the Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/status</span> file. The <span class="literal">Uid</span> and <span class="literal">Gid</span> lines list the identifiers in the order real, effective, saved set, and file system.</p>
<p class="indentb">In the following sections, we use the traditional definition of a privileged process as one whose effective user ID is 0. However, Linux divides the notion of superuser privileges into distinct capabilities, as described in <a href="ch39.xhtml#ch39">Chapter 39</a>. Two capabilities are relevant for our discussion of all of the system calls used to change process user and group IDs:</p>
<p class="bull">&#8226; The <span class="literal">CAP_SETUID</span> capability allows a process to make arbitrary changes to its user IDs.</p>
<p class="bull">&#8226; The <span class="literal">CAP_SETGID</span> capability allows a process to make arbitrary changes to its group IDs.</p>
<h4 class="h4" id="ch09lev2sec01"><strong>9.7.1 Retrieving and Modifying Real, Effective, and Saved Set IDs</strong></h4>
<p class="noindenta">In the following paragraphs, we describe the system calls that retrieve and modify the real, effective, and saved set IDs. There are several system calls that perform these tasks, and in some cases their functionality overlaps, reflecting the fact that the various system calls originated on different UNIX implementations.</p>
<h5 class="h5" id="ch09lev3sec01"><strong>Retrieving real and effective IDs</strong></h5>
<p class="noindenta">The <em>getuid()</em> and <em>getgid()</em> system calls return, respectively, the real user ID and real group ID of the calling process. The <em>geteuid()</em> and <em>getegid()</em> system calls perform the corresponding tasks for the effective IDs. These system calls are always successful.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_173"/>#include &lt;unistd.h&gt;<br/><br/>uid_t <span class="codestrong">getuid</span>(void);</p>
<p class="right">Returns real user ID of calling process</p>
<p class="programsat">uid_t <span class="codestrong">geteuid</span>(void);</p>
<p class="right">Returns effective user ID of calling process</p>
<p class="programsat">gid_t <span class="codestrong">getgid</span>(void);</p>
<p class="right">Returns real group ID of calling process</p>
<p class="programsat">gid_t <span class="codestrong">getegid</span>(void);</p>
<p class="right">Returns effective group ID of calling process</p>
</div>
<h5 class="h5" id="ch09lev3sec02"><strong>Modifying effective IDs</strong></h5>
<p class="noindenta">The <em>setuid()</em> system call changes the effective user ID&#8212;and possibly the real user ID and the saved set-user-ID&#8212;of the calling process to the value given by the <em>uid</em> argument. The <em>setgid()</em> system call performs the analogous task for the corresponding group IDs.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">setuid</span>(uid_t <span class="font1">uid</span>);<br/>int <span class="codestrong">setgid</span>(gid_t <span class="font1">gid</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The rules about what changes a process can make to its credentials using <em>setuid()</em> and <em>setgid()</em> depend on whether the process is privileged (i.e., has an effective user ID equal to 0). The following rules apply to <em>setuid()</em>:</p>
<ol>
<li class="order"><p class="orderp">When an unprivileged process calls <em>setuid()</em>, only the effective user ID of the process is changed. Furthermore, it can be changed only to the same value as either the real user ID or saved set-user-ID. (Attempts to violate this constraint yield the error <span class="literal">EPERM</span>.) This means that, for unprivileged users, this call is useful only when executing a set-user-ID program, since, for the execution of normal programs, the process&#8217;s real user ID, effective user ID, and saved set-user-ID all have the same value. On some BSD-derived implementations, calls to <em>setuid()</em> or <em>setgid()</em> by an unprivileged process have different semantics from other UNIX implementations: the calls change the real, effective, and saved set IDs (to the value of the current real or effective ID).</p></li>
<li class="order"><p class="orderp">When a privileged process executes <em>setuid()</em> with a nonzero argument, then the real user ID, effective user ID, and saved set-user-ID are all set to the value specified in the <em>uid</em> argument. This is a one-way trip, in that once a privileged process has changed its identifiers in this way, it loses all privileges and therefore can&#8217;t subsequently use <em>setuid()</em> to reset the identifiers back to 0. If this is not desired, then either <em>seteuid()</em> or <em>setreuid()</em>, which we describe shortly, should be used instead of <em>setuid()</em>.</p></li>
</ol>
<p class="noindent">The rules governing the changes that may be made to group IDs using <em>setgid()</em> are similar, but with <em>setgid()</em> substituted for <em>setuid()</em> and <em>group</em> for <em>user</em>. With these <span epub:type="pagebreak" id="page_174"/>changes, rule 1 applies exactly as stated. In rule 2, since changing the group IDs doesn&#8217;t cause a process to lose privileges (which are determined by the effective <em>user</em> ID), privileged programs can use <em>setgid()</em> to freely change the group IDs to any desired values.</p>
<p class="indent">The following call is the preferred method for a set-user-ID-<em>root</em> program whose effective user ID is currently 0 to irrevocably drop all privileges (by setting both the effective user ID and saved set-user-ID to the same value as the real user ID):</p>
<p class="programs">if (setuid(getuid()) == -1)<br/>&#160;&#160;&#160;&#160;errExit("setuid");</p>
<p class="noindent">A set-user-ID program owned by a user other than <em>root</em> can use <em>setuid()</em> to switch the effective user ID between the values of the real user ID and saved set-user-ID for the security reasons described in <a href="ch09.xhtml#ch09lev1sec04">Section 9.4</a>. However, <em>seteuid()</em> is preferable for this purpose, since it has the same effect, regardless of whether the set-user-ID program is owned by <em>root</em>.</p>
<p class="indent">A process can use <em>seteuid()</em> to change its effective user ID (to the value specified by <em>euid</em>), and <em>setegid()</em> to change its effective group ID (to the value specified by <em>egid</em>).</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">seteuid</span>(uid_t <span class="font1">euid</span>);<br/>int <span class="codestrong">setegid</span>(gid_t <span class="font1">egid</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The following rules govern the changes that a process may make to its effective IDs using <em>seteuid()</em> and <em>setegid()</em>:</p>
<ol>
<li class="order"><p class="orderp">An unprivileged process can change an effective ID only to the same value as the corresponding real or saved set ID. (In other words, for an unprivileged process, <em>seteuid()</em> and <em>setegid()</em> have the same effect as <em>setuid()</em> and <em>setgid()</em>, respectively, except for the BSD portability issues noted earlier.)</p></li>
<li class="order"><p class="orderp">A privileged process can change an effective ID to any value. If a privileged process uses <em>seteuid()</em> to change its effective user ID to a nonzero value, then it ceases to be privileged (but may be able to regain privilege via the previous rule).</p></li>
</ol>
<p class="noindent">Using <em>seteuid()</em> is the preferred method for set-user-ID and set-group-ID programs to temporarily drop and later regain privileges. Here&#8217;s an example:</p>
<p class="programs">euid = geteuid();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Save initial effective user ID (which<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;is same as saved set-user-ID) */<br/>if (seteuid(getuid()) == -1)&#160;&#160;&#160;&#160;/* Drop privileges */<br/>&#160;&#160;&#160;&#160;errExit("seteuid");<br/>if (seteuid(euid) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Regain privileges */<br/>&#160;&#160;&#160;&#160;errExit("seteuid");</p>
<p class="noindent">Originally derived from BSD, <em>seteuid()</em> and <em>setegid()</em> are now specified in SUSv3 and appear on most UNIX implementations.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_175"/>In older versions of the GNU C library (<em>glibc</em> 2.0 and earlier), <em>seteuid(euid)</em> is implemented as <em>setreuid(&#8211;1, euid)</em>. In modern versions of <em>glibc</em>, <em>seteuid(euid)</em> is implemented as <em>setresuid(&#8211;1, euid, &#8211;1)</em>. (We describe <em>setreuid()</em>, <em>setresuid()</em>, and their group analogs shortly.) Both implementations permit us to specify <em>euid</em> as the same value as the current effective user ID (i.e., no change). However, SUSv3 doesn&#8217;t specify this behavior for <em>seteuid()</em>, and it is not possible on some other UNIX implementations. Generally, this potential variation across implementations is not apparent, since, in normal circumstances, the effective user ID has the same value as either the real user ID or the saved set-user-ID. (The only way in which we can make the effective user ID differ from both the real user ID and the saved set-user-ID on Linux is via the use of the nonstandard <em>setresuid()</em> system call.)</p>
<p class="indent">Analogous remarks apply for the <em>glibc</em> implementation of <em>setegid(egid)</em>, except that the switch in implementation from <em>setregid(&#8211;1, egid)</em> to <em>setresgid(&#8211;1, egid, &#8211;1)</em> occurred in <em>glibc</em> 2.2 or 2.3 (the precise version depends on the hardware architecture).</p>
</div>
<h5 class="h5" id="ch09lev3sec03"><strong>Modifying real and effective IDs</strong></h5>
<p class="noindenta">The <em>setreuid()</em> system call allows the calling process to independently change the values of its real and effective user IDs. The <em>setregid()</em> system call performs the analogous task for the real and effective group IDs.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">setreuid</span>(uid_t <span class="font1">ruid</span>, uid_t <span class="font1">euid</span>);<br/>int <span class="codestrong">setregid</span>(gid_t <span class="font1">rgid</span>, gid_t <span class="font1">egid</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The first argument to each of these system calls is the new real ID. The second argument is the new effective ID. If we want to change only one of the identifiers, then we can specify &#8211;1 for the other argument.</p>
<p class="indent">Originally derived from BSD, <em>setreuid()</em> and <em>setregid()</em> are now specified in SUSv3 and are available on most UNIX implementations.</p>
<p class="indent">As with the other system calls described in this section, rules govern the changes that we can make using <em>setreuid()</em> and <em>setregid()</em>. We describe these rules from the point of view of <em>setreuid()</em>, with the understanding that <em>setregid()</em> is similar, except as noted:</p>
<ol>
<li class="order"><p class="orderp">An unprivileged process can set the real user ID only to the current value of the real (i.e., no change) or effective user ID. The effective user ID can be set only to the current value of the real user ID, effective user ID (i.e., no change), or saved set-user-ID.</p>
<div class="block1">
<p class="noindent">SUSv3 says that it is unspecified whether an unprivileged process can use <em>setreuid()</em> to change the value of the real user ID to the current value of the real user ID, effective user ID, or saved set-user-ID, and the details of precisely what changes can be made to the real user ID vary across implementations.</p>
<p class="indent"><span epub:type="pagebreak" id="page_176"/>SUSv3 describes slightly different behavior for <em>setregid()</em>: an unprivileged process can set the real group ID to the current value of the saved set-group-ID or set the effective group ID to the current value of either the real group ID or the saved set-group-ID. Again, the details of precisely what changes can be made vary across implementations.</p>
</div></li>
<li class="order"><p class="orderp">A privileged process can make any changes to the IDs.</p></li>
<li class="order"><p class="orderp">For both privileged and unprivileged processes, the saved set-user-ID is also set to the same value as the (new) effective user ID if either of the following is true:</p>
<p class="olista">a) <em>ruid</em> is not &#8211;1 (i.e., the real user ID is being set, even to the same value it already had), or</p>
<p class="olista">b) the effective user ID is being set to a value other than the value of the real user ID prior to the call.</p>
<p class="noindent">Put conversely, if a process uses <em>setreuid()</em> only to change the effective user ID to the same value as the current real user ID, then the saved set-user-ID is left unchanged, and a later call to <em>setreuid()</em> (or <em>seteuid()</em>) can restore the effective user ID to the saved set-user-ID value. (SUSv3 doesn&#8217;t specify the effect of <em>setreuid()</em> and <em>setregid()</em> on the saved set IDs, but SUSv4 specifies the behavior described here.)</p></li>
</ol>
<p class="noindent">The third rule provides a way for a set-user-ID program to permanently drop its privilege, using a call such as the following:</p>
<p class="programs">setreuid(getuid(), getuid());</p>
<p class="noindent">A set-user-ID-<em>root</em> process that wants to change both its user and group credentials to arbitrary values should first call <em>setregid()</em> and then call <em>setreuid()</em>. If the calls are made in the opposite order, then the <em>setregid()</em> call will fail, because the program will no longer be privileged after the call to <em>setreuid()</em>. Similar remarks apply if we are using <em>setresuid()</em> and <em>setresgid()</em> (described below) for this purpose.</p>
<div class="block">
<p class="noindent">BSD releases up to and including 4.3BSD did not have the saved set-user-ID and saved set-group-ID (which are nowadays mandated by SUSv3). Instead, on BSD, <em>setreuid()</em> and <em>setregid()</em> permitted a process to drop and regain privilege by swapping the values of the real and effective IDs back and forth. This had the undesirable side effect of changing the real user ID in order to change the effective user ID.</p>
</div>
<h5 class="h5" id="ch09lev3sec04"><strong>Retrieving real, effective, and saved set IDs</strong></h5>
<p class="noindenta">On most UNIX implementations, a process can&#8217;t directly retrieve (or update) its saved set-user-ID and saved set-group-ID. However, Linux provides two (nonstandard) system calls allowing us to do just that: <em>getresuid()</em> and <em>getresgid()</em>.</p>
<div class="box">
<p class="programsa">#define _GNU_SOURCE<br/>#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">getresuid</span>(uid_t *<span class="font1">ruid</span>, uid_t *<span class="font1">euid</span>, uid_t *<span class="font1">suid</span>);<br/>int <span class="codestrong">getresgid</span>(gid_t *<span class="font1">rgid</span>, gid_t *<span class="font1">egid</span>, gid_t *<span class="font1">sgid</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_177"/>The <em>getresuid()</em> system call returns the current values of the calling process&#8217;s real user ID, effective user ID, and saved set-user-ID in the locations pointed by its three arguments. The <em>getresgid()</em> system call does the same for the corresponding group IDs.</p>
<h5 class="h5" id="ch09lev3sec05"><strong>Modifying real, effective, and saved set IDs</strong></h5>
<p class="noindenta">The <em>setresuid()</em> system call allows the calling process to independently change the values of all three of its user IDs. The new values for each of the user IDs are specified by the three arguments to the system call. The <em>setresgid()</em> system call performs the analogous task for the group IDs.</p>
<div class="box">
<p class="programsa">#define _GNU_SOURCE<br/>#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">setresuid</span>(uid_t <span class="font1">ruid</span>, uid_t <span class="font1">euid</span>, uid_t <span class="font1">suid</span>);<br/>int <span class="codestrong">setresgid</span>(gid_t <span class="font1">rgid</span>, gid_t <span class="font1">egid</span>, gid_t <span class="font1">sgid</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">If we don&#8217;t want to change all of the identifiers, then specifying &#8211;1 for an argument leaves the corresponding identifier unchanged. For example, the following call is equivalent to <em>seteuid(x)</em>:</p>
<p class="programs">setresuid(-1, x, -1);</p>
<p class="noindent">The rules about what changes may be made by <em>setresuid()</em> (<em>setresgid()</em> is similar) are as follows:</p>
<ol>
<li class="order"><p class="orderp">An unprivileged process can set any of its real user ID, effective user ID, and saved set-user-ID to any of the values currently in its current real user ID, effective user ID, or saved set-user-ID.</p></li>
<li class="order"><p class="orderp">A privileged process can make arbitrary changes to its real user ID, effective user ID, and saved set-user-ID.</p></li>
<li class="order"><p class="orderp">Regardless of whether the call makes any changes to other IDs, the file-system user ID is always set to the same value as the (possibly new) effective user ID.</p></li>
</ol>
<p class="noindent">Calls to <em>setresuid()</em> and <em>setresgid()</em> have an all-or-nothing effect. Either all of the requested identifiers are successfully changed or none are changed. (The same comment applies with respect to the other system calls described in this chapter that change multiple identifiers.)</p>
<p class="indent">Although <em>setresuid()</em> and <em>setresgid()</em> provide the most straightforward API for changing process credentials, we can&#8217;t portably employ them in applications; they are not specified in SUSv3 and are available on only a few other UNIX implementations.</p>
<h4 class="h4" id="ch09lev2sec02"><strong>9.7.2 Retrieving and Modifying File-System IDs</strong></h4>
<p class="noindenta">All of the previously described system calls that change the process&#8217;s effective user or group ID also always change the corresponding file-system ID. To change the file-system IDs independently of the effective IDs, we must employ two Linux-specific system calls: <em>setfsuid()</em> and <em>setfsgid()</em>.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_178"/>#include &lt;sys/fsuid.h&gt;<br/><br/>int <span class="codestrong">setfsuid</span>(uid_t <span class="font1">fsuid</span>);</p>
<p class="right">Always returns the previous file-system user ID</p>
<p class="programsat">int <span class="codestrong">setfsgid</span>(gid_t <span class="font1">fsgid</span>);</p>
<p class="right">Always returns the previous file-system group ID</p>
</div>
<p class="noindent">The <em>setfsuid()</em> system call changes the file-system user ID of a process to the value specified by <em>fsuid</em>. The <em>setfsgid()</em> system call changes the file system group ID to the value specified by <em>fsgid</em>.</p>
<p class="indent">Again, there are rules about the kind of changes that can be made. The rules for <em>setfsgid()</em> are similar to the rules for <em>setfsuid()</em>, which are as follows:</p>
<ol>
<li class="order"><p class="orderp">An unprivileged process can set the file-system user ID to the current value of the real user ID, effective user ID, file-system user ID (i.e., no change), or saved set-user-ID.</p></li>
<li class="order"><p class="orderp">A privileged process can set the file-system user ID to any value.</p></li>
</ol>
<p class="noindent">The implementation of these calls is somewhat unpolished. To begin with, there are no corresponding system calls that retrieve the current value of the file-system IDs. In addition, the system calls do no error checking; if an unprivileged process attempts to set its file-system ID to an unacceptable value, the attempt is silently ignored. The return value from each of these system calls is the previous value of the corresponding file-system ID, <em>whether the call succeeds or fails</em>. Thus, we do have a way of finding out the current values of the file-system IDs, but only at the same time as we try (either successfully or unsuccessfully) to change them.</p>
<p class="indent">Use of the <em>setfsuid()</em> and <em>setfsgid()</em> system calls is no longer necessary on Linux and should be avoided in applications designed to be ported to other UNIX implementations.</p>
<h4 class="h4" id="ch09lev2sec03"><strong>9.7.3 Retrieving and Modifying Supplementary Group IDs</strong></h4>
<p class="noindenta">The <em>getgroups()</em> system call returns the set of groups of which the calling process is currently a member, in the array pointed to by <em>grouplist</em>.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">getgroups</span>(int <span class="font1">gidsetsize</span>, gid_t <span class="font1">grouplist</span>[]);</p>
<p class="right">Returns number of group IDs placed in <em>grouplist</em> on success, or &#8211;1 on error</p>
</div>
<p class="noindent">On Linux, as on most UNIX implementations, <em>getgroups()</em> simply returns the calling process&#8217;s supplementary group IDs. However, SUSv3 also allows an implementation to include the calling process&#8217;s effective group ID in the returned <em>grouplist</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_179"/>The calling program must allocate the <em>grouplist</em> array and specify its length in the argument <em>gidsetsize</em>. On successful completion, <em>getgroups()</em> returns the number of group IDs placed in <em>grouplist</em>.</p>
<p class="indent">If the number of groups of which a process is a member exceeds <em>gidsetsize</em>, <em>getgroups()</em> returns an error (<span class="literal">EINVAL</span>). To avoid this possibility, we can size the <em>grouplist</em> array to be one greater (to portably allow for the possible inclusion of the effective group ID) than the constant <span class="literal">NGROUPS_MAX</span> (defined in <span class="literal">&lt;limits.h&gt;</span>), which defines the maximum number of supplementary groups of which a process may be a member. Thus, we could declare <em>grouplist</em> as follows:</p>
<p class="programs">gid_t grouplist[NGROUPS_MAX + 1];</p>
<p class="noindent">In Linux kernels prior to 2.6.4, <span class="literal">NGROUPS_MAX</span> has the value 32. From kernel 2.6.4 onward, <span class="literal">NGROUPS_MAX</span> has the value 65,536.</p>
<p class="indentb">An application can also determine the <span class="literal">NGROUPS_MAX</span> limit at run time in the following ways:</p>
<p class="bull">&#8226; Call <em>sysconf(_SC_NGROUPS_MAX)</em>. (We explain the use of <em>sysconf()</em> in <a href="ch11.xhtml#ch11lev1sec02">Section 11.2</a>.)</p>
<p class="bull">&#8226; Read the limit from the read-only, Linux-specific <span class="literal">/proc/sys/kernel/ngroups_max</span> file. This file is provided since kernel 2.6.4.</p>
<p class="noindentt">Alternatively, an application can make a call to <em>getgroups()</em> specifying <em>gidsetsize</em> as 0. In this case, <em>grouplist</em> is not modified, but the return value of the call gives the number of groups of which the process is a member.</p>
<p class="indent">The value obtained by any of these run-time techniques can then be used to dynamically allocate a <em>grouplist</em> array for a future <em>getgroups()</em> call.</p>
<p class="indent">A privileged process can use <em>setgroups()</em> and <em>initgroups()</em> to change its set of supplementary group IDs.</p>
<div class="box">
<p class="programsa">#define _BSD_SOURCE<br/>#include &lt;grp.h&gt;<br/><br/>int <span class="codestrong">setgroups</span>(size_t <span class="font1">gidsetsize</span>, const gid_t *<span class="font1">grouplist</span>);<br/>int <span class="codestrong">initgroups</span>(const char *<span class="font1">user</span>, gid_t <span class="font1">group</span>);</p>
<p class="right">Both return 0 on success, or &#8211;1 on error</p>
</div>
<p class="indent">The <em>setgroups()</em> system call replaces the calling process&#8217;s supplementary group IDs with the set given in the array <em>grouplist</em>. The <em>gidsetsize</em> argument specifies the number of group IDs in the array argument <em>grouplist</em>.</p>
<p class="indent">The <em>initgroups()</em> function initializes the calling process&#8217;s supplementary group IDs by scanning <span class="literal">/etc/group</span> and building a list of all groups of which the named <em>user</em> is a member. In addition, the group ID specified in <em>group</em> is also added to the process&#8217;s set of supplementary group IDs.</p>
<p class="indent"><span epub:type="pagebreak" id="page_180"/>The primary users of <em>initgroups()</em> are programs that create login sessions&#8212;for example, <em>login(1)</em>, which sets various process attributes prior to executing the user&#8217;s login shell. Such programs typically obtain the value to be used for the <em>group</em> argument by reading the group ID field from the user&#8217;s record in the password file. This is slightly confusing, since the group ID from the password file is not really a supplementary group, Instead, it defines the initial real group ID, effective group ID, and saved set-group-ID of the login shell. Nevertheless, this is how <em>initgroups()</em> is usually employed.</p>
<p class="indent">Although not part of SUSv3, <em>setgroups()</em> and <em>initgroups()</em> are available on all UNIX implementations.</p>
<h4 class="h4" id="ch09lev2sec04"><strong>9.7.4 Summary of Calls for Modifying Process Credentials</strong></h4>
<p class="noindenta"><a href="ch09.xhtml#ch9table1">Table 9-1</a> summarizes the effects of the various system calls and library functions used to change process credentials.</p>
<p class="indent"><a href="ch09.xhtml#ch9fig1">Figure 9-1</a> provides a graphical overview of the same information given in <a href="ch09.xhtml#ch9table1">Table 9-1</a>. This diagram shows things from the perspective of the calls that change the user IDs, but the rules for changes to the group IDs are similar.</p>
<div class="image"><img src="../images/f09-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch9fig1"/><strong>Figure 9-1:</strong> Effect of credential-changing functions on process user IDs</p>
<p class="tablecap"><span epub:type="pagebreak" id="page_181"/><a id="ch9table1"/><strong>Table 9-1:</strong> Summary of interfaces used to change process credentials</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th" rowspan="2"><p class="tablec"><strong>Interface</strong></p></td>
<td style="vertical-align: top;" class="table_th" colspan="2"><p class="tablec"><strong>Purpose and effect within:</strong></p></td>
<td style="vertical-align: top;" class="table_th1" rowspan="2"><p class="tablec"><strong>Portability</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong>unprivileged process</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong>privileged process</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><em>setuid(u)</em><br/><em>setgid(g)</em></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Change effective ID to the same value as current real or saved set ID</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Change real, effective, and saved set IDs to any (single) value</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Specified in SUSv3; BSD derivatives have different semantics</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><em>seteuid(e)</em><br/><em>setegid(e)</em></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Change effective ID to the same value as current real or saved set ID</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Change effective ID to any value</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Specified in SUSv3</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><em>setreuid(r, e)</em><br/><em>setregid(r, e)</em></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">(Independently) change real ID to same value as current real or effective ID, and effective ID to same value as current real, effective, or saved set ID</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">(Independently) change real and effective IDs to any values</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Specified in SUSv3, but operation varies across implementations</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><em>setresuid(r, e, s)</em><br/><em>setresgid(r, e, s)</em></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">(Independently) change real, effective, and saved set IDs to same value as current real, effective, or saved set ID</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">(Independently) change real, effective, and saved set IDs to any values</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Not in SUSv3 and present on few other UNIX implementations</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><em>setfsuid(u)</em><br/><em>setfsgid(u)</em></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Change file-system ID to same value as current real, effective, file system, or saved set ID</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Change file-system ID to any value</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Linux-specific</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><em>setgroups(n, l)</em></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">Can&#8217;t be called from an unprivileged process</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">Set supplementary group IDs to any values</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Not in SUSv3, but available on all UNIX implementations</p></td>
</tr>
</tbody>
</table>
<p class="noindentb">Note the following supplementary information to <a href="ch09.xhtml#ch9table1">Table 9-1</a>:</p>
<p class="bull">&#8226; The <em>glibc</em> implementations of <em>seteuid()</em> and <em>setegid()</em> also allow the effective ID to be set to the same value it already has, but this is not specified in SUSv3.</p>
<p class="bull">&#8226; For calls to <em>setreuid()</em> and <em>setregid()</em> by both privileged and unprivileged processes, if <em>r</em> is not &#8211;1, or <em>e</em> is specified as a value different from the real ID prior to the call, then the saved set-user-ID or saved set-group-ID is also set to the same value as the (new) effective ID. (SUSv3 doesn&#8217;t specify that <em>setreuid()</em> and <em>setregid()</em> make changes to the saved set IDs.)</p>
<p class="bull">&#8226; Whenever the effective user (group) ID is changed, the Linux-specific file-system user (group) ID is changed to the same value.</p>
<p class="bull">&#8226; Calls to <em>setresuid()</em> always modify the file-system user ID to have the same value as the effective user ID, regardless of whether the effective user ID is changed by the call. Calls to <em>setresgid()</em> have an analogous effect on the file-system group ID.</p>
<h4 class="h4" id="ch09lev2sec05"><span epub:type="pagebreak" id="page_182"/><strong>9.7.5 Example: Displaying Process Credentials</strong></h4>
<p class="noindenta">The program in <a href="ch09.xhtml#ch9ex1">Listing 9-1</a> uses the system calls and library functions described in the preceding pages to retrieve all of the process&#8217;s user and group IDs, and then displays them.</p>
<p class="examplet"><a id="ch9ex1"/><strong>Listing 9-1:</strong> Display all process user and group IDs</p>
<p class="programsli">_________________________________________________________ <span class="codestrong">proccred/idshow.c</span><br/><br/>#define _GNU_SOURCE<br/>#include &lt;unistd.h&gt;<br/>#include &lt;sys/fsuid.h&gt;<br/>#include &lt;limits.h&gt;<br/>#include "ugid_functions.h"&#160;&#160;&#160;/* userNameFromId() &#38; groupNameFromId() */<br/>#include "tlpi_hdr.h"<br/><br/>#define SG_SIZE (NGROUPS_MAX + 1)<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;uid_t ruid, euid, suid, fsuid;<br/>&#160;&#160;&#160;&#160;gid_t rgid, egid, sgid, fsgid;<br/>&#160;&#160;&#160;&#160;gid_t suppGroups[SG_SIZE];<br/>&#160;&#160;&#160;&#160;int numGroups, j;<br/>&#160;&#160;&#160;&#160;char *p;<br/><br/>&#160;&#160;&#160;&#160;if (getresuid(&#38;ruid, &#38;euid, &#38;suid) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("getresuid");<br/>&#160;&#160;&#160;&#160;if (getresgid(&#38;rgid, &#38;egid, &#38;sgid) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("getresgid");<br/><br/>&#160;&#160;&#160;&#160;/* Attempts to change the file-system IDs are always ignored<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;for unprivileged processes, but even so, the following<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;calls return the current file-system IDs */<br/><br/>&#160;&#160;&#160;&#160;fsuid = setfsuid(0);<br/>&#160;&#160;&#160;&#160;fsgid = setfsgid(0);<br/><br/>&#160;&#160;&#160;&#160;printf("UID: ");<br/>&#160;&#160;&#160;&#160;p = userNameFromId(ruid);<br/>&#160;&#160;&#160;&#160;printf("real=%s (%ld); ", (p == NULL) ? "???" : p, (long) ruid);<br/>&#160;&#160;&#160;&#160;p = userNameFromId(euid);<br/>&#160;&#160;&#160;&#160;printf("eff=%s (%ld); ", (p == NULL) ? "???" : p, (long) euid);<br/>&#160;&#160;&#160;&#160;p = userNameFromId(suid);<br/>&#160;&#160;&#160;&#160;printf("saved=%s (%ld); ", (p == NULL) ? "???" : p, (long) suid);<br/>&#160;&#160;&#160;&#160;p = userNameFromId(fsuid);<br/>&#160;&#160;&#160;&#160;printf("fs=%s (%ld); ", (p == NULL) ? "???" : p, (long) fsuid);<br/>&#160;&#160;&#160;&#160;printf("\n");<br/><br/>&#160;&#160;&#160;&#160;printf("GID: ");<br/>&#160;&#160;&#160;&#160;p = groupNameFromId(rgid);<br/>&#160;&#160;&#160;&#160;printf("real=%s (%ld); ", (p == NULL) ? "???" : p, (long) rgid);<br/>&#160;&#160;&#160;&#160;p = groupNameFromId(egid);<br/>&#160;&#160;&#160;&#160;printf("eff=%s (%ld); ", (p == NULL) ? "???" : p, (long) egid);<br/>&#160;&#160;&#160;&#160;p = groupNameFromId(sgid);<br/>&#160;&#160;&#160;&#160;printf("saved=%s (%ld); ", (p == NULL) ? "???" : p, (long) sgid);<br/>&#160;&#160;&#160;&#160;p = groupNameFromId(fsgid);<br/>&#160;&#160;&#160;&#160;printf("fs=%s (%ld); ", (p == NULL) ? "???" : p, (long) fsgid);<br/>&#160;&#160;&#160;&#160;printf("\n");<br/><br/>&#160;&#160;&#160;&#160;numGroups = getgroups(SG_SIZE, suppGroups);<br/>&#160;&#160;&#160;&#160;if (numGroups == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("getgroups");<br/><br/>&#160;&#160;&#160;&#160;printf("Supplementary groups (%d): ", numGroups);<br/>&#160;&#160;&#160;&#160;for (j = 0; j &lt; numGroups; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p = groupNameFromId(suppGroups[j]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("%s (%ld) ", (p == NULL) ? "???" : p, (long) suppGroups[j]);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;printf("\n");<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________________ <span class="codestrong">proccred/idshow.c</span></p>
<h3 class="h3" id="ch09lev1sec08"><span epub:type="pagebreak" id="page_183"/><strong>9.8 Summary</strong></h3>
<p class="noindenta">Each process has a number of associated user and group IDs (credentials). The real IDs define the ownership of the process. On most UNIX implementations, the effective IDs are used to determine a process&#8217;s permissions when accessing resources such as files. On Linux, however, the file-system IDs are used for determining permissions for accessing files, while the effective IDs are used for other permission checks. (Because the file-system IDs normally have the same values as the corresponding effective IDs, Linux behaves in the same way as other UNIX implementations when checking file permissions.) A process&#8217;s supplementary group IDs are a further set of groups of which the process is considered to be a member for the purpose of permission checking. Various system calls and library functions allow a process to retrieve and change its user and group IDs.</p>
<p class="indent">When a set-user-ID program is run, the effective user ID of the process is set to that of the owner of the file. This mechanism allows a user to assume the identity, and thus the privileges, of another user while running a particular program. Correspondingly, set-group-ID programs change the effective group ID of the process running a program. The saved set-user-ID and saved set-group-ID allow set-user-ID and set-group-ID programs to temporarily drop and then later reassume privileges.</p>
<p class="indent">The user ID 0 is special. Normally, a single user account, named <em>root</em>, has this user ID. Processes with an effective user ID of 0 are privileged&#8212;that is, they are exempt from many of the permission checks normally performed when a process makes various system calls (such as those used to arbitrarily change the various process user and group IDs).</p>
<h3 class="h3" id="ch09lev1sec09"><span epub:type="pagebreak" id="page_184"/><strong>9.9 Exercises</strong></h3>
<p class="exer"><a id="ch9exe1"/><strong>9-1.</strong>&#160;&#160;&#160;&#160;&#160;Assume in each of the following cases that the initial set of process user IDs is <em>real=1000 effective=0 saved=0 file-system=0</em>. What would be the state of the user IDs after the following calls?</p>
<p class="olista1">a) <em>setuid(2000);</em></p>
<p class="olista1">b) <em>setreuid(&#8211;1, 2000);</em></p>
<p class="olista1">c) <em>seteuid(2000);</em></p>
<p class="olista1">d) <em>setfsuid(2000);</em></p>
<p class="olista1">e) <em>setresuid(&#8211;1, 2000, 3000);</em></p>
<p class="exer"><a id="ch9exe2"/><strong>9-2.</strong>&#160;&#160;&#160;&#160;&#160;Is a process with the following user IDs privileged? Explain your answer.</p>
<p class="programs1">real=0 effective=1000 saved=1000 file-system=1000</p>
<p class="exer"><a id="ch9exe3"/><strong>9-3.</strong>&#160;&#160;&#160;&#160;&#160;Implement <em>initgroups()</em> using <em>setgroups()</em> and library functions for retrieving information from the password and group files (<a href="ch08.xhtml#ch08lev1sec04">Section 8.4</a>). Remember that a process must be privileged in order to be able to call <em>setgroups()</em>.</p>
<p class="exer"><a id="ch9exe4"/><strong>9-4.</strong>&#160;&#160;&#160;&#160;&#160;If a process whose user IDs all have the value <em>X</em> executes a set-user-ID program whose user ID, <em>Y</em>, is nonzero, then the process credentials are set as follows:</p>
<p class="programs1">real=X effective=Y saved=Y</p>
<p class="exerp">(We ignore the file-system user ID, since it tracks the effective user ID.) Show the <em>setuid()</em>, <em>seteuid()</em>, <em>setreuid()</em>, and <em>setresuid()</em> calls, respectively, that would be used to perform the following operations:</p>
<p class="olista1">a) Suspend and resume the set-user-ID identity (i.e., switch the effective user ID to the value of the real user ID and then back to the saved set-user-ID).</p>
<p class="olista1">b) Permanently drop the set-user-ID identity (i.e., ensure that the effective user ID and the saved set-user-ID are set to the value of the real user ID).</p>
<p class="exerp">(This exercise also requires the use of <em>getuid()</em> and <em>geteuid()</em> to retrieve the process&#8217;s real and effective user IDs.) Note that for certain of the system calls listed above, some of these operations can&#8217;t be performed.</p>
<p class="exer"><a id="ch9exe5"/><strong>9-5.</strong>&#160;&#160;&#160;&#160;&#160;Repeat the previous exercise for a process executing a set-user-ID-<em>root</em> program, which has the following initial set of process credentials:</p>
<p class="programs1">real=X effective=0 saved=0</p>
</body>
</html>
