<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch27"><span epub:type="pagebreak" id="page_563"/><strong><span class="big">27</span></strong><br/><strong>PROGRAM EXECUTION</strong></h2>
<p class="noindenta">This chapter follows from our discussion of process creation and termination in the previous chapters. We now look at how a process can use the <em>execve()</em> system call to replace the program that it is running by a completely new program. We then show how to implement the <em>system()</em> function, which allows its caller to execute an arbitrary shell command.</p>
<h3 class="h3" id="ch27lev1sec01"><strong>27.1 Executing a New Program: <em>execve()</em></strong></h3>
<p class="noindenta">The <em>execve()</em> system call loads a new program into a process&#8217;s memory. During this operation, the old program is discarded, and the process&#8217;s stack, data, and heap are replaced by those of the new program. After executing various C library run-time startup code and program initialization code (e.g., C++ static constructors or C functions declared with the <em>gcc</em> <span class="literal">constructor</span> attribute described in <a href="ch42.xhtml#ch42lev1sec04">Section 42.4</a>), the new program commences execution at its <em>main()</em> function.</p>
<p class="indent">The most frequent use of <em>execve()</em> is in the child produced by a <em>fork()</em>, although it is also occasionally used in applications without a preceding <em>fork()</em>.</p>
<p class="indent">Various library functions, all with names beginning with <em>exec</em>, are layered on top of the <em>execve()</em> system call. Each of these functions provides a different interface to the same functionality. The loading of a new program by any of these calls is commonly referred to as an <em>exec</em> operation, or simply by the notation <em>exec()</em>. We begin with a description of <em>execve()</em> and then describe the library functions.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_564"/>#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">execve</span>(const char *<span class="font1">pathname</span>, char *const <span class="font1">argv</span>[], char *const <span class="font1">envp</span>[]);</p>
<p class="right">Never returns on success; returns &#8211;1 on error</p>
</div>
<p class="noindent">The <em>pathname</em> argument contains the pathname of the new program to be loaded into the process&#8217;s memory. This pathname can be absolute (indicated by an initial <span class="literal">/</span>) or relative to the current working directory of the calling process.</p>
<p class="indent">The <em>argv</em> argument specifies the command-line arguments to be passed to the new program. This array corresponds to, and has the same form as, the second (<em>argv</em>) argument to a C <em>main()</em> function; it is a <span class="literal">NULL</span>-terminated list of pointers to character strings. The value supplied for <em>argv[0]</em> corresponds to the command name. Typically, this value is the same as the basename (i.e., the final component) of <em>pathname</em>.</p>
<p class="indent">The final argument, <em>envp</em>, specifies the environment list for the new program. The <em>envp</em> argument corresponds to the <em>environ</em> array of the new program; it is a <span class="literal">NULL</span>-terminated list of pointers to character strings of the form <em>name=value</em> (<a href="ch06.xhtml#ch06lev1sec07">Section 6.7</a>).</p>
<div class="block">
<p class="noindent">The Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/exe</span> file is a symbolic link containing the absolute pathname of the executable file being run by the corresponding process.</p>
</div>
<p class="noindent">After an <em>execve()</em>, the process ID of the process remains the same, because the same process continues to exist. A few other process attributes also remain unchanged, as described in <a href="ch28.xhtml#ch28lev1sec04">Section 28.4</a>.</p>
<p class="indent">If the set-user-ID (set-group-ID) permission bit of the program file specified by <em>pathname</em> is set, then, when the file is execed, the effective user (group) ID of the process is changed to be the same as the owner (group) of the program file. This is a mechanism for temporarily granting privileges to users while running a specific program (see <a href="ch09.xhtml#ch09lev1sec03">Section 9.3</a>).</p>
<p class="indent">After optionally changing the effective IDs, and regardless of whether they were changed, an <em>execve()</em> copies the value of the process&#8217;s effective user ID into its saved set-user-ID, and copies the value of the process&#8217;s effective group ID into its saved set-group-ID.</p>
<p class="indentb">Since it replaces the program that called it, a successful <em>execve()</em> never returns. We never need to check the return value from <em>execve()</em>; it will always be &#8211;1. The very fact that it returned informs us that an error occurred, and, as usual, we can use <em>errno</em> to determine the cause. Among the errors that may be returned in <em>errno</em> are the following:</p>
<p class="term"><span class="literal">EACCES</span></p>
<p class="termlist">The <em>pathname</em> argument doesn&#8217;t refer to a regular file, the file doesn&#8217;t have execute permission enabled, or one of the directory components of <em>pathname</em> is not searchable (i.e., execute permission is denied on the directory). Alternatively, the file resides on a file system that was mounted with the <span class="literal">MS_NOEXEC</span> flag (<a href="ch14.xhtml#ch14lev2sec01">Section 14.8.1</a>).</p>
<p class="term"><span epub:type="pagebreak" id="page_565"/><span class="literal">ENOENT</span></p>
<p class="termlist">The file referred to by <em>pathname</em> doesn&#8217;t exist.</p>
<p class="term"><span class="literal">ENOEXEC</span></p>
<p class="termlist">The file referred to by <em>pathname</em> is marked as being executable, but it is not in a recognizable executable format. Possibly, it is a script that doesn&#8217;t begin with a line (starting with the characters <span class="literal">#!</span>) specifying a script interpreter.</p>
<p class="term"><span class="literal">ETXTBSY</span></p>
<p class="termlist">The file referred to by <em>pathname</em> is open for writing by one or more processes (<a href="ch04.xhtml#ch04lev2sec02">Section 4.3.2</a>).</p>
<p class="term"><span class="literal">E2BIG</span></p>
<p class="termlist">The total space required by the argument list and environment list exceeds the allowed maximum.</p>
<p class="noindentt">The errors listed above may also be generated if any of these conditions apply to the interpreter file defined to execute a script (refer to <a href="ch27.xhtml#ch27lev1sec03">Section 27.3</a>) or to the ELF interpreter being used to execute the program.</p>
<div class="block">
<p class="noindent">The Executable and Linking Format (ELF) is a widely implemented specification describing the layout of executable files. Normally, during an exec, a process image is constructed using the segments of the executable file (<a href="ch06.xhtml#ch06lev1sec03">Section 6.3</a>). However, the ELF specification also allows for an executable file to define an interpreter (the <span class="literal">PT_INTERP</span> ELF program header element) to be used to execute the program. If an interpreter is defined, the kernel constructs the process image from the segments of the specified interpreter executable file. It is then the responsibility of the interpreter to load and execute the program. We say a little more about the ELF interpreter in <a href="ch41.xhtml#ch41">Chapter 41</a> and provide some pointers to further information in that chapter.</p>
</div>
<h5 class="h5" id="ch27lev3sec01"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch27.xhtml#ch27ex1">Listing 27-1</a> demonstrates the use of <em>execve()</em>. This program creates an argument list and an environment for a new program, and then calls <em>execve()</em>, using its command-line argument (<em>argv[1]</em>) as the pathname to be executed.</p>
<p class="indent"><a href="ch27.xhtml#ch27ex2">Listing 27-2</a> shows a program that is designed to be executed by the program in <a href="ch27.xhtml#ch27ex1">Listing 27-1</a>. This program simply displays its command-line arguments and environment list (the latter is accessed using the global <em>environ</em> variable, as described in <a href="ch06.xhtml#ch06lev1sec07">Section 6.7</a>).</p>
<p class="indent">The following shell session demonstrates the use of the programs in <a href="ch27.xhtml#ch27ex1">Listing 27-1</a> and <a href="ch27.xhtml#ch27ex2">Listing 27-2</a> (in this example, a relative pathname is used to specify the program to be execed):</p>
<p class="programs">$ <span class="codestrong">./t_execve ./envargs</span><br/>argv[0] = envargs&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">All of the output is printed by</span> envargs<br/>argv[1] = hello world<br/>argv[2] = goodbye<br/>environ: GREET=salut<br/>environ: BYE=adieu</p>
<p class="examplet"><span epub:type="pagebreak" id="page_566"/><a id="ch27ex1"/><strong>Listing 27-1:</strong> Using <em>execve()</em> to execute a new program</p>
<p class="programsli">______________________________________________________ <span class="codestrong">procexec/t_execve.c</span><br/><br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;char *argVec[10];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Larger than required */<br/>&#160;&#160;&#160;&#160;char *envVec[] = { "GREET=salut", "BYE=adieu", NULL };<br/><br/>&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s pathname\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;argVec[0] = strrchr(argv[1], '/');&#160;&#160;&#160;&#160;&#160;&#160;/* Get basename from argv[1] */<br/>&#160;&#160;&#160;&#160;if (argVec[0] != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;argVec[0]++;<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;argVec[0] = argv[1];<br/>&#160;&#160;&#160;&#160;argVec[1] = "hello world";<br/>&#160;&#160;&#160;&#160;argVec[2] = "goodbye";<br/>&#160;&#160;&#160;&#160;argVec[3] = NULL;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* List must be NULL-terminated */<br/><br/>&#160;&#160;&#160;&#160;execve(argv[1], argVec, envVec);<br/>&#160;&#160;&#160;&#160;errExit("execve");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If we get here, something went wrong */<br/>}<br/>______________________________________________________ <span class="codestrong">procexec/t_execve.c</span></p>
<p class="examplet"><a id="ch27ex2"/><strong>Listing 27-2:</strong> Display argument list and environment</p>
<p class="programsli">_______________________________________________________ <span class="codestrong">procexec/envargs.c</span><br/><br/>#include "tlpi_hdr.h"<br/><br/>extern char **environ;<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int j;<br/>&#160;&#160;&#160;&#160;char **ep;<br/><br/>&#160;&#160;&#160;&#160;for (j = 0; j &lt; argc; j++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("argv[%d] = %s\n", j, argv[j]);<br/><br/>&#160;&#160;&#160;&#160;for (ep = environ; *ep != NULL; ep++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("environ: %s\n", *ep);<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_______________________________________________________ <span class="codestrong">procexec/envargs.c</span></p>
<h3 class="h3" id="ch27lev1sec02"><span epub:type="pagebreak" id="page_567"/><strong>27.2 The <em>exec()</em> Library Functions</strong></h3>
<p class="noindenta">The library functions described in this section provide alternative APIs for performing an <em>exec()</em>. All of these functions are layered on top of <em>execve()</em>, and they differ from one another and from <em>execve()</em> only in the way in which the program name, argument list, and environment of the new program are specified.</p>
<div class="box">
<p class="programsa">#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">execle</span>(const char *<span class="font1">pathname</span>, const char *<span class="font1">arg</span>, ...<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* , (char *) NULL, char *const <span class="font1">envp</span>[] */ );<br/>int <span class="codestrong">execlp</span>(const char *<span class="font1">filename</span>, const char *<span class="font1">arg</span>, ...<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* , (char *) NULL */);<br/>int <span class="codestrong">execvp</span>(const char *<span class="font1">filename</span>, char *const <span class="font1">argv</span>[]);<br/>int <span class="codestrong">execv</span>(const char *<span class="font1">pathname</span>, char *const <span class="font1">argv</span>[]);<br/>int <span class="codestrong">execl</span>(const char *<span class="font1">pathname</span>, const char *<span class="font1">arg</span>, ...<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* , (char *) NULL */);</p>
<p class="right">None of the above returns on success; all return &#8211;1 on error</p>
</div>
<p class="noindentb">The final letters in the names of these functions provide a clue to the differences between them. These differences are summarized in <a href="ch27.xhtml#ch27table1">Table 27-1</a> and detailed in the following list:</p>
<p class="bull">&#8226; Most of the <em>exec()</em> functions expect a pathname as the specification of the new program to be loaded. However, <em>execlp()</em> and <em>execvp()</em> allow the program to be specified using just a filename. The filename is sought in the list of directories specified in the <span class="literal">PATH</span> environment variable (explained in more detail below). This is the kind of searching that the shell performs when given a command name. To indicate this difference in operation, the names of these functions contain the letter <em>p</em> (for <span class="literal">PATH</span>). The <span class="literal">PATH</span> variable is not used if the filename contains a slash (<span class="literal">/</span>), in which case it is treated as a relative or absolute pathname.</p>
<p class="bull">&#8226; Instead of using an array to specify the <em>argv</em> list for the new program, <em>execle()</em>, <em>execlp()</em>, and <em>execl()</em> require the programmer to specify the arguments as a list of strings within the call. The first of these arguments corresponds to <em>argv[0]</em> in the <em>main</em> function of the new program, and is thus typically the same as the <em>filename</em> argument or the basename component of the <em>pathname</em> argument. A <span class="literal">NULL</span> pointer must terminate the argument list, so that these calls can locate the end of the list. (This requirement is indicated by the commented <em>(char *) NULL</em> in the above prototypes; for a discussion of why the cast is required before the <span class="literal">NULL</span>, see <a href="app03.xhtml#app03">Appendix C</a>.) The names of these functions contain the letter <em>l</em> (for <em>list</em>) to distinguish them from those functions requiring the argument list as a <span class="literal">NULL</span>-terminated array. The names of the functions that require the argument list as an array (<em>execve()</em>, <em>execvp()</em>, and <em>execv()</em>) contain the letter <em>v</em> (for <em>vector</em>).</p>
<p class="bull"><span epub:type="pagebreak" id="page_568"/>&#8226; The <em>execve()</em> and <em>execle()</em> functions allow the programmer to explicitly specify the environment for the new program using <em>envp</em>, a <span class="literal">NULL</span>-terminated array of pointers to character strings. The names of these functions end with the letter <em>e</em> (for <em>environment</em>) to indicate this fact. All of the other <em>exec()</em> functions use the caller&#8217;s existing environment (i.e., the contents of <em>environ</em>) as the environment for the new program.</p>
<div class="block">
<p class="noindent">Version 2.11 of <em>glibc</em> added a nonstandard function, <em>execvpe(file, argv, envp)</em>. This function is like <em>execvp()</em>, but instead of taking the environment for the new program from <em>environ</em>, the caller specifies the new environment via the <em>envp</em> argument (like <em>execve()</em> and <em>execle()</em>).</p>
</div>
<p class="noindent">In the next few pages, we demonstrate the use of some of these <em>exec()</em> variants.</p>
<p class="tablecap"><a id="ch27table1"/><strong>Table 27-1:</strong> Summary of differences between the <em>exec()</em> functions</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Function</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Specification of program file <em>(&#8211;, p)</em></strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Specification of arguments <em>(v, l)</em></strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Source of environment <em>(e, &#8211;)</em></strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>execve()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">pathname</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">array</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>envp</em> argument</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>execle()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">pathname</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">list</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table"><em>envp</em> argument</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>execlp()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">filename + <span class="literal">PATH</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">list</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">caller&#8217;s <em>environ</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>execvp()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">filename + <span class="literal">PATH</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">array</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">caller&#8217;s <em>environ</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><em>execv()</em></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">pathname</p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">array</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">caller&#8217;s <em>environ</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><em>execl()</em></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">pathname</p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">list</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">caller&#8217;s <em>environ</em></p></td>
</tr>
</tbody>
</table>
<h4 class="h4" id="ch27lev2sec01"><strong>27.2.1 The</strong> <span class="literal"><span class="codestrong">PATH</span></span> <strong>Environment Variable</strong></h4>
<p class="noindenta">The <em>execvp()</em> and <em>execlp()</em> functions allow us to specify just the name of the file to be executed. These functions make use of the <span class="literal">PATH</span> environment variable to search for the file. The value of <span class="literal">PATH</span> is a string consisting of colon-separated directory names called <em>path prefixes</em>. As an example, the following <span class="literal">PATH</span> value specifies five directories:</p>
<p class="programs">$ <span class="codestrong">echo $PATH</span><br/>/home/mtk/bin:/usr/local/bin:/usr/bin:/bin:.</p>
<p class="noindent">The <span class="literal">PATH</span> value for a login shell is set by system-wide and user-specific shell startup scripts. Since a child process inherits a copy of its parent&#8217;s environment variables, each process that the shell creates to execute a command inherits a copy of the shell&#8217;s <span class="literal">PATH</span>.</p>
<p class="indent">The directory pathnames specified in <span class="literal">PATH</span> can be either absolute (commencing with an initial <span class="literal">/</span>) or relative. A relative pathname is interpreted with respect to the current working directory of the calling process. The current working directory can be specified using <span class="literal">.</span> (dot), as in the above example.</p>
<div class="block">
<p class="noindent">It is also possible to specify the current working directory by including a zero-length prefix in <span class="literal">PATH</span>, by employing consecutive colons, an initial colon, or a trailing colon (e.g., <span class="literal">/usr/bin:/bin:</span>). SUSv3 declares this technique obsolete; the current working directory should be explicitly specified using <span class="literal">.</span> (dot).</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_569"/>If the <span class="literal">PATH</span> variable is not defined, then <em>execvp()</em> and <em>execlp()</em> assume a default path list of <span class="literal">.:/usr/bin:/bin</span>.</p>
<p class="indent">As a security measure, the superuser account (<em>root</em>) is normally set up so that the current working directory is excluded from <span class="literal">PATH</span>. This prevents <em>root</em> from accidentally executing a file from the current working directory (which may have been deliberately placed there by a malicious user) with the same name as a standard command or with a name that is a misspelling of a common command (e.g., <em>sl</em> instead of <em>ls</em>). In some Linux distributions, the default value for <span class="literal">PATH</span> also excludes the current working directory for unprivileged users. We assume such a <span class="literal">PATH</span> definition in all of the shell session logs shown in this book, which is why we always prefix <span class="literal">./</span> to the names of programs executed from the current working directory. (This also has the useful side effect of visually distinguishing our programs from standard commands in the shell session logs shown in this book.)</p>
<p class="indent">The <em>execvp()</em> and <em>execlp()</em> functions search for the filename in each of the directories named in <span class="literal">PATH</span>, starting from the beginning of the list and continuing until a file with the given name is successfully execed. Using the <span class="literal">PATH</span> environment variable in this way is useful if we don&#8217;t know the run-time location of an executable file or don&#8217;t want to create a hard-coded dependency on that location.</p>
<p class="indent">The use of <em>execvp()</em> and <em>execlp()</em> in set-user-ID or set-group-ID programs should be avoided, or at least approached with great caution. In particular, the <span class="literal">PATH</span> environment variable should be carefully controlled to prevent the execing of a malicious program. In practice, this means that the application should override any previously defined <span class="literal">PATH</span> value with a known-secure directory list.</p>
<p class="indent"><a href="ch27.xhtml#ch27ex3">Listing 27-3</a> provides an example of the use of <em>execlp()</em>. The following shell session log demonstrates the use of this program to invoke the <em>echo</em> command (<span class="literal">/bin/echo</span>):</p>
<p class="programs">$ <span class="codestrong">which echo</span><br/>/bin/echo<br/>$ <span class="codestrong">ls -l /bin/echo</span><br/>-rwxr-xr-x&#160;&#160;&#160;&#160;1 root&#160;&#160;&#160;&#160;&#160;&#160;15428 Mar 19 21:28 /bin/echo<br/>$ <span class="codestrong">echo $PATH</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Show contents of</span> PATH <span class="font1">environment variable</span><br/>/home/mtk/bin:/usr/local/bin:/usr/bin:/bin&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/bin <span class="font1">is in</span> PATH<br/>$ <span class="codestrong">./t_execlp echo</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">execlp() uses</span> PATH <span class="font1">to successfully find</span> echo<br/>hello world</p>
<p class="noindent">The string <em>hello world</em> that appears above was supplied as the third argument of the call to <em>execlp()</em> in the program in <a href="ch27.xhtml#ch27ex3">Listing 27-3</a>.</p>
<p class="indent">We continue by redefining <span class="literal">PATH</span> to omit <span class="literal">/bin</span>, which is the directory containing the <em>echo</em> program:</p>
<p class="programs">$ <span class="codestrong">PATH=/home/mtk/bin:/usr/local/bin:/usr/bin</span><br/>$ <span class="codestrong">./t_execlp echo</span><br/>ERROR [ENOENT No such file or directory] execlp<br/>$ <span class="codestrong">./t_execlp /bin/echo</span><br/>hello world</p>
<p class="noindent">As can be seen, when we supply a filename (i.e., a string containing no slashes) to <em>execlp()</em>, the call fails, since a file named <span class="literal">echo</span> was not found in any of the directories listed in <span class="literal">PATH</span>. On the other hand, when we provide a pathname containing one or more slashes, <em>execlp()</em> ignores the contents of <span class="literal">PATH</span>.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_570"/><a id="ch27ex3"/><strong>Listing 27-3:</strong> Using <em>execlp()</em> to search for a filename in <span class="literal">PATH</span></p>
<p class="programsli">______________________________________________________ <span class="codestrong">procexec/t_execlp.c</span><br/><br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s pathname\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;execlp(argv[1], argv[1], "hello world", (char *) NULL);<br/>&#160;&#160;&#160;&#160;errExit("execlp");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If we get here, something went wrong */<br/>}<br/>______________________________________________________ <span class="codestrong">procexec/t_execlp.c</span></p>
<h4 class="h4" id="ch27lev2sec02"><strong>27.2.2 Specifying Program Arguments as a List</strong></h4>
<p class="noindenta">When we know the number of arguments for an <em>exec()</em> at the time we write a program, we can use <em>execle()</em>, <em>execlp()</em>, or <em>execl()</em> to specify the arguments as a list within the function call. This can be convenient, since it requires less code than assembling the arguments in an <em>argv</em> vector. The program in <a href="ch27.xhtml#ch27ex4">Listing 27-4</a> achieves the same result as the program in <a href="ch27.xhtml#ch27ex1">Listing 27-1</a> but using <em>execle()</em> instead of <em>execve()</em>.</p>
<p class="examplet"><a id="ch27ex4"/><strong>Listing 27-4:</strong> Using <em>execle()</em> to specify program arguments as a list</p>
<p class="programsli">______________________________________________________ <span class="codestrong">procexec/t_execle.c</span><br/><br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;char *envVec[] = { "GREET=salut", "BYE=adieu", NULL };<br/>&#160;&#160;&#160;&#160;char *filename;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s pathname\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;filename = strrchr(argv[1], '/');&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get basename from argv[1] */<br/>&#160;&#160;&#160;&#160;if (filename != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;filename++;<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;filename = argv[1];<br/><br/>&#160;&#160;&#160;&#160;execle(argv[1], filename, "hello world", "goodbye", (char *) NULL, envVec);<br/>&#160;&#160;&#160;&#160;errExit("execle");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If we get here, something went wrong */<br/>}<br/>______________________________________________________ <span class="codestrong">procexec/t_execle.c</span></p>
<h4 class="h4" id="ch27lev2sec03"><strong>27.2.3 Passing the Caller&#8217;s Environment to the New Program</strong></h4>
<p class="noindenta">The <em>execlp()</em>, <em>execvp()</em>, <em>execl()</em>, and <em>execv()</em> functions don&#8217;t permit the programmer to explicitly specify an environment list; instead, the new program inherits its environment from the calling process (<a href="ch06.xhtml#ch06lev1sec07">Section 6.7</a>). This may, or may not, be desirable. For <span epub:type="pagebreak" id="page_571"/>security reasons, it is sometimes preferable to ensure that a program is execed with a known environment list. We consider this point further in <a href="ch38.xhtml#ch38lev1sec08">Section 38.8</a>.</p>
<p class="indent"><a href="ch27.xhtml#ch27ex5">Listing 27-5</a> demonstrates that the new program inherits its environment from the caller during an <em>execl()</em> call. This program first uses <em>putenv()</em> to make a change to the environment that it inherits from the shell as a result of <em>fork()</em>. Then the <em>printenv</em> program is execed to display the values of the <span class="literal">USER</span> and <span class="literal">SHELL</span> environment variables. When we run this program, we see the following:</p>
<p class="programs">$ <span class="codestrong">echo $USER $SHELL</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Display some of the shell's environment variables</span><br/>blv /bin/bash<br/>$ <span class="codestrong">./t_execl</span><br/>Initial value of USER: blv&#160;&#160;&#160;&#160;<span class="font1">Copy of environment was inherited from the shell</span><br/>britta&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">These two lines are displayed by execed printenv</span><br/>/bin/bash</p>
<p class="examplet"><a id="ch27ex5"/><strong>Listing 27-5:</strong> Passing the caller&#8217;s environment to the new program using <em>execl()</em></p>
<p class="programsli">_______________________________________________________ <span class="codestrong">procexec/t_execl.c</span><br/><br/>#include &lt;stdlib.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;printf("Initial value of USER: %s\n", getenv("USER"));<br/>&#160;&#160;&#160;&#160;if (putenv("USER=britta") != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("putenv");<br/><br/>&#160;&#160;&#160;&#160;execl("/usr/bin/printenv", "printenv", "USER", "SHELL", (char *) NULL);<br/>&#160;&#160;&#160;&#160;errExit("execl");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* If we get here, something went wrong */<br/>}<br/>_______________________________________________________ <span class="codestrong">procexec/t_execl.c</span></p>
<h4 class="h4" id="ch27lev2sec04"><strong>27.2.4 Executing a File Referred to by a Descriptor: <em>fexecve()</em></strong></h4>
<p class="noindenta">Since version 2.3.2, <em>glibc</em> provides <em>fexecve()</em>, which behaves just like <em>execve()</em>, but specifies the file to be execed via the open file descriptor <em>fd</em>, rather than as a pathname. Using <em>fexecve()</em> is useful for applications that want to open a file, verify its contents by performing a checksum, and then execute the file.</p>
<div class="box">
<p class="programsa">#define _GNU_SOURCE<br/>#include &lt;unistd.h&gt;<br/><br/>int <span class="codestrong">fexecve</span>(int <span class="font1">fd</span>, char *const <span class="font1">argv</span>[], char *const <span class="font1">envp</span>[]);</p>
<p class="right">Doesn&#8217;t return on success; returns &#8211;1 on error</p>
</div>
<p class="noindent">Without <em>fexecve()</em>, we could <em>open()</em> and read the file to verify its contents, and then exec it. However, this would allow the possibility that, between opening the file and execing it, the file was replaced (holding an open file descriptor doesn&#8217;t prevent a new file with the same name from being created), so that the content that was execed was different from the content that was checked.</p>
<h3 class="h3" id="ch27lev1sec03"><span epub:type="pagebreak" id="page_572"/><strong>27.3 Interpreter Scripts</strong></h3>
<p class="noindenta">An <em>interpreter</em> is a program that reads commands in text form and executes them. (This contrasts with a <em>compiler</em>, which translates input source code into a machine language that can then be executed on a real or virtual machine.) Examples of interpreters include the various UNIX shells and programs such as <em>awk</em>, <em>sed</em>, <em>perl</em>, <em>python</em>, and <em>ruby</em>. In addition to being able to read and execute commands interactively, interpreters usually provide a facility to read and execute commands from a text file, referred to as a <em>script</em>.</p>
<p class="indent">UNIX kernels allow interpreter scripts to be run in the same way as a binary program file, as long as two requirements are met. First, execute permission must be enabled for the script file. Second, the file must contain an initial line that specifies the pathname of the interpreter to be used to run the script. This line has the following form:</p>
<div class="box2">
<p class="noindenta"><span class="literal">#!</span> <em>interpreter-path</em> <span class="literal">[</span> <em>optional-arg</em> <span class="literal">]</span></p>
</div>
<p class="noindent">The <span class="literal">#!</span> characters must be placed at the start of the line; optionally, a space may separate these characters from the interpreter pathname. The <span class="literal">PATH</span> environment variable is <em>not</em> used in interpreting this pathname, so that an absolute pathname usually should be specified. A relative pathname is also possible, though unusual; it is interpreted relative to the current working directory of the process starting the interpreter. White space separates the interpreter pathname from an optional argument, whose purpose we explain shortly. The optional argument should not contain white-space characters.</p>
<p class="indent">As an example, UNIX shell scripts usually begin with the following line, which specifies that the shell is to be used to execute the script:</p>
<p class="programs">#!/bin/sh</p>
<div class="block">
<p class="noindent">The optional argument in the first line of the interpreter script file should not contain white space because the behavior in this case is highly implementation-dependent. On Linux, white space in <em>optional-arg</em> is not interpreted specially&#8212;all of the text from the start of the argument to the end of the line is interpreted as a single word (which is given as an argument to the interpreter, as we describe below). Note that this treatment of spaces contrasts with the shell, where white space delimits the words of a command line.</p>
<p class="indent">While some UNIX implementations treat white space in <em>optional-arg</em> in the same way as Linux, other implementations do not. On FreeBSD before version 6.0, multiple space-delimited optional arguments may follow <em>interpreter-path</em> (and these are passed as separate words to the interpreter); since version 6.0, FreeBSD behaves like Linux. On Solaris 8, white-space characters terminate <em>optional-arg</em>, and any remaining text in the <span class="literal">#!</span> line is ignored.</p>
</div>
<p class="noindent">The Linux kernel places a 127-character limit on the length of the <span class="literal">#!</span> line of a script (excluding the newline character at the end of the line). Additional characters are silently ignored.</p>
<p class="indent">The <span class="literal">#!</span> technique for interpreter scripts is not specified in SUSv3, but is available on most UNIX implementations.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_573"/>The limit placed on the length of the <span class="literal">#!</span> line varies across UNIX implementations. For example, the limit is 64 characters in OpenBSD 3.1 and 1024 characters on Tru64 5.1. On some historical implementations (e.g., SunOS 4), this limit was as low as 32 characters.</p>
</div>
<h5 class="h5" id="ch27lev3sec02"><strong>Execution of interpreter scripts</strong></h5>
<p class="noindenta">Since a script doesn&#8217;t contain binary machine code, when <em>execve()</em> is used to run the script, obviously something different from usual must be occurring when the script is executed. If <em>execve()</em> detects that the file it has been given commences with the 2-byte sequence <span class="literal">#!</span>, then it extracts the remainder of the line (the pathname and argument), and execs the interpreter file with the following list of arguments:</p>
<div class="box2">
<p class="noindenta"><em>interpreter-path</em> <span class="literal">[</span> <em>optional-arg</em> <span class="literal">]</span> <em>script-path arg</em><span class="literal">...</span></p>
</div>
<p class="noindent">Here, <em>interpreter-path</em> and <em>optional-arg</em> are taken from the <span class="literal">#!</span> line of the script, <em>script-path</em> is the pathname given to <em>execve()</em>, and <em>arg...</em> is the list of any further arguments specified via the <em>argv</em> argument to <em>execve()</em> (but excluding <em>argv[0]</em>). The origin of each of the script arguments is summarized in <a href="ch27.xhtml#ch27fig1">Figure 27-1</a>.</p>
<div class="image"><img src="../images/f27-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch27fig1"/><strong>Figure 27-1:</strong> The argument list supplied to an execed script</p>
<p class="noindent">We can demonstrate the origin of the interpreter arguments by writing a script that uses the program in <a href="ch06.xhtml#ch6ex2">Listing 6-2</a> (<span class="literal">necho.c</span>, on <a href="ch06.xhtml#page_123">page 123</a>) as an interpreter. This program simply echoes all of its command-line arguments. We then use the program in <a href="ch27.xhtml#ch27ex1">Listing 27-1</a> to exec the script:</p>
<p class="programs">$ <span class="codestrong">cat &gt; necho.script</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Create script</span><br/>#!/home/mtk/bin/necho some argument<br/>Some junk<br/><span class="font1">Type Control-D</span><br/>$ <span class="codestrong">chmod +x necho.script</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Make script executable</span><br/>$ <span class="codestrong">./t_execve necho.script</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">And exec the script</span><br/>argv[0] = /home/mtk/bin/necho&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">First 3 arguments are generated by kernel</span><br/>argv[1] = some argument&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Script argument is treated as a single word</span><br/>argv[2] = necho.script&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">This is the script path</span><br/>argv[3] = hello world&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">This was argVec[1] given to execve()</span><br/>argv[4] = goodbye&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">And this was argVec[2]</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_574"/>In this example, our &#8220;interpreter&#8221; (<span class="literal">necho</span>) ignores the contents of its script file (<span class="literal">necho.script</span>), and the second line of the script (<em>Some junk</em>) has no effect on its execution.</p>
<div class="block">
<p class="noindent">The Linux 2.2 kernel passes only the basename part of the <em>interpreter-path</em> as the first argument when invoking a script. Consequently, on Linux 2.2, the line displaying <em>argv[0]</em> would show just the value <em>necho</em>.</p>
</div>
<p class="noindent">Most UNIX shells and interpreters treat the <span class="literal">#</span> character as the start of a comment. Thus, these interpreters ignore the initial <span class="literal">#!</span> line when interpreting the script.</p>
<h5 class="h5" id="ch27lev3sec03"><strong>Using the script <em>optional-arg</em></strong></h5>
<p class="noindenta">One use of the <em>optional-arg</em> in a script&#8217;s initial <span class="literal">#!</span> line is to specify command-line options for the interpreter. This feature is useful with certain interpreters, such as <em>awk</em>.</p>
<div class="block">
<p class="noindent">The <em>awk</em> interpreter has been part of the UNIX system since the late 1970s. The <em>awk</em> language is described in a number of books, including one by its creators [<a href="bib.xhtml#bib01">Aho et al., 1988</a>], whose initials gave the language its name. Its forte is rapid prototyping of text-processing applications. In its design&#8212;a weakly typed language, with a rich set of text-handling primitives, and a syntax based on C&#8212;<em>awk</em> is the ancestor of many widely used contemporary scripting languages, such as JavaScript and PHP.</p>
</div>
<p class="noindent">A script can be supplied to <em>awk</em> in two different ways. The default is to provide the script as the first command-line argument to <em>awk</em>:</p>
<p class="programs">$ <span class="codestrong">awk '<span class="codeitalic">script</span>' <span class="codeitalic">input-file</span></span>...</p>
<p class="noindent">Alternatively, an <em>awk</em> script can reside inside a file, as in the following <em>awk</em> script, which prints out the length of the longest line of its input:</p>
<p class="programs">$ <span class="codestrong">cat longest_line.awk</span><br/>#!/usr/bin/awk<br/>length &gt; max { max = length; }<br/>END&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ print max; }</p>
<p class="noindent">Suppose that we try execing this script using the following C code:</p>
<p class="programs">execl("longest_line.awk", "longest_line.awk", "input.txt", (char *) NULL);</p>
<p class="noindent">This <em>execl()</em> call in turn employs <em>execve()</em> with the following argument list to invoke <em>awk</em>:</p>
<p class="programs">/usr/bin/awk longest_line.awk input.txt</p>
<p class="noindent">This <em>execve()</em> call fails, because <em>awk</em> interprets the string <em>longest_line.awk</em> as a script containing an invalid <em>awk</em> command. We need a way of informing <em>awk</em> that this argument is actually the name of a file containing the script. We can do this by adding the <em>&#8211;f</em> option as the optional argument in the script&#8217;s <span class="literal">#!</span> line. This tells <em>awk</em> that the following argument is a script file:</p>
<p class="programs">#!/usr/bin/awk -f<br/>length &gt; max { max = length; }<br/>END&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ print max; }</p>
<p class="noindent"><span epub:type="pagebreak" id="page_575"/>Now, our <em>execl()</em> call results in the following argument list being used:</p>
<p class="programs">/usr/bin/awk -f longest_line.awk input.txt</p>
<p class="noindent">This successfully invokes <em>awk</em> using the script <span class="literal">longest_line.awk</span> to process the file <span class="literal">input.txt</span>.</p>
<h5 class="h5" id="ch27lev3sec04"><strong>Executing scripts with <em>execlp()</em> and <em>execvp()</em></strong></h5>
<p class="noindenta">Normally, the absence of a <span class="literal">#!</span> line at the start of a script causes the <em>exec()</em> functions to fail. However, <em>execlp()</em> and <em>execvp()</em> do things somewhat differently. Recall that these are the functions that use the <span class="literal">PATH</span> environment variable to obtain a list of directories in which to search for a file to be executed. If either of these functions finds a file that has execute permission turned on, but is not a binary executable and does not start with a <span class="literal">#!</span> line, then they exec the shell to interpret the file. On Linux, this means that such files are treated as though they started with a line containing the string <span class="literal">#!/bin/sh</span>.</p>
<h3 class="h3" id="ch27lev1sec04"><strong>27.4 File Descriptors and <em>exec()</em></strong></h3>
<p class="noindenta">By default, all file descriptors opened by a program that calls <em>exec()</em> remain open across the <em>exec()</em> and are available for use by the new program. This is frequently useful, because the calling program may open files on particular descriptors, and these files are automatically available to the new program, without it needing to know the names of, or open, the files.</p>
<p class="indent">The shell takes advantage of this feature to handle I/O redirection for the programs that it executes. For example, suppose we enter the following shell command:</p>
<p class="programs">$ <span class="codestrong">ls /tmp &gt; dir.txt</span></p>
<p class="noindent">The shell performs the following steps to execute this command:</p>
<ol>
<li class="order"><p class="orderp">A <em>fork()</em> is performed to create a child process that is also running a copy of the shell (and thus has a copy of the command).</p></li>
<li class="order"><p class="orderp">The child shell opens <span class="literal">dir.txt</span> for output using file descriptor 1 (standard output). This can be done in either of the following ways:</p>
<p class="olista">a) The child shell closes descriptor 1 (<span class="literal">STDOUT_FILENO</span>) and then opens the file <span class="literal">dir.txt</span>. Since <em>open()</em> always uses the lowest available file descriptor, and standard input (descriptor 0) remains open, the file will be opened on descriptor 1.</p>
<p class="olista">b) The shell opens <span class="literal">dir.txt</span>, obtaining a new file descriptor. Then, if that file descriptor is not standard output, the shell uses <em>dup2()</em> to force standard output to be a duplicate of the new descriptor and closes the new descriptor, since it is no longer required. (This method is safer than the preceding <span epub:type="pagebreak" id="page_576"/>method, since it doesn&#8217;t rely on lower-numbered descriptors being open.) The code sequence is something like the following:</p>
<p class="programs2">fd = open("dir.txt", O_WRONLY | O_CREAT,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* rw-rw-rw- */<br/>if (fd != STDOUT_FILENO) {<br/>&#160;&#160;&#160;&#160;dup2(fd, STDOUT_FILENO);<br/>&#160;&#160;&#160;&#160;close(fd);<br/>}</p></li>
<li class="order"><p class="orderp">The child shell execs the <em>ls</em> program. The <em>ls</em> program writes its output to standard output, which is the file <span class="literal">dir.txt</span>.</p></li>
</ol>
<div class="block2">
<p class="noindent">The explanation given here of how the shell performs I/O redirections simplifies some points. In particular, certain commands&#8212;so-called shell <em>built-in</em> commands&#8212;are executed directly by the shell, without performing a <em>fork()</em> or an <em>exec()</em>. Such commands must be treated somewhat differently for the purposes of I/O redirection.</p>
<p class="indent">A shell command is implemented as a built-in for either of two reasons: efficiency and to obtain side effects within the shell. Some frequently used commands&#8212;such as <em>pwd</em>, <em>echo</em>, and <em>test</em>&#8212;are sufficiently simple that it is a worthwhile efficiency to implement them inside the shell. Other commands are implemented within the shell so that they have side effects on the shell itself&#8212;that is, they change information stored by the shell, or modify attributes of or affect the execution of the shell process. For example, the <em>cd</em> command must change the working directory of the shell itself, and so can&#8217;t be executed within a separate process. Other examples of commands that are built in for their side effects include <em>exec</em>, <em>exit</em>, <em>read</em>, <em>set</em>, <em>source</em>, <em>ulimit</em>, <em>umask</em>, <em>wait</em>, and the shell job-control commands (<em>jobs</em>, <em>fg</em>, and <em>bg</em>). The full set of built-in commands understood by a shell is documented in the shell&#8217;s manual page.</p>
</div>
<h5 class="h5" id="ch27lev3sec05"><strong>The close-on-exec flag (</strong><span class="literal"><span class="codestrong">FD_CLOEXEC</span></span><strong>)</strong></h5>
<p class="noindentab">Sometimes, it may be desirable to ensure that certain file descriptors are closed before an <em>exec()</em>. In particular, if we <em>exec()</em> an unknown program (i.e., one that we did not write) from a privileged process, or a program that doesn&#8217;t need descriptors for files we have already opened, then it is secure programming practice to ensure that all unnecessary file descriptors are closed before the new program is loaded. We could do this by calling <em>close()</em> on all such descriptors, but this suffers the following limitations:</p>
<p class="bull">&#8226; The file descriptor may have been opened by a library function. This function has no mechanism to force the main program to close the file descriptor before the <em>exec()</em> is performed. (As a general principle, library functions should always set the close-on-exec flag, using the technique described below, for any files that they open.)</p>
<p class="bull"><span epub:type="pagebreak" id="page_577"/>&#8226; If the <em>exec()</em> call fails for some reason, we may want to keep the file descriptors open. If they are already closed, it may be difficult, or impossible, to reopen them so that they refer to the same files.</p>
<p class="noindentt">For these reasons, the kernel provides a close-on-exec flag for each file descriptor. If this flag is set, then the file descriptor is automatically closed during a successful <em>exec()</em>, but left open if the <em>exec()</em> fails. The close-on-exec flag for a file descriptor can be accessed using the <em>fcntl()</em> system call (<a href="ch05.xhtml#ch05lev1sec02">Section 5.2</a>). The <em>fcntl()</em> <span class="literal">F_GETFD</span> operation retrieves a copy of the file descriptor flags:</p>
<p class="programs">int flags;<br/><br/>flags = fcntl(fd, F_GETFD);<br/>if (flags == -1)<br/>&#160;&#160;&#160;&#160;errExit("fcntl");</p>
<p class="noindent">After retrieving these flags, we can modify the <span class="literal">FD_CLOEXEC</span> bit and use a second <em>fcntl()</em> call specifying <span class="literal">F_SETFD</span> to update the flags:</p>
<p class="programs">flags |= FD_CLOEXEC;<br/>if (fcntl(fd, F_SETFD, flags) == -1)<br/>&#160;&#160;&#160;&#160;errExit("fcntl");</p>
<div class="block">
<p class="noindent"><span class="literal">FD_CLOEXEC</span> is actually the only bit used in the file descriptor flags. This bit corresponds to the value 1. In older programs, we may sometimes see the close-on-exec flag set using just the call <em>fcntl(fd, F_SETFD, 1)</em>, relying on the fact that there are no other bits that can be affected by this operation. Theoretically, this may not always be so (in the future, some UNIX system might implement additional flag bits), so we should use the technique shown in the main text.</p>
<p class="indent">Many UNIX implementations, including Linux, also allow the close-on-exec flag to be modified using two unstandardized <em>ioctl()</em> calls: <em>ioctl(fd, FIOCLEX)</em> to set the close-on-exec flag for <em>fd</em>, and <em>ioctl(fd, FIONCLEX)</em> to clear the flag.</p>
</div>
<p class="noindent">When <em>dup()</em>, <em>dup2()</em>, or <em>fcntl()</em> is used to create a duplicate of a file descriptor, the close-on-exec flag is always cleared for the duplicate descriptor. (This behavior is historical and an SUSv3 requirement.)</p>
<p class="indent"><a href="ch27.xhtml#ch27ex6">Listing 27-6</a> demonstrates the manipulation of the close-on-exec flag. Depending on the presence of a command-line argument (any string), this program first sets the close-on-exec flag for standard output and then execs the <em>ls</em> program. Here is what we see when we run the program:</p>
<p class="programs">$ <span class="codestrong">./closeonexec</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Exec ls without closing standard output</span><br/>-rwxr-xr-x&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;28098 Jun 15 13:59 closeonexec<br/>$ <span class="codestrong">./closeonexec n</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Sets close-on-exec flag for standard output</span><br/>ls: write error: Bad file descriptor</p>
<p class="noindent">In the second run shown above, <em>ls</em> detects that its standard output is closed and prints an error message on standard error.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_578"/><a id="ch27ex6"/><strong>Listing 27-6:</strong> Setting the close-on-exec flag for a file descriptor</p>
<p class="programsli">____________________________________________________ <span class="codestrong">procexec/closeonexec.c</span><br/><br/>#include &lt;fcntl.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int flags;<br/><br/>&#160;&#160;&#160;&#160;if (argc &gt; 1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flags = fcntl(STDOUT_FILENO, F_GETFD);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Fetch flags */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (flags == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fcntl - F_GETFD");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flags |= FD_CLOEXEC;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Turn on FD_CLOEXEC */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (fcntl(STDOUT_FILENO, F_SETFD, flags) == -1)&#160;&#160;&#160;&#160;&#160;/* Update flags */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fcntl - F_SETFD");<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;execlp("ls", "ls", "-l", argv[0], (char *) NULL);<br/>&#160;&#160;&#160;&#160;errExit("execlp");<br/>}<br/>____________________________________________________ <span class="codestrong">procexec/closeonexec.c</span></p>
<h3 class="h3" id="ch27lev1sec05"><strong>27.5 Signals and <em>exec()</em></strong></h3>
<p class="noindenta">During an <em>exec()</em>, the text of the existing process is discarded. This text may include signal handlers established by the calling program. Because the handlers disappear, the kernel resets the dispositions of all handled signals to <span class="literal">SIG_DFL</span>. The dispositions of all other signals (i.e., those with dispositions of <span class="literal">SIG_IGN</span> or <span class="literal">SIG_DFL</span>) are left unchanged by an <em>exec()</em>. This behavior is required by SUSv3.</p>
<p class="indent">SUSv3 makes a special case for an ignored <span class="literal">SIGCHLD</span> signal. (We noted in <a href="ch26.xhtml#ch26lev2sec09">Section 26.3.3</a> that ignoring <span class="literal">SIGCHLD</span> prevents the creation of zombies.) SUSv3 leaves it unspecified whether an ignored <span class="literal">SIGCHLD</span> remains ignored across an <em>exec()</em> or its disposition is reset to <span class="literal">SIG_DFL</span>. Linux does the former, but some other UNIX implementations (e.g., Solaris) do the latter. This implies that, in programs that ignore <span class="literal">SIGCHLD</span>, for maximum portability, we should perform a <em>signal(SIGCHLD, SIG_DFL)</em> call prior to an <em>exec()</em>, and ensure that we don&#8217;t write programs that rely on the initial disposition of <span class="literal">SIGCHLD</span> being anything other than <span class="literal">SIG_DFL</span>.</p>
<p class="indent">The destruction of the old program&#8217;s data, heap, and stack also means that any alternate signal stack established by a call to <em>sigaltstack()</em> (<a href="ch21.xhtml#ch21lev1sec03">Section 21.3</a>) is lost. Since an alternate signal stack is not preserved across an <em>exec()</em>, the <span class="literal">SA_ONSTACK</span> bit is also cleared for all signals.</p>
<p class="indent">During an <em>exec()</em>, the process signal mask and set of pending signals are both preserved. This feature allows us to block and queue signals for the newly execed program. However, SUSv3 notes that many existing applications wrongly assume that they are started with the disposition of certain signals set to <span class="literal">SIG_DFL</span> or that these signals are unblocked. (In particular, the C standards provide a much weaker <span epub:type="pagebreak" id="page_579"/>specification of signals, which doesn&#8217;t specify signal blocking; therefore, C programs written on non-UNIX systems won&#8217;t know to unblock signals.) For this reason, SUSv3 recommends that signals should not be blocked or ignored across an <em>exec()</em> of an arbitrary program. Here, &#8220;arbitrary&#8221; means a program that we did not write. It is acceptable to block or ignore signals when execing a program we have written or one with known behavior with respect to signals.</p>
<h3 class="h3" id="ch27lev1sec06"><strong>27.6 Executing a Shell Command: <em>system()</em></strong></h3>
<p class="noindenta">The <em>system()</em> function allows the calling program to execute an arbitrary shell command. In this section, we describe the operation of <em>system()</em>, and in the next section we show how <em>system()</em> can be implemented using <em>fork()</em>, <em>exec()</em>, <em>wait()</em>, and <em>exit()</em>.</p>
<div class="block">
<p class="noindent">In <a href="ch44.xhtml#ch44lev1sec05">Section 44.5</a>, we look at the <em>popen()</em> and <em>pclose()</em> functions, which can also be used to execute a shell command, but allow the calling program to either read the output of the command or to send input to the command.</p>
</div>
<div class="box">
<p class="programsa">#include &lt;stdlib.h&gt;<br/><br/>int <span class="codestrong">system</span>(const char *<span class="font1">command</span>);</p>
<p class="right">See main text for a description of return value</p>
</div>
<p class="noindent">The <em>system()</em> function creates a child process that invokes a shell to execute <em>command</em>. Here is an example of a call to <em>system()</em>:</p>
<p class="programs">system("ls | wc");</p>
<p class="noindentb">The principal advantages of <em>system()</em> are simplicity and convenience:</p>
<p class="bull">&#8226; We don&#8217;t need to handle the details of calling <em>fork()</em>, <em>exec()</em>, <em>wait()</em>, and <em>exit()</em>.</p>
<p class="bull">&#8226; Error and signal handling are performed by <em>system()</em> on our behalf.</p>
<p class="bull">&#8226; Because <em>system()</em> uses the shell to execute <em>command</em>, all of the usual shell processing, substitutions, and redirections are performed on <em>command</em> before it is executed. This makes it easy to add an &#8220;execute a shell command&#8221; feature to an application. (Many interactive applications provide such a feature in the form of a <span class="literal">!</span> command.)</p>
<p class="noindentt">The main cost of <em>system()</em> is inefficiency. Executing a command using <em>system()</em> requires the creation of at least two processes&#8212;one for the shell and one or more for the command(s) it executes&#8212;each of which performs an <em>exec()</em>. If efficiency or speed is a requirement, it is preferable to use explicit <em>fork()</em> and <em>exec()</em> calls to execute the desired program.</p>
<p class="indentb">The return value of <em>system()</em> is as follows:</p>
<p class="bull">&#8226; If <em>command</em> is a <span class="literal">NULL</span> pointer, then <em>system()</em> returns a nonzero value if a shell is available, and 0 if no shell is available. This case arises out of the C programming language standards, which are not tied to any operating system, so a shell might not be available if <em>system()</em> is running on a non-UNIX system. Furthermore, even though all UNIX implementations have a shell, this shell might not <span epub:type="pagebreak" id="page_580"/>be available if the program called <em>chroot()</em> before calling <em>system()</em>. If <em>command</em> is non-<span class="literal">NULL</span>, then the return value for <em>system()</em> is determined according to the remaining rules in this list.</p>
<p class="bull">&#8226; If a child process could not be created or its termination status could not be retrieved, then <em>system()</em> returns &#8211;1.</p>
<p class="bull">&#8226; If a shell could not be execed in the child process, then <em>system()</em> returns a value as though the child shell had terminated with the call <em>_exit(127)</em>.</p>
<p class="bull">&#8226; If all system calls succeed, then <em>system()</em> returns the termination status of the child shell used to execute <em>command</em>. The termination status of a shell is the exit status of the last command it executes; if that command is killed by a signal, most shells exit with the value <em>128</em>+<em>n</em>, where <em>n</em> is the signal number. (If the child shell is itself killed by a signal, the termination status is as described in <a href="ch26.xhtml#ch26lev2sec03">Section 26.1.3</a>.)</p>
<div class="block">
<p class="noindent">It is impossible (using the value returned by <em>system()</em>) to distinguish the case where <em>system()</em> fails to exec a shell from the case where the shell exits with the status 127 (the latter possibility can occur if the shell could not find a program with the given name to exec).</p>
</div>
<p class="noindent">In the last two cases, the value returned by <em>system()</em> is a <em>wait status</em> of the same form returned by <em>waitpid()</em>. This means we should use the functions described in <a href="ch26.xhtml#ch26lev2sec03">Section 26.1.3</a> to dissect this value, and we can display the value using our <em>printWaitStatus()</em> function (<a href="ch26.xhtml#ch26ex2">Listing 26-2</a>, on <a href="ch26.xhtml#page_546">page 546</a>).</p>
<h5 class="h5" id="ch27lev3sec06"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch27.xhtml#ch27ex7">Listing 27-7</a> demonstrates the use of <em>system()</em>. This program executes a loop that reads a command string, executes it using <em>system()</em>, and then analyzes and displays the value returned by <em>system()</em>. Here is a sample run:</p>
<p class="programs">$ <span class="codestrong">./t_system</span><br/>Command: <span class="codestrong">whoami</span><br/>mtk<br/>system() returned: status=0x0000 (0,0)<br/>child exited, status=0<br/>Command: <span class="codestrong">ls | grep XYZ</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Shell terminates with the status of&#8230;</span><br/>system() returned: status=0x0100 (1,0)&#160;&#160;&#160;<span class="font1">its last command (grep), which&#8230;</span><br/>child exited, status=1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">found no match, and so did an exit(1)</span><br/>Command: <span class="codestrong">exit 127</span><br/>system() returned: status=0x7f00 (127,0)<br/>(Probably) could not invoke shell&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Actually, not true in this case</span><br/>Command: <span class="codestrong">sleep 100</span><br/><span class="font1">Type Control-Z to suspend foreground process group</span><br/>[1]+&#160;&#160;Stopped&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;./t_system<br/>$ <span class="codestrong">ps | grep sleep</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Find PID of sleep</span><br/>29361 pts/6&#160;&#160;&#160;&#160;00:00:00 sleep<br/>$ <span class="codestrong">kill 29361</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">And send a signal to terminate it</span><br/>$ <span class="codestrong">fg</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Bring t_system back into foreground</span><br/>./t_system<br/>system() returned: status=0x000f (0,15)<br/>child killed by signal 15 (Terminated)<br/>Command: <span class="codestrong">^D</span>$&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Type Control-D to terminate program</span></p>
<p class="examplet"><span epub:type="pagebreak" id="page_581"/><a id="ch27ex7"/><strong>Listing 27-7:</strong> Executing shell commands with <em>system()</em></p>
<p class="programsli">______________________________________________________ <span class="codestrong">procexec/t_system.c</span><br/><br/>#include &lt;sys/wait.h&gt;<br/>#include "print_wait_status.h"<br/>#include "tlpi_hdr.h"<br/><br/>#define MAX_CMD_LEN 200<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;char str[MAX_CMD_LEN];&#160;&#160;&#160;&#160;&#160;&#160;/* Command to be executed by system() */<br/>&#160;&#160;&#160;&#160;int status;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Status return from system() */<br/><br/>&#160;&#160;&#160;&#160;for (;;) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Read and execute a shell command */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Command: ");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fflush(stdout);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (fgets(str, MAX_CMD_LEN, stdin) == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* end-of-file */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;status = system(str);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("system() returned: status=0x%04x (%d,%d)\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(unsigned int) status, status &gt;&gt; 8, status &#38; 0xff);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (status == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("system");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (WIFEXITED(status) &#38;&#38; WEXITSTATUS(status) == 127)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("(Probably) could not invoke shell\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Shell successfully executed command */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printWaitStatus(NULL, status);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>______________________________________________________ <span class="codestrong">procexec/t_system.c</span></p>
<h5 class="h5" id="ch27lev3sec07"><strong>Avoid using <em>system()</em> in set-user-ID and set-group-ID programs</strong></h5>
<p class="noindenta">Set-user-ID and set-group-ID programs should never use <em>system()</em> while operating under the program&#8217;s privileged identifier. Even when such programs don&#8217;t allow the user to specify the text of the command to be executed, the shell&#8217;s reliance on various environment variables to control its operation means that the use of <em>system()</em> inevitably opens the door for a system security breach.</p>
<p class="indent">For example, in older Bourne shells, the <span class="literal">IFS</span> environment variable, which defined the internal field separator used to break a command line into separate words, was the source of a number of successful system break-ins. If we defined <span class="literal">IFS</span> to have the value <em>a</em>, then the shell would treat the command string <em>shar</em> as the word <em>sh</em> followed by the argument <em>r</em>, and invoke another shell to execute the script file named <span class="literal">r</span> in the current working directory, instead of the intended purpose (executing a command named <em>shar</em>). This particular security hole was fixed by applying <span class="literal">IFS</span> <span epub:type="pagebreak" id="page_582"/>only to the words produced by shell expansions. In addition, modern shells reset <span class="literal">IFS</span> (to a string consisting of the three characters space, tab, and newline) on shell startup to ensure that scripts behave consistently if they inherit a strange <span class="literal">IFS</span> value. As a further security measure, <em>bash</em> reverts to the real user (group) ID when invoked from a set-user-ID (set-group-ID) program.</p>
<p class="indent">Secure programs that need to spawn another program should use <em>fork()</em> and one of the <em>exec()</em> functions&#8212;other than <em>execlp()</em> or <em>execvp()</em>&#8212;directly.</p>
<h3 class="h3" id="ch27lev1sec07"><strong>27.7 Implementing <em>system()</em></strong></h3>
<p class="noindenta">In this section, we explain how to implement <em>system()</em>. We begin with a simple implementation, explain what pieces are missing from that implementation, and then present a complete implementation.</p>
<h5 class="h5" id="ch27lev3sec08"><strong>A simple implementation of <em>system()</em></strong></h5>
<p class="noindenta">The <em>&#8211;c</em> option of the <em>sh</em> command provides an easy way to execute a string containing arbitrary shell commands:</p>
<p class="programs">$ <span class="codestrong">sh -c "ls | wc"</span><br/>&#160;&#160;&#160;&#160;&#160;38&#160;&#160;&#160;&#160;&#160;&#160;38&#160;&#160;&#160;&#160;&#160;444</p>
<p class="noindent">Thus, to implement <em>system()</em>, we need to use <em>fork()</em> to create a child that then does an <em>execl()</em> with arguments corresponding to the above <em>sh</em> command:</p>
<p class="programs">execl("/bin/sh", "sh", "-c", command, (char *) NULL);</p>
<p class="noindent">To collect the status of the child created by <em>system()</em>, we use a <em>waitpid()</em> call that specifies the child&#8217;s process ID. (Using <em>wait()</em> would not suffice, because <em>wait()</em> waits for any child, which could accidentally collect the status of some other child created by the calling process.) A simple, and incomplete, implementation of <em>system()</em> is shown in <a href="ch27.xhtml#ch27ex8">Listing 27-8</a>.</p>
<p class="examplet"><a id="ch27ex8"/><strong>Listing 27-8:</strong> An implementation of <em>system()</em> that excludes signal handling</p>
<p class="programsli">__________________________________________________ <span class="codestrong">procexec/simple_system.c</span><br/><br/>#include &lt;unistd.h&gt;<br/>#include &lt;sys/wait.h&gt;<br/>#include &lt;sys/types.h&gt;<br/><br/>int<br/>system(char *command)<br/>{<br/>&#160;&#160;&#160;&#160;int status;<br/>&#160;&#160;&#160;&#160;pid_t childPid;<br/><br/>&#160;&#160;&#160;&#160;switch (childPid = fork()) {<br/>&#160;&#160;&#160;&#160;case -1: /* Error */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/>&#160;&#160;&#160;&#160;case 0: /* Child */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;execl("/bin/sh", "sh", "-c", command, (char *) NULL);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_exit(127);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Failed exec */<br/><br/>&#160;&#160;&#160;&#160;default: /* Parent */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (waitpid(childPid, &#38;status, 0) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return status;<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>__________________________________________________ <span class="codestrong">procexec/simple_system.c</span></p>
<h5 class="h5" id="ch27lev3sec09"><span epub:type="pagebreak" id="page_583"/><strong>Treating signals correctly inside <em>system()</em></strong></h5>
<p class="noindenta">What adds complexity to the implementation of <em>system()</em> is the correct treatment with signals.</p>
<p class="indentb">The first signal to consider is <span class="literal">SIGCHLD</span>. Suppose that the program calling <em>system()</em> is also directly creating children, and has established a handler for <span class="literal">SIGCHLD</span> that performs its own <em>wait()</em>. In this situation, when a <span class="literal">SIGCHLD</span> signal is generated by the termination of the child created by <em>system()</em>, it is possible that the signal handler of the main program will be invoked&#8212;and collect the child&#8217;s status&#8212;before <em>system()</em> has a chance to call <em>waitpid()</em>. (This is an example of a race condition.) This has two undesirable consequences:</p>
<p class="bull">&#8226; The calling program would be deceived into thinking that one of the children that it created has terminated.</p>
<p class="bull">&#8226; The <em>system()</em> function would be unable to obtain the termination status of the child that it created.</p>
<p class="noindentt">Therefore, <em>system()</em> must block delivery of <span class="literal">SIGCHLD</span> while it is executing.</p>
<p class="indent">The other signals to consider are those generated by the terminal <em>interrupt</em> (usually <em>Control-C</em>) and <em>quit</em> (usually <em>Control-\</em>) characters, <span class="literal">SIGINT</span> and <span class="literal">SIGQUIT</span>, respectively. Consider what is happening when we execute the following call:</p>
<p class="programs">system("sleep 20");</p>
<p class="noindent">At this point, three processes are running: the process executing the calling program, a shell, and <em>sleep</em>, as shown in <a href="ch27.xhtml#ch27fig2">Figure 27-2</a>.</p>
<div class="block">
<p class="noindent">As an efficiency measure, when the string given to the <em>&#8211;c</em> option is a simple command (as opposed to a pipeline or a sequence), some shells (including <em>bash</em>) directly exec the command, rather than forking a child shell. For shells that perform such an optimization, <a href="ch27.xhtml#ch27fig2">Figure 27-2</a> is not strictly accurate, since there will be only two processes (the calling process and <em>sleep</em>). Nevertheless, the arguments in this section about how <em>system()</em> should handle signals still apply.</p>
</div>
<p class="noindent">All of the processes shown in <a href="ch27.xhtml#ch27fig2">Figure 27-2</a> form part of the foreground process group for the terminal. (We consider process groups in detail in <a href="ch34.xhtml#ch34lev1sec02">Section 34.2</a>.) Therefore, when we type the <em>interrupt</em> or <em>quit</em> characters, all three processes are sent the corresponding signal. The shell ignores <span class="literal">SIGINT</span> and <span class="literal">SIGQUIT</span> while waiting for its <span epub:type="pagebreak" id="page_584"/>child. However, both the calling program and the <em>sleep</em> process would, by default, be killed by these signals.</p>
<p class="indentb">How should the calling process and the executed command respond to these signals? SUSv3 specifies the following:</p>
<p class="bull">&#8226; <span class="literal">SIGINT</span> and <span class="literal">SIGQUIT</span> should be ignored in the calling process while the command is being executed.</p>
<p class="bull">&#8226; In the child, <span class="literal">SIGINT</span> and <span class="literal">SIGQUIT</span> should be treated as they would be if the calling process did a <em>fork()</em> and <em>exec()</em>; that is, the disposition of handled signals is reset to the default, and the disposition of other signals remains unchanged.</p>
<div class="image"><img src="../images/f27-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch27fig2"/><strong>Figure 27-2:</strong> Arrangement of processes during execution of <em>system(&#8220;sleep 20&#8221;)</em></p>
<p class="noindentb">Dealing with signals in the manner specified by SUSv3 is the most reasonable approach, for the following reasons:</p>
<p class="bull">&#8226; It would not make sense to have both processes responding to these signals, since this could lead to confusing behaviors for the user of the application.</p>
<p class="bull">&#8226; Similarly, it would not make sense to ignore these signals in the process executing the command while treating them according to their default dispositions in the calling process. This would allow the user to do things such as killing the calling process while the executed command was left running. It is also inconsistent with the fact that the calling process has actually given up control (i.e., is blocked in a <em>waitpid()</em> call) while the command passed to <em>system()</em> is being executed.</p>
<p class="bull">&#8226; The command executed by <em>system()</em> may be an interactive application, and it makes sense to have this application respond to terminal-generated signals.</p>
<p class="noindentt">SUSv3 requires the treatment of <span class="literal">SIGINT</span> and <span class="literal">SIGQUIT</span> described above, but notes that this could have an undesirable effect in a program that invisibly uses <em>system()</em> to perform some task. While the command is being executed, typing <em>Control-C</em> or <em>Control-\</em> will kill only the child of <em>system()</em>, while the application (unexpectedly, to the user) continues to run. A program that uses <em>system()</em> in this way should check the termination status returned by <em>system()</em>, and take appropriate action if it detects that the command was killed by a signal.</p>
<h5 class="h5" id="ch27lev3sec10"><span epub:type="pagebreak" id="page_585"/><strong>An improved <em>system()</em> implementation</strong></h5>
<p class="noindentab"><a href="ch27.xhtml#ch27ex9">Listing 27-9</a> shows an implementation of <em>system()</em> conforming to the rules described above. Note the following points about this implementation:</p>
<p class="bull">&#8226; As noted earlier, if <em>command</em> is a <span class="literal">NULL</span> pointer, then <em>system()</em> should return nonzero if a shell is available or 0 if no shell is available. The only way to reliably determine this information is to try to execute a shell. We do this by recursively calling <em>system()</em> to execute the <span class="literal">:</span> shell command and checking for a return status of 0 from the recursive call <span class="ent">&#x2460;</span>. The <span class="literal">:</span> command is a shell built-in command that does nothing, but always returns a success status. We could have executed the shell command <em>exit 0</em> to achieve the same result. (Note that it isn&#8217;t sufficient to use <em>access()</em> to check whether the file <span class="literal">/bin/sh</span> exists and has execute permission enabled. In a <em>chroot()</em> environment, even if the shell executable is present, it may not be able to be executed if it is dynamically linked and the required shared libraries are not available.)</p>
<p class="bull">&#8226; It is only in the parent process (the caller of <em>system()</em>) that <span class="literal">SIGCHLD</span> needs to be blocked <span class="ent">&#x2461;</span>, and <span class="literal">SIGINT</span> and <span class="literal">SIGQUIT</span> need to be ignored <span class="ent">&#x2462;</span>. However, we must perform these actions prior to the <em>fork()</em> call, because, if they were done in the parent after the <em>fork()</em>, we would create a race condition. (Suppose, for example, that the child exited before the parent had a chance to block <span class="literal">SIGCHLD</span>.) Consequently, the child must undo these changes to the signal attributes, as described shortly.</p>
<p class="bull">&#8226; In the parent, we ignore errors from the <em>sigaction()</em> and <em>sigprocmask()</em> calls used to manipulate signal dispositions and the signal mask <span class="ent">&#x2461;</span> <span class="ent">&#x2462;</span> <span class="ent">&#x2468;</span>. We do this for two reasons. First, these calls are very unlikely to fail. In practice, the only thing that can realistically go wrong with these calls is an error in specifying their arguments, and such an error should be eliminated during initial debugging. Second, we assume that the caller is more interested in knowing if <em>fork()</em> or <em>waitpid()</em> failed than in knowing if these signal-manipulation calls failed. For similar reasons, we bracket the signal-manipulation calls used at the end of <em>system()</em> with code to save <span class="ent">&#x2467;</span> and restore <em>errno</em> <span class="ent">&#x2469;</span>, so that if <em>fork()</em> or <em>waitpid()</em> fails, then the caller can determine why. If we returned &#8211;1 because these signal-manipulation calls failed, then the caller might wrongly assume that <em>system()</em> failed to execute <em>command</em>.</p>
<div class="block1">
<p class="noindent">SUSv3 merely says that <em>system()</em> should return &#8211;1 if a child process could not be created or its status could not be obtained. No mention is made of a &#8211;1 return because of failures in signal-manipulation operations by <em>system()</em>.</p>
</div>
<p class="bull">&#8226; Error checking is not performed for signal-related system calls in the child <span class="ent">&#x2463;</span> <span class="ent">&#x2464;</span>. On the one hand, there is no way of reporting such an error (the use of <em>_exit(127)</em> is reserved for reporting an error when execing the shell); on the other hand, such failures don&#8217;t affect the caller of <em>system()</em>, which is a separate process.</p>
<p class="bull"><span epub:type="pagebreak" id="page_586"/>&#8226; On return from <em>fork()</em> in the child, the disposition of <span class="literal">SIGINT</span> and <span class="literal">SIGQUIT</span> is <span class="literal">SIG_IGN</span> (i.e., the disposition inherited from the parent). However, as noted earlier, in the child, these signals should be treated as if the caller of <em>system()</em> did a <em>fork()</em> and an <em>exec()</em>. A <em>fork()</em> leaves the treatment of signals unchanged in the child. An <em>exec()</em> resets the dispositions of handled signals to their defaults and leaves the dispositions of other signals unchanged (<a href="ch27.xhtml#ch27lev1sec05">Section 27.5</a>). Therefore, if the dispositions of <span class="literal">SIGINT</span> and <span class="literal">SIGQUIT</span> in the caller were other than <span class="literal">SIG_IGN</span>, then the child resets the dispositions to <span class="literal">SIG_DFL</span> <span class="ent">&#x2463;</span>.</p>
<div class="block1">
<p class="noindent">Some implementations of <em>system()</em> instead reset the <span class="literal">SIGINT</span> and <span class="literal">SIGQUIT</span> dispositions to those that were in effect in the caller, relying on the fact that the subsequent <em>execl()</em> will automatically reset the disposition of handled signals to their defaults. However, this could result in potentially undesirable behavior if the caller is handling either of these signals. In this case, if a signal was delivered to the child in the small time interval before the call to <em>execl()</em>, then the handler would be invoked in the child, after the signal was unblocked by <em>sigprocmask()</em>.</p>
</div>
<p class="bull">&#8226; If the <em>execl()</em> call in the child fails, then we use <em>_exit()</em> to terminate the process <span class="ent">&#x2465;</span>, rather than <em>exit()</em>, in order to prevent flushing of any unwritten data in the child&#8217;s copy of the <em>stdio</em> buffers.</p>
<p class="bull">&#8226; In the parent, we must use <em>waitpid()</em> to wait specifically for the child that we created <span class="ent">&#x2466;</span>. If we used <em>wait()</em>, then we might inadvertently fetch the status of some other child created by the calling program.</p>
<p class="bull">&#8226; Although the implementation of <em>system()</em> doesn&#8217;t require the use of a signal handler, the calling program may have established signal handlers, and one of these could interrupt a blocked call to <em>waitpid()</em>. SUSv3 explicitly requires that the wait be restarted in this case. Therefore, we use a loop to restart <em>waitpid()</em> if it fails with the error <span class="literal">EINTR</span> <span class="ent">&#x2466;</span>; any other error from <em>waitpid()</em> causes this loop to terminate.</p>
<p class="examplet"><a id="ch27ex9"/><strong>Listing 27-9:</strong> Implementation of <em>system()</em></p>
<p class="programsli">________________________________________________________ <span class="codestrong">procexec/system.c</span><br/><br/>&#160;&#160;&#160;#include &lt;unistd.h&gt;<br/>&#160;&#160;&#160;#include &lt;signal.h&gt;<br/>&#160;&#160;&#160;#include &lt;sys/wait.h&gt;<br/>&#160;&#160;&#160;#include &lt;sys/types.h&gt;<br/>&#160;&#160;&#160;#include &lt;errno.h&gt;<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;system(const char *command)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigset_t blockMask, origMask;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sigaction saIgnore, saOrigQuit, saOrigInt, saDefault;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;pid_t childPid;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int status, savedErrno;<br/><br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;if (command == NULL)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Is a shell available? */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return system(":") == 0;<br/><span epub:type="pagebreak" id="page_587"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;blockMask);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Block SIGCHLD */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigaddset(&#38;blockMask, SIGCHLD);<br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;sigprocmask(SIG_BLOCK, &#38;blockMask, &#38;origMask);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;saIgnore.sa_handler = SIG_IGN;&#160;&#160;&#160;&#160;&#160;&#160;/* Ignore SIGINT and SIGQUIT */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;saIgnore.sa_flags = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;saIgnore.sa_mask);<br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;sigaction(SIGINT, &#38;saIgnore, &#38;saOrigInt);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigaction(SIGQUIT, &#38;saIgnore, &#38;saOrigQuit);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (childPid = fork()) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;case -1: /* fork() failed */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;status = -1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Carry on to reset signal attributes */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 0: /* Child: exec command */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;saDefault.sa_handler = SIG_DFL;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;saDefault.sa_flags = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigemptyset(&#38;saDefault.sa_mask);<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (saOrigInt.sa_handler != SIG_IGN)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigaction(SIGINT, &#38;saDefault, NULL);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (saOrigQuit.sa_handler != SIG_IGN)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigaction(SIGQUIT, &#38;saDefault, NULL);<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigprocmask(SIG_SETMASK, &#38;origMask, NULL);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;execl("/bin/sh", "sh", "-c", command, (char *) NULL);<br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_exit(127);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* We could not exec the shell */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;default: /* Parent: wait for our child to terminate */<br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (waitpid(childPid, &#38;status, 0) == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno != EINTR) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Error other than EINTR */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;status = -1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* So exit loop */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Unblock SIGCHLD, restore dispositions of SIGINT and SIGQUIT */<br/><br/><span class="ent">&#x2467;</span>&#160;&#160;&#160;&#160;&#160;savedErrno = errno;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* The following may change 'errno' */<br/><br/><span class="ent">&#x2468;</span>&#160;&#160;&#160;&#160;&#160;sigprocmask(SIG_SETMASK, &#38;origMask, NULL);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigaction(SIGINT, &#38;saOrigInt, NULL);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;sigaction(SIGQUIT, &#38;saOrigQuit, NULL);<br/><br/><span class="ent">&#x2469;</span>&#160;&#160;&#160;&#160;&#160;errno = savedErrno;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;return status;<br/>&#160;&#160;&#160;}<br/>________________________________________________________ <span class="codestrong">procexec/system.c</span></p>
<h5 class="h5" id="ch27lev3sec11"><span epub:type="pagebreak" id="page_588"/><strong>Further details on <em>system()</em></strong></h5>
<p class="noindenta">Portable applications should ensure that <em>system()</em> is not called with the disposition of <span class="literal">SIGCHLD</span> set to <span class="literal">SIG_IGN</span>, because it is impossible for the <em>waitpid()</em> call to obtain the status of the child in this case. (Ignoring <span class="literal">SIGCHLD</span> causes the status of a child process to be immediately discarded, as described in <a href="ch26.xhtml#ch26lev2sec09">Section 26.3.3</a>.)</p>
<p class="indent">On some UNIX implementations, <em>system()</em> handles the case that it is called with the disposition of <span class="literal">SIGCHLD</span> set to <span class="literal">SIG_IGN</span> by temporarily setting the disposition of <span class="literal">SIGCHLD</span> to <span class="literal">SIG_DFL</span>. This is workable, as long as the UNIX implementation is one of those that (unlike Linux) reaps existing zombie children when the disposition of <span class="literal">SIGCHLD</span> is reset to <span class="literal">SIG_IGN</span>. (If the implementation doesn&#8217;t do this, then implementing <em>system()</em> in this way would have the negative consequence that if another child that was created by the caller terminated during the execution of <em>system()</em>, it would become a zombie that might never be reaped.)</p>
<p class="indent">On some UNIX implementations (notably Solaris), <span class="literal">/bin/sh</span> is not a standard POSIX shell. If we want to ensure that we exec a standard shell, then we must use the <em>confstr()</em> library function to obtain the value of the <span class="literal">_CS_PATH</span> configuration variable. This value is a <span class="literal">PATH</span>-style list of directories containing the standard system utilities. We can assign this list to <span class="literal">PATH</span>, and then use <em>execlp()</em> to exec the standard shell as follows:</p>
<p class="programs">char path[PATH_MAX];<br/><br/>if (confstr(_CS_PATH, path, PATH_MAX) == 0)<br/>&#160;&#160;&#160;&#160;_exit(127);<br/>if (setenv("PATH", path, 1) == -1)<br/>&#160;&#160;&#160;&#160;_exit(127);<br/>execlp("sh", "sh", "-c", command, (char *) NULL);<br/>_exit(127);</p>
<h3 class="h3" id="ch27lev1sec08"><strong>27.8 Summary</strong></h3>
<p class="noindenta">Using <em>execve()</em>, a process can replace the program that it is currently running by a new program. Arguments to the <em>execve()</em> call allow the specification of the argument list (<em>argv</em>) and environment list for the new program. Various similarly named library functions are layered on top of <em>execve()</em> and provide different interfaces to the same functionality.</p>
<p class="indent">All of the <em>exec()</em> functions can be used to load a binary executable file or to execute an interpreter script. When a process execs a script, the script&#8217;s interpreter program replaces the program currently being executed by the process. The script&#8217;s interpreter is normally identified by an initial line (starting with the characters <span class="literal">#!</span>) in the script that specifies the pathname of the interpreter. If no such line is present, then the script is executable only via <em>execlp()</em> or <em>execvp()</em>, and these functions exec the shell as the script interpreter.</p>
<p class="indent">We showed how <em>fork()</em>, <em>exec()</em>, <em>exit()</em>, and <em>wait()</em> can be combined to implement the <em>system()</em> function, which can be used to execute an arbitrary shell command.</p>
<h5 class="h5" id="ch27lev3sec12"><strong>Further information</strong></h5>
<p class="noindenta">Refer to the sources of further information listed in <a href="ch24.xhtml#ch24lev1sec06">Section 24.6</a>.</p>
<h3 class="h3" id="ch27lev1sec09"><span epub:type="pagebreak" id="page_589"/><strong>27.9 Exercises</strong></h3>
<p class="exer"><a id="ch27exe1"/><strong>27-1.</strong>&#160;&#160;&#160;The final command in the following shell session uses the program in <a href="ch27.xhtml#ch27ex3">Listing 27-3</a> to exec the program <em>xyz</em>. What happens?</p>
<p class="programs1">$ <span class="codestrong">echo $PATH</span><br/>/usr/local/bin:/usr/bin:/bin:./dir1:./dir2<br/>$ <span class="codestrong">ls -l dir1</span><br/>total 8<br/>-rw-r--r--&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7860 Jun 13 11:55 xyz<br/>$ <span class="codestrong">ls -l dir2</span><br/>total 28<br/>-rwxr-xr-x&#160;&#160;&#160;1 mtk&#160;&#160;&#160;&#160;&#160;&#160;users&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;27452 Jun 13 11:55 xyz<br/>$ <span class="codestrong">./t_execlp xyz</span></p>
<p class="exer"><a id="ch27exe2"/><strong>27-2.</strong>&#160;&#160;&#160;Use <em>execve()</em> to implement <em>execlp()</em>. You will need to use the <em>stdarg(3)</em> API to handle the variable-length argument list supplied to <em>execlp()</em>. You will also need to use functions in the <em>malloc</em> package to allocate space for the argument and environment vectors. Finally, note that an easy way of checking whether a file exists in a particular directory and is executable is simply to try execing the file.</p>
<p class="exer"><a id="ch27exe3"/><strong>27-3.</strong>&#160;&#160;&#160;What output would we see if we make the following script executable and <em>exec()</em> it?</p>
<p class="programs1">#!/bin/cat -n<br/>Hello world</p>
<p class="exer"><a id="ch27exe4"/><strong>27-4.</strong>&#160;&#160;&#160;What is the effect of the following code? In what circumstances might it be useful?</p>
<p class="programs1">childPid = fork();<br/>if (childPid == -1)<br/>&#160;&#160;&#160;&#160;errExit("fork1");<br/>if (childPid == 0) { /* Child */<br/>&#160;&#160;&#160;&#160;switch (fork()) {<br/>&#160;&#160;&#160;&#160;case -1: errExit("fork2");<br/><br/>&#160;&#160;&#160;&#160;case 0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Grandchild */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* ----- Do real work here ----- */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* After doing real work */<br/><br/>&#160;&#160;&#160;&#160;default:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Make grandchild an orphan */<br/>&#160;&#160;&#160;&#160;}<br/>}<br/><br/>/* Parent falls through to here */<br/><br/>if (waitpid(childPid, &#38;status, 0) == -1)<br/>&#160;&#160;&#160;&#160;errExit("waitpid");<br/><br/>/* Parent carries on to do other things */</p>
<p class="exer"><span epub:type="pagebreak" id="page_590"/><a id="ch27exe5"/><strong>27-5.</strong>&#160;&#160;&#160;When we run the following program, we find it produces no output. Why is this?</p>
<p class="programs1">#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;printf("Hello world");<br/>&#160;&#160;&#160;&#160;execlp("sleep", "sleep", "0", (char *) NULL);<br/>}</p>
<p class="exer"><a id="ch27exe6"/><strong>27-6.</strong>&#160;&#160;&#160;Suppose that a parent process has established a handler for <span class="literal">SIGCHLD</span> and also blocked this signal. Subsequently, one of its children exits, and the parent then does a <em>wait()</em> to collect the child&#8217;s status. What happens when the parent unblocks <span class="literal">SIGCHLD</span>? Write a program to verify your answer. What is the relevance of the result for a program calling the <em>system()</em> function?</p>
</body>
</html>
