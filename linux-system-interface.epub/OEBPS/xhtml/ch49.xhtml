<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch49"><span epub:type="pagebreak" id="page_1017"/><strong><span class="big">49</span></strong><br/><strong>MEMORY MAPPINGS</strong></h2>
<p class="noindenta">This chapter discusses the use of the <em>mmap()</em> system call to create memory mappings. Memory mappings can be used for IPC, as well as a range of other purposes. We begin with an overview of some fundamental concepts before considering <em>mmap()</em> in depth.</p>
<h3 class="h3" id="ch49lev1sec01"><strong>49.1 Overview</strong></h3>
<p class="noindentab">The <em>mmap()</em> system call creates a new <em>memory mapping</em> in the calling process&#8217;s virtual address space. A mapping can be of two types:</p>
<p class="bull">&#8226; <em>File mapping</em>: A file mapping maps a region of a file directly into the calling process&#8217;s virtual memory. Once a file is mapped, its contents can be accessed by operations on the bytes in the corresponding memory region. The pages of the mapping are (automatically) loaded from the file as required. This type of mapping is also known as a <em>file-based mapping</em> or <em>memory-mapped file</em>.</p>
<p class="bull">&#8226; <em>Anonymous mapping</em>: An anonymous mapping doesn&#8217;t have a corresponding file. Instead, the pages of the mapping are initialized to 0.</p>
<div class="block1">
<p class="noindent">Another way of thinking of an anonymous mapping (and one that is close to the truth) is that it is a mapping of a virtual file whose contents are always initialized with zeros.</p>
</div>
<p class="noindentb"><span epub:type="pagebreak" id="page_1018"/>The memory in one process&#8217;s mapping may be shared with mappings in other processes (i.e., the page-table entries of each process point to the same pages of RAM). This can occur in two ways:</p>
<p class="bull">&#8226; When two processes map the same region of a file, they share the same pages of physical memory.</p>
<p class="bull">&#8226; A child process created by <em>fork()</em> inherits copies of its parent&#8217;s mappings, and these mappings refer to the same pages of physical memory as the corresponding mappings in the parent.</p>
<p class="noindenttb">When two or more processes share the same pages, each process can potentially see the changes to the page contents made by other processes, depending on whether the mapping is <em>private</em> or <em>shared</em>:</p>
<p class="bull">&#8226; <em>Private mapping</em> (<span class="literal">MAP_PRIVATE</span>): Modifications to the contents of the mapping are not visible to other processes and, for a file mapping, are not carried through to the underlying file. Although the pages of a private mapping are initially shared in the circumstances described above, changes to the contents of the mapping are nevertheless private to each process. The kernel accomplishes this using the copy-on-write technique (<a href="ch24.xhtml#ch24lev2sec02">Section 24.2.2</a>). This means that whenever a process attempts to modify the contents of a page, the kernel first creates a new, separate copy of that page for the process (and adjusts the process&#8217;s page tables). For this reason, a <span class="literal">MAP_PRIVATE</span> mapping is sometimes referred to as a <em>private, copy-on-write mapping</em>.</p>
<p class="bull">&#8226; <em>Shared mapping</em> (<span class="literal">MAP_SHARED</span>): Modifications to the contents of the mapping are visible to other processes that share the same mapping and, for a file mapping, are carried through to the underlying file.</p>
<p class="noindentt">The two mapping attributes described above (file versus anonymous and private versus shared) can be combined in four different ways, as summarized in <a href="ch49.xhtml#ch49table1">Table 49-1</a>.</p>
<p class="tablecap"><a id="ch49table1"/><strong>Table 49-1:</strong> Purposes of various types of memory mappings</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th" rowspan="2"><p class="tablec"><strong>Visibility of modifications</strong></p></td>
<td style="vertical-align: top;" class="table_th1" colspan="2"><p class="tablec"><strong>Mapping type</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="tablec"><strong>File</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="tablec"><strong>Anonymous</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><strong>Private</strong></p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Initializing memory from contents of file</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Memory allocation</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><strong>Shared</strong></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">Memory-mapped I/O; sharing memory between processes (IPC)</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">Sharing memory between processes (IPC)</p></td>
</tr>
</tbody>
</table>
<p class="noindentb">The four different types of memory mappings are created and used as follows:</p>
<p class="bull">&#8226; <em>Private file mapping</em>: The contents of the mapping are initialized from a file region. Multiple processes mapping the same file initially share the same physical pages of memory, but the copy-on-write technique is employed, so that changes to the mapping by one process are invisible to other processes. The <span epub:type="pagebreak" id="page_1019"/>main use of this type of mapping is to initialize a region of memory from the contents of a file. Some common examples are initializing a process&#8217;s text and initialized data segments from the corresponding parts of a binary executable file or a shared library file.</p>
<p class="bull">&#8226; <em>Private anonymous mapping</em>: Each call to <em>mmap()</em> to create a private anonymous mapping yields a new mapping that is distinct from (i.e., does not share physical pages with) other anonymous mappings created by the same (or a different) process. Although a child process inherits its parent&#8217;s mappings, copy-on-write semantics ensure that, after the <em>fork()</em>, the parent and child don&#8217;t see changes made to the mapping by the other process. The primary purpose of private anonymous mappings is to allocate new (zero-filled) memory for a process (e.g., <em>malloc()</em> employs <em>mmap()</em> for this purpose when allocating large blocks of memory).</p>
<p class="bull">&#8226; <em>Shared file mapping</em>: All processes mapping the same region of a file share the same physical pages of memory, which are initialized from a file region. Modifications to the contents of the mapping are carried through to the file. This type of mapping serves two purposes. First, it permits <em>memory-mapped I/O</em>. By this, we mean that a file is loaded into a region of the process&#8217;s virtual memory, and modifications to that memory are automatically written to the file. Thus, memory-mapped I/O provides an alternative to using <em>read()</em> and <em>write()</em> for performing file I/O. A second purpose of this type of mapping is to allow unrelated processes to share a region of memory in order to perform (fast) IPC in a manner similar to System V shared memory segments (<a href="ch48.xhtml#ch48">Chapter 48</a>).</p>
<p class="bull">&#8226; <em>Shared anonymous mapping</em>: As with a private anonymous mapping, each call to <em>mmap()</em> to create a shared anonymous mapping creates a new, distinct mapping that doesn&#8217;t share pages with any other mapping. The difference is that the pages of the mapping are not copied-on-write. This means that when a child inherits the mapping after a <em>fork()</em>, the parent and child share the same pages of RAM, and changes made to the contents of the mapping by one process are visible to the other process. Shared anonymous mappings allow IPC in a manner similar to System V shared memory segments, but only between related processes.</p>
<p class="noindentt">We consider each of these types of mapping in more detail in the remainder of this chapter.</p>
<p class="indent">Mappings are lost when a process performs an <em>exec()</em>, but are inherited by the child of a <em>fork()</em>. The mapping type (<span class="literal">MAP_PRIVATE</span> or <span class="literal">MAP_SHARED</span>) is also inherited.</p>
<p class="indent">Information about all of a process&#8217;s mappings is visible in the Linux-specific <span class="literal">/proc/</span> <em>PID</em><span class="literal">/maps</span> file, which we described in <a href="ch48.xhtml#ch48lev1sec05">Section 48.5</a>.</p>
<div class="block">
<p class="noindent">One further use of <em>mmap()</em> is with POSIX shared memory objects, which allow a region of memory to be shared between unrelated processes without having to create an associated disk file (as is required for a shared file mapping). We describe POSIX shared memory objects in <a href="ch54.xhtml#ch54">Chapter 54</a>.</p>
</div>
<h3 class="h3" id="ch49lev1sec02"><span epub:type="pagebreak" id="page_1020"/><strong>49.2 Creating a Mapping: <em>mmap()</em></strong></h3>
<p class="noindenta">The <em>mmap()</em> system call creates a new mapping in the calling process&#8217;s virtual address space.</p>
<div class="box">
<p class="programsa">#include &lt;sys/mman.h&gt;<br/><br/>void *<span class="codestrong">mmap</span>(void *<span class="font1">addr</span>, size_t <span class="font1">length</span>, int <span class="font1">prot</span>, int <span class="font1">flags</span>, int <span class="font1">fd</span>, off_t <span class="font1">offset</span>);</p>
<p class="right">Returns starting address of mapping on success, or <span class="literal">MAP_FAILED</span> on error</p>
</div>
<p class="noindent">The <em>addr</em> argument indicates the virtual address at which the mapping is to be located. If we specify <em>addr</em> as <span class="literal">NULL</span>, the kernel chooses a suitable address for the mapping. This is the preferred way of creating a mapping. Alternatively, we can specify a non-<span class="literal">NULL</span> value in <em>addr</em>, which the kernel takes as a hint about the address at which the mapping should be placed. In practice, the kernel will at the very least round the address to a nearby page boundary. In either case, the kernel will choose an address that doesn&#8217;t conflict with any existing mapping. (If the value <span class="literal">MAP_FIXED</span> is included in <em>flags</em>, then <em>addr</em> must be page-aligned. We describe this flag in <a href="ch49.xhtml#ch49lev1sec10">Section 49.10</a>.)</p>
<p class="indent">On success, <em>mmap()</em> returns the starting address of the new mapping. On error, <em>mmap()</em> returns <span class="literal">MAP_FAILED</span>.</p>
<div class="block">
<p class="noindent">On Linux (and on most other UNIX implementations), the <span class="literal">MAP_FAILED</span> constant equates to <em>((void *) &#8211;1)</em>. However, SUSv3 specifies this constant because the C standards can&#8217;t guarantee that <em>((void *) &#8211;1)</em> is distinct from a successful <em>mmap()</em> return value.</p>
</div>
<p class="noindent">The <em>length</em> argument specifies the size of the mapping in bytes. Although <em>length</em> doesn&#8217;t need to be a multiple of the system page size (as returned by <em>sysconf(_SC_PAGESIZE)</em>), the kernel creates mappings in units of this size, so that <em>length</em> is, in effect, rounded up to the next multiple of the page size.</p>
<p class="indent">The <em>prot</em> argument is a bit mask specifying the protection to be placed on the mapping. It can be either <span class="literal">PROT_NONE</span> or a combination (ORing) of any of the other three flags listed in <a href="ch49.xhtml#ch49table2">Table 49-2</a>.</p>
<p class="tablecap"><a id="ch49table2"/><strong>Table 49-2:</strong> Memory protection values</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Value</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table"><span class="literal">PROT_NONE</span></p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">The region may not be accessed</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">PROT_READ</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">The contents of the region can be read</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">PROT_WRITE</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">The contents of the region can be modified</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">PROT_EXEC</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">The contents of the region can be executed</p></td>
</tr>
</tbody>
</table>
<p class="noindentb"><span epub:type="pagebreak" id="page_1021"/>The <em>flags</em> argument is a bit mask of options controlling various aspects of the mapping operation. Exactly one of the following values must be included in this mask:</p>
<p class="term"><span class="literal">MAP_PRIVATE</span></p>
<p class="termlist">Create a private mapping. Modifications to the contents of the region are not visible to other processes employing the same mapping, and, in the case of a file mapping, are not carried through to the underlying file.</p>
<p class="term"><span class="literal">MAP_SHARED</span></p>
<p class="termlist">Create a shared mapping. Modifications to the contents of the region are visible to other processes mapping the same region with the <span class="literal">MAP_SHARED</span> attribute and, in the case of a file mapping, are carried through to the underlying file. Updates to the file are not guaranteed to be immediate; see the discussion of the <em>msync()</em> system call in <a href="ch49.xhtml#ch49lev1sec05">Section 49.5</a>.</p>
<p class="noindentt">Aside from <span class="literal">MAP_PRIVATE</span> and <span class="literal">MAP_SHARED</span>, other flag values can optionally be ORed in <em>flags</em>. We discuss these flags in <a href="ch49.xhtml#ch49lev1sec06">Sections 49.6</a> and <a href="ch49.xhtml#ch49lev1sec10">49.10</a>.</p>
<p class="indent">The remaining arguments, <em>fd</em> and <em>offset</em>, are used with file mappings (they are ignored for anonymous mappings). The <em>fd</em> argument is a file descriptor identifying the file to be mapped. The <em>offset</em> argument specifies the starting point of the mapping in the file, and must be a multiple of the system page size. To map the entire file, we would specify <em>offset</em> as 0 and <em>length</em> as the size of the file. We say more about file mappings in <a href="ch49.xhtml#ch49lev1sec04">Section 49.4</a>.</p>
<h5 class="h5" id="ch49lev3sec01"><strong>Memory protection in more detail</strong></h5>
<p class="noindenta">As noted above, the <em>mmap() prot</em> argument specifies the protection on a new memory mapping. It can contain the value <span class="literal">PROT_NONE</span>, or a mask of one or more of the flags <span class="literal">PROT_READ</span>, <span class="literal">PROT_WRITE</span>, and <span class="literal">PROT_EXEC</span>. If a process attempts to access a memory region in a way that violates the protection on the region, then the kernel delivers the <span class="literal">SIGSEGV</span> signal to a process.</p>
<div class="block">
<p class="noindent">Although SUSv3 specifies that <span class="literal">SIGSEGV</span> should be used to signal memory protection violations, on some implementations, <span class="literal">SIGBUS</span> is used instead.</p>
</div>
<p class="noindent">One use of pages of memory marked <span class="literal">PROT_NONE</span> is as guard pages at the start or end of a region of memory that a process has allocated. If the process accidentally steps into one of the pages marked <span class="literal">PROT_NONE</span>, the kernel informs it of that fact by generating a <span class="literal">SIGSEGV</span> signal.</p>
<p class="indent">Memory protections reside in process-private virtual memory tables. Thus, different processes may map the same memory region with different protections.</p>
<p class="indent">Memory protection can be changed using the <em>mprotect()</em> system call (<a href="ch50.xhtml#ch50lev1sec01">Section 50.1</a>).</p>
<p class="indent">On some UNIX implementations, the actual protections placed on the pages of a mapping may not be exactly those specified in <em>prot</em>. In particular, limitations of the protection granularity of the underlying hardware (e.g., older x86-32 architectures) mean that, on many UNIX implementations, <span class="literal">PROT_READ</span> implies <span class="literal">PROT_EXEC</span> and vice versa, and on some implementations, specifying <span class="literal">PROT_WRITE</span> implies <span class="literal">PROT_READ</span>. However, applications should not rely on such behavior; <em>prot</em> should always specify exactly the memory protections that are required.</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_1022"/>Modern x86-32 architectures provide hardware support for marking pages tables as <em>NX</em> (no execute), and, since kernel 2.6.8, Linux makes use of this feature to properly separate <span class="literal">PROT_READ</span> and <span class="literal">PROT_EXEC</span> permissions on Linux/x86-32.</p>
</div>
<h5 class="h5" id="ch49lev3sec02"><strong>Alignment restrictions specified in standards for <em>offset</em> and <em>addr</em></strong></h5>
<p class="noindentab">SUSv3 specifies that the <em>offset</em> argument of <em>mmap()</em> must be page-aligned, and that the <em>addr</em> argument must also be page-aligned if <span class="literal">MAP_FIXED</span> is specified. Linux conforms to these requirements. However, it was later noted that the SUSv3 requirements differed from earlier standards, which imposed looser requirements on these arguments. The consequence of the SUSv3 wording was to (unnecessarily) render some formerly standards-conformant implementations nonconforming. SUSv4 returns to the looser requirements:</p>
<p class="bull">&#8226; An implementation may require that <em>offset</em> be a multiple of the system page size.</p>
<p class="bull">&#8226; If <span class="literal">MAP_FIXED</span> is specified, then an implementation may require that <em>addr</em> be page-aligned.</p>
<p class="bull">&#8226; If <span class="literal">MAP_FIXED</span> is specified, and <em>addr</em> is nonzero, then <em>addr</em> and <em>offset</em> shall have the same remainder modulo the system page size.</p>
<div class="block">
<p class="noindent">A similar situation arose for the <em>addr</em> argument of <em>mprotect()</em>, <em>msync()</em>, and <em>munmap()</em>. SUSv3 specified that this argument must be page-aligned. SUSv4 says that an implementation may require this argument to be page-aligned.</p>
</div>
<h5 class="h5" id="ch49lev3sec03"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch49.xhtml#ch49ex1">Listing 49-1</a> demonstrates the use of <em>mmap()</em> to create a private file mapping. This program is a simple version of <em>cat(1)</em>. It maps the (entire) file named in its command-line argument, and then writes the contents of the mapping to standard output.</p>
<p class="examplet"><a id="ch49ex1"/><strong>Listing 49-1:</strong> Using <em>mmap()</em> to create a private file mapping</p>
<p class="programsli">____________________________________________________________ <span class="codestrong">mmap/mmcat.c</span><br/><br/>#include &lt;sys/mman.h&gt;<br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;char *addr;<br/>&#160;&#160;&#160;&#160;int fd;<br/>&#160;&#160;&#160;&#160;struct stat sb;<br/><br/>&#160;&#160;&#160;&#160;if (argc != 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s file\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;fd = open(argv[1], O_RDONLY);<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open");<br/><br/>&#160;&#160;&#160;&#160;/* Obtain the size of the file and use it to specify the size of<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;the mapping and the size of the buffer to be written */<br/><br/>&#160;&#160;&#160;&#160;if (fstat(fd, &#38;sb) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fstat");<br/><br/>&#160;&#160;&#160;&#160;addr = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);<br/>&#160;&#160;&#160;&#160;if (addr == MAP_FAILED)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mmap");<br/><br/>&#160;&#160;&#160;&#160;if (write(STDOUT_FILENO, addr, sb.st_size) != sb.st_size)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("partial/failed write");<br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>____________________________________________________________ <span class="codestrong">mmap/mmcat.c</span></p>
<h3 class="h3" id="ch49lev1sec03"><span epub:type="pagebreak" id="page_1023"/><strong>49.3 Unmapping a Mapped Region: <em>munmap()</em></strong></h3>
<p class="noindenta">The <em>munmap()</em> system call performs the converse of <em>mmap()</em>, removing a mapping from the calling process&#8217;s virtual address space.</p>
<div class="box">
<p class="programsa">#include &lt;sys/mman.h&gt;<br/><br/>int <span class="codestrong">munmap</span>(void *<span class="font1">addr</span>, size_t <span class="font1">length</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>addr</em> argument is the starting address of the address range to be unmapped. It must be aligned to a page boundary. (SUSv3 specified that <em>addr must</em> be page-aligned. SUSv4 says that an implementation <em>may</em> require this argument to be page-aligned.)</p>
<p class="indent">The <em>length</em> argument is a nonnegative integer specifying the size (in bytes) of the region to be unmapped. The address range up to the next multiple of the system page size will be unmapped.</p>
<p class="indent">Commonly, we unmap an entire mapping. Thus, we specify <em>addr</em> as the address returned by a previous call to <em>mmap()</em>, and specify the same <em>length</em> value as was used in the <em>mmap()</em> call. Here&#8217;s an example:</p>
<p class="programs">addr = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);<br/>if (addr == MAP_FAILED)<br/>&#160;&#160;&#160;&#160;errExit("mmap");<br/><br/>/* Code for working with mapped region */<br/><br/>if (munmap(addr, length) == -1)<br/>&#160;&#160;&#160;&#160;errExit("munmap");</p>
<p class="noindent">Alternatively, we can unmap part of a mapping, in which case the mapping either shrinks or is cut in two, depending on where the unmapping occurs. It is also possible to specify an address range spanning several mappings, in which case all of the mappings are unmapped.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1024"/>If there are no mappings in the address range specified by <em>addr</em> and <em>length</em>, then <em>munmap()</em> has no effect, and returns 0 (for success).</p>
<p class="indent">During unmapping, the kernel removes any memory locks that the process holds for the specified address range. (Memory locks are established using <em>mlock()</em> or <em>mlockall()</em>, as described in <a href="ch50.xhtml#ch50lev1sec02">Section 50.2</a>.)</p>
<p class="indent">All of a process&#8217;s mappings are automatically unmapped when it terminates or performs an <em>exec()</em>.</p>
<p class="indent">To ensure that the contents of a shared file mapping are written to the underlying file, a call to <em>msync()</em> (<a href="ch49.xhtml#ch49lev1sec05">Section 49.5</a>) should be made before unmapping a mapping with <em>munmap()</em>.</p>
<h3 class="h3" id="ch49lev1sec04"><strong>49.4 File Mappings</strong></h3>
<p class="noindenta">To create a file mapping, we perform the following steps:</p>
<ol>
<li class="order"><p class="orderp">Obtain a descriptor for the file, typically via a call to <em>open()</em>.</p></li>
<li class="order"><p class="orderp">Pass that file descriptor as the <em>fd</em> argument in a call to <em>mmap()</em>.</p></li>
</ol>
<p class="noindent">As a result of these steps, <em>mmap()</em> maps the contents of the open file into the address space of the calling process. Once <em>mmap()</em> has been called, we can close the file descriptor without affecting the mapping. However, in some cases it may be useful to keep this file descriptor open&#8212;see, for example, <a href="ch49.xhtml#ch49ex1">Listing 49-1</a> and also <a href="ch54.xhtml#ch54">Chapter 54</a>.</p>
<div class="block">
<p class="noindent">As well as normal disk files, it is possible to use <em>mmap()</em> to map the contents of various real and virtual devices, such as hard disks, optical disks, and <span class="literal">/dev/mem</span>.</p>
</div>
<p class="noindent">The file referred to by the descriptor <em>fd</em> must have been opened with permissions appropriate for the values specified in <em>prot</em> and <em>flags</em>. In particular, the file must always be opened for reading, and, if <span class="literal">PROT_WRITE</span> and <span class="literal">MAP_SHARED</span> are specified in <em>flags</em>, then the file must be opened for both reading and writing.</p>
<p class="indent">The <em>offset</em> argument specifies the starting byte of the region to be mapped from the file, and must be a multiple of the system page size. Specifying <em>offset</em> as 0 causes the file to be mapped from the beginning. The <em>length</em> argument specifies the number of bytes to be mapped. Together, the <em>offset</em> and <em>length</em> arguments determine which region of the file is to be mapped into memory, as shown in <a href="ch49.xhtml#ch49fig1">Figure 49-1</a>.</p>
<div class="block">
<p class="noindent">On Linux, the pages of a file mapping are mapped in on the first access. This means that if changes are made to a file region after the <em>mmap()</em> call, but before the corresponding part (i.e., page) of the mapping is accessed, then the changes may be visible to the process, if the page has not otherwise already been loaded into memory. This behavior is implementation-dependent; portable applications should avoid relying on a particular kernel behavior in this scenario.</p>
</div>
<h4 class="h4" id="ch49lev2sec01"><strong>49.4.1 Private File Mappings</strong></h4>
<p class="noindentab">The two most common uses of private file mappings are the following:</p>
<p class="bull">&#8226; To allow multiple processes executing the same program or using the same shared library to share the same (read-only) text segment, which is mapped from the corresponding part of the underlying executable or library file.</p>
<div class="block1">
<p class="noindent"><span epub:type="pagebreak" id="page_1025"/>Although the executable text segment is normally protected to allow only read and execute access (<span class="literal">PROT_READ | PROT_EXEC</span>), it is mapped using <span class="literal">MAP_PRIVATE</span> rather than <span class="literal">MAP_SHARED</span>, because a debugger or a self-modifying program can modify the program text (after first changing the protection on the memory), and such changes should not be carried through to the underlying file or affect other processes.</p>
</div>
<p class="bull">&#8226; To map the initialized data segment of an executable or shared library. Such mappings are made private so that modifications to the contents of the mapped data segment are not carried through to the underlying file.</p>
<p class="noindentt">Both of these uses of <em>mmap()</em> are normally invisible to a program, because these mappings are created by the program loader and dynamic linker. Examples of both kinds of mappings can be seen in the <span class="literal">/proc/</span><em>PID</em><span class="literal">/maps</span> output shown in <a href="ch48.xhtml#ch48lev1sec05">Section 48.5</a>.</p>
<p class="indent">One other, less frequent, use of a private file mapping is to simplify the file-input logic of a program. This is similar to the use of shared file mappings for memory-mapped I/O (described in the next section), but allows only for file input.</p>
<div class="image"><img src="../images/f49-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch49fig1"/><strong>Figure 49-1:</strong> Overview of memory-mapped file</p>
<h4 class="h4" id="ch49lev2sec02"><strong>49.4.2 Shared File Mappings</strong></h4>
<p class="noindenta">When multiple processes create shared mappings of the same file region, they all share the same physical pages of memory. In addition, modifications to the contents of the mapping are carried through to the file. In effect, the file is being treated as the paging store for this region of memory, as shown in <a href="ch49.xhtml#ch49fig2">Figure 49-2</a>. (We simplify things in this diagram by omitting to show that the mapped pages are typically not contiguous in physical memory.)</p>
<p class="indent">Shared file mappings serve two purposes: memory-mapped I/O and IPC. We consider each of these uses below.</p>
<div class="image"><span epub:type="pagebreak" id="page_1026"/><img src="../images/f49-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch49fig2"/><strong>Figure 49-2:</strong> Two processes with a shared mapping of the same region of a file</p>
<h5 class="h5" id="ch49lev3sec04"><strong>Memory-mapped I/O</strong></h5>
<p class="noindenta">Since the contents of the shared file mapping are initialized from the file, and any modifications to the contents of the mapping are automatically carried through to the file, we can perform file I/O simply by accessing bytes of memory, relying on the kernel to ensure that the changes to memory are propagated to the mapped file. (Typically, a program would define a structured data type that corresponds to the contents of the disk file, and then use that data type to cast the contents of the mapping.) This technique is referred to as <em>memory-mapped I/O</em>, and is an alternative to using <em>read()</em> and <em>write()</em> to access the contents of a file.</p>
<p class="indentb">Memory-mapped I/O has two potential advantages:</p>
<p class="bull">&#8226; By replacing <em>read()</em> and <em>write()</em> system calls with memory accesses, it can simplify the logic of some applications.</p>
<p class="bull">&#8226; It can, in some circumstances, provide better performance than file I/O carried out using the conventional I/O system calls.</p>
<p class="noindenttb">The reasons that memory-mapped I/O can provide performance benefits are as follows:</p>
<p class="bull">&#8226; A normal <em>read()</em> or <em>write()</em> involves two transfers: one between the file and the kernel buffer cache, and the other between the buffer cache and a user-space buffer. Using <em>mmap()</em> eliminates the second of these transfers. For input, the data is available to the user process as soon as the kernel has mapped the <span epub:type="pagebreak" id="page_1027"/>corresponding file blocks into memory. For output, the user process merely needs to modify the contents of the memory, and can then rely on the kernel memory manager to automatically update the underlying file.</p>
<p class="bull">&#8226; In addition to saving a transfer between kernel space and user space, <em>mmap()</em> can also improve performance by lowering memory requirements. When using <em>read()</em> or <em>write()</em>, the data is maintained in two buffers: one in user space and the other in kernel space. When using <em>mmap()</em>, a single buffer is shared between the kernel space and user space. Furthermore, if multiple processes are performing I/O on the same file, then, using <em>mmap()</em>, they can all share the same kernel buffer, resulting in an additional memory saving.</p>
<p class="noindentt">Performance benefits from memory-mapped I/O are most likely to be realized when performing repeated random accesses in a large file. If we are performing sequential access of a file, then <em>mmap()</em> will probably provide little or no gain over <em>read()</em> and <em>write()</em>, assuming that we perform I/O using buffer sizes big enough to avoid making a large number of I/O system calls. The reason that there is little performance benefit is that, regardless of which technique we use, the entire contents of the file will be transferred between disk and memory exactly once, and the efficiency gains of eliminating a data transfer between user space and kernel space and reducing memory usage are typically negligible compared to the time required for disk I/O.</p>
<div class="block">
<p class="noindent">Memory-mapped I/O can also have disadvantages. For small I/Os, the cost of memory-mapped I/O (i.e., mapping, page faulting, unmapping, and updating the hardware memory management unit&#8217;s translation look-aside buffer) can actually be higher than for a simple <em>read()</em> or <em>write()</em>. In addition, it can sometimes be difficult for the kernel to efficiently handle write-back for writable mappings (the use of <em>msync()</em> or <em>sync_file_range()</em> can help improve efficiency in this case).</p>
</div>
<h5 class="h5" id="ch49lev3sec05"><strong>IPC using a shared file mapping</strong></h5>
<p class="noindenta">Since all processes with a shared mapping of the same file region share the same physical pages of memory, the second use of a shared file mapping is as a method of (fast) IPC. The feature that distinguishes this type of shared memory region from a System V shared memory object (<a href="ch48.xhtml#ch48">Chapter 48</a>) is that modifications to the contents of the region are carried through to the underlying mapped file. This feature is useful in an application that requires the shared memory contents to persist across application or system restarts.</p>
<h5 class="h5" id="ch49lev3sec06"><strong>Example program</strong></h5>
<p class="noindenta"><a href="ch49.xhtml#ch49ex2">Listing 49-2</a> provides a simple example of the use of <em>mmap()</em> to create a shared file mapping. This program begins by mapping the file named in its first command-line argument. It then prints the value of the string lying at the start of the mapped region. Finally, if a second command-line argument is supplied, that string is copied into the shared memory region.</p>
<p class="indent">The following shell session log demonstrates the use of this program. We begin by creating a 1024-byte file that is populated with zeros:</p>
<p class="programs">$ <span class="codestrong">dd if=/dev/zero of=s.txt bs=1 count=1024</span><br/>1024+0 records in<br/>1024+0 records out</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1028"/>We then use our program to map the file and copy a string into the mapped region:</p>
<p class="programs">$ <span class="codestrong">./t_mmap s.txt hello</span><br/>Current string=<br/>Copied "hello" to shared memory</p>
<p class="noindent">The program displayed nothing for the current string because the initial value of the mapped files began with a null byte (i.e., zero-length string).</p>
<p class="indent">Next, we use our program to again map the file and copy a new string into the mapped region:</p>
<p class="programs">$ <span class="codestrong">./t_mmap s.txt goodbye</span><br/>Current string=hello<br/>Copied "goodbye" to shared memory</p>
<p class="noindent">Finally, we dump the contents of the file, 8 characters per line, to verify its contents:</p>
<p class="programs">$ <span class="codestrong">od -c -w8 s.txt</span><br/>0000000&#160;&#160;&#160;g&#160;&#160;&#160;o&#160;&#160;&#160;o&#160;&#160;&#160;d&#160;&#160;&#160;b&#160;&#160;&#160;y&#160;&#160;&#160;e nul<br/>0000010 nul nul nul nul nul nul nul nul<br/>*<br/>0002000</p>
<p class="noindent">Our trivial program doesn&#8217;t use any mechanism to synchronize access by multiple processes to the mapped file. However, real-world applications typically need to synchronize access to shared mappings. This can be done using a variety of techniques, including semaphores (<a href="ch47.xhtml#ch47">Chapters 47</a> and <a href="ch53.xhtml#ch53">53</a>) and file locking (<a href="ch55.xhtml#ch55">Chapter 55</a>).</p>
<p class="indent">We explain the <em>msync()</em> system call used in <a href="ch49.xhtml#ch49ex2">Listing 49-2</a> in <a href="ch49.xhtml#ch49lev1sec05">Section 49.5</a>.</p>
<p class="examplet"><a id="ch49ex2"/><strong>Listing 49-2:</strong> Using <em>mmap()</em> to create a shared file mapping</p>
<p class="programsli">___________________________________________________________ <span class="codestrong">mmap/t_mmap.c</span><br/><br/>#include &lt;sys/mman.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>#define MEM_SIZE 10<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;char *addr;<br/>&#160;&#160;&#160;&#160;int fd;<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s file [new-value]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;fd = open(argv[1], O_RDWR);<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open");<br/><br/>&#160;&#160;&#160;&#160;addr = mmap(NULL, MEM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);<br/>&#160;&#160;&#160;&#160;if (addr == MAP_FAILED)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mmap");<br/><br/>&#160;&#160;&#160;&#160;if (close(fd) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* No longer need 'fd' */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close");<br/><br/>&#160;&#160;&#160;&#160;printf("Current string=%.*s\n", MEM_SIZE, addr);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Secure practice: output at most MEM_SIZE bytes */<br/><br/>&#160;&#160;&#160;&#160;if (argc &gt; 2) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Update contents of region */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (strlen(argv[2]) &gt;= MEM_SIZE)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cmdLineErr("'new-value' too large\n");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;memset(addr, 0, MEM_SIZE);&#160;&#160;&#160;&#160;&#160;&#160;/* Zero out region */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;strncpy(addr, argv[2], MEM_SIZE - 1);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (msync(addr, MEM_SIZE, MS_SYNC) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("msync");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Copied \"%s\" to shared memory\n", argv[2]);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>___________________________________________________________ <span class="codestrong">mmap/t_mmap.c</span></p>
<h4 class="h4" id="ch49lev2sec03"><span epub:type="pagebreak" id="page_1029"/><strong>49.4.3 Boundary Cases</strong></h4>
<p class="noindenta">In many cases, the size of a mapping is a multiple of the system page size, and the mapping falls entirely within the bounds of the mapped file. However, this is not necessarily so, and we now look at what happens when these conditions don&#8217;t hold.</p>
<p class="indent"><a href="ch49.xhtml#ch49fig3">Figure 49-3</a> portrays the case where the mapping falls entirely within the bounds of the mapped file, but the size of the region is not a multiple of the system page size (which we assume is 4096 bytes for the purposes of this discussion).</p>
<div class="image"><img src="../images/f49-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch49fig3"/><strong>Figure 49-3:</strong> Memory mapping whose <em>length</em> is not a multiple of the system page size</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1030"/>Since the size of the mapping is not a multiple of the system page size, it is rounded up to the next multiple of the system page size. Because the file is larger than this rounded-up size, the corresponding bytes of the file are mapped as shown in <a href="ch49.xhtml#ch49fig3">Figure 49-3</a>.</p>
<p class="indent">Attempts to access bytes beyond the end of the mapping result in the generation of a <span class="literal">SIGSEGV</span> signal (assuming that there is no other mapping at that location). The default action for this signal is to terminate the process with a core dump.</p>
<p class="indent">When the mapping extends beyond the end of the underlying file (see <a href="ch49.xhtml#ch49fig4">Figure 49-4</a>), the situation is more complex. As before, because the size of the mapping is not a multiple of the system page size, it is rounded up. However, in this case, while the bytes in the rounded-up region (i.e., bytes 2200 to 4095 in the diagram) are accessible, they are not mapped to the underlying file (since no corresponding bytes exist in the file). Instead, they are initialized to 0 (SUSv3 requires this). These bytes will nevertheless be shared with other processes mapping the file, if they specify a sufficiently large <em>length</em> argument. Changes to these bytes are not written to the file.</p>
<p class="indent">If the mapping includes pages beyond the rounded-up region (i.e., bytes 4096 and beyond in <a href="ch49.xhtml#ch49fig4">Figure 49-4</a>), then attempts to access addresses in these pages result in the generation of a <span class="literal">SIGBUS</span> signal, which warns the process that there is no region of the file corresponding to these addresses. As before, attempts to access addresses beyond the end of the mapping result in the generation of a <span class="literal">SIGSEGV</span> signal.</p>
<p class="indent">From the above description, it may appear pointless to create a mapping whose size exceeds that of the underlying file. However, by extending the size of the file (e.g., using <em>ftruncate()</em> or <em>write()</em>), we can render previously inaccessible parts of such a mapping usable.</p>
<div class="image"><img src="../images/f49-04.jpg" alt="image"/></div>
<p class="figcap"><a id="ch49fig4"/><strong>Figure 49-4:</strong> Memory mapping extending beyond end of mapped file</p>
<h4 class="h4" id="ch49lev2sec04"><strong>49.4.4 Memory Protection and File Access Mode Interactions</strong></h4>
<p class="noindenta">One point that we have not so far explained in detail is the interaction between the memory protection specified in the <em>mmap() prot</em> argument and the mode in which the mapped file is opened. As a general principle, we can say that the <span class="literal">PROT_READ</span> and <span class="literal">PROT_EXEC</span> protections require that the mapped file is opened <span class="literal">O_RDONLY</span> or <span class="literal">O_RDWR</span>, and that the <span class="literal">PROT_WRITE</span> protection requires that the mapped file is opened <span class="literal">O_WRONLY</span> or <span class="literal">O_RDWR</span>.</p>
<p class="indentb"><span epub:type="pagebreak" id="page_1031"/>However, the situation is complicated by the limited granularity of memory protections provided by some hardware architectures (<a href="ch49.xhtml#ch49lev1sec02">Section 49.2</a>). For such architectures, we make the following observations:</p>
<p class="bull">&#8226; All combinations of memory protection are compatible with opening the file with the <span class="literal">O_RDWR</span> flag.</p>
<p class="bull">&#8226; No combination of memory protections&#8212;not even just <span class="literal">PROT_WRITE</span>&#8212;is compatible with a file opened <span class="literal">O_WRONLY</span> (the error <span class="literal">EACCES</span> results). This is consistent with the fact that some hardware architectures don&#8217;t allow us write-only access to a page. As noted in <a href="ch49.xhtml#ch49lev1sec02">Section 49.2</a>, <span class="literal">PROT_WRITE</span> implies <span class="literal">PROT_READ</span> on those architectures, which means that if the page can be written, then it can also be read. A read operation is incompatible with <span class="literal">O_WRONLY</span>, which must not reveal the original contents of the file.</p>
<p class="bull">&#8226; The results when a file is opened with the <span class="literal">O_RDONLY</span> flag depend on whether we specify <span class="literal">MAP_PRIVATE</span> or <span class="literal">MAP_SHARED</span> when calling <em>mmap()</em>. For a <span class="literal">MAP_PRIVATE</span> mapping, we can specify any combination of memory protection in <em>mmap()</em>&#8212;because modifications to the contents of a <span class="literal">MAP_PRIVATE</span> page are never written to the file, the inability to write to the file is not a problem. For a <span class="literal">MAP_SHARED</span> mapping, the only memory protections that are compatible with <span class="literal">O_RDONLY</span> are <span class="literal">PROT_READ</span> and <span class="literal">(PROT_READ | PROT_EXEC)</span>. This is logical, since a <span class="literal">PROT_WRITE</span>, <span class="literal">MAP_SHARED</span> mapping allows updates to the mapped file.</p>
<h3 class="h3" id="ch49lev1sec05"><strong>49.5 Synchronizing a Mapped Region: <em>msync()</em></strong></h3>
<p class="noindenta">The kernel automatically carries modifications of the contents of a <span class="literal">MAP_SHARED</span> mapping through to the underlying file, but, by default, provides no guarantees about when such synchronization will occur. (SUSv3 doesn&#8217;t require an implementation to provide such guarantees.)</p>
<p class="indent">The <em>msync()</em> system call gives an application explicit control over when a shared mapping is synchronized with the mapped file. Synchronizing a mapping with the underlying file is useful in various scenarios. For example, to ensure data integrity, a database application may call <em>msync()</em> to force data to be written to the disk. Calling <em>msync()</em> also allows an application to ensure that updates to a writable mapping are visible to some other process that performs a <em>read()</em> on the file.</p>
<div class="box">
<p class="programsa">#include &lt;sys/mman.h&gt;<br/><br/>int <span class="codestrong">msync</span>(void *<span class="font1">addr</span>, size_t <span class="font1">length</span>, int <span class="font1">flags</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>addr</em> and <em>length</em> arguments to <em>msync()</em> specify the starting address and size of the memory region to be synchronized. The address specified in <em>addr</em> must be page-aligned, and <em>length</em> is rounded up to the next multiple of the system page size. (SUSv3 specified that <em>addr must</em> be page-aligned. SUSv4 says that an implementation <em>may</em> require this argument to be page-aligned.)</p>
<p class="noindentb"><span epub:type="pagebreak" id="page_1032"/>Possible values for the <em>flags</em> argument include one of the following:</p>
<p class="term"><span class="literal">MS_SYNC</span></p>
<p class="termlist">Perform a synchronous file write. The call blocks until all modified pages of the memory region have been written to the disk.</p>
<p class="term"><span class="literal">MS_ASYNC</span></p>
<p class="termlist">Perform an asynchronous file write. The modified pages of the memory region are written to the disk at some later point and are immediately made visible to other processes performing a <em>read()</em> on the corresponding file region.</p>
<p class="noindentt">Another way of distinguishing these two values is to say that after an <span class="literal">MS_SYNC</span> operation, the memory region is synchronized with the disk, while after an <span class="literal">MS_ASYNC</span> operation, the memory region is merely synchronized with the kernel buffer cache.</p>
<div class="block">
<p class="noindent">If we take no further action after an <span class="literal">MS_ASYNC</span> operation, then the modified pages in the memory region will eventually be flushed as part of the automatic buffer flushing performed by the <em>pdflush</em> kernel thread (<em>kupdated</em> in Linux 2.4 and earlier). On Linux, there are two (nonstandard) methods of initiating the output sooner. We can follow the call to <em>msync()</em> with a call to <em>fsync()</em> (or <em>fdatasync()</em>) on the file descriptor corresponding to the mapping. This call will block until the buffer cache is synchronized with the disk. Alternatively, we can initiate asynchronous write out of the pages using the <em>posix_fadvise()</em> <span class="literal">POSIX_FADV_DONTNEED</span> operation. (The Linux-specific details in these two cases are not specified by SUSv3.)</p>
</div>
<p class="noindentb">One other value can additionally be specified for <em>flags</em>:</p>
<p class="term"><span class="literal">MS_INVALIDATE</span></p>
<p class="termlist">Invalidate cached copies of mapped data. After any modified pages in the memory region have been synchronized with the file, all pages of the memory region that are inconsistent with the underlying file data are marked as invalid. When next referenced, the contents of the pages will be copied from the corresponding locations in the file. As a consequence, any updates that have been made to the file by another process are made visible in the memory region.</p>
<p class="noindentt">Like many other modern UNIX implementations, Linux provides a so-called <em>unified virtual memory</em> system. This means that, where possible, memory mappings and blocks of the buffer cache share the same pages of physical memory. Thus, the views of a file obtained via a mapping and via I/O system calls (<em>read()</em>, <em>write()</em>, and so on) are always consistent, and the only use of <em>msync()</em> is to force the contents of a mapped region to be flushed to disk.</p>
<p class="indent">However, a unified virtual memory system is not required by SUSv3 and is not employed on all UNIX implementations. On such systems, a call to <em>msync()</em> is required to make changes to the contents of a mapping visible to other processes that <em>read()</em> the file, and the <span class="literal">MS_INVALIDATE</span> flag is required to perform the converse action of making writes to the file by another process visible in the mapped region. Multiprocess applications that employ both <em>mmap()</em> and I/O system calls to operate on the same file should be designed to make appropriate use of <em>msync()</em> if they are to be portable to systems that don&#8217;t have a unified virtual memory system.</p>
<h3 class="h3" id="ch49lev1sec06"><span epub:type="pagebreak" id="page_1033"/><strong>49.6 Additional <em>mmap()</em> Flags</strong></h3>
<p class="noindenta">In addition to <span class="literal">MAP_PRIVATE</span> and <span class="literal">MAP_SHARED</span>, Linux allows a number of other values to be included (ORed) in the <em>mmap() flags</em> argument. <a href="ch49.xhtml#ch49table3">Table 49-3</a> summarizes these values. Other than <span class="literal">MAP_PRIVATE</span> and <span class="literal">MAP_SHARED</span>, only the <span class="literal">MAP_FIXED</span> flag is specified in SUSv3.</p>
<p class="tablecap"><a id="ch49table3"/><strong>Table 49-3:</strong> Bit-mask values for the <em>mmap() flags</em> argument</p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Value</strong></p></td>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Description</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="tablec"><strong>SUSv3</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MAP_ANONYMOUS</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Create an anonymous mapping</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MAP_FIXED</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Interpret <em>addr</em> argument exactly (<a href="ch49.xhtml#ch49lev1sec10">Section 49.10</a>)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MAP_LOCKED</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Lock mapped pages into memory (since Linux 2.6)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MAP_HUGETLB</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Create a mapping that uses huge pages (since Linux 2.6.32)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MAP_NORESERVE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Control reservation of swap space (<a href="ch49.xhtml#ch49lev1sec09">Section 49.9</a>)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MAP_PRIVATE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Modifications to mapped data are private</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MAP_POPULATE</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Populate the pages of a mapping (since Linux 2.6)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">&#160;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MAP_SHARED</span></p></td>
<td style="vertical-align: top;" class="table_1"><p class="table">Modifications to mapped data are visible to other processes and propagated to underlying file (converse of <span class="literal">MAP_PRIVATE</span>)</p></td>
<td style="vertical-align: top;" class="table_2"><p class="tablec">&#8226;</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">MAP_UNINITIALIZED</span></p></td>
<td style="vertical-align: top;" class="table_3"><p class="table">Don&#8217;t clear an anonymous mapping (since Linux 2.6.33)</p></td>
<td style="vertical-align: top;" class="table_3a"><p class="tablec">&#160;</p></td>
</tr>
</tbody>
</table>
<p class="noindentb">The following list provides further details on the <em>flags</em> values listed in <a href="ch49.xhtml#ch49table3">Table 49-3</a> (other than <span class="literal">MAP_PRIVATE</span> and <span class="literal">MAP_SHARED</span>, which have already been discussed):</p>
<p class="term"><span class="literal">MAP_ANONYMOUS</span></p>
<p class="termlist">Create an anonymous mapping&#8212;that is, a mapping that is not backed by a file. We describe this flag further in <a href="ch49.xhtml#ch49lev1sec07">Section 49.7</a>.</p>
<p class="term"><span class="literal">MAP_FIXED</span></p>
<p class="termlist">We describe this flag in <a href="ch49.xhtml#ch49lev1sec10">Section 49.10</a>.</p>
<p class="term"><span class="literal">MAP_HUGETLB</span> (since Linux 2.6.32)</p>
<p class="termlist">This flag serves the same purpose for <em>mmap()</em> as the <span class="literal">SHM_HUGETLB</span> flag serves for System V shared memory segments. See <a href="ch48.xhtml#ch48lev1sec02">Section 48.2</a>.</p>
<p class="term"><span class="literal">MAP_LOCKED</span> (since Linux 2.6)</p>
<p class="termlist">Preload and lock the mapped pages into memory in the manner of <em>mlock()</em>. We describe the privileges required to use this flag and the limits governing its operation in <a href="ch50.xhtml#ch50lev1sec02">Section 50.2</a>.</p>
<p class="term"><span class="literal">MAP_NORESERVE</span></p>
<p class="termlist">This flag is used to control whether reservation of swap space for the mapping is performed in advance. See <a href="ch49.xhtml#ch49lev1sec09">Section 49.9</a> for details.</p>
<p class="term"><span class="literal">MAP_POPULATE</span> (since Linux 2.6)</p>
<p class="termlist">Populate the pages of a mapping. For a file mapping, this will perform read-ahead on the file. This means that later accesses of the contents of the mapping won&#8217;t be blocked by page faults (assuming that memory pressure has not in the meantime caused the pages to be swapped out).</p>
<p class="term"><span epub:type="pagebreak" id="page_1034"/><span class="literal">MAP_UNINITIALIZED</span> (since Linux 2.6.33)</p>
<p class="termlist">Specifying this flag prevents the pages of an anonymous mapping from being zeroed. It provides a performance benefit, but carries a security risk, because the allocated pages may contain sensitive information left by a previous process. This flag is thus only intended for use on embedded systems, where performance may be critical, and the entire system is under the control of the embedded application(s). This flag is only honored if the kernel was configured with the <span class="literal">CONFIG_MMAP_ALLOW_UNINITIALIZED</span> option.</p>
<h3 class="h3" id="ch49lev1sec07"><strong>49.7 Anonymous Mappings</strong></h3>
<p class="noindenta">An <em>anonymous mapping</em> is one that doesn&#8217;t have a corresponding file. In this section, we show how to create anonymous mappings, and look at the purposes served by private and shared anonymous mappings.</p>
<h5 class="h5" id="ch49lev3sec07"><span class="literal"><span class="codestrong">MAP_ANONYMOUS</span></span> <strong>and</strong> <span class="literal"><span class="codestrong">/dev/zero</span></span></h5>
<p class="noindentab">On Linux, there are two different, equivalent methods of creating an anonymous mapping with <em>mmap()</em>:</p>
<p class="bull">&#8226; Specify <span class="literal">MAP_ANONYMOUS</span> in <em>flags</em> and specify <em>fd</em> as &#8211;1. (On Linux, the value of <em>fd</em> is ignored when <span class="literal">MAP_ANONYMOUS</span> is specified. However, some UNIX implementations require <em>fd</em> to be &#8211;1 when employing <span class="literal">MAP_ANONYMOUS</span>, and portable applications should ensure that they do this.)</p>
<div class="block1">
<p class="noindentb">We must define either the <span class="literal">_BSD_SOURCE</span> or the <span class="literal">_SVID_SOURCE</span> feature test macros to get the definition of <span class="literal">MAP_ANONYMOUS</span> from <span class="literal">&lt;sys/mman.h&gt;</span>. Linux provides the constant <span class="literal">MAP_ANON</span> as a synonym for <span class="literal">MAP_ANONYMOUS</span> for compatibility with some other UNIX implementations using this alternative name.</p>
</div>
<p class="bull">&#8226; Open the <span class="literal">/dev/zero</span> device file and pass the resulting file descriptor to <em>mmap()</em>.</p>
<div class="block1">
<p class="noindent"><span class="literal">/dev/zero</span> is a virtual device that always returns zeros when we read from it. Writes to this device are always discarded. A common use of <span class="literal">/dev/zero</span> is to populate a file with zeros (e.g., using the <em>dd(1)</em> command).</p>
</div>
<p class="noindent">With both the <span class="literal">MAP_ANONYMOUS</span> and the <span class="literal">/dev/zero</span> techniques, the bytes of the resulting mapping are initialized to 0. For both techniques, the <em>offset</em> argument is ignored (since there is no underlying file in which to specify an offset). We show examples of each technique shortly.</p>
<div class="block">
<p class="noindent">The <span class="literal">MAP_ANONYMOUS</span> and <span class="literal">/dev/zero</span> techniques are not specified in SUSv3, although most UNIX implementations support one or both of them. The reason for the existence of two different techniques with the same semantics is that one (<span class="literal">MAP_ANONYMOUS</span>) derives from BSD, while the other (<span class="literal">/dev/zero</span>) derives from System V.</p>
</div>
<h5 class="h5" id="ch49lev3sec08"><span epub:type="pagebreak" id="page_1035"/><span class="literal"><span class="codestrong">MAP_PRIVATE</span></span> <strong>anonymous mappings</strong></h5>
<p class="noindenta"><span class="literal">MAP_PRIVATE</span> anonymous mappings are used to allocate blocks of process-private memory initialized to 0. We can use the <span class="literal">/dev/zero</span> technique to create a <span class="literal">MAP_PRIVATE</span> anonymous mapping as follows:</p>
<p class="programs">fd = open("/dev/zero", O_RDWR);<br/>if (fd == -1)<br/>&#160;&#160;&#160;&#160;errExit("open");<br/>addr = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);<br/>if (addr == MAP_FAILED)<br/>&#160;&#160;&#160;&#160;errExit("mmap");</p>
<div class="block">
<p class="noindent">The <em>glibc</em> implementation of <em>malloc()</em> uses <span class="literal">MAP_PRIVATE</span> anonymous mappings to allocate blocks of memory larger than <span class="literal">MMAP_THRESHOLD</span> bytes. This makes it possible to efficiently deallocate such blocks (via <em>munmap()</em>) if they are later given to <em>free()</em>. (It also reduces the possibility of memory fragmentation when repeatedly allocating and deallocating large blocks of memory.) <span class="literal">MMAP_THRESHOLD</span> is 128 kB by default, but this parameter is adjustable via the <em>mallopt()</em> library function.</p>
</div>
<h5 class="h5" id="ch49lev3sec09"><span class="literal"><span class="codestrong">MAP_SHARED</span></span> <strong>anonymous mappings</strong></h5>
<p class="noindenta">A <span class="literal">MAP_SHARED</span> anonymous mapping allows related processes (e.g., parent and child) to share a region of memory without needing a corresponding mapped file.</p>
<div class="block">
<p class="noindent"><span class="literal">MAP_SHARED</span> anonymous mappings are available only with Linux 2.4 and later.</p>
</div>
<p class="noindent">We can use the <span class="literal">MAP_ANONYMOUS</span> technique to create a <span class="literal">MAP_SHARED</span> anonymous mapping as follows:</p>
<p class="programs">addr = mmap(NULL, length, PROT_READ | PROT_WRITE,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MAP_SHARED | MAP_ANONYMOUS, -1, 0);<br/>if (addr == MAP_FAILED)<br/>&#160;&#160;&#160;&#160;errExit("mmap");</p>
<p class="noindent">If the above code is followed by a call to <em>fork()</em>, then, because the child produced by <em>fork()</em> inherits the mapping, both processes share the memory region.</p>
<h5 class="h5" id="ch49lev3sec10"><strong>Example program</strong></h5>
<p class="noindenta">The program in <a href="ch49.xhtml#ch49ex3">Listing 49-3</a> demonstrates the use of either <span class="literal">MAP_ANONYMOUS</span> or <span class="literal">/dev/zero</span> to share a mapped region between parent and child processes. The choice of technique is determined by whether <span class="literal">USE_MAP_ANON</span> is defined when compiling the program. The parent initializes an integer in the shared region to 1 prior to calling <em>fork()</em>. The child then increments the shared integer and exits, while the parent waits for the child to exit and then prints the value of the integer. When we run this program, we see the following:</p>
<p class="programs">$ <span class="codestrong">./anon_mmap</span><br/>Child started, value = 1<br/>In parent, value = 2</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1036"/><a id="ch49ex3"/><strong>Listing 49-3:</strong> Sharing an anonymous mapping between parent and child processes</p>
<p class="programsli">_________________________________________________________ <span class="codestrong">mmap/anon_mmap.c</span><br/><br/>#ifdef USE_MAP_ANON<br/>#define _BSD_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Get MAP_ANONYMOUS definition */<br/>#endif<br/>#include &lt;sys/wait.h&gt;<br/>#include &lt;sys/mman.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;int *addr;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Pointer to shared memory region */<br/><br/>#ifdef USE_MAP_ANON&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Use MAP_ANONYMOUS */<br/>&#160;&#160;&#160;&#160;addr = mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MAP_SHARED | MAP_ANONYMOUS, -1, 0);<br/>&#160;&#160;&#160;&#160;if (addr == MAP_FAILED)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mmap");<br/><br/>#else&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Map /dev/zero */<br/>&#160;&#160;&#160;&#160;int fd;<br/><br/>&#160;&#160;&#160;&#160;fd = open("/dev/zero", O_RDWR);<br/>&#160;&#160;&#160;&#160;if (fd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("open");<br/><br/>&#160;&#160;&#160;&#160;addr = mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);<br/>&#160;&#160;&#160;&#160;if (addr == MAP_FAILED)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("mmap");<br/><br/>&#160;&#160;&#160;&#160;if (close(fd) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* No longer needed */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("close");<br/>#endif<br/><br/>&#160;&#160;&#160;&#160;*addr = 1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Initialize integer in mapped region */<br/><br/>&#160;&#160;&#160;&#160;switch (fork()) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent and child share mapping */<br/>&#160;&#160;&#160;&#160;case -1:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("fork");<br/><br/>&#160;&#160;&#160;&#160;case 0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Child: increment shared integer and exit */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Child started, value = %d\n", *addr);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(*addr)++;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (munmap(addr, sizeof(int)) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("munmap");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/><br/>&#160;&#160;&#160;&#160;default:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Parent: wait for child to terminate */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (wait(NULL) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("wait");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("In parent, value = %d\n", *addr);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (munmap(addr, sizeof(int)) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("munmap");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>_________________________________________________________ <span class="codestrong">mmap/anon_mmap.c</span></p>
<h3 class="h3" id="ch49lev1sec08"><span epub:type="pagebreak" id="page_1037"/><strong>49.8 Remapping a Mapped Region: <em>mremap()</em></strong></h3>
<p class="noindenta">On most UNIX implementations, once a mapping has been created, its location and size can&#8217;t be changed. However, Linux provides the (nonportable) <em>mremap()</em> system call, which permits such changes.</p>
<div class="box">
<p class="programsa">#define _GNU_SOURCE<br/>#include &lt;sys/mman.h&gt;<br/><br/>void *<span class="codestrong">mremap</span>(void *<span class="font1">old_address</span>, size_t <span class="font1">old_size</span>, size_t <span class="font1">new_size</span>, int <span class="font1">flags</span>, ...);</p>
<p class="right">Returns starting address of remapped region on success, or <span class="literal">MAP_FAILED</span> on error</p>
</div>
<p class="noindent">The <em>old_address</em> and <em>old_size</em> arguments specify the location and size of an existing mapping that we wish to expand or shrink. The address specified in <em>old_address</em> must be page-aligned, and is normally a value returned by a previous call to <em>mmap()</em>. The desired new size of the mapping is specified in <em>new_size</em>. The values specified in <em>old_size</em> and <em>new_size</em> are both rounded up to the next multiple of the system page size.</p>
<p class="indentb">While carrying out the remapping, the kernel may relocate the mapping within the process&#8217;s virtual address space. Whether or not this is permitted is controlled by the <em>flags</em> argument, which is a bit mask that may either be 0 or include the following values:</p>
<p class="term"><span class="literal">MREMAP_MAYMOVE</span></p>
<p class="termlist">If this flag is specified, then, as space requirements dictate, the kernel may relocate the mapping within the process&#8217;s virtual address space. If this flag is not specified, and there is insufficient space to expand the mapping at the current location, then the error <span class="literal">ENOMEM</span> results.</p>
<p class="term"><span class="literal">MREMAP_FIXED</span> (since Linux 2.4)</p>
<p class="termlist">This flag can be used only in conjunction with <span class="literal">MREMAP_MAYMOVE</span>. It serves a purpose for <em>mremap()</em> that is analogous to that served by <span class="literal">MAP_FIXED</span> for <em>mmap()</em> (<a href="ch49.xhtml#ch49lev1sec10">Section 49.10</a>). If this flag is specified, then <em>mremap()</em> takes an additional argument, <em>void *new_address</em>, that specifies a page-aligned address to which the mapping should be moved. Any previous mapping in the address range specified by <em>new_address</em> and <em>new_size</em> is unmapped.</p>
<p class="noindentt">On success, <em>mremap()</em> returns the starting address of the mapping. Since (if the <span class="literal">MREMAP_MAYMOVE</span> flag is specified) this address may be different from the previous starting address, pointers into the region may cease to be valid. Therefore, applications that use <em>mremap()</em> should use only offsets (not absolute pointers) when referring to addresses in the mapped region (see <a href="ch48.xhtml#ch48lev1sec06">Section 48.6</a>).</p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_1038"/>On Linux, the <em>realloc()</em> function uses <em>mremap()</em> to efficiently reallocate large blocks of memory that <em>malloc()</em> previously allocated using <em>mmap()</em> <span class="literal">MAP_ANONYMOUS</span>. (We mentioned this feature of the <em>glibc malloc()</em> implementation in <a href="ch49.xhtml#ch49lev1sec07">Section 49.7</a>.) Using <em>mremap()</em> for this task makes it possible to avoid copying of bytes during the reallocation.</p>
</div>
<h3 class="h3" id="ch49lev1sec09"><strong>49.9</strong> <span class="literal"><span class="codestrong">MAP_NORESERVE</span></span> <strong>and Swap Space Overcommitting</strong></h3>
<p class="noindenta">Some applications create large (usually private anonymous) mappings, but use only a small part of the mapped region. For example, certain types of scientific applications allocate a very large array, but operate on only a few widely separated elements of the array (a so-called <em>sparse array</em>).</p>
<p class="indent">If the kernel always allocated (or reserved) enough swap space for the whole of such mappings, then a lot of swap space would potentially be wasted. Instead, the kernel can reserve swap space for the pages of a mapping only as they are actually required (i.e., when the application accesses a page). This approach is called <em>lazy swap reservation</em>, and has the advantage that the total virtual memory used by applications can exceed the total size of RAM plus swap space.</p>
<p class="indent">To put things another way, lazy swap reservation allows swap space to be overcommitted. This works fine, as long as all processes don&#8217;t attempt to access the entire range of their mappings. However, if all applications <em>do</em> attempt to access the full range of their mappings, RAM and swap space will be exhausted. In this situation, the kernel reduces memory pressure by killing one or more of the processes on the system. Ideally, the kernel attempts to select the process causing the memory problems (see the discussion of the <em>OOM killer</em> below), but this isn&#8217;t guaranteed. For this reason, we may choose to prevent lazy swap reservation, instead forcing the system to allocate all of the necessary swap space when the mapping is created.</p>
<p class="indent">How the kernel handles reservation of swap space is controlled by the use of the <span class="literal">MAP_NORESERVE</span> flag when calling <em>mmap()</em>, and via <span class="literal">/proc</span> interfaces that affect the system-wide operation of swap space overcommitting. These factors are summarized in <a href="ch49.xhtml#ch49table4">Table 49-4</a>.</p>
<p class="tablecap"><a id="ch49table4"/><strong>Table 49-4:</strong> Handling of swap space reservation during <em>mmap()</em></p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: middle;" class="table_th" rowspan="2"><p class="table"><span class="literal"><span class="codestrong">overcommit_memory</span></span> <strong>value</strong></p></td>
<td style="vertical-align: top;" class="table_th1" colspan="2"><p class="table"><span class="literal"><span class="codestrong">MAP_NORESERVE</span></span> <strong>specified in <em>mmap()</em> call?</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>No</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Yes</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">0</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Deny obvious overcommits</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Allow overcommits</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1b"><p class="table">1</p></td>
<td style="vertical-align: top;" class="table_1b"><p class="table">Allow overcommits</p></td>
<td style="vertical-align: top;" class="table_2b"><p class="table">Allow overcommits</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table">2 (since Linux 2.6)</p></td>
<td style="vertical-align: top;" class="table_3a" colspan="2"><p class="table">Strict overcommitting</p></td>
</tr>
</tbody>
</table>
<p class="noindent">The Linux-specific <span class="literal">/proc/sys/vm/overcommit_memory</span> file contains an integer value that controls the kernel&#8217;s handling of swap space overcommits. Linux versions before 2.6 differentiated only two values in this file: 0, meaning deny obvious overcommits (subject to the use of the <span class="literal">MAP_NORESERVE</span> flag), and greater than 0, meaning that overcommits should be permitted in all cases.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1039"/>Denying obvious overcommits means that new mappings whose size doesn&#8217;t exceed the amount of currently available free memory are permitted. Existing allocations may be overcommitted (since they may not be using all of the pages that they mapped).</p>
<p class="indent">Since Linux 2.6, a value of 1 has the same meaning as a positive value in earlier kernels, but the value 2 (or greater) causes <em>strict overcommitting</em> to be employed. In this case, the kernel performs strict accounting on all <em>mmap()</em> allocations and limits the system-wide total of all such allocations to be less than or equal to:</p>
<p class="programs">[swap size] + [RAM size] * overcommit_ratio / 100</p>
<p class="noindent">The <span class="literal">overcommit_ratio</span> value is an integer&#8212;expressing a percentage&#8212;contained in the Linux-specific <span class="literal">/proc/sys/vm/overcommit_ratio</span> file. The default value contained in this file is 50, meaning that the kernel can overallocate up to 50% of the size of the system&#8217;s RAM, and this will be successful, as long as not all processes try to use their full allocation.</p>
<p class="indentb">Note that overcommit monitoring comes into play only for the following types of mappings:</p>
<p class="bull">&#8226; private writable mappings (both file and anonymous mappings), for which the swap &#8220;cost&#8221; of the mapping is equal to the size of the mapping for each process that employs the mapping; and</p>
<p class="bull">&#8226; shared anonymous mappings, for which the swap &#8220;cost&#8221; of the mapping is the size of the mapping (since all processes share that mapping).</p>
<p class="noindentt">Reserving swap space for a read-only private mapping is unnecessary: since the contents of the mapping can&#8217;t be modified, there is no need to employ swap space. Swap space is also not required for shared file mappings, because the mapped file itself acts as the swap space for the mapping.</p>
<p class="indent">When a child process inherits a mapping across a <em>fork()</em>, it inherits the <span class="literal">MAP_NORESERVE</span> setting for the mapping. The <span class="literal">MAP_NORESERVE</span> flag is not specified in SUSv3, but it is supported on a few other UNIX implementations.</p>
<div class="block">
<p class="noindent">In this section, we have discussed how a call to <em>mmap()</em> may fail to increase the address space of a process because of the system limitations on RAM and swap space. A call to <em>mmap()</em> can also fail because it encounters the per-process <span class="literal">RLIMIT_AS</span> resource limit (described in <a href="ch36.xhtml#ch36lev1sec03">Section 36.3</a>), which places an upper limit on the size of the address space of the calling process.</p>
</div>
<h5 class="h5" id="ch49lev3sec11"><strong>The OOM killer</strong></h5>
<p class="noindenta">Above, we noted that when we employ lazy swap reservation, memory may become exhausted if applications attempt to employ the entire range of their mappings. In this case, the kernel relieves memory exhaustion by killing processes.</p>
<p class="indentb">The kernel code dedicated to selecting a process to kill when memory is exhausted is commonly known as the out-of-memory (OOM) killer. The OOM killer tries to choose the best process to kill in order to relieve the memory exhaustion, where &#8220;best&#8221; is determined by a range of factors. For example, the more memory a process is consuming, the more likely it will be a candidate for the OOM <span epub:type="pagebreak" id="page_1040"/>killer. Other factors that increase a process&#8217;s likelihood of selection are forking to create many child processes and having a low priority (i.e., a nice value that is greater than 0). The kernel disfavors killing the following:</p>
<p class="bull">&#8226; processes that are privileged, since they are probably performing important tasks;</p>
<p class="bull">&#8226; processes that are performing raw device access, since killing them may leave the device in an unusable state; and</p>
<p class="bull">&#8226; processes that have been running for a long time or have consumed a lot of CPU, since killing them would result in a lot of lost &#8220;work.&#8221;</p>
<p class="noindentt">To kill the selected process, the OOM killer delivers a <span class="literal">SIGKILL</span> signal.</p>
<p class="indent">The Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/oom_score</span> file, available since kernel 2.6.11, shows the weighting that the kernel gives to a process if it is necessary to invoke the OOM killer. The greater the value in this file, the more likely the process is to be selected, if necessary, by the OOM killer. The Linux-specific <span class="literal">/proc/</span><em>PID</em><span class="literal">/oom_adj</span> file, also available since kernel 2.6.11, can be used to influence the <span class="literal">oom_score</span> of a process. This file can be set to any value in the range &#8211;16 to +15, where negative values decrease the <span class="literal">oom_score</span> and positive values increase it. The special value &#8211;17 removes the process altogether as a candidate for selection by the OOM killer. For further details, see the <em>proc(5)</em> manual page.</p>
<h3 class="h3" id="ch49lev1sec10"><strong>49.10 The</strong> <span class="literal"><span class="codestrong">MAP_FIXED</span></span> <strong>Flag</strong></h3>
<p class="noindenta">Specifying <span class="literal">MAP_FIXED</span> in the <em>mmap() flags</em> argument forces the kernel to interpret the address in <em>addr</em> exactly, rather than take it as a hint. If we specify <span class="literal">MAP_FIXED</span>, <em>addr</em> must be page-aligned.</p>
<p class="indent">Generally, a portable application should omit the use of <span class="literal">MAP_FIXED</span>, and specify <em>addr</em> as <span class="literal">NULL</span>, which allows the system to choose the address at which to place the mapping. The reasons for this are the same as those that we outlined in <a href="ch48.xhtml#ch48lev1sec03">Section 48.3</a> when explaining why it is usually preferable to specify <em>shmaddr</em> as <span class="literal">NULL</span> when attaching a System V shared memory segment using <em>shmat()</em>.</p>
<p class="indent">There is, however, one situation where a portable application might use <span class="literal">MAP_FIXED</span>. If <span class="literal">MAP_FIXED</span> is specified when calling <em>mmap()</em>, and the memory region beginning at <em>addr</em> and running for <em>length</em> bytes overlaps the pages of any previous mapping, then the overlapped pages are replaced by the new mapping. We can use this feature to portably map multiple parts of a file (or files) into a contiguous region of memory, as follows:</p>
<ol>
<li class="order"><p class="orderp">Use <em>mmap()</em> to create an anonymous mapping (<a href="ch49.xhtml#ch49lev1sec07">Section 49.7</a>). In the <em>mmap()</em> call, we specify <em>addr</em> as <span class="literal">NULL</span> and don&#8217;t specify the <span class="literal">MAP_FIXED</span> flag. This allows the kernel to choose an address for the mapping.</p></li>
<li class="order"><p class="orderp">Use a series of <em>mmap()</em> calls specifying <span class="literal">MAP_FIXED</span> to map (i.e., overlay) file regions into different parts of the mapping created in the preceding step.</p></li>
</ol>
<p class="noindent">Although we could skip the first step, and use a series of <em>mmap()</em> <span class="literal">MAP_FIXED</span> operations to create a set of contiguous mappings at an address range selected by the application, this approach is less portable than performing both steps. As noted <span epub:type="pagebreak" id="page_1041"/>above, a portable application should avoid trying to create a new mapping at a fixed address. The first step avoids the portability problem, because we let the kernel select a contiguous address range, and then create new mappings within that address range.</p>
<p class="indent">From Linux 2.6 onward, the <em>remap_file_pages()</em> system call, which we describe in the next section, can also be used to achieve the same effect. However, the use of <span class="literal">MAP_FIXED</span> is more portable than <em>remap_file_pages()</em>, which is Linux-specific.</p>
<h3 class="h3" id="ch49lev1sec11"><strong>49.11 Nonlinear Mappings: <em>remap_file_pages()</em></strong></h3>
<p class="noindenta">File mappings created with <em>mmap()</em> are linear: there is a sequential, one-to-one correspondence between the pages of the mapped file and the pages of the memory region. For most applications, a linear mapping suffices. However, some applications need to create large numbers of nonlinear mappings&#8212;mappings where the pages of the file appear in a different order within contiguous memory. We show an example of a nonlinear mapping in <a href="ch49.xhtml#ch49fig5">Figure 49-5</a>.</p>
<p class="indent">We described one way of creating nonlinear mappings in the previous section: using multiple calls to <em>mmap()</em> with the <span class="literal">MAP_FIXED</span> flag. However, this approach doesn&#8217;t scale well. The problem is that each of these <em>mmap()</em> calls creates a separate kernel virtual memory area (VMA) data structure. Each VMA takes time to set up and consumes some nonswappable kernel memory. Furthermore, the presence of a large number of VMAs can degrade the performance of the virtual memory manager; in particular, the time taken to process each page fault can significantly increase when there are tens of thousands of VMAs. (This was a problem for some large database management systems that maintain multiple different views in a database file.)</p>
<div class="block">
<p class="noindent">Each line in the <span class="literal">/proc/</span><em>PID</em><span class="literal">/maps</span> file (<a href="ch48.xhtml#ch48lev1sec05">Section 48.5</a>) represents one VMA.</p>
</div>
<p class="noindent">From kernel 2.6 onward, Linux provides the <em>remap_file_pages()</em> system call to create nonlinear mappings without creating multiple VMAs. We do this as follows:</p>
<ol>
<li class="order"><p class="orderp">Create a mapping with <em>mmap()</em>.</p></li>
<li class="order"><p class="orderp">Use one or more calls to <em>remap_file_pages()</em> to rearrange the correspondence between the pages of memory and the pages of the file. (All that <em>remap_file_pages()</em> is doing is manipulating process page tables.)</p></li>
</ol>
<div class="block2">
<p class="noindent">It is possible to use <em>remap_file_pages()</em> to map the same page of a file into multiple locations within the mapped region.</p>
</div>
<div class="box">
<p class="programsa">#define _GNU_SOURCE<br/>#include &lt;sys/mman.h&gt;<br/><br/>int <span class="codestrong">remap_file_pages</span>(void *<span class="font1">addr</span>, size_t <span class="font1">size</span>, int <span class="font1">prot</span>, size_t <span class="font1">pgoff</span>, int <span class="font1">flags</span>);</p>
<p class="right">Returns 0 on success, or &#8211;1 on error</p>
</div>
<p class="noindentb"><span epub:type="pagebreak" id="page_1042"/>The <em>pgoff</em> and <em>size</em> arguments identify a file region whose position in memory is to be changed. The <em>pgoff</em> argument specifies the start of the file region in units of the system page size (as returned by <em>sysconf(_SC_PAGESIZE)</em>). The <em>size</em> argument specifies the length of the file region, in bytes. The <em>addr</em> argument serves two purposes:</p>
<p class="bull">&#8226; It identifies the existing mapping whose pages we want to rearrange. In other words, <em>addr</em> must be an address that falls somewhere within a region that was previously mapped with <em>mmap()</em>.</p>
<p class="bull">&#8226; It specifies the memory address at which the file pages identified by <em>pgoff</em> and <em>size</em> are to be located.</p>
<p class="noindentt">Both <em>addr</em> and <em>size</em> should be specified as multiples of the system page size. If they are not, they are rounded down to the nearest multiple of the page size.</p>
<p class="indent">Suppose that we use the following call to <em>mmap()</em> to map three pages of the open file referred to by the descriptor <em>fd</em>, and that the call assigns the returned address <span class="literal">0x4001a000</span> to <em>addr</em>:</p>
<p class="programs">ps = sysconf(_SC_PAGESIZE);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Obtain system page size */<br/>addr = mmap(0, 3 * ps, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</p>
<p class="noindent">The following calls would then create the nonlinear mapping shown in <a href="ch49.xhtml#ch49fig5">Figure 49-5</a>:</p>
<p class="programs">remap_file_pages(addr, ps, 0, 2, 0);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Maps page 2 of file into page 0 of region */<br/>remap_file_pages(addr + 2 * ps, ps, 0, 0, 0);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Maps page 0 of file into page 2 of region */</p>
<div class="image"><img src="../images/f49-05.jpg" alt="image"/></div>
<p class="figcap"><a id="ch49fig5"/><strong>Figure 49-5:</strong> A nonlinear file mapping</p>
<p class="noindentb">There are two other arguments to <em>remap_file_pages()</em> that we haven&#8217;t yet described:</p>
<p class="bull">&#8226; The <em>prot</em> argument is ignored, and must be specified as 0. In the future, it may be possible to use this argument to change the protection of the memory region affected by <em>remap_file_pages()</em>. In the current implementation, the protection remains the same as that on the entire VMA.</p>
<div class="block1">
<p class="noindent">Virtual machines and garbage collectors are other applications that employ multiple VMAs. Some of these applications need to be able to write-protect individual pages. It was intended that <em>remap_file_pages()</em> would allow permissions <span epub:type="pagebreak" id="page_1043"/>on individual pages within a VMA to be changed, but this facility has not so far been implemented.</p>
</div>
<p class="bull">&#8226; The <em>flags</em> argument is currently unused.</p>
<p class="noindentt">As currently implemented, <em>remap_file_pages()</em> can be applied only to shared (<span class="literal">MAP_SHARED</span>) mappings.</p>
<p class="indent">The <em>remap_file_pages()</em> system call is Linux-specific; it is not specified in SUSv3 and is not available on other UNIX implementations.</p>
<h3 class="h3" id="ch49lev1sec12"><strong>49.12 Summary</strong></h3>
<p class="noindenta">The <em>mmap()</em> system call creates a new memory mapping in the calling process&#8217;s virtual address space. The <em>munmap()</em> system call performs the converse operation, removing a mapping from a process&#8217;s address space.</p>
<p class="indent">A mapping may be of two types: file-based or anonymous. A file mapping maps the contents of a file region into the process&#8217;s virtual address space. An anonymous mapping (created by using the <span class="literal">MAP_ANONYMOUS</span> flag or by mapping <span class="literal">/dev/zero</span>) doesn&#8217;t have a corresponding file region; the bytes of the mapping are initialized to 0.</p>
<p class="indent">Mappings can be either private (<span class="literal">MAP_PRIVATE</span>) or shared (<span class="literal">MAP_SHARED</span>). This distinction determines the visibility of changes made to the shared memory, and, in the case of file mappings, determines whether the kernel propagates changes to the contents of the mapping to the underlying file. When a process maps a file with the <span class="literal">MAP_PRIVATE</span> flag, any changes it makes to the contents of the mapping are not visible to other processes and are not carried through to the mapped file. A <span class="literal">MAP_SHARED</span> file mapping is the converse&#8212;changes to the mapping are visible to other processes and are carried through to the mapped file.</p>
<p class="indent">Although the kernel automatically propagates changes to the contents of a <span class="literal">MAP_SHARED</span> mapping to the underlying file, it doesn&#8217;t provide any guarantees about when this is done. An application can use the <em>msync()</em> system call to explicitly control when the contents of a mapping are synchronized with the mapped file.</p>
<p class="indentb">Memory mappings serve a variety of uses, including:</p>
<p class="bull">&#8226; allocating process-private memory (private anonymous mappings);</p>
<p class="bull">&#8226; initializing the contents of the text and initialized data segments of a process (private file mappings);</p>
<p class="bull">&#8226; sharing memory between processes related via <em>fork()</em> (shared anonymous mappings); and</p>
<p class="bull">&#8226; performing memory-mapped I/O, optionally combined with memory sharing between unrelated processes (shared file mappings).</p>
<p class="noindentt">Two signals may come into play when accessing the contents of a mapping. <span class="literal">SIGSEGV</span> is generated if we attempt access in a manner that violates the protections on the mapping (or if we access any currently unmapped address). <span class="literal">SIGBUS</span> is generated for file-based mappings if we access a part of the mapping for which no corresponding region exists in the file (i.e., the mapping is larger than the underlying file).</p>
<p class="indent">Swap space overcommitting allows the system to allocate more memory to processes than is actually available in RAM and swap space. Overcommitting is possible <span epub:type="pagebreak" id="page_1044"/>because, typically, each process does not make full use of its allocation. Overcommitting can be controlled on a per-<em>mmap()</em> basis using the <span class="literal">MAP_NORESERVE</span> flag, and on a system-wide basis using <span class="literal">/proc</span> files.</p>
<p class="indent">The <em>mremap()</em> system call allows an existing mapping to be resized. The <em>remap_file_pages()</em> system call allows the creation of nonlinear file mappings.</p>
<h5 class="h5" id="ch49lev3sec12"><strong>Further information</strong></h5>
<p class="noindenta">Information about the implementation of <em>mmap()</em> on Linux can be found in [<a href="bib.xhtml#bib09">Bovet &#38; Cesati, 2005</a>]. Information about the implementation of <em>mmap()</em> on other UNIX systems can be found in [<a href="bib.xhtml#bib66">McKusick et al., 1996</a>] (BSD), [<a href="bib.xhtml#bib35">Goodheart &#38; Cox, 1994</a>] (System V Release 4), and [<a href="bib.xhtml#bib104">Vahalia, 1996</a>] (System V Release 4).</p>
<h3 class="h3" id="ch49lev1sec13"><strong>49.13 Exercises</strong></h3>
<p class="exer"><a id="ch49exe1"/><strong>49-1.</strong>&#160;&#160;&#160;Write a program, analogous to <em>cp(1)</em>, that uses <em>mmap()</em> and <em>memcpy()</em> calls (instead of <em>read()</em> or <em>write()</em>) to copy a source file to a destination file. (Use <em>fstat()</em> to obtain the size of the input file, which can then be used to size the required memory mappings, and use <em>ftruncate()</em> to set the size of the output file.)</p>
<p class="exer"><a id="ch49exe2"/><strong>49-2.</strong>&#160;&#160;&#160;Rewrite the programs in <a href="ch48.xhtml#ch48ex2">Listing 48-2</a> (<span class="literal">svshm_xfr_writer.c</span>, <a href="ch48.xhtml#page_1003">page 1003</a>) and <a href="ch48.xhtml#ch48ex3">Listing 48-3</a> (<span class="literal">svshm_xfr_reader.c</span>, <a href="ch48.xhtml#page_1005">page 1005</a>) to use a shared memory mapping instead of System V shared memory.</p>
<p class="exer"><a id="ch49exe3"/><strong>49-3.</strong>&#160;&#160;&#160;Write programs to verify that the <span class="literal">SIGBUS</span> and <span class="literal">SIGSEGV</span> signals are delivered in the circumstances described in <a href="ch49.xhtml#ch49lev2sec03">Section 49.4.3</a>.</p>
<p class="exer"><a id="ch49exe4"/><strong>49-4.</strong>&#160;&#160;&#160;Write a program that uses the <span class="literal">MAP_FIXED</span> technique described in <a href="ch49.xhtml#ch49lev1sec10">Section 49.10</a> to create a nonlinear mapping similar to that shown in <a href="ch49.xhtml#ch49fig5">Figure 49-5</a>.</p>
</body>
</html>
