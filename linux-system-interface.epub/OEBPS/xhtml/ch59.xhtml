<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>The Linux Programming Interface</title>
<link rel="stylesheet" type="text/css" href="../styles/9781593272203.css"/>
</head>
<body>
<h2 class="h2" id="ch59"><span epub:type="pagebreak" id="page_1197"/><strong><span class="big">59</span></strong><br/><strong>SOCKETS: INTERNET DOMAINS</strong></h2>
<p class="noindenta">Having looked at generic sockets concepts and the TCP/IP protocol suite in previous chapters, we are now ready in this chapter to look at programming with sockets in the IPv4 (<span class="literal">AF_INET</span>) and IPv6 (<span class="literal">AF_INET6</span>) domains.</p>
<p class="indent">As noted in <a href="ch58.xhtml#ch58">Chapter 58</a>, Internet domain socket addresses consist of an IP address and a port number. Although computers use binary representations of IP addresses and port numbers, humans are much better at dealing with names than with numbers. Therefore, we describe the techniques used to identify host computers and ports using names. We also examine the use of library functions to obtain the IP address(es) for a particular hostname and the port number that corresponds to a particular service name. Our discussion of hostnames includes a description of the Domain Name System (DNS), which implements a distributed database that maps hostnames to IP addresses and vice versa.</p>
<h3 class="h3" id="ch59lev1sec01"><strong>59.1 Internet Domain Sockets</strong></h3>
<p class="noindenta">Internet domain stream sockets are implemented on top of TCP. They provide a reliable, bidirectional, byte-stream communication channel.</p>
<p class="indentb"><span epub:type="pagebreak" id="page_1198"/>Internet domain datagram sockets are implemented on top of UDP. UDP sockets are similar to their UNIX domain counterparts, but note the following differences:</p>
<p class="bull">&#8226; UNIX domain datagram sockets are reliable, but UDP sockets are not&#8212;datagrams may be lost, duplicated, or arrive in a different order from that in which they were sent.</p>
<p class="bull">&#8226; Sending on a UNIX domain datagram socket will block if the queue of data for the receiving socket is full. By contrast, with UDP, if the incoming datagram would overflow the receiver&#8217;s queue, then the datagram is silently dropped.</p>
<h3 class="h3" id="ch59lev1sec02"><strong>59.2 Network Byte Order</strong></h3>
<p class="noindenta">IP addresses and port numbers are integer values. One problem we encounter when passing these values across a network is that different hardware architectures store the bytes of a multibyte integer in different orders. As shown in <a href="ch59.xhtml#ch59fig1">Figure 59-1</a>, architectures that store integers with the most significant byte first (i.e., at the lowest memory address) are termed <em>big endian</em>; those that store the least significant byte first are termed <em>little endian</em>. (The terms derive from Jonathan Swift&#8217;s 1726 satirical novel <em>Gulliver&#8217;s Travels</em>, in which the terms refer to opposing political factions who open their boiled eggs at opposite ends.) The most notable example of a little-endian architecture is x86. (Digital&#8217;s VAX architecture was another historically important example, since BSD was widely used on that machine.) Most other architectures are big endian. A few hardware architectures are switchable between the two formats. The byte ordering used on a particular machine is called the <em>host byte order</em>.</p>
<div class="image"><img src="../images/f59-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch59fig1"/><strong>Figure 59-1:</strong> Big-endian and little-endian byte order for 2-byte and 4-byte integers</p>
<p class="noindent">Since port numbers and IP addresses must be transmitted between, and understood by, all hosts on a network, a standard ordering must be used. This ordering is called <em>network byte order</em>, and happens to be big endian.</p>
<p class="indent">Later in this chapter, we look at various functions that convert hostnames (e.g., <span class="literal"><a href="http://www.kernel.org">www.kernel.org</a></span>) and service names (e.g., <em>http</em>) into the corresponding numeric forms. These functions generally return integers in network byte order, and these integers can be copied directly into the relevant fields of a socket address structure.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1199"/>However, we sometimes make direct use of integer constants for IP addresses and port numbers. For example, we may choose to hard-code a port number into our program, specify a port number as a command-line argument to a program, or use constants such as <span class="literal">INADDR_ANY</span> and <span class="literal">INADDR_LOOPBACK</span> when specifying an IPv4 address. These values are represented in C according to the conventions of the host machine, so they are in host byte order. We must convert these values to network byte order before storing them in socket address structures.</p>
<p class="indent">The <em>htons()</em>, <em>htonl()</em>, <em>ntohs()</em>, and <em>ntohl()</em> functions are defined (typically as macros) for converting integers in either direction between host and network byte order.</p>
<div class="box">
<p class="programsa">#include &lt;arpa/inet.h&gt;<br/><br/>uint16_t <span class="codestrong">htons</span>(uint16_t <span class="font1">host_uint16</span>);</p>
<p class="right">Returns <em>host_uint16</em> converted to network byte order</p>
<p class="programsat">uint32_t <span class="codestrong">htonl</span>(uint32_t <span class="font1">host_uint32</span>);</p>
<p class="right">Returns <em>host_uint32</em> converted to network byte order</p>
<p class="programsat">uint16_t <span class="codestrong">ntohs</span>(uint16_t <span class="font1">net_uint16</span>);</p>
<p class="right">Returns <em>net_uint16</em> converted to host byte order</p>
<p class="programsat">uint32_t <span class="codestrong">ntohl</span>(uint32_t <span class="font1">net_uint32</span>);</p>
<p class="right">Returns <em>net_uint32</em> converted to host byte order</p>
</div>
<p class="noindent">In earlier times, these functions had prototypes such as the following:</p>
<p class="programs">unsigned long htonl(unsigned long hostlong);</p>
<p class="noindent">This reveals the origin of the function names&#8212;in this case, <em>host to network long</em>. On most early systems on which sockets were implemented, short integers were 16 bits, and long integers were 32 bits. This no longer holds true on modern systems (at least for long integers), so the prototypes given above provide a more exact definition of the types dealt with by these functions, although the names remain unchanged. The <em>uint16_t</em> and <em>uint32_t</em> data types are 16-bit and 32-bit unsigned integers.</p>
<p class="indent">Strictly speaking, the use of these four functions is necessary only on systems where the host byte order differs from network byte order. However, these functions should always be used, so that programs are portable to different hardware architectures. On systems where the host byte order is the same as network byte order, these functions simply return their arguments unchanged.</p>
<h3 class="h3" id="ch59lev1sec03"><strong>59.3 Data Representation</strong></h3>
<p class="noindenta">When writing network programs, we need to be aware of the fact that different computer architectures use different conventions for representing various data types. We have already noted that integer types can be stored in big-endian or little-endian form. There are also other possible differences. For example, the C <em>long</em> data type may be 32 bits on some systems and 64 bits on others. When we consider structures, the issue is further complicated by the fact that different implementations <span epub:type="pagebreak" id="page_1200"/>employ different rules for aligning the fields of a structure to address boundaries on the host system, leaving different numbers of padding bytes between the fields.</p>
<p class="indent">Because of these differences in data representation, applications that exchange data between heterogeneous systems over a network must adopt some common convention for encoding that data. The sender must encode data according to this convention, while the receiver decodes following the same convention. The process of putting data into a standard format for transmission across a network is referred to as <em>marshalling</em>. Various marshalling standards exist, such as XDR (External Data Representation, described in RFC 1014), ASN.1-BER (Abstract Syntax Notation 1, <em><a href="http://www.asn1.org/">http://www.asn1.org/</a></em>), CORBA, and XML. Typically, these standards define a fixed format for each data type (defining, for example, byte order and number of bits used). As well as being encoded in the required format, each data item is tagged with extra field(s) identifying its type (and, possibly, length).</p>
<p class="indent">However, a simpler approach than marshalling is often employed: encode all transmitted data in text form, with separate data items delimited by a designated character, typically a newline character. One advantage of this approach is that we can use <em>telnet</em> to debug an application. To do this, we use the following command:</p>
<p class="programs">$ <span class="codestrong">telnet <span class="codeitalic">host port</span></span></p>
<p class="noindent">We can then type lines of text to be transmitted to the application, and view the responses sent by the application. We demonstrate this technique in <a href="ch59.xhtml#ch59lev1sec11">Section 59.11</a>.</p>
<div class="block">
<p class="noindent">The problems associated with differences in representation across heterogeneous systems apply not only to data transfer across a network, but also to any mechanism of data exchange between such systems. For example, we face the same problems when transferring files on disk or tape between heterogeneous systems. Network programming is simply the most common programming context in which we are nowadays likely to encounter this issue.</p>
</div>
<p class="noindent">If we encode data transmitted on a stream socket as newline-delimited text, then it is convenient to define a function such as <em>readLine()</em>, shown in <a href="ch59.xhtml#ch59ex1">Listing 59-1</a>.</p>
<div class="box">
<p class="programsa">#include "read_line.h"<br/><br/>ssize_t <span class="codestrong">readLine</span>(int <span class="font1">fd</span>, void *<span class="font1">buffer</span>, size_t <span class="font1">n</span>);</p>
<p class="right">Returns number of bytes copied into <em>buffer</em> (excluding terminating null byte), or 0 on end-of-file, or &#8211;1 on error</p>
</div>
<p class="noindent">The <em>readLine()</em> function reads bytes from the file referred to by the file descriptor argument <em>fd</em> until a newline is encountered. The input byte sequence is returned in the location pointed to by <em>buffer</em>, which must point to a region of at least <em>n</em> bytes of memory. The returned string is always null-terminated; thus, at most <em>(n &#8211; 1)</em> bytes of actual data will be returned. On success, <em>readLine()</em> returns the number of bytes of data placed in <em>buffer</em>; the terminating null byte is not included in this count.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1201"/><a id="ch59ex1"/><strong>Listing 59-1:</strong> Reading data a line at a time</p>
<p class="programsli">______________________________________________________ <span class="codestrong">sockets/read_line.c</span><br/><br/>#include &lt;unistd.h&gt;<br/>#include &lt;errno.h&gt;<br/>#include "read_line.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declaration of readLine() */<br/><br/>ssize_t<br/>readLine(int fd, void *buffer, size_t n)<br/>{<br/>&#160;&#160;&#160;&#160;ssize_t numRead;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* # of bytes fetched by last read() */<br/>&#160;&#160;&#160;&#160;size_t totRead;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Total bytes read so far */<br/>&#160;&#160;&#160;&#160;char *buf;<br/>&#160;&#160;&#160;&#160;char ch;<br/><br/>&#160;&#160;&#160;&#160;if (n &lt;= 0 || buffer == NULL) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errno = EINVAL;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;buf = buffer;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* No pointer arithmetic on "void *" */<br/><br/>&#160;&#160;&#160;&#160;totRead = 0;<br/>&#160;&#160;&#160;&#160;for (;;) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numRead = read(fd, &#38;ch, 1);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (errno == EINTR)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Interrupted --&gt; restart read() */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Some other error */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else if (numRead == 0) {&#160;&#160;&#160;&#160;&#160;&#160;/* EOF */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (totRead == 0)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* No bytes read; return 0 */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Some bytes read; add '\0' */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* 'numRead' must be 1 if we get here */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (totRead &lt; n - 1) {&#160;&#160;&#160;&#160;&#160;&#160;/* Discard &gt; (n - 1) bytes */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;totRead++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*buf++ = ch;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (ch == '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;*buf = '\0';<br/>&#160;&#160;&#160;&#160;return totRead;<br/>}<br/>______________________________________________________ <span class="codestrong">sockets/read_line.c</span></p>
<p class="noindent"><span epub:type="pagebreak" id="page_1202"/>If the number of bytes read before a newline is encountered is greater than or equal to <em>(n &#8211; 1)</em>, then the <em>readLine()</em> function discards the excess bytes (including the newline). If a newline was read within the first <em>(n &#8211; 1)</em> bytes, then it is included in the returned string. (Thus, we can determine if bytes were discarded by checking if a newline precedes the terminating null byte in the returned <em>buffer</em>.) We take this approach so that application protocols that rely on handling input in units of lines don&#8217;t end up processing a long line as though it were multiple lines. This would likely break the protocol, as the applications on either end would become desynchronized. An alternative approach would be to have <em>readLine()</em> read only sufficient bytes to fill the supplied buffer, leaving any remaining bytes up to the next newline for the next call to <em>readLine()</em>. In this case, the caller of <em>readLine()</em> would need to handle the possibility of a partial line being read.</p>
<p class="indent">We employ the <em>readLine()</em> function in the example programs presented in <a href="ch59.xhtml#ch59lev1sec11">Section 59.11</a>.</p>
<h3 class="h3" id="ch59lev1sec04"><strong>59.4 Internet Socket Addresses</strong></h3>
<p class="noindenta">There are two types of Internet domain socket addresses: IPv4 and IPv6.</p>
<h5 class="h5" id="ch59lev3sec01"><strong>IPv4 socket addresses: <em>struct sockaddr_in</em></strong></h5>
<p class="noindenta">An IPv4 socket address is stored in a <em>sockaddr_in</em> structure, defined in <span class="literal">&lt;netinet/in.h&gt;</span> as follows:</p>
<p class="programs">struct in_addr {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* IPv4 4-byte address */<br/>&#160;&#160;&#160;&#160;in_addr_t s_addr;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Unsigned 32-bit integer */<br/>};<br/><br/>struct sockaddr_in {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* IPv4 socket address */<br/>&#160;&#160;&#160;&#160;sa_family_t sin_family;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Address family (AF_INET) */<br/>&#160;&#160;&#160;&#160;in_port_t sin_port;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Port number */<br/>&#160;&#160;&#160;&#160;struct in_addr sin_addr;&#160;&#160;&#160;&#160;&#160;&#160;/* IPv4 address */<br/>&#160;&#160;&#160;&#160;unsigned char __pad[X];&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Pad to size of 'sockaddr'<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;structure (16 bytes) */<br/>};</p>
<p class="noindent">In <a href="ch56.xhtml#ch56lev1sec04">Section 56.4</a>, we saw that the generic <em>sockaddr</em> structure commences with a field identifying the socket domain. This corresponds to the <em>sin_family</em> field in the <em>sockaddr_in</em> structure, which is always set to <span class="literal">AF_INET</span>. The <em>sin_port</em> and <em>sin_addr</em> fields are the port number and the IP address, both in network byte order. The <em>in_port_t</em> and <em>in_addr_t</em> data types are unsigned integer types, 16 and 32 bits in length, respectively.</p>
<h5 class="h5" id="ch59lev3sec02"><strong>IPv6 socket addresses: <em>struct sockaddr_in6</em></strong></h5>
<p class="noindenta">Like an IPv4 address, an IPv6 socket address includes an IP address plus a port number. The difference is that an IPv6 address is 128 bits instead of 32 bits. An IPv6 socket address is stored in a <em>sockaddr_in6</em> structure, defined in <span class="literal">&lt;netinet/in.h&gt;</span> as follows:</p>
<p class="programs">struct in6_addr {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* IPv6 address structure */<br/>&#160;&#160;&#160;&#160;uint8_t s6_addr[16];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* 16 bytes == 128 bits */<br/>};<br/><br/>struct sockaddr_in6 {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* IPv6 socket address */<br/>&#160;&#160;&#160;&#160;sa_family_t sin6_family;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Address family (AF_INET6) */<br/>&#160;&#160;&#160;&#160;in_port_t&#160;&#160;&#160;sin6_port;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Port number */<br/>&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;&#160;sin6_flowinfo;&#160;&#160;&#160;&#160;&#160;&#160;/* IPv6 flow information */<br/>&#160;&#160;&#160;&#160;struct in6_addr sin6_addr;&#160;&#160;&#160;&#160;&#160;&#160;/* IPv6 address */<br/>&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;&#160;sin6_scope_id;&#160;&#160;&#160;&#160;&#160;&#160;/* Scope ID (new in kernel 2.4) */<br/>};</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1203"/>The <em>sin6_family</em> field is set to <span class="literal">AF_INET6</span>. The <em>sin6_port</em> and <em>sin6_addr</em> fields are the port number and the IP address. (The <em>uint8_t</em> data type, used to type the bytes of the <em>in6_addr</em> structure, is an 8-bit unsigned integer.) The remaining fields, <em>sin6_flowinfo</em> and <em>sin6_scope_id</em>, are beyond the scope of this book; for our purposes, they are always set to 0. All of the fields in the <em>sockaddr_in6</em> structure are in network byte order.</p>
<div class="block">
<p class="noindent">IPv6 addresses are described in RFC 4291. Information about IPv6 flow control (<em>sin6_flowinfo</em>) can be found in <a href="app01.xhtml#app01">Appendix A</a> of [<a href="bib.xhtml#bib93">Stevens et al., 2004</a>] and in RFCs 2460 and 3697. RFCs 3493 and 4007 provide information about <em>sin6_scope_id</em>.</p>
</div>
<p class="noindent">IPv6 has equivalents of the IPv4 wildcard and loopback addresses. However, their use is complicated by the fact that an IPv6 address is stored in an array (rather than using a scalar type). We use the IPv6 wildcard address (<span class="literal">0::0</span>) to illustrate this point. The constant <span class="literal">IN6ADDR_ANY_INIT</span> is defined for this address as follows:</p>
<p class="programs">#define IN6ADDR_ANY_INIT { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } }</p>
<div class="block">
<p class="noindent">On Linux, some details in the header files differ from our description in this section. In particular, the <em>in6_addr</em> structure contains a union definition that divides the 128-bit IPv6 address into 16 bytes, eight 2-byte integers, or four 4-byte integers. Because of the presence of this definition, the <em>glibc</em> definition of the <span class="literal">IN6ADDR_ANY_INIT</span> constant actually includes one more set of nested braces than is shown in the main text.</p>
</div>
<p class="noindent">We can use the <span class="literal">IN6ADDR_ANY_INIT</span> constant in the initializer that accompanies a variable declaration, but can&#8217;t use it on the right-hand side of an assignment statement, since C syntax doesn&#8217;t permit structured constants to be used in assignments. Instead, we must use a predefined variable, <em>in6addr_any</em>, which is initialized as follows by the C library:</p>
<p class="programs">const struct in6_addr in6addr_any = IN6ADDR_ANY_INIT;</p>
<p class="noindent">Thus, we can initialize an IPv6 socket address structure using the wildcard address as follows:</p>
<p class="programs">struct sockaddr_in6 addr;<br/><br/>memset(&#38;addr, 0, sizeof(struct sockaddr_in6));<br/>addr.sin6_family = AF_INET6;<br/>addr.sin6_addr = in6addr_any;<br/>addr.sin6_port = htons(SOME_PORT_NUM);</p>
<p class="noindent">The corresponding constant and variable for the IPv6 loopback address (<span class="literal">::1</span>) are <span class="literal">IN6ADDR_LOOPBACK_INIT</span> and <em>in6addr_loopback</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1204"/>Unlike their IPv4 counterparts, the IPv6 constant and variable initializers are in network byte order. But, as shown in the above code, we still must ensure that the port number is in network byte order.</p>
<p class="indent">If IPv4 and IPv6 coexist on a host, they share the same port-number space. This means that if, for example, an application binds an IPv6 socket to TCP port 2000 (using the IPv6 wildcard address), then an IPv4 TCP socket can&#8217;t be bound to the same port. (The TCP/IP implementation ensures that sockets on other hosts are able to communicate with this socket, regardless of whether those hosts are running IPv4 or IPv6.)</p>
<h5 class="h5" id="ch59lev3sec03"><strong>The <em>sockaddr_storage</em> structure</strong></h5>
<p class="noindenta">With the IPv6 sockets API, the new generic <em>sockaddr_storage</em> structure was introduced. This structure is defined to be large enough to hold any type of socket address (i.e., any type of socket address structure can be cast and stored in it). In particular, this structure allows us to transparently store either an IPv4 or an IPv6 socket address, thus removing IP version dependencies from our code. The <em>sockaddr_storage</em> structure is defined on Linux as follows:</p>
<p class="programs">#define __ss_aligntype uint32_t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* On 32-bit architectures */<br/>struct sockaddr_storage {<br/>&#160;&#160;&#160;&#160;sa_family_t ss_family;<br/>&#160;&#160;&#160;&#160;__ss_aligntype __ss_align;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Force alignment */<br/>&#160;&#160;&#160;&#160;char __ss_padding[SS_PADSIZE];&#160;&#160;&#160;&#160;&#160;&#160;/* Pad to 128 bytes */<br/>};</p>
<h3 class="h3" id="ch59lev1sec05"><strong>59.5 Overview of Host and Service Conversion Functions</strong></h3>
<p class="noindenta">Computers represent IP addresses and port numbers in binary. However, humans find names easier to remember than numbers. Employing symbolic names also provides a useful level of indirection; users and programs can continue to use the same name even if the underlying numeric value changes.</p>
<p class="indent">A <em>hostname</em> is the symbolic identifier for a system that is connected to a network (possibly with multiple IP addresses). A <em>service name</em> is the symbolic representation of a port number.</p>
<p class="indentb">The following methods are available for representing host addresses and ports:</p>
<p class="bull">&#8226; A host address can be represented as a binary value, as a symbolic hostname, or in presentation format (dotted-decimal for IPv4 or hex-string for IPv6).</p>
<p class="bull">&#8226; A port can be represented as a binary value or as a symbolic service name.</p>
<p class="noindentt">Various library functions are provided for converting between these formats. This section briefly summarizes these functions. The following sections describe the modern APIs (<em>inet_ntop()</em>, <em>inet_pton()</em>, <em>getaddrinfo()</em>, <em>getnameinfo()</em>, and so on) in detail. In <a href="ch59.xhtml#ch59lev1sec13">Section 59.13</a>, we briefly discuss the obsolete APIs (<em>inet_aton()</em>, <em>inet_ntoa()</em>, <em>gethostbyname()</em>, <em>getservbyname()</em>, and so on).</p>
<h5 class="h5" id="ch59lev3sec04"><strong>Converting IPv4 addresses between binary and human-readable forms</strong></h5>
<p class="noindenta">The <em>inet_aton()</em> and <em>inet_ntoa()</em> functions convert an IPv4 address in dotted-decimal notation to binary and vice versa. We describe these functions primarily because <span epub:type="pagebreak" id="page_1205"/>they appear in historical code. Nowadays, they are obsolete. Modern programs that need to do such conversions should use the functions that we describe next.</p>
<h5 class="h5" id="ch59lev3sec05"><strong>Converting IPv4 and IPv6 addresses between binary and human-readable forms</strong></h5>
<p class="noindenta">The <em>inet_pton()</em> and <em>inet_ntop()</em> functions are like <em>inet_aton()</em> and <em>inet_ntoa()</em>, but differ in that they also handle IPv6 addresses. They convert binary IPv4 and IPv6 addresses to and from <em>presentation</em> format&#8212;that is, either dotted-decimal or hex-string notation.</p>
<p class="indentb">Since humans deal better with names than with numbers, we normally use these functions only occasionally in programs. One use of <em>inet_ntop()</em> is to produce a printable representation of an IP address for logging purposes. Sometimes, it is preferable to use this function instead of converting (&#8220;resolving&#8221;) an IP address to a hostname, for the following reasons:</p>
<p class="bull">&#8226; Resolving an IP address to a hostname involves a possibly time-consuming request to a DNS server.</p>
<p class="bull">&#8226; In some circumstances, there may not be a DNS (PTR) record that maps the IP address to a corresponding hostname.</p>
<p class="noindentt">We describe these functions (in <a href="ch59.xhtml#ch59lev1sec06">Section 59.6</a>) before <em>getaddrinfo()</em> and <em>getnameinfo()</em>, which perform conversions between binary representations and the corresponding symbolic names, principally because they present a much simpler API. This allows us to quickly show some working examples of the use of Internet domain sockets.</p>
<h5 class="h5" id="ch59lev3sec06"><strong>Converting host and service names to and from binary form (obsolete)</strong></h5>
<p class="noindenta">The <em>gethostbyname()</em> function returns the binary IP address(es) corresponding to a hostname and the <em>getservbyname()</em> function returns the port number corresponding to a service name. The reverse conversions are performed by <em>gethostbyaddr()</em> and <em>getservbyport()</em>. We describe these functions because they are widely used in existing code. However, they are now obsolete. (SUSv3 marks these functions obsolete, and SUSv4 removes their specifications.) New code should use the <em>getaddrinfo()</em> and <em>getnameinfo()</em> functions (described next) for such conversions.</p>
<h5 class="h5" id="ch59lev3sec07"><strong>Converting host and service names to and from binary form (modern)</strong></h5>
<p class="noindenta">The <em>getaddrinfo()</em> function is the modern successor to both <em>gethostbyname()</em> and <em>getservbyname()</em>. Given a hostname and a service name, <em>getaddrinfo()</em> returns a set of structures containing the corresponding binary IP address(es) and port number. Unlike <em>gethostbyname()</em>, <em>getaddrinfo()</em> transparently handles both IPv4 and IPv6 addresses. Thus, we can use it to write programs that don&#8217;t contain dependencies on the IP version being employed. All new code should use <em>getaddrinfo()</em> for converting hostnames and service names to binary representation.</p>
<p class="indent">The <em>getnameinfo()</em> function performs the reverse translation, converting an IP address and port number into the corresponding hostname and service name.</p>
<p class="indent">We can also use <em>getaddrinfo()</em> and <em>getnameinfo()</em> to convert binary IP addresses to and from presentation format.</p>
<p class="indent">The discussion of <em>getaddrinfo()</em> and <em>getnameinfo()</em>, in <a href="ch59.xhtml#ch59lev1sec10">Section 59.10</a>, requires an accompanying description of DNS (<a href="ch59.xhtml#ch59lev1sec08">Section 59.8</a>) and the <span class="literal">/etc/services</span> file (<a href="ch59.xhtml#ch59lev1sec09">Section 59.9</a>). DNS allows cooperating servers to maintain a distributed database <span epub:type="pagebreak" id="page_1206"/>that maps binary IP addresses to hostnames and vice versa. The existence of a system such as DNS is essential to the operation of the Internet, since centralized management of the enormous set of Internet hostnames would be impossible. The <span class="literal">/etc/services</span> file maps port numbers to symbolic service names.</p>
<h3 class="h3" id="ch59lev1sec06"><strong>59.6 The <em>inet_pton()</em> and <em>inet_ntop()</em> Functions</strong></h3>
<p class="noindenta">The <em>inet_pton()</em> and <em>inet_ntop()</em> functions allow conversion of both IPv4 and IPv6 addresses between binary form and dotted-decimal or hex-string notation.</p>
<div class="box">
<p class="programsa">#include &lt;arpa/inet.h&gt;<br/><br/>int <span class="codestrong">inet_pton</span>(int <span class="font1">domain</span>, const char *<span class="font1">src_str</span>, void *<span class="font1">addrptr</span>);</p>
<p class="right">Returns 1 on successful conversion, 0 if <em>src_str</em> is not in presentation format, or &#8211;1 on error</p>
<p class="programsat">const char *<span class="codestrong">inet_ntop</span>(int <span class="font1">domain</span>, const void *<span class="font1">addrptr</span>, char *<span class="font1">dst_str</span>, size_t <span class="font1">len</span>);</p>
<p class="right">Returns pointer to <em>dst_str</em> on success, or <span class="literal">NULL</span> on error</p>
</div>
<p class="noindentb">The <em>p</em> in the names of these functions stands for &#8220;presentation,&#8221; and the <em>n</em> stands for &#8220;network.&#8221; The presentation form is a human-readable string, such as the following:</p>
<p class="bull">&#8226; <span class="literal">204.152.189.116</span> (IPv4 dotted-decimal address);</p>
<p class="bull">&#8226; <span class="literal">::1</span> (an IPv6 colon-separated hexadecimal address); or</p>
<p class="bull">&#8226; <span class="literal">::FFFF:204.152.189.116</span> (an IPv4-mapped IPv6 address).</p>
<p class="noindentt">The <em>inet_pton()</em> function converts the presentation string contained in <em>src_str</em> into a binary IP address in network byte order. The <em>domain</em> argument should be specified as either <span class="literal">AF_INET</span> or <span class="literal">AF_INET6</span>. The converted address is placed in the structure pointed to by <em>addrptr</em>, which should point to either an <em>in_addr</em> or an <em>in6_addr</em> structure, according to the value specified in <em>domain</em>.</p>
<p class="indent">The <em>inet_ntop()</em> function performs the reverse conversion. Again, <em>domain</em> should be specified as either <span class="literal">AF_INET</span> or <span class="literal">AF_INET6</span>, and <em>addrptr</em> should point to an <em>in_addr</em> or <em>in6_addr</em> structure that we wish to convert. The resulting null-terminated string is placed in the buffer pointed to by <em>dst_str</em>. The <em>len</em> argument must specify the size of this buffer. On success, <em>inet_ntop()</em> returns <em>dst_str</em>. If <em>len</em> is too small, then <em>inet_ntop()</em> returns <span class="literal">NULL</span>, with <em>errno</em> set to <span class="literal">ENOSPC</span>.</p>
<p class="indent">To correctly size the buffer pointed to by <em>dst_str</em>, we can employ two constants defined in <span class="literal">&lt;netinet/in.h&gt;</span>. These constants indicate the maximum lengths (including the terminating null byte) of the presentation strings for IPv4 and IPv6 addresses:</p>
<p class="programs">#define INET_ADDRSTRLEN&#160;&#160;16&#160;&#160;&#160;&#160;&#160;/* Maximum IPv4 dotted-decimal string */<br/>#define INET6_ADDRSTRLEN 46&#160;&#160;&#160;&#160;&#160;/* Maximum IPv6 hexadecimal string */</p>
<p class="noindent">We provide examples of the use of <em>inet_pton()</em> and <em>inet_ntop()</em> in the next section.</p>
<h3 class="h3" id="ch59lev1sec07"><span epub:type="pagebreak" id="page_1207"/><strong>59.7 Client-Server Example (Datagram Sockets)</strong></h3>
<p class="noindenta">In this section, we take the case-conversion server and client programs shown in <a href="ch57.xhtml#ch57lev1sec03">Section 57.3</a> and modify them to use datagram sockets in the <span class="literal">AF_INET6</span> domain. We present these programs with a minimum of commentary, since their structure is similar to the earlier programs. The main differences in the new programs lie in the declaration and initialization of the IPv6 socket address structure, which we described in <a href="ch59.xhtml#ch59lev1sec04">Section 59.4</a>.</p>
<p class="indent">The client and server both employ the header file shown in <a href="ch59.xhtml#ch59ex2">Listing 59-2</a>. This header file defines the server&#8217;s port number and the maximum size of messages that the client and server can exchange.</p>
<p class="examplet"><a id="ch59ex2"/><strong>Listing 59-2:</strong> Header file used by <span class="literal">i6d_ucase_sv.c</span> and <span class="literal">i6d_ucase_cl.c</span></p>
<p class="programsli">______________________________________________________ <span class="codestrong">sockets/i6d_ucase.h</span><br/><br/>#include &lt;netinet/in.h&gt;<br/>#include &lt;arpa/inet.h&gt;<br/>#include &lt;sys/socket.h&gt;<br/>#include &lt;ctype.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>#define BUF_SIZE 10&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Maximum size of messages exchanged<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;between client and server */<br/><br/>#define PORT_NUM 50002&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Server port number */<br/>______________________________________________________ <span class="codestrong">sockets/i6d_ucase.h</span></p>
<p class="noindent"><a href="ch59.xhtml#ch59ex3">Listing 59-3</a> shows the server program. The server uses the <em>inet_ntop()</em> function to convert the host address of the client (obtained via the <em>recvfrom()</em> call) to printable form.</p>
<p class="indent">The client program shown in <a href="ch59.xhtml#ch59ex4">Listing 59-4</a> contains two notable modifications from the earlier UNIX domain version (<a href="ch57.xhtml#ch57ex7">Listing 57-7</a>, on <a href="ch57.xhtml#page_1173">page 1173</a>). The first difference is that the client interprets its initial command-line argument as the IPv6 address of the server. (The remaining command-line arguments are passed as separate datagrams to the server.) The client converts the server address to binary form using <em>inet_pton()</em>. The other difference is that the client doesn&#8217;t bind its socket to an address. As noted in <a href="ch58.xhtml#ch58lev2sec01">Section 58.6.1</a>, if an Internet domain socket is not bound to an address, the kernel binds the socket to an ephemeral port on the host system. We can observe this in the following shell session log, where we run the server and the client on the same host:</p>
<p class="programs">$ <span class="codestrong">./i6d_ucase_sv &#38;</span><br/>[1] 31047<br/>$ <span class="codestrong">./i6d_ucase_cl ::1 ciao</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Send to server on local host</span><br/>Server received 4 bytes from (::1, 32770)<br/>Response 1: CIAO</p>
<p class="noindent">From the above output, we see that the server&#8217;s <em>recvfrom()</em> call was able to obtain the address of the client&#8217;s socket, including the ephemeral port number, despite the fact that the client did not do a <em>bind()</em>.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1208"/><a id="ch59ex3"/><strong>Listing 59-3:</strong> IPv6 case-conversion server using datagram sockets</p>
<p class="programsli">____________________________________________________ <span class="codestrong">sockets/i6d_ucase_sv.c</span><br/><br/>#include "i6d_ucase.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct sockaddr_in6 svaddr, claddr;<br/>&#160;&#160;&#160;&#160;int sfd, j;<br/>&#160;&#160;&#160;&#160;ssize_t numBytes;<br/>&#160;&#160;&#160;&#160;socklen_t len;<br/>&#160;&#160;&#160;&#160;char buf[BUF_SIZE];<br/>&#160;&#160;&#160;&#160;char claddrStr[INET6_ADDRSTRLEN];<br/><br/>&#160;&#160;&#160;&#160;sfd = socket(AF_INET6, SOCK_DGRAM, 0);<br/>&#160;&#160;&#160;&#160;if (sfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("socket");<br/><br/>&#160;&#160;&#160;&#160;memset(&#38;svaddr, 0, sizeof(struct sockaddr_in6));<br/>&#160;&#160;&#160;&#160;svaddr.sin6_family = AF_INET6;<br/>&#160;&#160;&#160;&#160;svaddr.sin6_addr = in6addr_any;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wildcard address */<br/>&#160;&#160;&#160;&#160;svaddr.sin6_port = htons(PORT_NUM);<br/><br/>&#160;&#160;&#160;&#160;if (bind(sfd, (struct sockaddr *) &#38;svaddr,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sizeof(struct sockaddr_in6)) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("bind");<br/><br/>&#160;&#160;&#160;&#160;/* Receive messages, convert to uppercase, and return to client */<br/><br/>&#160;&#160;&#160;&#160;for (;;) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;len = sizeof(struct sockaddr_in6);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numBytes = recvfrom(sfd, buf, BUF_SIZE, 0,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(struct sockaddr *) &#38;claddr, &#38;len);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numBytes == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("recvfrom");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (inet_ntop(AF_INET6, &#38;claddr.sin6_addr, claddrStr,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;INET6_ADDRSTRLEN) == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Couldn't convert client address to string\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Server received %ld bytes from (%s, %u)\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(long) numBytes, claddrStr, ntohs(claddr.sin6_port));<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (j = 0; j &lt; numBytes; j++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;buf[j] = toupper((unsigned char) buf[j]);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sendto(sfd, buf, numBytes, 0, (struct sockaddr *) &#38;claddr, len) !=<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numBytes)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("sendto");<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>____________________________________________________ <span class="codestrong">sockets/i6d_ucase_sv.c</span></p>
<p class="examplet"><span epub:type="pagebreak" id="page_1209"/><a id="ch59ex4"/><strong>Listing 59-4:</strong> IPv6 case-conversion client using datagram sockets</p>
<p class="programsli">____________________________________________________ <span class="codestrong">sockets/i6d_ucase_cl.c</span><br/><br/>#include "i6d_ucase.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct sockaddr_in6 svaddr;<br/>&#160;&#160;&#160;&#160;int sfd, j;<br/>&#160;&#160;&#160;&#160;size_t msgLen;<br/>&#160;&#160;&#160;&#160;ssize_t numBytes;<br/>&#160;&#160;&#160;&#160;char resp[BUF_SIZE];<br/><br/>&#160;&#160;&#160;&#160;if (argc &lt; 3 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s host-address msg...\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;sfd = socket(AF_INET6, SOCK_DGRAM, 0);&#160;&#160;&#160;&#160;&#160;&#160;/* Create client socket */<br/>&#160;&#160;&#160;&#160;if (sfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("socket");<br/><br/>&#160;&#160;&#160;&#160;memset(&#38;svaddr, 0, sizeof(struct sockaddr_in6));<br/>&#160;&#160;&#160;&#160;svaddr.sin6_family = AF_INET6;<br/>&#160;&#160;&#160;&#160;svaddr.sin6_port = htons(PORT_NUM);<br/>&#160;&#160;&#160;&#160;if (inet_pton(AF_INET6, argv[1], &#38;svaddr.sin6_addr) &lt;= 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("inet_pton failed for address '%s'", argv[1]);<br/><br/>&#160;&#160;&#160;&#160;/* Send messages to server; echo responses on stdout */<br/><br/>&#160;&#160;&#160;&#160;for (j = 2; j &lt; argc; j++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msgLen = strlen(argv[j]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sendto(sfd, argv[j], msgLen, 0, (struct sockaddr *) &#38;svaddr,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sizeof(struct sockaddr_in6)) != msgLen)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("sendto");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numBytes = recvfrom(sfd, resp, BUF_SIZE, 0, NULL, NULL);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numBytes == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("recvfrom");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Response %d: %.*s\n", j - 1, (int) numBytes, resp);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>____________________________________________________ <span class="codestrong">sockets/i6d_ucase_cl.c</span></p>
<h3 class="h3" id="ch59lev1sec08"><strong>59.8 Domain Name System (DNS)</strong></h3>
<p class="noindenta">In <a href="ch59.xhtml#ch59lev1sec10">Section 59.10</a>, we describe <em>getaddrinfo()</em>, which obtains the IP address(es) corresponding to a hostname, and <em>getnameinfo()</em>, which performs the converse task. However, before looking at these functions, we explain how DNS is used to maintain the mappings between hostnames and IP addresses.</p>
<p class="indent"><span epub:type="pagebreak" id="page_1210"/>Before the advent of DNS, mappings between hostnames and IP addresses were defined in a manually maintained local file, <span class="literal">/etc/hosts</span>, containing records of the following form:</p>
<p class="programs"># IP-address&#160;&#160;&#160;&#160;canonical hostname&#160;&#160;&#160;&#160;&#160;&#160;[aliases]<br/>127.0.0.1&#160;&#160;&#160;&#160;&#160;&#160;&#160;localhost</p>
<p class="noindent">The <em>gethostbyname()</em> function (the predecessor to <em>getaddrinfo()</em>) obtained an IP address by searching this file, looking for a match on either the canonical hostname (i.e., the official or primary name of the host) or one of the (optional, space-delimited) aliases.</p>
<p class="indent">However, the <span class="literal">/etc/hosts</span> scheme scales poorly, and then becomes impossible, as the number of hosts in the network increases (e.g., the Internet, with millions of hosts).</p>
<p class="indentb">DNS was devised to address this problem. The key ideas of DNS are the following:</p>
<p class="bull">&#8226; Hostnames are organized into a hierarchical namespace (<a href="ch59.xhtml#ch59fig2">Figure 59-2</a>). Each <em>node</em> in the DNS hierarchy has a <em>label</em> (name), which may be up to 63 characters. At the root of the hierarchy is an unnamed node, the &#8220;anonymous root.&#8221;</p>
<p class="bull">&#8226; A node&#8217;s <em>domain name</em> consists of all of the names from that node up to the root concatenated together, with each name separated by a period (<span class="literal">.</span>). For example, <span class="literal">google.com</span> is the domain name for the node <span class="literal">google</span>.</p>
<p class="bull">&#8226; A <em>fully qualified domain name</em> (FQDN), such as <span class="literal"><a href="http://www.kernel.org">www.kernel.org</a></span>., identifies a host within the hierarchy. A fully qualified domain name is distinguished by being terminated by a period, although in many contexts the period may be omitted.</p>
<p class="bull">&#8226; No single organization or system manages the entire hierarchy. Instead, there is a hierarchy of DNS servers, each of which manages a branch (a <em>zone</em>) of the tree. Normally, each zone has a <em>primary master name server</em>, and one or more <em>slave name servers</em> (sometimes also known as <em>secondary master name servers</em>), which provide backup in the event that the primary master name server crashes. Zones may themselves be divided into separately managed smaller zones. When a host is added within a zone, or the mapping of a hostname to an IP address is changed, the administrator responsible for the corresponding local name server updates the name database on that server. (No manual changes are required on any other name-server databases in the hierarchy.)</p>
<div class="block1">
<p class="noindent">The DNS server implementation employed on Linux is the widely used Berkeley Internet Name Domain (BIND) implementation, <em>named(8)</em>, maintained by the <em>Internet Systems Consortium</em> (<em><a href="http://www.isc.org/">http://www.isc.org/</a></em>). The operation of this daemon is controlled by the file <span class="literal">/etc/named.conf</span> (see the <em>named.conf(5)</em> manual page). The key reference on DNS and BIND is [<a href="bib.xhtml#bib02">Albitz &#38; Liu, 2006</a>]. Information about DNS can also be found in <a href="ch14.xhtml#ch14">Chapter 14</a> of [<a href="bib.xhtml#bib91">Stevens, 1994</a>], <a href="ch11.xhtml#ch11">Chapter 11</a> of [<a href="bib.xhtml#bib93">Stevens et al., 2004</a>], and <a href="ch24.xhtml#ch24">Chapter 24</a> of [<a href="bib.xhtml#bib12">Comer, 2000</a>].</p>
</div>
<p class="bull">&#8226; When a program calls <em>getaddrinfo()</em> to <em>resolve</em> (i.e., obtain the IP address for) a domain name, <em>getaddrinfo()</em> employs a suite of library functions (the <em>resolver library</em>) that communicate with the local DNS server. If this server can&#8217;t supply the required information, then it communicates with other DNS servers within the hierarchy in order to obtain the information. Occasionally, this resolution process may take a noticeable amount of time, and DNS servers employ caching techniques to avoid unnecessary communication for frequently queried domain names.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_1211"/>Using the above approach allows DNS to cope with large namespaces, and does not require centralized management of names.</p>
<div class="image"><img src="../images/f59-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch59fig2"/><strong>Figure 59-2:</strong> A subset of the DNS hierarchy</p>
<h5 class="h5" id="ch59lev3sec08"><strong>Recursive and iterative resolution requests</strong></h5>
<p class="noindenta">DNS resolution requests fall into two categories: <em>recursive</em> and <em>iterative</em>. In a recursive request, the requester asks the server to handle the entire task of resolution, including the task of communicating with any other DNS servers, if necessary. When an application on the local host calls <em>getaddrinfo()</em>, that function makes a recursive request to the local DNS server. If the local DNS server does not itself have the information to perform the resolution, it resolves the domain name iteratively.</p>
<p class="indent">We explain iterative resolution via an example. Suppose that the local DNS server is asked to resolve the name <span class="literal"><a href="http://www.otago.ac.nz">www.otago.ac.nz</a></span>. To do this, it first communicates with one of a small set of <em>root name servers</em> that every DNS server is required to know about. (We can obtain a list of these servers using the command <em>dig . NS</em> or from the web page at <em><a href="http://www.root-servers.org/">http://www.root-servers.org/</a></em>.) Given the name <span class="literal"><a href="http://www.otago.ac.nz">www.otago.ac.nz</a></span>, the root name server refers the local DNS server to one of the <span class="literal">nz</span> DNS servers. The local DNS server then queries the <span class="literal">nz</span> server with the name <span class="literal"><a href="http://www.otago.ac.nz">www.otago.ac.nz</a></span>, and receives a response referring it to the <span class="literal">ac.nz</span> server. The local DNS server then queries the <span class="literal">ac.nz</span> server with the name <span class="literal"><a href="http://www.otago.ac.nz">www.otago.ac.nz</a></span>, and is referred to the <span class="literal">otago.ac.nz</span> server. Finally, the local DNS server queries the <span class="literal">otago.ac.nz</span> server with the name <span class="literal"><a href="http://www.otago.ac.nz">www.otago.ac.nz</a></span>, and obtains the required IP address.</p>
<p class="indent">If we supply an incomplete domain name to <em>gethostbyname()</em>, the resolver will attempt to complete it before resolving it. The rules on how a domain name is completed are defined in <span class="literal">/etc/resolv.conf</span> (see the <em>resolv.conf(5)</em> manual page). By default, the resolver will at least try completion using the domain name of the local host. For example, if we are logged in on the machine <span class="literal">oghma.otago.ac.nz</span> and we type the command <em>ssh octavo</em>, the resulting DNS query will be for the name <span class="literal">octavo.otago.ac.nz</span>.</p>
<h5 class="h5" id="ch59lev3sec09"><span epub:type="pagebreak" id="page_1212"/><strong>Top-level domains</strong></h5>
<p class="noindenta">The nodes immediately below the anonymous root form the so-called <em>top-level domains</em> (TLDs). (Below these are the <em>second-level domains</em>, and so on.) TLDs fall into two categories: <em>generic</em> and <em>country</em>.</p>
<p class="indent">Historically, there were seven <em>generic</em> TLDs, most of which can be considered international. We have shown four of the original generic TLDs in <a href="ch59.xhtml#ch59fig2">Figure 59-2</a>. The other three are <span class="literal">int</span>, <span class="literal">mil</span>, and <span class="literal">gov</span>; the latter two are reserved for the United States. In more recent times, a number of new generic TLDs have been added (e.g., <span class="literal">info</span>, <span class="literal">name</span>, and <span class="literal">museum</span>).</p>
<p class="indent">Each nation has a corresponding <em>country</em> (or <em>geographical</em>) TLD (standardized as ISO 3166-1), with a 2-character name. In <a href="ch59.xhtml#ch59fig2">Figure 59-2</a>, we have shown a few of these: <span class="literal">de</span> (Germany, <em>Deutschland</em>), <span class="literal">eu</span> (a supra-national geographical TLD for the European Union), <span class="literal">nz</span> (New Zealand), and <span class="literal">us</span> (United States of America). Several countries divide their TLD into a set of second-level domains in a manner similar to the generic domains. For example, New Zealand has <span class="literal">ac.nz</span> (academic institutions), <span class="literal">co.nz</span> (commercial), and <span class="literal">govt.nz</span> (government).</p>
<h3 class="h3" id="ch59lev1sec09"><strong>59.9 The</strong> <span class="literal"><span class="codestrong">/etc/services</span></span> <strong>File</strong></h3>
<p class="noindenta">As noted in <a href="ch58.xhtml#ch58lev2sec01">Section 58.6.1</a>, well-known port numbers are centrally registered by IANA. Each of these ports has a corresponding <em>service name</em>. Because service numbers are centrally managed and are less volatile than IP addresses, an equivalent of the DNS server is usually not necessary. Instead, the port numbers and service names are recorded in the file <span class="literal">/etc/services</span>. The <em>getaddrinfo()</em> and <em>getnameinfo()</em> functions use the information in this file to convert service names to port numbers and vice versa.</p>
<p class="indent">The <span class="literal">/etc/services</span> file consists of lines containing three columns, as shown in the following examples:</p>
<p class="programs"># Service name&#160;&#160;port/protocol&#160;&#160;[aliases]<br/>echo&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7/tcp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Echo&#160;&#160;&#160;&#160;&#160;# echo service<br/>echo&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7/udp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Echo<br/>ssh&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;22/tcp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# Secure Shell<br/>ssh&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;22/udp<br/>telnet&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;23/tcp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# Telnet<br/>telnet&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;23/udp<br/>smtp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;25/tcp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# Simple Mail Transfer Protocol<br/>smtp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;25/udp<br/>domain&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;53/tcp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# Domain Name Server<br/>domain&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;53/udp<br/>http&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;80/tcp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# Hypertext Transfer Protocol<br/>http&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;80/udp<br/>ntp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;123/tcp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# Network Time Protocol<br/>ntp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;123/udp<br/>login&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;513/tcp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# rlogin(1)<br/>who&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;513/udp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# rwho(1)<br/>shell&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;514/tcp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# rsh(1)<br/>syslog&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;514/udp&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# syslog</p>
<p class="noindent"><span epub:type="pagebreak" id="page_1213"/>The <em>protocol</em> is typically either <span class="literal">tcp</span> or <span class="literal">udp</span>. The optional (space-delimited) <em>aliases</em> specify alternative names for the service. In addition to the above, lines may include comments starting with the <span class="literal">#</span> character.</p>
<p class="indent">As noted previously, a given port number refers to distinct entities for UDP and TCP, but IANA policy assigns both port numbers to a service, even if that service uses only one protocol. For example, <em>telnet</em>, <em>ssh</em>, HTTP, and SMTP all use TCP, but the corresponding UDP port is also assigned to these services. Conversely, NTP uses only UDP, but the TCP port 123 is also assigned to this service. In some cases, a service uses both UDP and TCP; DNS and <em>echo</em> are examples of such services. Finally, there are a very few cases where the UDP and TCP ports with the same number are assigned to different services; for example, <em>rsh</em> uses TCP port 514, while the <em>syslog</em> daemon (<a href="ch37.xhtml#ch37lev1sec05">Section 37.5</a>) uses UDP port 514. This is because these port numbers were assigned before the adoption of the present IANA policy.</p>
<div class="block">
<p class="noindent">The <span class="literal">/etc/services</span> file is merely a record of name-to-number mappings. It is not a reservation mechanism: the appearance of a port number in <span class="literal">/etc/services</span> doesn&#8217;t guarantee that it will actually be available for binding by a particular service.</p>
</div>
<h3 class="h3" id="ch59lev1sec10"><strong>59.10 Protocol-Independent Host and Service Conversion</strong></h3>
<p class="noindenta">The <em>getaddrinfo()</em> function converts host and service names to IP addresses and port numbers. It was defined in POSIX.1g as the (reentrant) successor to the obsolete <em>gethostbyname()</em> and <em>getservbyname()</em> functions. (Replacing the use of <em>gethostbyname()</em> with <em>getaddrinfo()</em> allows us to eliminate IPv4-versus-IPv6 dependencies from our programs.)</p>
<p class="indent">The <em>getnameinfo()</em> function is the converse of <em>getaddrinfo()</em>. It translates a socket address structure (either IPv4 or IPv6) to strings containing the corresponding host and service name. This function is the (reentrant) equivalent of the obsolete <em>gethostbyaddr()</em> and <em>getservbyport()</em> functions.</p>
<div class="block">
<p class="noindent"><a href="ch11.xhtml#ch11">Chapter 11</a> of [<a href="bib.xhtml#bib93">Stevens et al., 2004</a>] describes <em>getaddrinfo()</em> and <em>getnameinfo()</em> in detail, and provides implementations of these functions. These functions are also described in RFC 3493.</p>
</div>
<h4 class="h4" id="ch59lev2sec01"><strong>59.10.1 The <em>getaddrinfo()</em> Function</strong></h4>
<p class="noindenta">Given a host name and a service name, <em>getaddrinfo()</em> returns a list of socket address structures, each of which contains an IP address and port number.</p>
<div class="box">
<p class="programsa">#include &lt;sys/socket.h&gt;<br/>#include &lt;netdb.h&gt;<br/><br/>int <span class="codestrong">getaddrinfo</span>(const char *<span class="font1">host</span>, const char *<span class="font1">service</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const struct addrinfo *<span class="font1">hints</span>, struct addrinfo **<span class="font1">result</span>);</p>
<p class="right">Returns 0 on success, or nonzero on error</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_1214"/>As input, <em>getaddrinfo()</em> takes the arguments <em>host</em>, <em>service</em>, and <em>hints</em>. The <em>host</em> argument contains either a hostname or a numeric address string, expressed in IPv4 dotted-decimal notation or IPv6 hex-string notation. (To be precise, <em>getaddrinfo()</em> accepts IPv4 numeric strings in the more general numbers-and-dots notation described in <a href="ch59.xhtml#ch59lev2sec05">Section 59.13.1</a>.) The <em>service</em> argument contains either a service name or a decimal port number. The <em>hints</em> argument points to an <em>addrinfo</em> structure that specifies further criteria for selecting the socket address structures returned via <em>result</em>. We describe the <em>hints</em> argument in more detail below.</p>
<p class="indent">As output, <em>getaddrinfo()</em> dynamically allocates a linked list of <em>addrinfo</em> structures and sets <em>result</em> pointing to the beginning of this list. Each of these <em>addrinfo</em> structures includes a pointer to a socket address structure corresponding to <em>host</em> and <em>service</em> (<a href="ch59.xhtml#ch59fig3">Figure 59-3</a>). The <em>addrinfo</em> structure has the following form:</p>
<p class="programs">struct addrinfo {<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;&#160;&#160;ai_flags;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Input flags (AI_* constants) */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;&#160;&#160;ai_family;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Address family */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;&#160;&#160;ai_socktype;&#160;&#160;&#160;&#160;&#160;&#160;/* Type: SOCK_STREAM, SOCK_DGRAM */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;&#160;&#160;ai_protocol;&#160;&#160;&#160;&#160;&#160;&#160;/* Socket protocol */<br/>&#160;&#160;&#160;&#160;socklen_t ai_addrlen;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Size of structure pointed to by ai_addr */<br/>&#160;&#160;&#160;&#160;char&#160;&#160;&#160;&#160;&#160;*ai_canonname;&#160;&#160;&#160;&#160;&#160;/* Canonical name of host */<br/>&#160;&#160;&#160;&#160;struct sockaddr *ai_addr;&#160;&#160;&#160;/* Pointer to socket address structure */<br/>&#160;&#160;&#160;&#160;struct addrinfo *ai_next;&#160;&#160;&#160;/* Next structure in linked list */<br/>};</p>
<p class="noindent">The <em>result</em> argument returns a list of structures, rather than a single structure, because there may be multiple combinations of host and service corresponding to the criteria specified in <em>host</em>, <em>service</em>, and <em>hints</em>. For example, multiple address structures could be returned for a host with more than one network interface. Furthermore, if <em>hints.ai_socktype</em> was specified as 0, then two structures could be returned&#8212;one for a <span class="literal">SOCK_DGRAM</span> socket, the other for a <span class="literal">SOCK_STREAM</span> socket&#8212;if the given <em>service</em> was available for both UDP and TCP.</p>
<p class="indent">The fields of each <em>addrinfo</em> structure returned via <em>result</em> describe properties of the associated socket address structure. The <em>ai_family</em> field is set to either <span class="literal">AF_INET</span> or <span class="literal">AF_INET6</span>, informing us of the type of the socket address structure. The <em>ai_socktype</em> field is set to either <span class="literal">SOCK_STREAM</span> or <span class="literal">SOCK_DGRAM</span>, indicating whether this address structure is for a TCP or a UDP service. The <em>ai_protocol</em> field returns a protocol value appropriate for the address family and socket type. (The three fields <em>ai_family</em>, <em>ai_socktype</em>, and <em>ai_protocol</em> supply the values required for the arguments used when calling <em>socket()</em> to create a socket for this address.) The <em>ai_addrlen</em> field gives the size (in bytes) of the socket address structure pointed to by <em>ai_addr</em>. The <em>ai_addr</em> field points to the socket address structure (a <em>sockaddr_in</em> structure for IPv4 or a <em>sockaddr_in6</em> structure for IPv6). The <em>ai_flags</em> field is unused (it is used for the <em>hints</em> argument). The <em>ai_canonname</em> field is used only in the first <em>addrinfo</em> structure, and only if the <span class="literal">AI_CANONNAME</span> flag is employed in <em>hints.ai_flags</em>, as described below.</p>
<p class="indent">As with <em>gethostbyname()</em>, <em>getaddrinfo()</em> may need to send a request to a DNS server, and this request may take some time to complete. The same applies for <em>getnameinfo()</em>, which we describe in <a href="ch59.xhtml#ch59lev2sec04">Section 59.10.4</a>.</p>
<p class="indent">We demonstrate the use of <em>getaddrinfo()</em> in <a href="ch59.xhtml#ch59lev1sec11">Section 59.11</a>.</p>
<div class="image"><span epub:type="pagebreak" id="page_1215"/><img src="../images/f59-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch59fig3"/><strong>Figure 59-3:</strong> Structures allocated and returned by <em>getaddrinfo()</em></p>
<h5 class="h5" id="ch59lev3sec10"><strong>The <em>hints</em> argument</strong></h5>
<p class="noindenta">The <em>hints</em> argument specifies further criteria for selecting the socket address structures returned by <em>getaddrinfo()</em>. When used as the <em>hints</em> argument, only the <em>ai_flags</em>, <em>ai_family</em>, <em>ai_socktype</em>, and <em>ai_protocol</em> fields of the <em>addrinfo</em> structure can be set. The other fields are unused, and should be initialized to 0 or <span class="literal">NULL</span>, as appropriate.</p>
<p class="indent">The <em>hints.ai_family</em> field selects the domain for the returned socket address structures. It may be specified as <span class="literal">AF_INET</span> or <span class="literal">AF_INET6</span> (or some other <span class="literal">AF_*</span> constant, if the implementation supports it). If we are interested in getting back all types of socket address structures, we can specify the value <span class="literal">AF_UNSPEC</span> for this field.</p>
<p class="indent">The <em>hints.ai_socktype</em> field specifies the type of socket for which the returned address structure is to be used. If we specify this field as <span class="literal">SOCK_DGRAM</span>, then a lookup is performed for the UDP service, and a corresponding socket address structure is returned via <em>result</em>. If we specify <span class="literal">SOCK_STREAM</span>, a lookup for the TCP service is performed. If <em>hints.ai_socktype</em> is specified as 0, any socket type is acceptable.</p>
<p class="indent">The <em>hints.ai_protocol</em> field selects the socket protocol for the returned address structures. For our purposes, this field is always specified as 0, meaning that the caller will accept any protocol.</p>
<p class="indentb"><span epub:type="pagebreak" id="page_1216"/>The <em>hints.ai_flags</em> field is a bit mask that modifies the behavior of <em>getaddrinfo()</em>. This field is formed by ORing together zero or more of the following values:</p>
<p class="term"><span class="literal">AI_ADDRCONFIG</span></p>
<p class="termlist">Return IPv4 addresses only if there is at least one IPv4 address configured for the local system (other than the IPv4 loopback address), and return IPv6 addresses only if there is at least one IPv6 address configured for the local system (other than the IPv6 loopback address).</p>
<p class="term"><span class="literal">AI_ALL</span></p>
<p class="termlist">See the description of <span class="literal">AI_V4MAPPED</span> below.</p>
<p class="term"><span class="literal">AI_CANONNAME</span></p>
<p class="termlist">If <em>host</em> is not <span class="literal">NULL</span>, return a pointer to a null-terminated string containing the canonical name of the host. This pointer is returned in a buffer pointed to by the <em>ai_canonname</em> field of the first of the <em>addrinfo</em> structures returned via <em>result</em>.</p>
<p class="term"><span class="literal">AI_NUMERICHOST</span></p>
<p class="termlist">Force interpretation of <em>host</em> as a numeric address string. This is used to prevent name resolution in cases where it is unnecessary, since name resolution can be time-consuming.</p>
<p class="term"><span class="literal">AI_NUMERICSERV</span></p>
<p class="termlist">Interpret <em>service</em> as a numeric port number. This flag prevents the invocation of any name-resolution service, which is not required if <em>service</em> is a numeric string.</p>
<p class="term"><span class="literal">AI_PASSIVE</span></p>
<p class="termlist">Return socket address structures suitable for a passive open (i.e., a listening socket). In this case, <em>host</em> should be <span class="literal">NULL</span>, and the IP address component of the socket address structure(s) returned by <em>result</em> will contain a wildcard IP address (i.e., <span class="literal">INADDR_ANY</span> or <span class="literal">IN6ADDR_ANY_INIT</span>). If this flag is not set, then the address structure(s) returned via <em>result</em> will be suitable for use with <em>connect()</em> and <em>sendto()</em>; if <em>host</em> is <span class="literal">NULL</span>, then the IP address in the returned socket address structures will be set to the loopback IP address (either <span class="literal">INADDR_LOOPBACK</span> or <span class="literal">IN6ADDR_LOOPBACK_INIT</span>, according to the domain).</p>
<p class="term"><span class="literal">AI_V4MAPPED</span></p>
<p class="termlist">If <span class="literal">AF_INET6</span> was specified in the <em>ai_family</em> field of <em>hints</em>, then IPv4-mapped IPv6 address structures should be returned in <em>result</em> if no matching IPv6 address could be found. If <span class="literal">AI_ALL</span> is specified in conjunction with <span class="literal">AI_V4MAPPED</span>, then both IPv6 and IPv4 address structures are returned in <em>result</em>, with IPv4 addresses being returned as IPv4-mapped IPv6 address structures.</p>
<p class="noindentt">As noted above for <span class="literal">AI_PASSIVE</span>, <em>host</em> can be specified as <span class="literal">NULL</span>. It is also possible to specify <em>service</em> as <span class="literal">NULL</span>, in which case the port number in the returned address structures is set to 0 (i.e., we are just interested in resolving hostnames to addresses). It is not permitted, however, to specify both <em>host</em> and <em>service</em> as <span class="literal">NULL</span>.</p>
<p class="indent">If we don&#8217;t need to specify any of the above selection criteria in hints, then <em>hints</em> may be specified as <span class="literal">NULL</span>, in which case <em>ai_socktype</em> and <em>ai_protocol</em> are assumed <span epub:type="pagebreak" id="page_1217"/>as 0, <em>ai_flags</em> is assumed as <span class="literal">(AI_V4MAPPED | AI_ADDRCONFIG)</span>, and <em>ai_family</em> is assumed as <span class="literal">AF_UNSPEC</span>. (The <em>glibc</em> implementation deliberately deviates from SUSv3, which states that if <em>hints</em> is <span class="literal">NULL</span>, <em>ai_flags</em> is assumed as 0.)</p>
<h4 class="h4" id="ch59lev2sec02"><strong>59.10.2 Freeing <em>addrinfo</em> Lists: <em>freeaddrinfo()</em></strong></h4>
<p class="noindenta">The <em>getaddrinfo()</em> function dynamically allocates memory for all of the structures referred to by <em>result</em> (<a href="ch59.xhtml#ch59fig3">Figure 59-3</a>). Consequently, the caller must deallocate these structures when they are no longer needed. The <em>freeaddrinfo()</em> function is provided to conveniently perform this deallocation in a single step.</p>
<div class="box">
<p class="programsa">#include &lt;sys/socket.h&gt;<br/>#include &lt;netdb.h&gt;<br/><br/>void <span class="codestrong">freeaddrinfo</span>(struct addrinfo *<span class="font1">result</span>);</p>
</div>
<p class="noindent">If we want to preserve a copy of one of the <em>addrinfo</em> structures or its associated socket address structure, then we must duplicate the structure(s) before calling <em>freeaddrinfo()</em>.</p>
<h4 class="h4" id="ch59lev2sec03"><strong>59.10.3 Diagnosing Errors: <em>gai_strerror()</em></strong></h4>
<p class="noindenta">On error, <em>getaddrinfo()</em> returns one of the nonzero error codes shown in <a href="ch59.xhtml#ch59table1">Table 59-1</a>.</p>
<p class="tablecap"><a id="ch59table1"/><strong>Table 59-1:</strong> Error returns for <em>getaddrinfo()</em> and <em>getnameinfo()</em></p>
<table class="all">
<thead>
<tr>
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Error constant</strong></p></td>
<td style="vertical-align: top;" class="table_th1"><p class="table"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">EAI_ADDRFAMILY</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">No addresses for <em>host</em> exist in <em>hints.ai_family</em> (not in SUSv3, but defined on most implementations; <em>getaddrinfo()</em> only)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">EAI_AGAIN</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Temporary failure in name resolution (try again later)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">EAI_BADFLAGS</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">An invalid flag was specified in <em>hints.ai_flags</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">EAI_FAIL</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Unrecoverable failure while accessing name server</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">EAI_FAMILY</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Address family specified in <em>hints.ai_family</em> is not supported</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">EAI_MEMORY</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Memory allocation failure</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">EAI_NODATA</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">No address associated with <em>host</em> (not in SUSv3, but defined on most implementations; <em>getaddrinfo()</em> only)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">EAI_NONAME</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Unknown <em>host</em> or <em>service</em>, or both <em>host</em> and <em>service</em> were <span class="literal">NULL</span>, or <span class="literal">AI_NUMERICSERV</span> specified and <em>service</em> didn&#8217;t point to numeric string</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">EAI_OVERFLOW</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Argument buffer overflow</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">EAI_SERVICE</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Specified <em>service</em> not supported for <em>hints.ai_socktype</em> (<em>getaddrinfo()</em> only)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">EAI_SOCKTYPE</span></p></td>
<td style="vertical-align: top;" class="table_2"><p class="table">Specified <em>hints.ai_socktype</em> is not supported (<em>getaddrinfo()</em> only)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table_3"><p class="table"><span class="literal">EAI_SYSTEM</span></p></td>
<td style="vertical-align: top;" class="table_3a"><p class="table">System error returned in <em>errno</em></p></td>
</tr>
</tbody>
</table>
<p class="noindent">Given one of the error codes in <a href="ch59.xhtml#ch59table1">Table 59-1</a>, the <em>gai_strerror()</em> function returns a string describing the error. (This string is typically briefer than the description shown in <a href="ch59.xhtml#ch59table1">Table 59-1</a>.)</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_1218"/>#include &lt;netdb.h&gt;<br/><br/>const char *<span class="codestrong">gai_strerror</span>(int <span class="font1">errcode</span>);</p>
<p class="right">Returns pointer to string containing error message</p>
</div>
<p class="noindent">We can use the string returned by <em>gai_strerror()</em> as part of an error message displayed by an application.</p>
<h4 class="h4" id="ch59lev2sec04"><strong>59.10.4 The <em>getnameinfo()</em> Function</strong></h4>
<p class="noindenta">The <em>getnameinfo()</em> function is the converse of <em>getaddrinfo()</em>. Given a socket address structure (either IPv4 or IPv6), it returns strings containing the corresponding host and service name, or numeric equivalents if the names can&#8217;t be resolved.</p>
<div class="box">
<p class="programsa">#include &lt;sys/socket.h&gt;<br/>#include &lt;netdb.h&gt;<br/><br/>int <span class="codestrong">getnameinfo</span>(const struct sockaddr *<span class="font1">addr</span>, socklen_t <span class="font1">addrlen</span>, char *<span class="font1">host</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;socklen_t <span class="font1">hostlen</span>, char *<span class="font1">service</span>, socklen_t <span class="font1">servlen</span>, int <span class="font1">flags</span>);</p>
<p class="right">Returns 0 on success, or nonzero on error</p>
</div>
<p class="noindent">The <em>addr</em> argument is a pointer to the socket address structure that is to be converted. The length of that structure is given in <em>addrlen</em>. Typically, the values for <em>addr</em> and <em>addrlen</em> are obtained from a call to <em>accept()</em>, <em>recvfrom()</em>, <em>getsockname()</em>, or <em>getpeername()</em>.</p>
<p class="indent">The resulting host and service names are returned as null-terminated strings in the buffers pointed to by <em>host</em> and <em>service</em>. These buffers must be allocated by the caller, and their sizes must be passed in <em>hostlen</em> and <em>servlen</em>. The <span class="literal">&lt;netdb.h&gt;</span> header file defines two constants to assist in sizing these buffers. <span class="literal">NI_MAXHOST</span> indicates the maximum size, in bytes, for a returned hostname string. It is defined as 1025. <span class="literal">NI_MAXSERV</span> indicates the maximum size, in bytes, for a returned service name string. It is defined as 32. These two constants are not specified in SUSv3, but they are defined on all UNIX implementations that provide <em>getnameinfo()</em>. (Since <em>glibc</em> 2.8, we must define one of the feature test macros <span class="literal">_BSD_SOURCE</span>, <span class="literal">_SVID_SOURCE</span>, or <span class="literal">_GNU_SOURCE</span> to obtain the definitions of <span class="literal">NI_MAXHOST</span> and <span class="literal">NI_MAXSERV</span>.)</p>
<p class="indent">If we are not interested in obtaining the hostname, we can specify <em>host</em> as <span class="literal">NULL</span> and <em>hostlen</em> as 0. Similarly, if we don&#8217;t need the service name, we can specify <em>service</em> as <span class="literal">NULL</span> and <em>servlen</em> as 0. However, at least one of <em>host</em> and <em>service</em> must be non-<span class="literal">NULL</span> (and the corresponding length argument must be nonzero).</p>
<p class="indentb">The final argument, <em>flags</em>, is a bit mask that controls the behavior of <em>getnameinfo()</em>. The following constants may be ORed together to form this bit mask:</p>
<p class="term"><span class="literal">NI_DGRAM</span></p>
<p class="termlist">By default, <em>getnameinfo()</em> returns the name corresponding to a <em>stream</em> socket (i.e., TCP) service. Normally, this doesn&#8217;t matter, because, as noted in <a href="ch59.xhtml#ch59lev1sec09">Section 59.9</a>, the service names are usually the same for corresponding <span epub:type="pagebreak" id="page_1219"/>TCP and UDP ports. However, in the few instances where the names differ, the <span class="literal">NI_DGRAM</span> flag forces the name of the datagram socket (i.e., UDP) service to be returned.</p>
<p class="term"><span class="literal">NI_NAMEREQD</span></p>
<p class="termlist">By default, if the hostname can&#8217;t be resolved, a numeric address string is returned in <em>host</em>. If the <span class="literal">NI_NAMEREQD</span> flag is specified, an error (<span class="literal">EAI_NONAME</span>) is returned instead.</p>
<p class="term"><span class="literal">NI_NOFQDN</span></p>
<p class="termlist">By default, the fully qualified domain name for the host is returned. Specifying the <span class="literal">NI_NOFQDN</span> flag causes just the first (i.e., the hostname) part of the name to be returned, if this is a host on the local network.</p>
<p class="term"><span class="literal">NI_NUMERICHOST</span></p>
<p class="termlist">Force a numeric address string to be returned in <em>host</em>. This is useful if we want to avoid a possibly time-consuming call to the DNS server.</p>
<p class="term"><span class="literal">NI_NUMERICSERV</span></p>
<p class="termlist">Force a decimal port number string to be returned in <em>service</em>. This is useful in cases where we know that the port number doesn&#8217;t correspond to a service name&#8212;for example, if it is an ephemeral port number assigned to the socket by the kernel&#8212;and we want to avoid the inefficiency of unnecessarily searching <span class="literal">/etc/services</span>.</p>
<p class="noindentt">On success, <em>getnameinfo()</em> returns 0. On error, it returns one of the nonzero error codes shown in <a href="ch59.xhtml#ch59table1">Table 59-1</a>.</p>
<h3 class="h3" id="ch59lev1sec11"><strong>59.11 Client-Server Example (Stream Sockets)</strong></h3>
<p class="noindenta">We now have enough information to look at a simple client-server application using TCP sockets. The task performed by this application is the same as that performed by the FIFO client-server application presented in <a href="ch44.xhtml#ch44lev1sec08">Section 44.8</a>: allocating unique sequence numbers (or ranges of sequence numbers) to clients.</p>
<p class="indent">In order to handle the possibility that integers may be represented in different formats on the server and client hosts, we encode all transmitted integers as strings terminated by a newline, and use our <em>readLine()</em> function (<a href="ch59.xhtml#ch59ex1">Listing 59-1</a>) to read these strings.</p>
<h5 class="h5" id="ch59lev3sec11"><strong>Common header file</strong></h5>
<p class="noindenta">Both the server and the client include the header file shown in <a href="ch59.xhtml#ch59ex5">Listing 59-5</a>. This file includes various other header files, and defines the TCP port number to be used by the application.</p>
<h5 class="h5" id="ch59lev3sec12"><strong>Server program</strong></h5>
<p class="noindentab">The server program shown in <a href="ch59.xhtml#ch59ex6">Listing 59-6</a> performs the following steps:</p>
<p class="bull">&#8226; Initialize the server&#8217;s sequence number either to 0 or to the value supplied in the optional command-line argument <span class="ent">&#x2460;</span>.</p>
<p class="bull"><span epub:type="pagebreak" id="page_1220"/>&#8226; Ignore the <span class="literal">SIGPIPE</span> signal <span class="ent">&#x2461;</span>. This prevents the server from receiving the <span class="literal">SIGPIPE</span> signal if it tries to write to a socket whose peer has been closed; instead, the <em>write()</em> fails with the error <span class="literal">EPIPE</span>.</p>
<p class="bull">&#8226; Call <em>getaddrinfo()</em> <span class="ent">&#x2463;</span> to obtain a set of socket address structures for a TCP socket that uses the port number <span class="literal">PORT_NUM</span>. (Instead of using a hard-coded port number, we would more typically use a service name.) We specify the <span class="literal">AI_PASSIVE</span> flag <span class="ent">&#x2462;</span> so that the resulting socket will be bound to the wildcard address (<a href="ch58.xhtml#ch58lev1sec05">Section 58.5</a>). As a result, if the server is run on a multihomed host, it can accept connection requests sent to any of the host&#8217;s network addresses.</p>
<p class="bull">&#8226; Enter a loop that iterates through the socket address structures returned by the previous step <span class="ent">&#x2464;</span>. The loop terminates when the program finds an address structure that can be used to successfully create and bind a socket <span class="ent">&#x2466;</span>.</p>
<p class="bull">&#8226; Set the <span class="literal">SO_REUSEADDR</span> option for the socket created in the previous step <span class="ent">&#x2465;</span>. We defer discussion of this option until <a href="ch61.xhtml#ch61lev1sec10">Section 61.10</a>, where we note that a TCP server should usually set this option on its listening socket.</p>
<p class="bull">&#8226; Mark the socket as a listening socket <span class="ent">&#x2467;</span>.</p>
<p class="bull">&#8226; Commence an infinite <span class="literal">for</span> loop <span class="ent">&#x2468;</span> that services clients iteratively (<a href="ch60.xhtml#ch60">Chapter 60</a>). Each client&#8217;s request is serviced before the next client&#8217;s request is accepted. For each client, the server performs the following steps:</p>
<p class="dash1">&#8211; Accept a new connection <span class="ent">&#x2469;</span>. The server passes non-<span class="literal">NULL</span> pointers for the second and third arguments to <em>accept()</em>, in order to obtain the address of the client. The server displays the client&#8217;s address (IP address plus port number) on standard output <span class="ent">&#x246A;</span>.</p>
<p class="dash1">&#8211; Read the client&#8217;s message <span class="ent">&#x246B;</span>, which consists of a newline-terminated string specifying how many sequence numbers the client wants. The server converts this string to an integer and stores it in the variable <em>reqLen</em> <span class="ent">&#x246C;</span>.</p>
<p class="dash1">&#8211; Send the current value of the sequence number (<em>seqNum</em>) back to the client, encoding it as a newline-terminated string <span class="ent">&#x246D;</span>. The client can assume that it has been allocated all of the sequence numbers in the range <em>seqNum</em> to <em>(seqNum + reqLen &#8211; 1)</em>.</p>
<p class="dash1">&#8211; Update the value of the server&#8217;s sequence number by adding <em>reqLen</em> to <em>seqNum</em> <span class="ent">&#x246E;</span>.</p>
<p class="examplet"><a id="ch59ex5"/><strong>Listing 59-5:</strong> Header file used by <span class="literal">is_seqnum_sv.c</span> and <span class="literal">is_seqnum_cl.c</span></p>
<p class="programsli">______________________________________________________ <span class="codestrong">sockets/is_seqnum.h</span><br/><br/>#include &lt;netinet/in.h&gt;<br/>#include &lt;sys/socket.h&gt;<br/>#include &lt;signal.h&gt;<br/>#include "read_line.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declaration of readLine() */<br/>#include "tlpi_hdr.h"<br/><br/>#define PORT_NUM "50000"&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Port number for server */<br/><br/>#define INT_LEN 30&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Size of string able to hold largest<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;integer (including terminating '\n') */<br/>______________________________________________________ <span class="codestrong">sockets/is_seqnum.h</span></p>
<p class="examplet"><span epub:type="pagebreak" id="page_1221"/><a id="ch59ex6"/><strong>Listing 59-6:</strong> An iterative server that uses a stream socket to communicate with clients</p>
<p class="programsli">____________________________________________________ <span class="codestrong">sockets/is_seqnum_sv.c</span><br/><br/>&#160;&#160;&#160;#define _BSD_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* To get definitions of NI_MAXHOST and<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;NI_MAXSERV from &lt;netdb.h&gt; */<br/>&#160;&#160;&#160;#include &lt;netdb.h&gt;<br/>&#160;&#160;&#160;#include "is_seqnum.h"<br/><br/>&#160;&#160;&#160;#define BACKLOG 50<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;uint32_t seqNum;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char reqLenStr[INT_LEN];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Length of requested sequence */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char seqNumStr[INT_LEN];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Start of granted sequence */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct sockaddr_storage claddr;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int lfd, cfd, optval, reqLen;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;socklen_t addrlen;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct addrinfo hints;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct addrinfo *result, *rp;<br/>&#160;&#160;&#160;#define ADDRSTRLEN (NI_MAXHOST + NI_MAXSERV + 10)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char addrStr[ADDRSTRLEN];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char host[NI_MAXHOST];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char service[NI_MAXSERV];<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc &gt; 1 &#38;&#38; strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s [init-seq-num]\n", argv[0]);<br/><br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;seqNum = (argc &gt; 1) ? getInt(argv[1], 0, "init-seq-num") : 0;<br/><br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("signal");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Call getaddrinfo() to obtain a list of addresses that<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;we can try binding to */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;memset(&#38;hints, 0, sizeof(struct addrinfo));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;hints.ai_canonname = NULL;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;hints.ai_addr = NULL;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;hints.ai_next = NULL;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;hints.ai_socktype = SOCK_STREAM;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;hints.ai_family = AF_UNSPEC;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allows IPv4 or IPv6 */<br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;hints.ai_flags = AI_PASSIVE | AI_NUMERICSERV;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Wildcard IP address; service name is numeric */<br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;if (getaddrinfo(NULL, PORT_NUM, &#38;hints, &#38;result) != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("getaddrinfo");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Walk through returned list until we find an address structure<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;that can be used to successfully create and bind a socket */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;optval = 1;<br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;for (rp = result; rp != NULL; rp = rp-&gt;ai_next) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lfd = socket(rp-&gt;ai_family, rp-&gt;ai_socktype, rp-&gt;ai_protocol);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (lfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* On error, try next address */<br/><br/><span epub:type="pagebreak" id="page_1222"/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &#38;optval, sizeof(optval))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;== -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("setsockopt");<br/><br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (bind(lfd, rp-&gt;ai_addr, rp-&gt;ai_addrlen) == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Success */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* bind() failed: close this socket and try next address */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;close(lfd);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (rp == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("Could not bind socket to any address");<br/><br/><span class="ent">&#x2467;</span>&#160;&#160;&#160;&#160;&#160;if (listen(lfd, BACKLOG) == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("listen");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;freeaddrinfo(result);<br/><br/><span class="ent">&#x2468;</span>&#160;&#160;&#160;&#160;&#160;for (;;) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Handle clients iteratively */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Accept a client connection, obtaining client's address */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;addrlen = sizeof(struct sockaddr_storage);<br/><span class="ent">&#x2469;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cfd = accept(lfd, (struct sockaddr *) &#38;claddr, &#38;addrlen);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (cfd == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("accept");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/><span class="ent">&#x246A;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (getnameinfo((struct sockaddr *) &#38;claddr, addrlen,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;host, NI_MAXHOST, service, NI_MAXSERV, 0) == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;snprintf(addrStr, ADDRSTRLEN, "(%s, %s)", host, service);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;snprintf(addrStr, ADDRSTRLEN, "(?UNKNOWN?)");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Connection from %s\n", addrStr);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Read client request, send sequence number back */<br/><br/><span class="ent">&#x246B;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (readLine(cfd, reqLenStr, INT_LEN) &lt;= 0) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;close(cfd);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Failed read; skip request */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/><span class="ent">&#x246C;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;reqLen = atoi(reqLenStr);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (reqLen &lt;= 0) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Watch for misbehaving clients */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;close(cfd);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Bad request; skip it */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/><span class="ent">&#x246D;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;snprintf(seqNumStr, INT_LEN, "%d\n", seqNum);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (write(cfd, seqNumStr, strlen(seqNumStr)) != strlen(seqNumStr))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(stderr, "Error on write");<br/><br/><span class="ent">&#x246E;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;seqNum += reqLen;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Update sequence number */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (close(cfd) == -1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Close connection */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errMsg("close");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;}<br/>____________________________________________________ <span class="codestrong">sockets/is_seqnum_sv.c</span></p>
<h5 class="h5" id="ch59lev3sec13"><span epub:type="pagebreak" id="page_1223"/><strong>Client program</strong></h5>
<p class="noindentab">The client program is shown in <a href="ch59.xhtml#ch59ex7">Listing 59-7</a>. This program accepts two arguments. The first argument, which is the name of the host on which the server is running, is mandatory. The optional second argument is the length of the sequence desired by the client. The default length is 1. The client performs the following steps:</p>
<p class="bull">&#8226; Call <em>getaddrinfo()</em> to obtain a set of socket address structures suitable for connecting to a TCP server bound to the specified host <span class="ent">&#x2460;</span>. For the port number, the client specifies <span class="literal">PORT_NUM</span>.</p>
<p class="bull">&#8226; Enter a loop <span class="ent">&#x2461;</span> that iterates through the socket address structures returned by the previous step, until the client finds one that can be used to successfully create <span class="ent">&#x2462;</span> and connect <span class="ent">&#x2463;</span> a socket to the server. Since the client has not bound its socket, the <em>connect()</em> call causes the kernel to assign an ephemeral port to the socket.</p>
<p class="bull">&#8226; Send an integer specifying the length of the client&#8217;s desired sequence <span class="ent">&#x2464;</span>. This integer is sent as a newline-terminated string.</p>
<p class="bull">&#8226; Read the sequence number sent back by the server (which is likewise a newline-terminated string) <span class="ent">&#x2465;</span> and print it on standard output <span class="ent">&#x2466;</span>.</p>
<p class="noindentt">When we run the server and the client on the same host, we see the following:</p>
<p class="programs">$ <span class="codestrong">./is_seqnum_sv &#38;</span><br/>[1] 4075<br/>$ <span class="codestrong">./is_seqnum_cl localhost</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Client 1: requests 1 sequence number</span><br/>Connection from (localhost, 33273)&#160;&#160;&#160;&#160;&#160;<span class="font1">Server displays client address + port</span><br/>Sequence number: 0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Client displays returned sequence number</span><br/>$ <span class="codestrong">./is_seqnum_cl localhost 10</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Client 2: requests 10 sequence numbers</span><br/>Connection from (localhost, 33274)<br/>Sequence number: 1<br/>$ <span class="codestrong">./is_seqnum_cl localhost</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Client 3: requests 1 sequence number</span><br/>Connection from (localhost, 33275)<br/>Sequence number: 11</p>
<p class="noindent">Next, we demonstrate the use of <em>telnet</em> for debugging this application:</p>
<p class="programs">$ <span class="codestrong">telnet localhost 50000</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Our server uses this port number</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Empty line printed by telnet</span><br/>Trying 127.0.0.1...<br/>Connection from (localhost, 33276)<br/>Connected to localhost.<br/>Escape character is '^]'.<br/><span class="codestrong">1</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">Enter length of requested sequence</span><br/>12&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="font1">telnet displays sequence number and</span><br/>Connection closed by foreign host.&#160;&#160;&#160;&#160;&#160;<span class="font1">detects that server closed connection</span></p>
<div class="block">
<p class="noindent"><span epub:type="pagebreak" id="page_1224"/>In the shell session log, we see that the kernel cycles sequentially through the ephemeral port numbers. (Other implementations exhibit similar behavior.) On Linux, this behavior is the result of an optimization to minimize hash lookups in the kernel&#8217;s table of local socket bindings. When the upper limit for these numbers is reached, the kernel recommences allocating an available number starting at the low end of the range (defined by the Linux-specific <span class="literal">/proc/sys/net/ipv4/ip_local_port_range</span> file).</p>
</div>
<p class="examplet"><a id="ch59ex7"/><strong>Listing 59-7:</strong> A client that uses stream sockets</p>
<p class="programsli">____________________________________________________ <span class="codestrong">sockets/is_seqnum_cl.c</span><br/><br/>&#160;&#160;&#160;#include &lt;netdb.h&gt;<br/>&#160;&#160;&#160;#include "is_seqnum.h"<br/><br/>&#160;&#160;&#160;int<br/>&#160;&#160;&#160;main(int argc, char *argv[])<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char *reqLenStr;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Requested length of sequence */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;char seqNumStr[INT_LEN];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Start of granted sequence */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;int cfd;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;ssize_t numRead;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct addrinfo hints;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct addrinfo *result, *rp;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;usageErr("%s server-host [sequence-len]\n", argv[0]);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Call getaddrinfo() to obtain a list of addresses that<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;we can try connecting to */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;memset(&#38;hints, 0, sizeof(struct addrinfo));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;hints.ai_canonname = NULL;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;hints.ai_addr = NULL;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;hints.ai_next = NULL;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;hints.ai_family = AF_UNSPEC;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allows IPv4 or IPv6 */<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;hints.ai_socktype = SOCK_STREAM;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;hints.ai_flags = AI_NUMERICSERV;<br/><br/><span class="ent">&#x2460;</span>&#160;&#160;&#160;&#160;&#160;if (getaddrinfo(argv[1], PORT_NUM, &#38;hints, &#38;result) != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("getaddrinfo");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Walk through returned list until we find an address structure<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;that can be used to successfully connect a socket */<br/><br/><span class="ent">&#x2461;</span>&#160;&#160;&#160;&#160;&#160;for (rp = result; rp != NULL; rp = rp-&gt;ai_next) {<br/><span class="ent">&#x2462;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cfd = socket(rp-&gt;ai_family, rp-&gt;ai_socktype, rp-&gt;ai_protocol);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (cfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* On error, try next address */<br/><br/><span class="ent">&#x2463;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (connect(cfd, rp-&gt;ai_addr, rp-&gt;ai_addrlen) != -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Success */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Connect failed: close this socket and try next address */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;close(cfd);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (rp == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("Could not connect socket to any address");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;freeaddrinfo(result);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Send requested sequence length, with terminating newline */<br/><br/><span class="ent">&#x2464;</span>&#160;&#160;&#160;&#160;&#160;reqLenStr = (argc &gt; 2) ? argv[2] : "1";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (write(cfd, reqLenStr, strlen(reqLenStr)) !=&#160;&#160;strlen(reqLenStr))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("Partial/failed write (reqLenStr)");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (write(cfd, "\n", 1) != 1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("Partial/failed write (newline)");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Read and display sequence number returned by server */<br/><br/><span class="ent">&#x2465;</span>&#160;&#160;&#160;&#160;&#160;numRead = readLine(cfd, seqNumStr, INT_LEN);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errExit("readLine");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (numRead == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fatal("Unexpected EOF from server");<br/><br/><span class="ent">&#x2466;</span>&#160;&#160;&#160;&#160;&#160;printf("Sequence number: %s", seqNumStr);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Includes '\n' */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Closes 'cfd' */<br/><br/>&#160;&#160;&#160;}<br/>____________________________________________________ <span class="codestrong">sockets/is_seqnum_cl.c</span></p>
<h3 class="h3" id="ch59lev1sec12"><span epub:type="pagebreak" id="page_1225"/><strong>59.12 An Internet Domain Sockets Library</strong></h3>
<p class="noindenta">In this section, we use the functions presented in <a href="ch59.xhtml#ch59lev1sec10">Section 59.10</a> to implement a library of functions to perform tasks commonly required for Internet domain sockets. (This library abstracts many of the steps shown in the example programs presented in <a href="ch59.xhtml#ch59lev1sec11">Section 59.11</a>.) Since these functions employ the protocol-independent <em>getaddrinfo()</em> and <em>getnameinfo()</em> functions, they can be used with both IPv4 and IPv6. <a href="ch59.xhtml#ch59ex8">Listing 59-8</a> shows the header file that declares these functions.</p>
<p class="indentb">Many of the functions in this library have similar arguments:</p>
<p class="bull">&#8226; The <em>host</em> argument is a string containing either a hostname or a numeric address (in IPv4 dotted-decimal, or IPv6 hex-string notation). Alternatively, <em>host</em> can be specified as a <span class="literal">NULL</span> pointer to indicate that the loopback IP address is to be used.</p>
<p class="bull">&#8226; The <em>service</em> argument is either a service name or a port number specified as a decimal string.</p>
<p class="bull">&#8226; The <em>type</em> argument is a socket type, specified as either <span class="literal">SOCK_STREAM</span> or <span class="literal">SOCK_DGRAM</span>.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1226"/><a id="ch59ex8"/><strong>Listing 59-8:</strong> Header file for <span class="literal">inet_sockets.c</span></p>
<p class="programsli">____________________________________________________ <span class="codestrong">sockets/inet_sockets.h</span><br/><br/>#ifndef INET_SOCKETS_H<br/>#define INET_SOCKETS_H&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Prevent accidental double inclusion */<br/><br/>#include &lt;sys/socket.h&gt;<br/>#include &lt;netdb.h&gt;<br/><br/>int inetConnect(const char *host, const char *service, int type);<br/><br/>int inetListen(const char *service, int backlog, socklen_t *addrlen);<br/><br/>int inetBind(const char *service, int type, socklen_t *addrlen);<br/><br/>char *inetAddressStr(const struct sockaddr *addr, socklen_t addrlen,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;char *addrStr, int addrStrLen);<br/><br/>#define IS_ADDR_STR_LEN 4096<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Suggested length for string buffer that caller<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;should pass to inetAddressStr(). Must be greater<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;than (NI_MAXHOST + NI_MAXSERV + 4) */<br/>#endif<br/>____________________________________________________ <span class="codestrong">sockets/inet_sockets.h</span></p>
<p class="noindent">The <em>inetConnect()</em> function creates a socket with the given socket <em>type</em>, and connects it to the address specified by <em>host</em> and <em>service</em>. This function is designed for TCP or UDP clients that need to connect their socket to a server socket.</p>
<div class="box">
<p class="programsa">#include "inet_sockets.h"<br/><br/>int <span class="codestrong">inetConnect</span>(const char *<span class="font1">host</span>, const char *<span class="font1">service</span>, int <span class="font1">type</span>);</p>
<p class="right">Returns a file descriptor on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The file descriptor for the new socket is returned as the function result.</p>
<p class="indent">The <em>inetListen()</em> function creates a listening stream (<span class="literal">SOCK_STREAM</span>) socket bound to the wildcard IP address on the TCP port specified by <em>service</em>. This function is designed for use by TCP servers.</p>
<div class="box">
<p class="programsa">#include "inet_sockets.h"<br/><br/>int <span class="codestrong">inetListen</span>(const char *<span class="font1">service</span>, int <span class="font1">backlog</span>, socklen_t *<span class="font1">addrlen</span>);</p>
<p class="right">Returns a file descriptor on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The file descriptor for the new socket is returned as the function result.</p>
<p class="indent">The <em>backlog</em> argument specifies the permitted backlog of pending connections (as for <em>listen()</em>).</p>
<p class="indent"><span epub:type="pagebreak" id="page_1227"/>If <em>addrlen</em> is specified as a non-<span class="literal">NULL</span> pointer, then the location it points to is used to return the size of the socket address structure corresponding to the returned file descriptor. This value allows us to allocate a socket address buffer of the appropriate size to be passed to a later <em>accept()</em> call if we want to obtain the address of a connecting client.</p>
<p class="indent">The <em>inetBind()</em> function creates a socket of the given <em>type</em>, bound to the wildcard IP address on the port specified by <em>service</em> and <em>type</em>. (The socket <em>type</em> indicates whether this is a TCP or UDP service.) This function is designed (primarily) for UDP servers and clients to create a socket bound to a specific address.</p>
<div class="box">
<p class="programsa">#include "inet_sockets.h"<br/><br/>int <span class="codestrong">inetBind</span>(const char *<span class="font1">service</span>, int <span class="font1">type</span>, socklen_t *<span class="font1">addrlen</span>);</p>
<p class="right">Returns a file descriptor on success, or &#8211;1 on error</p>
</div>
<p class="noindent">The file descriptor for the new socket is returned as the function result.</p>
<p class="indent">As with <em>inetListen()</em>, <em>inetBind()</em> returns the length of the associated socket address structure for this socket in the location pointed to by <em>addrlen</em>. This is useful if we want to allocate a buffer to pass to <em>recvfrom()</em> in order to obtain the address of the socket sending a datagram. (Many of the steps required for <em>inetListen()</em> and <em>inetBind()</em> are the same, and these steps are implemented within the library by a single function, <em>inetPassiveSocket()</em>.)</p>
<p class="indent">The <em>inetAddressStr()</em> function converts an Internet socket address to printable form.</p>
<div class="box">
<p class="programsa">#include "inet_sockets.h"<br/><br/>char *<span class="codestrong">inetAddressStr</span>(const struct sockaddr *<span class="font1">addr</span>, socklen_t <span class="font1">addrlen</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;char *<span class="font1">addrStr</span>, int <span class="font1">addrStrLen</span>);</p>
<p class="right">Returns pointer to <em>addrStr</em>, a string containing host and service name</p>
</div>
<p class="noindent">Given a socket address structure in <em>addr</em>, whose length is specified in <em>addrlen</em>, <em>inetAddressStr()</em> returns a null-terminated string containing the corresponding hostname and port number in the following form:</p>
<p class="programs">(hostname, port-number)</p>
<p class="noindent">The string is returned in the buffer pointed to by <em>addrStr</em>. The caller must specify the size of this buffer in <em>addrStrLen</em>. If the returned string would exceed <em>(addrStrLen &#8211; 1)</em> bytes, it is truncated. The constant <span class="literal">IS_ADDR_STR_LEN</span> defines a suggested size for the <em>addrStr</em> buffer that should be large enough to handle all possible return strings. As its function result, <em>inetAddressStr()</em> returns <em>addrStr</em>.</p>
<p class="indent">The implementation of the functions described in this section is shown in <a href="ch59.xhtml#ch59ex9">Listing 59-9</a>.</p>
<p class="examplet"><span epub:type="pagebreak" id="page_1228"/><a id="ch59ex9"/><strong>Listing 59-9:</strong> An Internet domain sockets library</p>
<p class="programsli">____________________________________________________ <span class="codestrong">sockets/inet_sockets.c</span><br/><br/>#define _BSD_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* To get NI_MAXHOST and NI_MAXSERV<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;definitions from &lt;netdb.h&gt; */<br/>#include &lt;sys/socket.h&gt;<br/>#include &lt;netinet/in.h&gt;<br/>#include &lt;arpa/inet.h&gt;<br/>#include &lt;netdb.h&gt;<br/>#include "inet_sockets.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Declares functions defined here */<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>inetConnect(const char *host, const char *service, int type)<br/>{<br/>&#160;&#160;&#160;&#160;struct addrinfo hints;<br/>&#160;&#160;&#160;&#160;struct addrinfo *result, *rp;<br/>&#160;&#160;&#160;&#160;int sfd, s;<br/><br/>&#160;&#160;&#160;&#160;memset(&#38;hints, 0, sizeof(struct addrinfo));<br/>&#160;&#160;&#160;&#160;hints.ai_canonname = NULL;<br/>&#160;&#160;&#160;&#160;hints.ai_addr = NULL;<br/>&#160;&#160;&#160;&#160;hints.ai_next = NULL;<br/>&#160;&#160;&#160;&#160;hints.ai_family = AF_UNSPEC;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allows IPv4 or IPv6 */<br/>&#160;&#160;&#160;&#160;hints.ai_socktype = type;<br/><br/>&#160;&#160;&#160;&#160;s = getaddrinfo(host, service, &#38;hints, &#38;result);<br/>&#160;&#160;&#160;&#160;if (s != 0) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;errno = ENOSYS;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;/* Walk through returned list until we find an address structure<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;that can be used to successfully connect a socket */<br/><br/>&#160;&#160;&#160;&#160;for (rp = result; rp != NULL; rp = rp-&gt;ai_next) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sfd = socket(rp-&gt;ai_family, rp-&gt;ai_socktype, rp-&gt;ai_protocol);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* On error, try next address */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (connect(sfd, rp-&gt;ai_addr, rp-&gt;ai_addrlen) != -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Success */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Connect failed: close this socket and try next address */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;close(sfd);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;freeaddrinfo(result);<br/><br/>&#160;&#160;&#160;&#160;return (rp == NULL) ? -1 : sfd;<br/>}<br/><br/><span epub:type="pagebreak" id="page_1229"/>static int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Public interfaces: inetBind() and inetListen() */<br/>inetPassiveSocket(const char *service, int type, socklen_t *addrlen,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Boolean doListen, int backlog)<br/>{<br/>&#160;&#160;&#160;&#160;struct addrinfo hints;<br/>&#160;&#160;&#160;&#160;struct addrinfo *result, *rp;<br/>&#160;&#160;&#160;&#160;int sfd, optval, s;<br/><br/>&#160;&#160;&#160;&#160;memset(&#38;hints, 0, sizeof(struct addrinfo));<br/>&#160;&#160;&#160;&#160;hints.ai_canonname = NULL;<br/>&#160;&#160;&#160;&#160;hints.ai_addr = NULL;<br/>&#160;&#160;&#160;&#160;hints.ai_next = NULL;<br/>&#160;&#160;&#160;&#160;hints.ai_socktype = type;<br/>&#160;&#160;&#160;&#160;hints.ai_family = AF_UNSPEC;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Allows IPv4 or IPv6 */<br/>&#160;&#160;&#160;&#160;hints.ai_flags = AI_PASSIVE;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Use wildcard IP address */<br/><br/>&#160;&#160;&#160;&#160;s = getaddrinfo(NULL, service, &#38;hints, &#38;result);<br/>&#160;&#160;&#160;&#160;if (s != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/><br/>&#160;&#160;&#160;&#160;/* Walk through returned list until we find an address structure<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;that can be used to successfully create and bind a socket */<br/><br/>&#160;&#160;&#160;&#160;optval = 1;<br/>&#160;&#160;&#160;&#160;for (rp = result; rp != NULL; rp = rp-&gt;ai_next) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sfd = socket(rp-&gt;ai_family, rp-&gt;ai_socktype, rp-&gt;ai_protocol);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sfd == -1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* On error, try next address */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (doListen) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &#38;optval,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sizeof(optval)) == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;close(sfd);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;freeaddrinfo(result);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (bind(sfd, rp-&gt;ai_addr, rp-&gt;ai_addrlen) == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Success */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* bind() failed: close this socket and try next address */<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;close(sfd);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (rp != NULL &#38;&#38; doListen) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (listen(sfd, backlog) == -1) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;freeaddrinfo(result);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (rp != NULL &#38;&#38; addrlen != NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*addrlen = rp-&gt;ai_addrlen;&#160;&#160;&#160;&#160;&#160;&#160;/* Return address structure size */<br/><br/>&#160;&#160;&#160;&#160;freeaddrinfo(result);<br/><br/>&#160;&#160;&#160;&#160;return (rp == NULL) ? -1 : sfd;<br/>}<br/><br/>int<br/>inetListen(const char *service, int backlog, socklen_t *addrlen)<br/>{<br/>&#160;&#160;&#160;&#160;return inetPassiveSocket(service, SOCK_STREAM, addrlen, TRUE, backlog);<br/>}<br/><br/>int<br/>inetBind(const char *service, int type, socklen_t *addrlen)<br/>{<br/>&#160;&#160;&#160;&#160;return inetPassiveSocket(service, type, addrlen, FALSE, 0);<br/>}<br/><br/>char *<br/>inetAddressStr(const struct sockaddr *addr, socklen_t addrlen,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;char *addrStr, int addrStrLen)<br/>{<br/>&#160;&#160;&#160;&#160;char host[NI_MAXHOST], service[NI_MAXSERV];<br/><br/>&#160;&#160;&#160;&#160;if (getnameinfo(addr, addrlen, host, NI_MAXHOST,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;service, NI_MAXSERV, NI_NUMERICSERV) == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;snprintf(addrStr, addrStrLen, "(%s, %s)", host, service);<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;snprintf(addrStr, addrStrLen, "(?UNKNOWN?)");<br/><br/>&#160;&#160;&#160;&#160;return addrStr;<br/>}<br/>____________________________________________________ <span class="codestrong">sockets/inet_sockets.c</span></p>
<h3 class="h3" id="ch59lev1sec13"><span epub:type="pagebreak" id="page_1230"/><strong>59.13 Obsolete APIs for Host and Service Conversions</strong></h3>
<p class="noindenta">In the following sections, we describe the older, now obsolete functions for converting host names and service names to and from binary and presentation formats. Although new programs should perform these conversions using the modern functions described earlier in this chapter, a knowledge of the obsolete functions is useful because we may encounter them in older code.</p>
<h4 class="h4" id="ch59lev2sec05"><strong>59.13.1 The <em>inet_aton()</em> and <em>inet_ntoa()</em> Functions</strong></h4>
<p class="noindenta">The <em>inet_aton()</em> and <em>inet_ntoa()</em> functions convert IPv4 addresses between dotted-decimal notation and binary form (in network byte order). These functions are nowadays made obsolete by <em>inet_pton()</em> and <em>inet_ntop()</em>.</p>
<p class="indent">The <em>inet_aton()</em> (&#8220;ASCII to network&#8221;) function converts the dotted-decimal string pointed to by <em>str</em> into an IPv4 address in network byte order, which is returned in the <em>in_addr</em> structure pointed to by <em>addr</em>.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_1231"/>#include &lt;arpa/inet.h&gt;<br/><br/>int <span class="codestrong">inet_aton</span>(const char *<span class="font1">str</span>, struct in_addr *<span class="font1">addr</span>);</p>
<p class="right">Returns 1 (true) if <em>str</em> is a valid dotted-decimal address, or 0 (false) on error</p>
</div>
<p class="noindent">The <em>inet_aton()</em> function returns 1 if the conversion was successful, or 0 if <em>str</em> was invalid.</p>
<p class="indent">The numeric components of the string given to <em>inet_aton()</em> need not be decimal. They can be octal (specified by a leading 0) or hexadecimal (specified by a leading 0x or 0X). Furthermore, <em>inet_aton()</em> supports shorthand forms that allow an address to be specified using fewer than four numeric components. (See the <em>inet(3)</em> manual page for details.) The term <em>numbers-and-dots notation</em> is used for the more general address strings that employ these features.</p>
<p class="indent">SUSv3 doesn&#8217;t specify <em>inet_aton()</em>. Nevertheless, this function is available on most implementations. On Linux, we must define one of the feature test macros <span class="literal">_BSD_SOURCE</span>, <span class="literal">_SVID_SOURCE</span>, or <span class="literal">_GNU_SOURCE</span> in order to obtain the declaration of <em>inet_aton()</em> from <span class="literal">&lt;arpa/inet.h&gt;</span>.</p>
<p class="indent">The <em>inet_ntoa()</em> (&#8220;network to ASCII&#8221;) function performs the converse of <em>inet_aton()</em>.</p>
<div class="box">
<p class="programsa">#include &lt;arpa/inet.h&gt;<br/><br/>char *<span class="codestrong">inet_ntoa</span>(struct in_addr <span class="font1">addr</span>);</p>
<p class="right">Returns pointer to (statically allocated) dotted-decimal string version of <em>addr</em></p>
</div>
<p class="noindent">Given an <em>in_addr</em> structure (a 32-bit IPv4 address in network byte order), <em>inet_ntoa()</em> returns a pointer to a (statically allocated) string containing the address in dotted-decimal notation.</p>
<p class="indent">Because the string returned by <em>inet_ntoa()</em> is statically allocated, it is overwritten by successive calls.</p>
<h4 class="h4" id="ch59lev2sec06"><strong>59.13.2 The <em>gethostbyname()</em> and <em>gethostbyaddr()</em> Functions</strong></h4>
<p class="noindenta">The <em>gethostbyname()</em> and <em>gethostbyaddr()</em> functions allow conversion between hostnames and IP addresses. These functions are nowadays made obsolete by <em>getaddrinfo()</em> and <em>getnameinfo()</em>.</p>
<div class="box">
<p class="programsa">#include &lt;netdb.h&gt;<br/><br/>extern int <span class="codestrong">h_errno</span>;<br/><br/>struct hostent *<span class="codestrong">gethostbyname</span>(const char *<span class="font1">name</span>);<br/>struct hostent *<span class="codestrong">gethostbyaddr</span>(const void *<span class="font1">addr</span>, socklen_t <span class="font1">len</span>, int <span class="font1">type</span>);</p>
<p class="right">Both return pointer to (statically allocated) <em>hostent</em> structure on success, or <span class="literal">NULL</span> on error</p>
</div>
<p class="noindent"><span epub:type="pagebreak" id="page_1232"/>The <em>gethostbyname()</em> function resolves the hostname given in <em>name</em>, returning a pointer to a statically allocated <em>hostent</em> structure containing information about that hostname. This structure has the following form:</p>
<p class="programs">struct hostent {<br/>&#160;&#160;&#160;&#160;char *h_name;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Official (canonical) name of host */<br/>&#160;&#160;&#160;&#160;char **h_aliases;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* NULL-terminated array of pointers<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;to alias strings */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;h_addrtype;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Address type (AF_INET or AF_INET6) */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;h_length;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Length (in bytes) of addresses pointed<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;to by h_addr_list (4 bytes for AF_INET,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16 bytes for AF_INET6) */<br/>&#160;&#160;&#160;&#160;char **h_addr_list;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* NULL-terminated array of pointers to<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;host IP addresses (in_addr or in6_addr<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;structures) in network byte order */<br/>};<br/><br/>#define h_addr h_addr_list[0]</p>
<p class="noindent">The <em>h_name</em> field returns the official name of the host, as a null-terminated string. The <em>h_aliases</em> fields points to an array of pointers to null-terminated strings containing aliases (alternative names) for this hostname.</p>
<p class="indent">The <em>h_addr_list</em> field is an array of pointers to IP address structures for this host. (A multihomed host has more than one address.) This list consists of either <em>in_addr</em> or <em>in6_addr</em> structures. We can determine the type of these structures from the <em>h_addrtype</em> field, which contains either <span class="literal">AF_INET</span> or <span class="literal">AF_INET6</span>, and their length from the <em>h_length</em> field. The <em>h_addr</em> definition is provided for backward compatibility with earlier implementations (e.g., 4.2BSD) that returned just one address in the <em>hostent</em> structure. Some existing code relies on this name (and thus is not multihomed-host aware).</p>
<p class="indent">With modern versions of <em>gethostbyname()</em>, <em>name</em> can also be specified as a numeric IP address string; that is, numbers-and-dots notation for IPv4 or hex-string notation for IPv6. In this case, no lookup is performed; instead, <em>name</em> is copied into the <em>h_name</em> field of the <em>hostent</em> structure, and <em>h_addr_list</em> is set to the binary equivalent of <em>name</em>.</p>
<p class="indent">The <em>gethostbyaddr()</em> function performs the converse of <em>gethostbyname()</em>. Given a binary IP address, it returns a <em>hostent</em> structure containing information about the host with that address.</p>
<p class="indent">On error (e.g., a name could not be resolved), both <em>gethostbyname()</em> and <em>gethostbyaddr()</em> return a <span class="literal">NULL</span> pointer and set the global variable <em>h_errno</em>. As the name suggests, this variable is analogous to <em>errno</em> (possible values placed in this variable are described in the <em>gethostbyname(3)</em> manual page), and the <em>herror()</em> and <em>hstrerror()</em> functions are analogous to <em>perror()</em> and <em>strerror()</em>.</p>
<p class="indent">The <em>herror()</em> function displays (on standard error) the string given in <em>str</em>, followed by a colon (<span class="literal">:</span>), and then a message for the current error in <em>h_errno</em>. Alternatively, we can use <em>hstrerror()</em> to obtain a pointer to a string corresponding to the error value specified in <em>err</em>.</p>
<div class="box">
<p class="programsa"><span epub:type="pagebreak" id="page_1233"/>#define _BSD_SOURCE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Or _SVID_SOURCE or _GNU_SOURCE */<br/>#include &lt;netdb.h&gt;<br/><br/>void <span class="codestrong">herror</span>(const char *<span class="font1">str</span>);<br/><br/>const char *<span class="codestrong">hstrerror</span>(int <span class="font1">err</span>);</p>
<p class="right">Returns pointer to <em>h_errno</em> error string corresponding to <em>err</em></p>
</div>
<p class="noindent"><a href="ch59.xhtml#ch59ex10">Listing 59-10</a> demonstrates the use of <em>gethostbyname()</em>. This program displays <em>hostent</em> information for each of the hosts named on its command line. The following shell session demonstrates the use of this program:</p>
<p class="programs">$ <span class="codestrong">./t_gethostbyname www.jambit.com</span><br/>Canonical name: jamjam1.jambit.com<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;alias(es):&#160;&#160;&#160;&#160;&#160;&#160;www.jambit.com<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;address type:&#160;&#160;&#160;AF_INET<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;address(es):&#160;&#160;&#160;&#160;62.245.207.90</p>
<p class="examplet"><a id="ch59ex10"/><strong>Listing 59-10:</strong> Using <em>gethostbyname()</em> to retrieve host information</p>
<p class="programsli">_________________________________________________ <span class="codestrong">sockets/t_gethostbyname.c</span><br/><br/>#define _BSD_SOURCE&#160;&#160;&#160;&#160;&#160;/* To get hstrerror() declaration from &lt;netdb.h&gt; */<br/>#include &lt;netdb.h&gt;<br/>#include &lt;netinet/in.h&gt;<br/>#include &lt;arpa/inet.h&gt;<br/>#include "tlpi_hdr.h"<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>&#160;&#160;&#160;&#160;struct hostent *h;<br/>&#160;&#160;&#160;&#160;char **pp;<br/>&#160;&#160;&#160;&#160;char str[INET6_ADDRSTRLEN];<br/><br/>&#160;&#160;&#160;&#160;for (argv++; *argv != NULL; argv++) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;h = gethostbyname(*argv);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (h == NULL) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fprintf(stderr, "gethostbyname() failed for '%s': %s\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*argv, hstrerror(h_errno));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("Canonical name: %s\n", h-&gt;h_name);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;alias(es):&#160;&#160;&#160;&#160;&#160;");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (pp = h-&gt;h_aliases; *pp != NULL; pp++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf(" %s", *pp);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("\n");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;address type:&#160;&#160;&#160;%s\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(h-&gt;h_addrtype == AF_INET) ? "AF_INET" :<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(h-&gt;h_addrtype == AF_INET6) ? "AF_INET6" : "???");<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (h-&gt;h_addrtype == AF_INET || h-&gt;h_addrtype == AF_INET6) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;address(es):&#160;&#160;&#160;");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (pp = h-&gt;h_addr_list; *pp != NULL; pp++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf(" %s", inet_ntop(h-&gt;h_addrtype, *pp,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str, INET6_ADDRSTRLEN));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printf("\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;exit(EXIT_SUCCESS);<br/>}<br/>_________________________________________________ <span class="codestrong">sockets/t_gethostbyname.c</span></p>
<h4 class="h4" id="ch59lev2sec07"><span epub:type="pagebreak" id="page_1234"/><strong>59.13.3 The <em>getservbyname()</em> and <em>getservbyport()</em> Functions</strong></h4>
<p class="noindenta">The <em>getservbyname()</em> and <em>getservbyport()</em> functions retrieve records from the <span class="literal">/etc/services</span> file (<a href="ch59.xhtml#ch59lev1sec09">Section 59.9</a>). These functions are nowadays made obsolete by <em>getaddrinfo()</em> and <em>getnameinfo()</em>.</p>
<div class="box">
<p class="programsa">#include &lt;netdb.h&gt;<br/><br/>struct servent *<span class="codestrong">getservbyname</span>(const char *<span class="font1">name</span>, const char *<span class="font1">proto</span>);<br/>struct servent *<span class="codestrong">getservbyport</span>(int <span class="font1">port</span>, const char *<span class="font1">proto</span>);</p>
<p class="right">Both return pointer to a (statically allocated) <em>servent</em> structure on success, or <span class="literal">NULL</span> on not found or error</p>
</div>
<p class="noindent">The <em>getservbyname()</em> function looks up the record whose service name (or one of its aliases) matches <em>name</em> and whose protocol matches <em>proto</em>. The <em>proto</em> argument is a string such as <em>tcp</em> or <em>udp</em>, or it can be <span class="literal">NULL</span>. If <em>proto</em> is specified as <span class="literal">NULL</span>, any record whose service name matches <em>name</em> is returned. (This is usually sufficient since, where both UDP and TCP records with the same name exist in the <span class="literal">/etc/services</span> file, they normally have the same port number.) If a matching record is found, then <em>getservbyname()</em> returns a pointer to a statically allocated structure of the following type:</p>
<p class="programs">struct servent {<br/>&#160;&#160;&#160;&#160;char&#160;&#160;*s_name;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Official service name */<br/>&#160;&#160;&#160;&#160;char **s_aliases;&#160;&#160;&#160;&#160;&#160;&#160;/* Pointers to aliases (NULL-terminated) */<br/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;s_port;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Port number (in network byte order) */<br/>&#160;&#160;&#160;&#160;char&#160;&#160;*s_proto;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* Protocol */<br/>};</p>
<p class="noindent">Typically, we call <em>getservbyname()</em> only in order to obtain the port number, which is returned in the <em>s_port</em> field.</p>
<p class="indent">The <em>getservbyport()</em> function performs the converse of <em>getservbyname()</em>. It returns a <em>servent</em> record containing information from the <span class="literal">/etc/services</span> record whose port number matches <em>port</em> and whose protocol matches <em>proto</em>. Again, we can specify <em>proto</em> as <span class="literal">NULL</span>, in which case the call will return any record whose port number matches <span epub:type="pagebreak" id="page_1235"/>the one specified in <em>port</em>. (This may not return the desired result in the few cases mentioned above where the same port number maps to different service names in UDP and TCP.)</p>
<div class="block">
<p class="noindent">An example of the use of the <em>getservbyname()</em> function is provided in the file <span class="literal">sockets/t_getservbyname.c</span> in the source code distribution for this book.</p>
</div>
<h3 class="h3" id="ch59lev1sec14"><strong>59.14 UNIX Versus Internet Domain Sockets</strong></h3>
<p class="noindenta">When writing applications that communicate over a network, we must necessarily use Internet domain sockets. However, when using sockets to communicate between applications on the same system, we have the choice of using either Internet or UNIX domain sockets. In this case, which domain should we use and why?</p>
<p class="indentb">Writing an application using just Internet domain sockets is often the simplest approach, since it will work on both a single host and across a network. However, there are some reasons why we may choose to use UNIX domain sockets:</p>
<p class="bull">&#8226; On some implementations, UNIX domain sockets are faster than Internet domain sockets.</p>
<p class="bull">&#8226; We can use directory (and, on Linux, file) permissions to control access to UNIX domain sockets, so that only applications with a specified user or group ID can connect to a listening stream socket or send a datagram to a datagram socket. This provides a simple method of authenticating clients. With Internet domain sockets, we need to do rather more work if we wish to authenticate clients.</p>
<p class="bull">&#8226; Using UNIX domain sockets, we can pass open file descriptors and sender credentials, as summarized in <a href="ch61.xhtml#ch61lev2sec10">Section 61.13.3</a>.</p>
<h3 class="h3" id="ch59lev1sec15"><strong>59.15 Further Information</strong></h3>
<p class="noindentab">There is a wealth of printed and online resources on TCP/IP and the sockets API:</p>
<p class="bull">&#8226; The key book on network programming with the sockets API is [<a href="bib.xhtml#bib93">Stevens at al., 2004</a>]. [<a href="bib.xhtml#bib87">Snader, 2000</a>] adds some useful guidelines on sockets programming.</p>
<p class="bull">&#8226; [<a href="bib.xhtml#bib91">Stevens, 1994</a>] and [<a href="bib.xhtml#bib111">Wright &#38; Stevens, 1995</a>] describe TCP/IP in detail. [<a href="bib.xhtml#bib12">Comer, 2000</a>], [<a href="bib.xhtml#bib13">Comer &#38; Stevens, 1999</a>], [<a href="bib.xhtml#bib12">Comer &#38; Stevens, 2000</a>], [<a href="bib.xhtml#bib49">Kozierok, 2005</a>], and [<a href="bib.xhtml#bib36">Goralksi, 2009</a>] also provide good coverage of the same material.</p>
<p class="bull">&#8226; [<a href="bib.xhtml#bib100">Tanenbaum, 2002</a>] provides general background on computer networks.</p>
<p class="bull">&#8226; [<a href="bib.xhtml#bib42">Herbert, 2004</a>] describes the details of the Linux 2.6 TCP/IP stack.</p>
<p class="bull">&#8226; The GNU C library manual (online at <em><a href="http://www.gnu.org/">http://www.gnu.org/</a></em>) has an extensive discussion of the sockets API.</p>
<p class="bull">&#8226; The IBM Redbook, <em>TCP/IP Tutorial and Technical Overview</em>, provides lengthy coverage of networking concepts, TCP/IP internals, the sockets API, and a host of related topics. It is freely downloadable from <em><a href="http://www.redbooks.ibm.com/">http://www.redbooks.ibm.com/</a></em>.</p>
<p class="bull">&#8226; [<a href="bib.xhtml#bib32">Gont, 2008</a>] and [<a href="bib.xhtml#bib34">Gont, 2009b</a>] provide security assessments of IPv4 and TCP.</p>
<p class="bull">&#8226; The Usenet newsgroup <em>comp.protocols.tcp-ip</em> is dedicated to questions related to the TCP/IP networking protocols.</p>
<p class="bull"><span epub:type="pagebreak" id="page_1236"/>&#8226; [<a href="bib.xhtml#bib85">Sarolahti &#38; Kuznetsov, 2002</a>] describes congestion control and other details of the Linux TCP implementation.</p>
<p class="bull">&#8226; Linux-specific information can be found in the following manual pages: <em>socket(7)</em>, <em>ip(7)</em>, <em>raw(7)</em>, <em>tcp(7)</em>, <em>udp(7)</em>, and <em>packet(7)</em>.</p>
<p class="bull">&#8226; See also the RFC list in <a href="ch58.xhtml#ch58lev1sec07">Section 58.7</a>.</p>
<h3 class="h3" id="ch59lev1sec16"><strong>59.16 Summary</strong></h3>
<p class="noindenta">Internet domain sockets allow applications on different hosts to communicate via a TCP/IP network. An Internet domain socket address consists of an IP address and a port number. In IPv4, an IP address is a 32-bit number; in IPv6, it is a 128-bit number. Internet domain datagram sockets operate over UDP, providing connectionless, unreliable, message-oriented communication. Internet domain stream sockets operate over TCP, and provide a reliable, bidirectional, byte-stream communication channel between two connected applications.</p>
<p class="indent">Different computer architectures use different conventions for representing data types. For example, integers may be stored in little-endian or big-endian form, and different computers may use different numbers of bytes to represent numeric types such as <em>int</em> or <em>long</em>. These differences mean that we need to employ some architecture-independent representation when transferring data between heterogeneous machines connected via a network. We noted that various marshalling standards exist to deal with this problem, and also described a simple solution used by many applications: encoding all transmitted data in text form, with fields delimited by a designated character (usually a newline).</p>
<p class="indent">We looked at a range of functions that can be used to convert between (numeric) string representations of IP addresses (dotted-decimal for IPv4 and hex-string for IPv6) and their binary equivalents. However, it is generally preferable to use host and service names rather than numbers, since names are easier to remember and continue to be usable, even if the corresponding number is changed. We looked at various functions that convert host and service names to their numeric equivalents and vice versa. The modern function for translating host and service names into socket addresses is <em>getaddrinfo()</em>, but it is common to see the historical functions <em>gethostbyname()</em> and <em>getservbyname()</em> in existing code.</p>
<p class="indent">Consideration of hostname conversions led us into a discussion of DNS, which implements a distributed database for a hierarchical directory service. The advantage of DNS is that the management of the database is not centralized. Instead, local zone administrators update changes for the hierarchical component of the database for which they are responsible, and DNS servers communicate with one another in order to resolve a hostname.</p>
<h3 class="h3" id="ch59lev1sec17"><strong>59.17 Exercises</strong></h3>
<p class="exer"><a id="ch59exe1"/><strong>59-1.</strong>&#160;&#160;&#160;When reading large quantities of data, the <em>readLine()</em> function shown in <a href="ch59.xhtml#ch59ex1">Listing 59-1</a> is inefficient, since a system call is required to read each character. A more efficient interface would read a block of characters into a buffer and extract a line at a time from this buffer. Such an interface might consist of two functions. The first of these functions, which might be called <em>readLineBufInit(fd, &#38;rlbuf)</em>, initializes the bookkeeping <span epub:type="pagebreak" id="page_1237"/>data structure pointed to by <em>rlbuf</em>. This structure includes space for a data buffer, the size of that buffer, and a pointer to the next &#8220;unread&#8221; character in that buffer. It also includes a copy of the file descriptor given in the argument <em>fd</em>. The second function, <em>readLineBuf(&#38;rlbuf)</em>, returns the next line from the buffer associated with <em>rlbuf</em>. If required, this function reads a further block of data from the file descriptor saved in <em>rlbuf</em>. Implement these two functions. Modify the programs in <a href="ch59.xhtml#ch59ex6">Listing 59-6</a> (<span class="literal">is_seqnum_sv.c</span>) and <a href="ch59.xhtml#ch59ex7">Listing 59-7</a> (<span class="literal">is_seqnum_cl.c</span>) to use these functions.</p>
<p class="exer"><a id="ch59exe2"/><strong>59-2.</strong>&#160;&#160;&#160;Modify the programs in <a href="ch59.xhtml#ch59ex6">Listing 59-6</a> (<span class="literal">is_seqnum_sv.c</span>) and <a href="ch59.xhtml#ch59ex7">Listing 59-7</a> (<span class="literal">is_seqnum_cl.c</span>) to use the <em>inetListen()</em> and <em>inetConnect()</em> functions provided in <a href="ch59.xhtml#ch59ex9">Listing 59-9</a> (<span class="literal">inet_sockets.c</span>).</p>
<p class="exer"><a id="ch59exe3"/><strong>59-3.</strong>&#160;&#160;&#160;Write a UNIX domain sockets library with an API similar to the Internet domain sockets library shown in <a href="ch59.xhtml#ch59lev1sec12">Section 59.12</a>. Rewrite the programs in <a href="ch57.xhtml#ch57ex3">Listing 57-3</a> (<span class="literal">us_xfr_sv.c</span>, on <a href="ch57.xhtml#page_1168">page 1168</a>) and <a href="ch57.xhtml#ch57ex4">Listing 57-4</a> (<span class="literal">us_xfr_cl.c</span>, on <a href="ch57.xhtml#page_1169">page 1169</a>) to use this library.</p>
<p class="exer"><a id="ch59exe4"/><strong>59-4.</strong>&#160;&#160;&#160;Write a network server that stores name-value pairs. The server should allow names to be added, deleted, modified, and retrieved by clients. Write one or more client programs to test the server. Optionally, implement some kind of security mechanism that allows only the client that created the name to delete it or to modify the value associated with it.</p>
<p class="exer"><a id="ch59exe5"/><strong>59-5.</strong>&#160;&#160;&#160;Suppose that we create two Internet domain datagram sockets, bound to specific addresses, and connect the first socket to the second. What happens if we create a third datagram socket and try to send (<em>sendto()</em>) a datagram via that socket to the first socket? Write a program to determine the answer.<span epub:type="pagebreak" id="page_1238"/></p>
</body>
</html>
